{"ast":null,"code":"var _objectWithoutProperties = require(\"C:/Users/Mega Store/Downloads/Shahen-website-main/front-end/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nconst _excluded = [\"data\"],\n  _excluded2 = [\"data\"];\n/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());\n})(this, function () {\n  'use strict';\n\n  /* eslint-disable */\n  var shared, worker, mapboxgl;\n  // define gets called three times: one for each chunk. we rely on the order\n  // they're imported to know which is which\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \"self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (\" + shared + \")(sharedChunk); (\" + worker + \")(sharedChunk); self.onerror = null;\";\n      var sharedChunk = {};\n      shared(sharedChunk);\n      mapboxgl = chunk(sharedChunk);\n      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {\n        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: 'text/javascript'\n        }));\n      }\n    }\n  }\n  define([\"exports\"], function (t) {\n    var e = 1e-6,\n      r = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n    function n(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        o = r * s - i * n;\n      return o ? (t[0] = s * (o = 1 / o), t[1] = -n * o, t[2] = -i * o, t[3] = r * o, t) : null;\n    }\n    function i() {\n      var t = new r(9);\n      return r != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }\n    function s(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        o = e[4],\n        a = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8];\n      return t[0] = o * c - a * u, t[1] = i * u - n * c, t[2] = n * a - i * o, t[3] = a * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * a, t[6] = s * u - o * l, t[7] = n * l - r * u, t[8] = r * o - n * s, t;\n    }\n    function o(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3],\n        a = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = r[0],\n        d = r[1],\n        f = r[2],\n        m = r[3],\n        y = r[4],\n        g = r[5],\n        x = r[6],\n        v = r[7],\n        b = r[8];\n      return t[0] = p * n + d * o + f * u, t[1] = p * i + d * a + f * c, t[2] = p * s + d * l + f * h, t[3] = m * n + y * o + g * u, t[4] = m * i + y * a + g * c, t[5] = m * s + y * l + g * h, t[6] = x * n + v * o + b * u, t[7] = x * i + v * a + b * c, t[8] = x * s + v * l + b * h, t;\n    }\n    function a() {\n      var t = new r(16);\n      return r != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }\n    function l(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    function u(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        o = e[4],\n        a = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = e[9],\n        p = e[10],\n        d = e[11],\n        f = e[12],\n        m = e[13],\n        y = e[14],\n        g = e[15],\n        x = r * a - n * o,\n        v = r * l - i * o,\n        b = r * u - s * o,\n        w = n * l - i * a,\n        _ = n * u - s * a,\n        A = i * u - s * l,\n        M = c * m - h * f,\n        I = c * y - p * f,\n        S = c * g - d * f,\n        P = h * y - p * m,\n        k = h * g - d * m,\n        z = p * g - d * y,\n        E = x * z - v * k + b * P + w * S - _ * I + A * M;\n      return E ? (t[0] = (a * z - l * k + u * P) * (E = 1 / E), t[1] = (i * k - n * z - s * P) * E, t[2] = (m * A - y * _ + g * w) * E, t[3] = (p * _ - h * A - d * w) * E, t[4] = (l * S - o * z - u * I) * E, t[5] = (r * z - i * S + s * I) * E, t[6] = (y * b - f * A - g * v) * E, t[7] = (c * A - p * b + d * v) * E, t[8] = (o * k - a * S + u * M) * E, t[9] = (n * S - r * k - s * M) * E, t[10] = (f * _ - m * b + g * x) * E, t[11] = (h * b - c * _ - d * x) * E, t[12] = (a * I - o * P - l * M) * E, t[13] = (r * P - n * I + i * M) * E, t[14] = (m * v - f * w - y * x) * E, t[15] = (c * w - h * v + p * x) * E, t) : null;\n    }\n    function c(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3],\n        a = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = e[9],\n        d = e[10],\n        f = e[11],\n        m = e[12],\n        y = e[13],\n        g = e[14],\n        x = e[15],\n        v = r[0],\n        b = r[1],\n        w = r[2],\n        _ = r[3];\n      return t[0] = v * n + b * a + w * h + _ * m, t[1] = v * i + b * l + w * p + _ * y, t[2] = v * s + b * u + w * d + _ * g, t[3] = v * o + b * c + w * f + _ * x, t[4] = (v = r[4]) * n + (b = r[5]) * a + (w = r[6]) * h + (_ = r[7]) * m, t[5] = v * i + b * l + w * p + _ * y, t[6] = v * s + b * u + w * d + _ * g, t[7] = v * o + b * c + w * f + _ * x, t[8] = (v = r[8]) * n + (b = r[9]) * a + (w = r[10]) * h + (_ = r[11]) * m, t[9] = v * i + b * l + w * p + _ * y, t[10] = v * s + b * u + w * d + _ * g, t[11] = v * o + b * c + w * f + _ * x, t[12] = (v = r[12]) * n + (b = r[13]) * a + (w = r[14]) * h + (_ = r[15]) * m, t[13] = v * i + b * l + w * p + _ * y, t[14] = v * s + b * u + w * d + _ * g, t[15] = v * o + b * c + w * f + _ * x, t;\n    }\n    function h(t, e, r) {\n      var n,\n        i,\n        s,\n        o,\n        a,\n        l,\n        u,\n        c,\n        h,\n        p,\n        d,\n        f,\n        m = r[0],\n        y = r[1],\n        g = r[2];\n      return e === t ? (t[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], s = e[2], o = e[3], a = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], d = e[10], f = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = o, t[4] = a, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = d, t[11] = f, t[12] = n * m + a * y + h * g + e[12], t[13] = i * m + l * y + p * g + e[13], t[14] = s * m + u * y + d * g + e[14], t[15] = o * m + c * y + f * g + e[15]), t;\n    }\n    function p(t, e, r) {\n      var n = r[0],\n        i = r[1],\n        s = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }\n    function d(t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        s = e[4],\n        o = e[5],\n        a = e[6],\n        l = e[7],\n        u = e[8],\n        c = e[9],\n        h = e[10],\n        p = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = o * i + c * n, t[6] = a * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - o * n, t[10] = h * i - a * n, t[11] = p * i - l * n, t;\n    }\n    function f(t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        s = e[0],\n        o = e[1],\n        a = e[2],\n        l = e[3],\n        u = e[8],\n        c = e[9],\n        h = e[10],\n        p = e[11];\n      return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = o * i - c * n, t[2] = a * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = o * n + c * i, t[10] = a * n + h * i, t[11] = l * n + p * i, t;\n    }\n    function m(t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        s = e[0],\n        o = e[1],\n        a = e[2],\n        l = e[3],\n        u = e[4],\n        c = e[5],\n        h = e[6],\n        p = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = o * i + c * n, t[2] = a * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - o * n, t[6] = h * i - a * n, t[7] = p * i - l * n, t;\n    }\n    function y(t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    function g(t, r, n) {\n      var i,\n        s,\n        o,\n        a = n[0],\n        l = n[1],\n        u = n[2],\n        c = Math.sqrt(a * a + l * l + u * u);\n      return c < e ? null : (a *= c = 1 / c, l *= c, u *= c, i = Math.sin(r), s = Math.cos(r), t[0] = a * a * (o = 1 - s) + s, t[1] = l * a * o + u * i, t[2] = u * a * o - l * i, t[3] = 0, t[4] = a * l * o - u * i, t[5] = l * l * o + s, t[6] = u * l * o + a * i, t[7] = 0, t[8] = a * u * o + l * i, t[9] = l * u * o - a * i, t[10] = u * u * o + s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);\n    }\n    function x(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        o = r + r,\n        a = n + n,\n        l = i + i,\n        u = r * o,\n        c = n * o,\n        h = n * a,\n        p = i * o,\n        d = i * a,\n        f = i * l,\n        m = s * o,\n        y = s * a,\n        g = s * l;\n      return t[0] = 1 - h - f, t[1] = c + g, t[2] = p - y, t[3] = 0, t[4] = c - g, t[5] = 1 - u - f, t[6] = d + m, t[7] = 0, t[8] = p + y, t[9] = d - m, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    var v = c;\n    function b() {\n      var t = new r(3);\n      return r != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n    }\n    function w(t) {\n      var e = new r(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }\n    function _(t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2];\n      return Math.sqrt(e * e + r * r + n * n);\n    }\n    function A(t, e, n) {\n      var i = new r(3);\n      return i[0] = t, i[1] = e, i[2] = n, i;\n    }\n    function M(t, e, r, n) {\n      return t[0] = e, t[1] = r, t[2] = n, t;\n    }\n    function I(t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }\n    function S(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }\n    function P(t, e, r) {\n      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;\n    }\n    function k(t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;\n    }\n    function z(t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;\n    }\n    function E(t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }\n    function T(t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;\n    }\n    function B(t, e) {\n      var r = e[0] - t[0],\n        n = e[1] - t[1],\n        i = e[2] - t[2];\n      return r * r + n * n + i * i;\n    }\n    function V(t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2];\n      return e * e + r * r + n * n;\n    }\n    function F(t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;\n    }\n    function C(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = r * r + n * n + i * i;\n      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;\n    }\n    function D(t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }\n    function R(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = r[0],\n        a = r[1],\n        l = r[2];\n      return t[0] = i * l - s * a, t[1] = s * o - n * l, t[2] = n * a - i * o, t;\n    }\n    function L(t, e, r, n) {\n      var i = e[0],\n        s = e[1],\n        o = e[2];\n      return t[0] = i + n * (r[0] - i), t[1] = s + n * (r[1] - s), t[2] = o + n * (r[2] - o), t;\n    }\n    function O(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = r[3] * n + r[7] * i + r[11] * s + r[15];\n      return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (o = o || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / o, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / o, t;\n    }\n    function U(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2];\n      return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;\n    }\n    function N(t, e, r) {\n      var n = r[0],\n        i = r[1],\n        s = r[2],\n        o = r[3],\n        a = e[0],\n        l = e[1],\n        u = e[2],\n        c = i * u - s * l,\n        h = s * a - n * u,\n        p = n * l - i * a;\n      return t[0] = a + o * (c += c) + i * (p += p) - s * (h += h), t[1] = l + o * h + s * c - n * p, t[2] = u + o * p + n * h - i * c, t;\n    }\n    function j(t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t;\n    }\n    function $(t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];\n    }\n    var G = S,\n      H = P,\n      q = _;\n    function X() {\n      var t = new r(4);\n      return r != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;\n    }\n    function Z(t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }\n    function W(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        o = r * r + n * n + i * i + s * s;\n      return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = r * o, t[1] = n * o, t[2] = i * o, t[3] = s * o, t;\n    }\n    function Y(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * o, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * o, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * o, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * o, t;\n    }\n    function K() {\n      var t = new r(4);\n      return r != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n    }\n    function J(t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n    }\n    function Q(t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3],\n        a = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + o * a, t[1] = i * l + s * a, t[2] = s * l - i * a, t[3] = o * l - n * a, t;\n    }\n    function tt(t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3],\n        a = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l - s * a, t[1] = i * l + o * a, t[2] = s * l + n * a, t[3] = o * l - i * a, t;\n    }\n    b(), X();\n    var et,\n      rt,\n      nt,\n      it = W,\n      st = (et = b(), rt = A(1, 0, 0), nt = A(0, 1, 0), function (t, e, r) {\n        var n = D(e, r);\n        return n < -.999999 ? (R(et, rt, e), q(et) < 1e-6 && R(et, nt, e), C(et, et), function (t, e, r) {\n          r *= .5;\n          var n = Math.sin(r);\n          t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = Math.cos(r);\n        }(t, et, Math.PI), t) : n > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (R(et, e, r), t[0] = et[0], t[1] = et[1], t[2] = et[2], t[3] = 1 + n, it(t, t));\n      });\n    function ot() {\n      var t = new r(2);\n      return r != Float32Array && (t[0] = 0, t[1] = 0), t;\n    }\n    function at(t, e) {\n      var n = new r(2);\n      return n[0] = t, n[1] = e, n;\n    }\n    function lt(t, e, r) {\n      return t[0] = e, t[1] = r, t;\n    }\n    function ut(t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t;\n    }\n    function ct(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t;\n    }\n    function ht(t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t;\n    }\n    function pt(t) {\n      var e = t[0],\n        r = t[1];\n      return Math.sqrt(e * e + r * r);\n    }\n    function dt(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = r * r + n * n;\n      return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t;\n    }\n    function ft(t, e) {\n      return t[0] * e[0] + t[1] * e[1];\n    }\n    K(), K(), i();\n    var mt,\n      yt,\n      gt = ct;\n    function xt(t) {\n      return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n    }\n    ot();\n    var vt = function () {\n        if (yt) return mt;\n        function t(t, e, r, n) {\n          this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;\n        }\n        return yt = 1, mt = t, t.prototype = {\n          sampleCurveX: function (t) {\n            return ((this.ax * t + this.bx) * t + this.cx) * t;\n          },\n          sampleCurveY: function (t) {\n            return ((this.ay * t + this.by) * t + this.cy) * t;\n          },\n          sampleCurveDerivativeX: function (t) {\n            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n          },\n          solveCurveX: function (t, e) {\n            if (void 0 === e && (e = 1e-6), t < 0) return 0;\n            if (t > 1) return 1;\n            for (var r = t, n = 0; n < 8; n++) {\n              var i = this.sampleCurveX(r) - t;\n              if (Math.abs(i) < e) return r;\n              var s = this.sampleCurveDerivativeX(r);\n              if (Math.abs(s) < 1e-6) break;\n              r -= i / s;\n            }\n            var o = 0,\n              a = 1;\n            for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? o = r : a = r, r = .5 * (a - o) + o;\n            return r;\n          },\n          solve: function (t, e) {\n            return this.sampleCurveY(this.solveCurveX(t, e));\n          }\n        }, mt;\n      }(),\n      bt = xt(vt);\n    function wt(t, e) {\n      this.x = t, this.y = e;\n    }\n    function _t(t, e) {\n      if (Array.isArray(t)) {\n        if (!Array.isArray(e) || t.length !== e.length) return !1;\n        for (let r = 0; r < t.length; r++) if (!_t(t[r], e[r])) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof t && null !== t && null !== e) {\n        if (\"object\" != typeof e) return !1;\n        if (Object.keys(t).length !== Object.keys(e).length) return !1;\n        for (const r in t) if (!_t(t[r], e[r])) return !1;\n        return !0;\n      }\n      return t === e;\n    }\n    wt.prototype = {\n      clone() {\n        return new wt(this.x, this.y);\n      },\n      add(t) {\n        return this.clone()._add(t);\n      },\n      sub(t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint(t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint(t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult(t) {\n        return this.clone()._mult(t);\n      },\n      div(t) {\n        return this.clone()._div(t);\n      },\n      rotate(t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround(t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult(t) {\n        return this.clone()._matMult(t);\n      },\n      unit() {\n        return this.clone()._unit();\n      },\n      perp() {\n        return this.clone()._perp();\n      },\n      round() {\n        return this.clone()._round();\n      },\n      mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals(t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist(t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr(t) {\n        const e = t.x - this.x,\n          r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle() {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo(t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith(t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep(t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult(t) {\n        const e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add(t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub(t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult(t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div(t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint(t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint(t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit() {\n        return this._div(this.mag()), this;\n      },\n      _perp() {\n        const t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate(t) {\n        const e = Math.cos(t),\n          r = Math.sin(t),\n          n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround(t, e) {\n        const r = Math.cos(t),\n          n = Math.sin(t),\n          i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round() {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      },\n      constructor: wt\n    }, wt.convert = function (t) {\n      if (t instanceof wt) return t;\n      if (Array.isArray(t)) return new wt(+t[0], +t[1]);\n      if (void 0 !== t.x && void 0 !== t.y) return new wt(+t.x, +t.y);\n      throw new Error(\"Expected [x, y] or {x, y} point format\");\n    };\n    const At = Math.PI / 180,\n      Mt = 180 / Math.PI;\n    function It(t) {\n      return t * At;\n    }\n    function St(t) {\n      return t * Mt;\n    }\n    const Pt = [[0, 0], [1, 0], [1, 1], [0, 1]];\n    function kt(t) {\n      if (t <= 0) return 0;\n      if (t >= 1) return 1;\n      const e = t * t,\n        r = e * t;\n      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n    }\n    function zt(t, e, r, n) {\n      const i = new bt(t, e, r, n);\n      return function (t) {\n        return i.solve(t);\n      };\n    }\n    const Et = zt(.25, .1, .25, 1);\n    function Tt(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n    function Bt(t, e, r) {\n      return (r = Tt((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);\n    }\n    function Vt(t, e, r) {\n      const n = r - e,\n        i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n    function Ft(t, e, r) {\n      if (!t.length) return r(null, []);\n      let n = t.length;\n      const i = new Array(t.length);\n      let s = null;\n      t.forEach((t, o) => {\n        e(t, (t, e) => {\n          t && (s = t), i[o] = e, 0 == --n && r(s, i);\n        });\n      });\n    }\n    let Ct = 1;\n    function Dt() {\n      return Ct++;\n    }\n    function Rt(t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log2(t)));\n    }\n    function Lt(t, e) {\n      t.forEach(t => {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n    function Ot(t, e, r) {\n      const n = {};\n      for (const r in t) n[r] = e.call(this, t[r], r, t);\n      return n;\n    }\n    function Ut(t, e, r) {\n      const n = {};\n      for (const r in t) e.call(this, t[r], r, t) && (n[r] = t[r]);\n      return n;\n    }\n    function Nt(t) {\n      return Array.isArray(t) ? t.map(Nt) : \"object\" == typeof t && t ? Ot(t, Nt) : t;\n    }\n    function jt(t, e) {\n      for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n      return !1;\n    }\n    const $t = {};\n    function Gt(t) {\n      $t[t] || (\"undefined\" != typeof console && console.warn(t), $t[t] = !0);\n    }\n    function Ht(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n    function qt(t) {\n      let e = 0;\n      for (let r, n, i = 0, s = t.length, o = s - 1; i < s; o = i++) r = t[i], n = t[o], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function Xt(_ref) {\n      let [t, e, r] = _ref;\n      const n = It(e + 90),\n        i = It(r);\n      return {\n        x: t * Math.cos(n) * Math.sin(i),\n        y: t * Math.sin(n) * Math.sin(i),\n        z: t * Math.cos(i),\n        azimuthal: e,\n        polar: r\n      };\n    }\n    function Zt(t) {\n      return (\"undefined\" != typeof self || void 0 !== t) && \"undefined\" != typeof WorkerGlobalScope && (void 0 !== t ? t : self) instanceof WorkerGlobalScope;\n    }\n    function Wt(t) {\n      const e = {};\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n        const s = n || i;\n        return e[r] = !s || s.toLowerCase(), \"\";\n      }), e[\"max-age\"]) {\n        const t = parseInt(e[\"max-age\"], 10);\n        isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n      }\n      return e;\n    }\n    let Yt = null;\n    function Kt(t, e) {\n      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];\n    }\n    function Jt(t, e, r, n) {\n      for (; e < r;) {\n        const i = e + r >> 1;\n        t[i] < n ? e = i + 1 : r = i;\n      }\n      return e;\n    }\n    function Qt(t, e, r, n) {\n      for (; e < r;) {\n        const i = e + r >> 1;\n        t[i] <= n ? e = i + 1 : r = i;\n      }\n      return e;\n    }\n    function te(t) {\n      return t > 0 ? 1 / (1.001 - t) : 1 + t;\n    }\n    function ee(t) {\n      return t > 0 ? 1 - 1 / (1.001 - t) : -t;\n    }\n    function re(t, e, r) {\n      return (t - e.min) * (r.max - r.min) / (e.max - e.min) + r.min;\n    }\n    const ne = {\n      API_URL: \"https://api.mapbox.com\",\n      get API_URL_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n      },\n      get API_TILEJSON_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/v[0-9]*\\/.*\\.json.*$)/i;\n      },\n      get API_SPRITE_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*\\/sprite.*\\..*$)/i;\n      },\n      get API_FONTS_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/fonts\\/v[0-9]*\\/)(.*\\.pbf.*$)/i;\n      },\n      get API_STYLE_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*$)/i;\n      },\n      get API_CDN_URL_REGEX() {\n        return /^((https?:)?\\/\\/)?api\\.mapbox\\.c(n|om)(\\/mapbox-gl-js\\/)(.*$)/i;\n      },\n      get EVENTS_URL() {\n        if (!ne.API_URL) return null;\n        try {\n          const t = new URL(ne.API_URL);\n          return \"api.mapbox.cn\" === t.hostname ? \"https://events.mapbox.cn/events/v2\" : \"api.mapbox.com\" === t.hostname ? \"https://events.mapbox.com/events/v2\" : null;\n        } catch (t) {\n          return null;\n        }\n      },\n      SESSION_PATH: \"/map-sessions/v1\",\n      FEEDBACK_URL: \"https://apps.mapbox.com/feedback\",\n      TILE_URL_VERSION: \"v4\",\n      RASTER_URL_PREFIX: \"raster/v1\",\n      RASTERARRAYS_URL_PREFIX: \"rasterarrays/v1\",\n      REQUIRE_ACCESS_TOKEN: !0,\n      ACCESS_TOKEN: null,\n      DEFAULT_STYLE: \"mapbox://styles/mapbox/standard\",\n      MAX_PARALLEL_IMAGE_REQUESTS: 16,\n      DRACO_URL: \"https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm\",\n      MESHOPT_URL: \"https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm\",\n      MESHOPT_SIMD_URL: \"https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm\",\n      BUILDING_GEN_URL: \"https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v1.2.3.wasm\",\n      GLYPHS_URL: \"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\",\n      TILES3D_URL_PREFIX: \"3dtiles/v1\"\n    };\n    function ie(t) {\n      return ne.API_URL_REGEX.test(t);\n    }\n    function se(t) {\n      return ne.API_SPRITE_REGEX.test(t);\n    }\n    let oe, ae, le, ue, ce, he;\n    function pe() {\n      return null == oe && (oe = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext(\"2d\") && \"function\" == typeof self.createImageBitmap), oe;\n    }\n    const de = {\n      now: () => void 0 !== ue ? ue : performance.now(),\n      setNow(t) {\n        ue = t;\n      },\n      restoreNow() {\n        ue = void 0;\n      },\n      frame(t) {\n        const e = requestAnimationFrame(t);\n        return {\n          cancel: () => cancelAnimationFrame(e)\n        };\n      },\n      getImageData(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        const {\n          width: r,\n          height: n\n        } = t;\n        ce || (ce = document.createElement(\"canvas\"));\n        const i = ce.getContext(\"2d\", {\n          willReadFrequently: !0\n        });\n        if (!i) throw new Error(\"failed to create canvas 2d context\");\n        return (r > ce.width || n > ce.height) && (ce.width = r, ce.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);\n      },\n      resolveURL: t => (ae || (ae = document.createElement(\"a\")), ae.href = t, ae.href),\n      get devicePixelRatio() {\n        return window.devicePixelRatio;\n      },\n      get prefersReducedMotion() {\n        return !!window.matchMedia && (null == le && (le = window.matchMedia(\"(prefers-reduced-motion: reduce)\")), le.matches);\n      },\n      hasCanvasFingerprintNoise() {\n        if (void 0 !== he) return he;\n        if (!pe()) return he = !1, !1;\n        const t = new OffscreenCanvas(85, 1),\n          e = t.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n        let r = 0;\n        for (let n = 0; n < t.width; ++n) e.fillStyle = \"rgba(\".concat(r++, \",\").concat(r++, \",\").concat(r++, \", 255)\"), e.fillRect(n, 0, 1, 1);\n        const n = e.getImageData(0, 0, t.width, t.height);\n        r = 0;\n        for (let t = 0; t < n.data.length; ++t) if (t % 4 != 3 && r++ !== n.data[t]) return he = !0, !0;\n        return he = !1, !1;\n      }\n    };\n    function fe(t, e) {\n      const r = t.indexOf(\"?\");\n      if (r < 0) return \"\".concat(t, \"?\").concat(new URLSearchParams(e).toString());\n      const n = new URLSearchParams(t.slice(r));\n      for (const t in e) n.set(t, e[t]);\n      return \"\".concat(t.slice(0, r), \"?\").concat(n.toString());\n    }\n    function me(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        persistentParams: []\n      };\n      const r = t.indexOf(\"?\");\n      if (r < 0) return t;\n      const n = new URLSearchParams(),\n        i = new URLSearchParams(t.slice(r));\n      for (const t of e.persistentParams) {\n        const e = i.get(t);\n        e && n.set(t, e);\n      }\n      const s = n.toString();\n      return \"\".concat(t.slice(0, r)).concat(s.length > 0 ? \"?\".concat(s) : \"\");\n    }\n    const ye = \"mapbox-tiles\";\n    let ge = 500,\n      xe = 50;\n    const ve = [\"language\", \"worldview\", \"jobid\"];\n    let be, we;\n    function _e() {\n      try {\n        return caches;\n      } catch (t) {}\n    }\n    function Ae() {\n      const t = _e();\n      t && null == be && (be = t.open(ye));\n    }\n    let Me = 1 / 0;\n    const Ie = {\n      supported: !1,\n      testSupport: function (t) {\n        !ke && Pe && (ze ? Te(t) : Se = t);\n      }\n    };\n    let Se,\n      Pe,\n      ke = !1,\n      ze = !1;\n    const Ee = \"undefined\" != typeof self ? self : {};\n    function Te(t) {\n      const e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, Pe), t.isContextLost()) return;\n        Ie.supported = !0;\n      } catch (t) {}\n      t.deleteTexture(e), ke = !0;\n    }\n    Ee.document && (Pe = Ee.document.createElement(\"img\"), Pe.onload = function () {\n      Se && Te(Se), Se = null, ze = !0;\n    }, Pe.onerror = function () {\n      ke = !0, Se = null;\n    }, Pe.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n    const Be = {\n      Unknown: \"Unknown\",\n      Style: \"Style\",\n      Source: \"Source\",\n      Tile: \"Tile\",\n      Glyphs: \"Glyphs\",\n      SpriteImage: \"SpriteImage\",\n      SpriteJSON: \"SpriteJSON\",\n      Iconset: \"Iconset\",\n      Image: \"Image\",\n      Model: \"Model\"\n    };\n    \"function\" == typeof Object.freeze && Object.freeze(Be);\n    class Ve extends Error {\n      constructor(t, e, r) {\n        401 === e && ie(r) && (t += \": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\"), super(t), this.status = e, this.url = r;\n      }\n      toString() {\n        return \"\".concat(this.name, \": \").concat(this.message, \" (\").concat(this.status, \"): \").concat(this.url);\n      }\n    }\n    const Fe = Zt() ? () => self.worker.referrer : () => (\"blob:\" === location.protocol ? parent : self).location.href;\n    const Ce = function (t, e) {\n        if (!(/^file:/.test(r = t.url) || /^file:/.test(Fe()) && !/^\\w+:/.test(r))) {\n          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty(\"signal\")) return function (t, e) {\n            const r = new AbortController(),\n              n = new Request(t.url, {\n                method: t.method || \"GET\",\n                body: t.body,\n                credentials: t.credentials,\n                headers: t.headers,\n                referrer: Fe(),\n                referrerPolicy: t.referrerPolicy,\n                signal: r.signal\n              });\n            let i = !1,\n              s = !1;\n            const o = (a = n.url).indexOf(\"sku=\") > 0 && ie(a);\n            var a;\n            \"json\" === t.type && n.headers.set(\"Accept\", \"application/json\");\n            const l = (r, i, a) => {\n                if (s) return;\n                if (r && \"SecurityError\" !== r.message && Gt(r.toString()), i && a) return u(i);\n                const l = Date.now();\n                fetch(n).then(r => {\n                  if (r.ok) {\n                    const t = o ? r.clone() : null;\n                    return u(r, t, l);\n                  }\n                  return e(new Ve(r.statusText, r.status, t.url));\n                }).catch(r => {\n                  \"AbortError\" !== r.name && e(new Error(\"\".concat(r.message, \" \").concat(t.url)));\n                });\n              },\n              u = (r, o, a) => {\n                (\"arrayBuffer\" === t.type ? r.arrayBuffer() : \"json\" === t.type ? r.json() : r.text()).then(t => {\n                  s || (o && a && function (t, e, r) {\n                    if (Ae(), null == be) return;\n                    const n = Wt(e.headers.get(\"Cache-Control\") || \"\");\n                    if (n[\"no-store\"]) return;\n                    const i = {\n                      status: e.status,\n                      statusText: e.statusText,\n                      headers: new Headers()\n                    };\n                    e.headers.forEach((t, e) => i.headers.set(e, t)), n[\"max-age\"] && i.headers.set(\"Expires\", new Date(r + 1e3 * n[\"max-age\"]).toUTCString());\n                    const s = i.headers.get(\"Expires\");\n                    if (!s) return;\n                    if (new Date(s).getTime() - r < 42e4) return;\n                    let o = me(t.url, {\n                      persistentParams: ve\n                    });\n                    if (206 === e.status) {\n                      const e = t.headers.get(\"Range\");\n                      if (!e) return;\n                      i.status = 200, o = fe(o, {\n                        range: e\n                      });\n                    }\n                    !function (t, e) {\n                      if (void 0 === we) try {\n                        new Response(new ReadableStream()), we = !0;\n                      } catch (t) {\n                        we = !1;\n                      }\n                      we ? e(t.body) : t.blob().then(e).catch(t => Gt(t.message));\n                    }(e, t => {\n                      const r = new Response(200 !== (n = e.status) && 404 !== n && [101, 103, 204, 205, 304].includes(n) ? null : t, i);\n                      var n;\n                      Ae(), null != be && be.then(t => t.put(o, r)).catch(t => Gt(t.message));\n                    });\n                  }(n, o, a), i = !0, e(null, t, r.headers.get(\"Cache-Control\"), r.headers.get(\"Expires\")));\n                }).catch(t => {\n                  s || e(new Error(t.message));\n                });\n              };\n            return o ? function (t, e) {\n              if (Ae(), null == be) return e(null);\n              be.then(r => {\n                let n = me(t.url, {\n                  persistentParams: ve\n                });\n                const i = t.headers.get(\"Range\");\n                i && (n = fe(n, {\n                  range: i\n                })), r.match(n).then(t => {\n                  const i = function (t) {\n                    if (!t) return !1;\n                    const e = new Date(t.headers.get(\"Expires\") || 0),\n                      r = Wt(t.headers.get(\"Cache-Control\") || \"\");\n                    return Number(e) > Date.now() && !r[\"no-cache\"];\n                  }(t);\n                  r.delete(n).catch(e), i && r.put(n, t.clone()).catch(e), e(null, t, i);\n                }).catch(e);\n              }).catch(e);\n            }(n, l) : l(null, null), {\n              cancel: () => {\n                s = !0, i || r.abort();\n              }\n            };\n          }(t, e);\n          if (Zt(self) && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e, void 0, !0);\n        }\n        var r;\n        return function (t, e) {\n          const r = new XMLHttpRequest();\n          r.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (r.responseType = \"arraybuffer\");\n          for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);\n          return \"json\" === t.type && (r.responseType = \"text\", r.setRequestHeader(\"Accept\", \"application/json\")), r.withCredentials = \"include\" === t.credentials, r.onerror = () => {\n            e(new Error(r.statusText));\n          }, r.onload = () => {\n            if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n              let n = r.response;\n              if (\"json\" === t.type) try {\n                n = JSON.parse(r.response);\n              } catch (t) {\n                return e(t);\n              }\n              e(null, n, r.getResponseHeader(\"Cache-Control\"), r.getResponseHeader(\"Expires\"));\n            } else e(new Ve(r.statusText, r.status, t.url));\n          }, r.send(t.body), {\n            cancel: () => r.abort()\n          };\n        }(t, e);\n      },\n      De = function (t, e) {\n        return Ce(Object.assign(t, {\n          type: \"arrayBuffer\"\n        }), e);\n      };\n    function Re(t) {\n      const e = document.createElement(\"a\");\n      return e.href = t, e.protocol === location.protocol && e.host === location.host;\n    }\n    const Le = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=\";\n    let Oe, Ue;\n    Oe = [], Ue = 0;\n    const Ne = function (t, e) {\n      if (Ie.supported && (t.headers || (t.headers = {}), t.headers.accept = \"image/webp,*/*\"), Ue >= ne.MAX_PARALLEL_IMAGE_REQUESTS) {\n        const r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n          cancel() {\n            this.cancelled = !0;\n          }\n        };\n        return Oe.push(r), r;\n      }\n      Ue++;\n      let r = !1;\n      const n = () => {\n          if (!r) for (r = !0, Ue--; Oe.length && Ue < ne.MAX_PARALLEL_IMAGE_REQUESTS;) {\n            const t = Oe.shift(),\n              {\n                requestParameters: e,\n                callback: r,\n                cancelled: n\n              } = t;\n            n || (t.cancel = Ne(e, r).cancel);\n          }\n        },\n        i = De(t, (t, r, i, s) => {\n          n(), t ? e(t) : r && (self.createImageBitmap ? function (t, e) {\n            const r = new Blob([new Uint8Array(t)], {\n              type: \"image/png\"\n            });\n            createImageBitmap(r).then(t => {\n              e(null, t);\n            }).catch(t => {\n              e(new Error(\"Could not load image because of \".concat(t.message, \". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\")));\n            });\n          }(r, (t, r) => e(t, r, i, s)) : function (t, e) {\n            const r = new Image();\n            r.onload = () => {\n              e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(() => {\n                r.src = Le;\n              });\n            }, r.onerror = () => e(new Error(\"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\"));\n            const n = new Blob([new Uint8Array(t)], {\n              type: \"image/png\"\n            });\n            r.src = t.byteLength ? URL.createObjectURL(n) : Le;\n          }(r, (t, r) => e(t, r, i, s)));\n        });\n      return {\n        cancel: () => {\n          i.cancel(), n();\n        }\n      };\n    };\n    var je,\n      $e,\n      Ge,\n      He = {\n        exports: {}\n      },\n      qe = {\n        exports: {}\n      },\n      Xe = {\n        exports: {}\n      },\n      Ze = function () {\n        if (Ge) return He.exports;\n        Ge = 1;\n        var t = (je || (je = 1, qe.exports = function (t, e) {\n            var r, n, i, s, o, a, l, u;\n            for (n = t.length - (r = 3 & t.length), i = e, o = 3432918353, a = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);\n            switch (l = 0, r) {\n              case 3:\n                l ^= (255 & t.charCodeAt(u + 2)) << 16;\n              case 2:\n                l ^= (255 & t.charCodeAt(u + 1)) << 8;\n              case 1:\n                i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295;\n            }\n            return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n          }), qe.exports),\n          e = ($e || ($e = 1, Xe.exports = function (t, e) {\n            for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;\n            switch (n) {\n              case 3:\n                i ^= (255 & t.charCodeAt(s + 2)) << 16;\n              case 2:\n                i ^= (255 & t.charCodeAt(s + 1)) << 8;\n              case 1:\n                i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n            }\n            return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n          }), Xe.exports);\n        return He.exports = t, He.exports.murmur3 = t, He.exports.murmur2 = e, He.exports;\n      }(),\n      We = xt(Ze);\n    class Ye {\n      constructor(t) {\n        Object.assign(this, (arguments.length <= 1 ? undefined : arguments[1]) || {}), this.type = t;\n      }\n    }\n    class Ke extends Ye {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(\"error\", Object.assign({\n          error: t\n        }, e));\n      }\n    }\n    function Je(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n    function Qe(t, e, r) {\n      if (r && r[t]) {\n        const n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n    class tr {\n      on(t, e) {\n        return this._listeners = this._listeners || {}, Je(t, e, this._listeners), this;\n      }\n      off(t, e) {\n        return Qe(t, e, this._listeners), Qe(t, e, this._oneTimeListeners), this;\n      }\n      once(t, e) {\n        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Je(t, e, this._oneTimeListeners), this) : new Promise(e => {\n          this.once(t, e);\n        });\n      }\n      fire(t, e) {\n        const r = \"string\" == typeof t ? new Ye(t, e) : t,\n          n = r.type;\n        if (this.listens(n)) {\n          r.target = this;\n          const t = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];\n          for (const e of t) e.call(this, r);\n          const e = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];\n          for (const t of e) Qe(n, t, this._oneTimeListeners), t.call(this, r);\n          const i = this._eventedParent;\n          if (i) {\n            const t = \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData;\n            Object.assign(r, t), i.fire(r);\n          }\n        } else r instanceof Ke && console.error(r.error);\n        return this;\n      }\n      listens(t) {\n        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));\n      }\n      setEventedParent(t, e) {\n        return this._eventedParent = t, this._eventedParentData = e, this;\n      }\n    }\n    class er {\n      constructor(t) {\n        \"string\" == typeof t ? this.name = t : (this.name = t.name, this.iconsetId = t.iconsetId);\n      }\n      static from(t) {\n        return new er(t);\n      }\n      static toString(t) {\n        return t.iconsetId ? \"\".concat(t.name, \"\\x1F\").concat(t.iconsetId) : t.name;\n      }\n      static parse(t) {\n        const [e, r] = t.split(\"\u001f\");\n        return new er({\n          name: e,\n          iconsetId: r\n        });\n      }\n      static isEqual(t, e) {\n        return t.name === e.name && t.iconsetId === e.iconsetId;\n      }\n      toString() {\n        return er.toString(this);\n      }\n      serialize() {\n        return {\n          name: this.name,\n          iconsetId: this.iconsetId\n        };\n      }\n    }\n    var rr,\n      nr = {},\n      ir = function () {\n        if (rr) return nr;\n        rr = 1;\n        var t = {\n          transparent: [0, 0, 0, 0],\n          aliceblue: [240, 248, 255, 1],\n          antiquewhite: [250, 235, 215, 1],\n          aqua: [0, 255, 255, 1],\n          aquamarine: [127, 255, 212, 1],\n          azure: [240, 255, 255, 1],\n          beige: [245, 245, 220, 1],\n          bisque: [255, 228, 196, 1],\n          black: [0, 0, 0, 1],\n          blanchedalmond: [255, 235, 205, 1],\n          blue: [0, 0, 255, 1],\n          blueviolet: [138, 43, 226, 1],\n          brown: [165, 42, 42, 1],\n          burlywood: [222, 184, 135, 1],\n          cadetblue: [95, 158, 160, 1],\n          chartreuse: [127, 255, 0, 1],\n          chocolate: [210, 105, 30, 1],\n          coral: [255, 127, 80, 1],\n          cornflowerblue: [100, 149, 237, 1],\n          cornsilk: [255, 248, 220, 1],\n          crimson: [220, 20, 60, 1],\n          cyan: [0, 255, 255, 1],\n          darkblue: [0, 0, 139, 1],\n          darkcyan: [0, 139, 139, 1],\n          darkgoldenrod: [184, 134, 11, 1],\n          darkgray: [169, 169, 169, 1],\n          darkgreen: [0, 100, 0, 1],\n          darkgrey: [169, 169, 169, 1],\n          darkkhaki: [189, 183, 107, 1],\n          darkmagenta: [139, 0, 139, 1],\n          darkolivegreen: [85, 107, 47, 1],\n          darkorange: [255, 140, 0, 1],\n          darkorchid: [153, 50, 204, 1],\n          darkred: [139, 0, 0, 1],\n          darksalmon: [233, 150, 122, 1],\n          darkseagreen: [143, 188, 143, 1],\n          darkslateblue: [72, 61, 139, 1],\n          darkslategray: [47, 79, 79, 1],\n          darkslategrey: [47, 79, 79, 1],\n          darkturquoise: [0, 206, 209, 1],\n          darkviolet: [148, 0, 211, 1],\n          deeppink: [255, 20, 147, 1],\n          deepskyblue: [0, 191, 255, 1],\n          dimgray: [105, 105, 105, 1],\n          dimgrey: [105, 105, 105, 1],\n          dodgerblue: [30, 144, 255, 1],\n          firebrick: [178, 34, 34, 1],\n          floralwhite: [255, 250, 240, 1],\n          forestgreen: [34, 139, 34, 1],\n          fuchsia: [255, 0, 255, 1],\n          gainsboro: [220, 220, 220, 1],\n          ghostwhite: [248, 248, 255, 1],\n          gold: [255, 215, 0, 1],\n          goldenrod: [218, 165, 32, 1],\n          gray: [128, 128, 128, 1],\n          green: [0, 128, 0, 1],\n          greenyellow: [173, 255, 47, 1],\n          grey: [128, 128, 128, 1],\n          honeydew: [240, 255, 240, 1],\n          hotpink: [255, 105, 180, 1],\n          indianred: [205, 92, 92, 1],\n          indigo: [75, 0, 130, 1],\n          ivory: [255, 255, 240, 1],\n          khaki: [240, 230, 140, 1],\n          lavender: [230, 230, 250, 1],\n          lavenderblush: [255, 240, 245, 1],\n          lawngreen: [124, 252, 0, 1],\n          lemonchiffon: [255, 250, 205, 1],\n          lightblue: [173, 216, 230, 1],\n          lightcoral: [240, 128, 128, 1],\n          lightcyan: [224, 255, 255, 1],\n          lightgoldenrodyellow: [250, 250, 210, 1],\n          lightgray: [211, 211, 211, 1],\n          lightgreen: [144, 238, 144, 1],\n          lightgrey: [211, 211, 211, 1],\n          lightpink: [255, 182, 193, 1],\n          lightsalmon: [255, 160, 122, 1],\n          lightseagreen: [32, 178, 170, 1],\n          lightskyblue: [135, 206, 250, 1],\n          lightslategray: [119, 136, 153, 1],\n          lightslategrey: [119, 136, 153, 1],\n          lightsteelblue: [176, 196, 222, 1],\n          lightyellow: [255, 255, 224, 1],\n          lime: [0, 255, 0, 1],\n          limegreen: [50, 205, 50, 1],\n          linen: [250, 240, 230, 1],\n          magenta: [255, 0, 255, 1],\n          maroon: [128, 0, 0, 1],\n          mediumaquamarine: [102, 205, 170, 1],\n          mediumblue: [0, 0, 205, 1],\n          mediumorchid: [186, 85, 211, 1],\n          mediumpurple: [147, 112, 219, 1],\n          mediumseagreen: [60, 179, 113, 1],\n          mediumslateblue: [123, 104, 238, 1],\n          mediumspringgreen: [0, 250, 154, 1],\n          mediumturquoise: [72, 209, 204, 1],\n          mediumvioletred: [199, 21, 133, 1],\n          midnightblue: [25, 25, 112, 1],\n          mintcream: [245, 255, 250, 1],\n          mistyrose: [255, 228, 225, 1],\n          moccasin: [255, 228, 181, 1],\n          navajowhite: [255, 222, 173, 1],\n          navy: [0, 0, 128, 1],\n          oldlace: [253, 245, 230, 1],\n          olive: [128, 128, 0, 1],\n          olivedrab: [107, 142, 35, 1],\n          orange: [255, 165, 0, 1],\n          orangered: [255, 69, 0, 1],\n          orchid: [218, 112, 214, 1],\n          palegoldenrod: [238, 232, 170, 1],\n          palegreen: [152, 251, 152, 1],\n          paleturquoise: [175, 238, 238, 1],\n          palevioletred: [219, 112, 147, 1],\n          papayawhip: [255, 239, 213, 1],\n          peachpuff: [255, 218, 185, 1],\n          peru: [205, 133, 63, 1],\n          pink: [255, 192, 203, 1],\n          plum: [221, 160, 221, 1],\n          powderblue: [176, 224, 230, 1],\n          purple: [128, 0, 128, 1],\n          rebeccapurple: [102, 51, 153, 1],\n          red: [255, 0, 0, 1],\n          rosybrown: [188, 143, 143, 1],\n          royalblue: [65, 105, 225, 1],\n          saddlebrown: [139, 69, 19, 1],\n          salmon: [250, 128, 114, 1],\n          sandybrown: [244, 164, 96, 1],\n          seagreen: [46, 139, 87, 1],\n          seashell: [255, 245, 238, 1],\n          sienna: [160, 82, 45, 1],\n          silver: [192, 192, 192, 1],\n          skyblue: [135, 206, 235, 1],\n          slateblue: [106, 90, 205, 1],\n          slategray: [112, 128, 144, 1],\n          slategrey: [112, 128, 144, 1],\n          snow: [255, 250, 250, 1],\n          springgreen: [0, 255, 127, 1],\n          steelblue: [70, 130, 180, 1],\n          tan: [210, 180, 140, 1],\n          teal: [0, 128, 128, 1],\n          thistle: [216, 191, 216, 1],\n          tomato: [255, 99, 71, 1],\n          turquoise: [64, 224, 208, 1],\n          violet: [238, 130, 238, 1],\n          wheat: [245, 222, 179, 1],\n          white: [255, 255, 255, 1],\n          whitesmoke: [245, 245, 245, 1],\n          yellow: [255, 255, 0, 1],\n          yellowgreen: [154, 205, 50, 1]\n        };\n        function e(t) {\n          return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n        }\n        function r(t) {\n          return e(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n        }\n        function n(t) {\n          return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n          var e;\n        }\n        function i(t, e, r) {\n          return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n        }\n        try {\n          nr.parseCSSColor = function (s) {\n            var o,\n              a = s.replace(/ /g, \"\").toLowerCase();\n            if (a in t) return t[a].slice();\n            if (\"#\" === a[0]) return 4 === a.length ? (o = parseInt(a.substr(1), 16)) >= 0 && o <= 4095 ? [(3840 & o) >> 4 | (3840 & o) >> 8, 240 & o | (240 & o) >> 4, 15 & o | (15 & o) << 4, 1] : null : 7 === a.length && (o = parseInt(a.substr(1), 16)) >= 0 && o <= 16777215 ? [(16711680 & o) >> 16, (65280 & o) >> 8, 255 & o, 1] : null;\n            var l = a.indexOf(\"(\"),\n              u = a.indexOf(\")\");\n            if (-1 !== l && u + 1 === a.length) {\n              var c = a.substr(0, l),\n                h = a.substr(l + 1, u - (l + 1)).split(\",\"),\n                p = 1;\n              switch (c) {\n                case \"rgba\":\n                  if (4 !== h.length) return null;\n                  p = n(h.pop());\n                case \"rgb\":\n                  return 3 !== h.length ? null : [r(h[0]), r(h[1]), r(h[2]), p];\n                case \"hsla\":\n                  if (4 !== h.length) return null;\n                  p = n(h.pop());\n                case \"hsl\":\n                  if (3 !== h.length) return null;\n                  var d = (parseFloat(h[0]) % 360 + 360) % 360 / 360,\n                    f = n(h[1]),\n                    m = n(h[2]),\n                    y = m <= .5 ? m * (f + 1) : m + f - m * f,\n                    g = 2 * m - y;\n                  return [e(255 * i(g, y, d + 1 / 3)), e(255 * i(g, y, d)), e(255 * i(g, y, d - 1 / 3)), p];\n                default:\n                  return null;\n              }\n            }\n            return null;\n          };\n        } catch (t) {}\n        return nr;\n      }();\n    class sr {\n      constructor(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n        this.r = t, this.g = e, this.b = r, this.a = n;\n      }\n      static parse(t) {\n        if (!t) return;\n        if (t instanceof sr) return t;\n        if (\"string\" != typeof t) return;\n        const e = ir.parseCSSColor(t);\n        return e ? new sr(e[0] / 255, e[1] / 255, e[2] / 255, e[3]) : void 0;\n      }\n      toString() {\n        const [t, e, r, n] = [this.r, this.g, this.b, this.a];\n        return \"rgba(\".concat(Math.round(255 * t), \",\").concat(Math.round(255 * e), \",\").concat(Math.round(255 * r), \",\").concat(n, \")\");\n      }\n      toNonPremultipliedRenderColor(t) {\n        const {\n          r: e,\n          g: r,\n          b: n,\n          a: i\n        } = this;\n        return new ar(t, e, r, n, i);\n      }\n      toPremultipliedRenderColor(t) {\n        const {\n          r: e,\n          g: r,\n          b: n,\n          a: i\n        } = this;\n        return new lr(t, e * i, r * i, n * i, i);\n      }\n      clone() {\n        return new sr(this.r, this.g, this.b, this.a);\n      }\n    }\n    class or {\n      constructor(t, e, r, n, i) {\n        let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;\n        if (this.premultiplied = !1, this.premultiplied = s, t) {\n          const s = t.image.height,\n            o = s * s;\n          this.premultiplied ? (e = 0 === i ? 0 : e / i * (s - 1), r = 0 === i ? 0 : r / i * (s - 1), n = 0 === i ? 0 : n / i * (s - 1)) : (e *= s - 1, r *= s - 1, n *= s - 1);\n          const a = Math.floor(e),\n            l = Math.floor(r),\n            u = Math.floor(n),\n            c = Math.ceil(e),\n            h = Math.ceil(r),\n            p = Math.ceil(n),\n            d = e - a,\n            f = r - l,\n            m = n - u,\n            y = t.image.data,\n            g = 4 * (a + l * o + u * s),\n            x = 4 * (a + l * o + p * s),\n            v = 4 * (a + h * o + u * s),\n            b = 4 * (a + h * o + p * s),\n            w = 4 * (c + l * o + u * s),\n            _ = 4 * (c + l * o + p * s),\n            A = 4 * (c + h * o + u * s),\n            M = 4 * (c + h * o + p * s);\n          if (g < 0 || M >= y.length) throw new Error(\"out of range\");\n          this.r = ur(ur(ur(y[g], y[x], m), ur(y[v], y[b], m), f), ur(ur(y[w], y[_], m), ur(y[A], y[M], m), f), d) / 255 * (this.premultiplied ? i : 1), this.g = ur(ur(ur(y[g + 1], y[x + 1], m), ur(y[v + 1], y[b + 1], m), f), ur(ur(y[w + 1], y[_ + 1], m), ur(y[A + 1], y[M + 1], m), f), d) / 255 * (this.premultiplied ? i : 1), this.b = ur(ur(ur(y[g + 2], y[x + 2], m), ur(y[v + 2], y[b + 2], m), f), ur(ur(y[w + 2], y[_ + 2], m), ur(y[A + 2], y[M + 2], m), f), d) / 255 * (this.premultiplied ? i : 1), this.a = i;\n        } else this.r = e, this.g = r, this.b = n, this.a = i;\n      }\n      toArray() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return [255 * t, 255 * e, 255 * r, n];\n      }\n      toHslaArray() {\n        let {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        if (this.premultiplied) {\n          if (0 === n) return [0, 0, 0, 0];\n          const i = 1 / n;\n          t *= i, e *= i, r *= i;\n        }\n        const i = Math.min(Math.max(t, 0), 1),\n          s = Math.min(Math.max(e, 0), 1),\n          o = Math.min(Math.max(r, 0), 1),\n          a = Math.min(i, s, o),\n          l = Math.max(i, s, o),\n          u = l - a,\n          c = .5 * (a + l);\n        if (0 === u) return [0, 0, 100 * c, n];\n        const h = c > .5 ? u / (2 - l - a) : u / (l + a);\n        let p;\n        switch (l) {\n          case i:\n            p = 60 * ((s - o) / u + (s < o ? 6 : 0));\n            break;\n          case s:\n            p = 60 * ((o - i) / u + 2);\n            break;\n          default:\n            p = 60 * ((i - s) / u + 4);\n        }\n        return [p, 100 * h, 100 * c, n];\n      }\n      toArray01() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return [t, e, r, n];\n      }\n      toArray01Scaled(t) {\n        const {\n          r: e,\n          g: r,\n          b: n\n        } = this;\n        return [e * t, r * t, n * t];\n      }\n      toArray01Linear() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return [Math.pow(t, 2.2), Math.pow(e, 2.2), Math.pow(r, 2.2), n];\n      }\n    }\n    class ar extends or {\n      constructor(t, e, r, n, i) {\n        super(t, e, r, n, i, !1);\n      }\n    }\n    class lr extends or {\n      constructor(t, e, r, n, i) {\n        super(t, e, r, n, i, !0);\n      }\n    }\n    function ur(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n    function cr(t, e, r) {\n      return t.map((t, n) => ur(t, e[n], r));\n    }\n    sr.black = new sr(0, 0, 0, 1), sr.white = new sr(1, 1, 1, 1), sr.transparent = new sr(0, 0, 0, 0), sr.red = new sr(1, 0, 0, 1), sr.blue = new sr(0, 0, 1, 1);\n    var hr = Object.freeze({\n      __proto__: null,\n      array: cr,\n      color: function (t, e, r) {\n        return new sr(ur(t.r, e.r, r), ur(t.g, e.g, r), ur(t.b, e.b, r), ur(t.a, e.a, r));\n      },\n      number: ur\n    });\n    class pr extends Error {\n      constructor(t, e) {\n        super(e), this.message = e, this.key = t;\n      }\n    }\n    class dr {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.parent = t, this.bindings = {};\n        for (const [t, r] of e) this.bindings[t] = r;\n      }\n      concat(t) {\n        return new dr(this, t);\n      }\n      get(t) {\n        if (this.bindings[t]) return this.bindings[t];\n        if (this.parent) return this.parent.get(t);\n        throw new Error(\"\".concat(t, \" not found in scope.\"));\n      }\n      has(t) {\n        return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n      }\n    }\n    const fr = {\n        kind: \"null\"\n      },\n      mr = {\n        kind: \"number\"\n      },\n      yr = {\n        kind: \"string\"\n      },\n      gr = {\n        kind: \"boolean\"\n      },\n      xr = {\n        kind: \"color\"\n      },\n      vr = {\n        kind: \"object\"\n      },\n      br = {\n        kind: \"value\"\n      },\n      wr = {\n        kind: \"collator\"\n      },\n      _r = {\n        kind: \"formatted\"\n      },\n      Ar = {\n        kind: \"resolvedImage\"\n      };\n    function Mr(t, e) {\n      return {\n        kind: \"array\",\n        itemType: t,\n        N: e\n      };\n    }\n    function Ir(t) {\n      if (\"array\" === t.kind) {\n        const e = Ir(t.itemType);\n        return \"number\" == typeof t.N ? \"array<\".concat(e, \", \").concat(t.N, \">\") : \"value\" === t.itemType.kind ? \"array\" : \"array<\".concat(e, \">\");\n      }\n      return t.kind;\n    }\n    const Sr = [fr, mr, yr, gr, xr, _r, vr, Mr(br), Ar];\n    function Pr(t, e) {\n      if (\"error\" === e.kind) return null;\n      if (\"array\" === t.kind) {\n        if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !Pr(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if (\"value\" === t.kind) for (const t of Sr) if (!Pr(t, e)) return null;\n      }\n      return \"Expected \".concat(Ir(t), \" but found \").concat(Ir(e), \" instead.\");\n    }\n    function kr(t, e) {\n      return e.some(e => e.kind === t.kind);\n    }\n    function zr(t, e) {\n      return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n    }\n    function Er(t, e) {\n      return \"array\" === t.kind && \"array\" === e.kind ? t.N === e.N && Er(t.itemType, e.itemType) : t.kind === e.kind;\n    }\n    class Tr {\n      constructor(t, e, r) {\n        this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n          sensitivity: this.sensitivity,\n          usage: \"search\"\n        });\n      }\n      compare(t, e) {\n        return this.collator.compare(t, e);\n      }\n      resolvedLocale() {\n        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n      }\n    }\n    class Br {\n      constructor(t, e, r, n, i) {\n        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      }\n    }\n    class Vr {\n      constructor(t) {\n        this.sections = t;\n      }\n      static fromString(t) {\n        return new Vr([new Br(t, null, null, null, null)]);\n      }\n      isEmpty() {\n        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || !!t.image && t.image.hasPrimary());\n      }\n      static factory(t) {\n        return t instanceof Vr ? t : Vr.fromString(t);\n      }\n      toString() {\n        return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          if (e.image) {\n            const r = e.image.getPrimary().id.toString();\n            t.push([\"image\", r]);\n            continue;\n          }\n          t.push(e.text);\n          const r = {};\n          e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toNonPremultipliedRenderColor(null).toArray())), t.push(r);\n        }\n        return t;\n      }\n    }\n    class Fr {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.id = er.from(t), this.options = Object.assign({}, e), e.transform) {\n          const {\n            a: t,\n            b: r,\n            c: n,\n            d: i,\n            e: s,\n            f: o\n          } = e.transform;\n          this.options.transform = new DOMMatrix([t, r, n, i, s, o]);\n        } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);\n      }\n      toString() {\n        const {\n          a: t,\n          b: e,\n          c: r,\n          d: n,\n          e: i,\n          f: s\n        } = this.options.transform;\n        return JSON.stringify({\n          name: this.id.name,\n          iconsetId: this.id.iconsetId,\n          params: this.options.params,\n          transform: {\n            a: t,\n            b: e,\n            c: r,\n            d: n,\n            e: i,\n            f: s\n          }\n        });\n      }\n      static parse(t) {\n        let e, r, n, i;\n        try {\n          ({\n            name: e,\n            iconsetId: r,\n            params: n,\n            transform: i\n          } = JSON.parse(t) || {});\n        } catch (t) {\n          return null;\n        }\n        if (!e) return null;\n        const {\n          a: s,\n          b: o,\n          c: a,\n          d: l,\n          e: u,\n          f: c\n        } = i || {};\n        return new Fr({\n          name: e,\n          iconsetId: r\n        }, {\n          params: n,\n          transform: new DOMMatrix([s, o, a, l, u, c])\n        });\n      }\n      scaleSelf(t, e) {\n        return this.options.transform.scaleSelf(t, e), this;\n      }\n    }\n    class Cr {\n      constructor(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n        this.primaryId = er.from(t), this.primaryOptions = e, r && (this.secondaryId = er.from(r)), this.secondaryOptions = n, this.available = i;\n      }\n      toString() {\n        return this.primaryId && this.secondaryId ? \"[\".concat(this.primaryId.name, \",\").concat(this.secondaryId.name, \"]\") : this.primaryId.name;\n      }\n      hasPrimary() {\n        return !!this.primaryId;\n      }\n      getPrimary() {\n        return new Fr(this.primaryId, this.primaryOptions);\n      }\n      hasSecondary() {\n        return !!this.secondaryId;\n      }\n      getSecondary() {\n        return this.secondaryId ? new Fr(this.secondaryId, this.secondaryOptions) : null;\n      }\n      static from(t) {\n        return \"string\" == typeof t ? Cr.build({\n          name: t\n        }) : t;\n      }\n      static build(t, e, r, n) {\n        return !t || \"object\" == typeof t && !(\"name\" in t) ? null : new Cr(t, r, e, n);\n      }\n    }\n    function Dr(t, e, r, n) {\n      return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : \"Invalid rgba value [\".concat([t, e, r, n].join(\", \"), \"]: 'a' must be between 0 and 1.\") : \"Invalid rgba value [\".concat((\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \"), \"]: 'r', 'g', and 'b' must be between 0 and 255.\");\n    }\n    function Rr(t) {\n      if (null === t) return !0;\n      if (\"string\" == typeof t) return !0;\n      if (\"boolean\" == typeof t) return !0;\n      if (\"number\" == typeof t) return !0;\n      if (t instanceof sr) return !0;\n      if (t instanceof Tr) return !0;\n      if (t instanceof Vr) return !0;\n      if (t instanceof Cr) return !0;\n      if (Array.isArray(t)) {\n        for (const e of t) if (!Rr(e)) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof t) {\n        for (const e in t) if (!Rr(t[e])) return !1;\n        return !0;\n      }\n      return !1;\n    }\n    function Lr(t) {\n      if (null === t) return fr;\n      if (\"string\" == typeof t) return yr;\n      if (\"boolean\" == typeof t) return gr;\n      if (\"number\" == typeof t) return mr;\n      if (t instanceof sr) return xr;\n      if (t instanceof Tr) return wr;\n      if (t instanceof Vr) return _r;\n      if (t instanceof Cr) return Ar;\n      if (Array.isArray(t)) {\n        const e = t.length;\n        let r;\n        for (const e of t) {\n          const t = Lr(e);\n          if (r) {\n            if (r === t) continue;\n            r = br;\n            break;\n          }\n          r = t;\n        }\n        return Mr(r || br, e);\n      }\n      return vr;\n    }\n    function Or(t) {\n      const e = typeof t;\n      return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof Vr || t instanceof Cr || t instanceof sr ? t.toString() : JSON.stringify(t);\n    }\n    class Ur {\n      constructor(t, e) {\n        this.type = t, this.value = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"'literal' expression requires exactly one argument, but found \".concat(t.length - 1, \" instead.\"));\n        if (!Rr(t[1])) return e.error(\"invalid value\");\n        const r = t[1];\n        let n = Lr(r);\n        const i = e.expectedType;\n        return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new Ur(n, r);\n      }\n      evaluate() {\n        return this.value;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof sr ? [\"rgba\"].concat(this.value.toNonPremultipliedRenderColor(null).toArray()) : this.value instanceof Vr ? this.value.serialize() : this.value;\n      }\n    }\n    class Nr {\n      constructor(t) {\n        this.name = \"ExpressionEvaluationError\", this.message = t;\n      }\n      toJSON() {\n        return this.message;\n      }\n    }\n    const jr = {\n      string: yr,\n      number: mr,\n      boolean: gr,\n      object: vr\n    };\n    class $r {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        let r,\n          n = 1;\n        const i = t[0];\n        if (\"array\" === i) {\n          let i, s;\n          if (t.length > 2) {\n            const r = t[1];\n            if (\"string\" != typeof r || !(r in jr) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            i = jr[r], n++;\n          } else i = br;\n          if (t.length > 3) {\n            if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n            s = t[2], n++;\n          }\n          r = Mr(i, s);\n        } else r = jr[i];\n        const s = [];\n        for (; n < t.length; n++) {\n          const r = e.parse(t[n], n, br);\n          if (!r) return null;\n          s.push(r);\n        }\n        return new $r(r, s);\n      }\n      evaluate(t) {\n        for (let e = 0; e < this.args.length; e++) {\n          const r = this.args[e].evaluate(t);\n          if (!Pr(this.type, Lr(r))) return r;\n          if (e === this.args.length - 1) throw new Nr(\"The expression \".concat(JSON.stringify(this.args[e].serialize()), \" evaluated to \").concat(Ir(Lr(r)), \" but was expected to be of type \").concat(Ir(this.type), \".\"));\n        }\n        return null;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = this.type,\n          e = [t.kind];\n        if (\"array\" === t.kind) {\n          const r = t.itemType;\n          if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n            e.push(r.kind);\n            const n = t.N;\n            (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n          }\n        }\n        return e.concat(this.args.map(t => t.serialize()));\n      }\n    }\n    class Gr {\n      constructor(t) {\n        this.type = _r, this.sections = t;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[1];\n        if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n        const n = [];\n        let i = !1;\n        for (let r = 1; r <= t.length - 1; ++r) {\n          const s = t[r];\n          if (i && \"object\" == typeof s && !Array.isArray(s)) {\n            i = !1;\n            let t = null;\n            if (s[\"font-scale\"] && (t = e.parseObjectValue(s[\"font-scale\"], r, \"font-scale\", mr), !t)) return null;\n            let o = null;\n            if (s[\"text-font\"] && (o = e.parseObjectValue(s[\"text-font\"], r, \"text-font\", Mr(yr)), !o)) return null;\n            let a = null;\n            if (s[\"text-color\"] && (a = e.parseObjectValue(s[\"text-color\"], r, \"text-color\", xr), !a)) return null;\n            const l = n[n.length - 1];\n            l.scale = t, l.font = o, l.textColor = a;\n          } else {\n            const s = e.parse(t[r], r, br);\n            if (!s) return null;\n            const o = s.type.kind;\n            if (\"string\" !== o && \"value\" !== o && \"null\" !== o && \"resolvedImage\" !== o) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n            i = !0, n.push({\n              content: s,\n              scale: null,\n              font: null,\n              textColor: null\n            });\n          }\n        }\n        return new Gr(n);\n      }\n      evaluate(t) {\n        return new Vr(this.sections.map(e => {\n          const r = e.content.evaluate(t);\n          return Er(Lr(r), Ar) ? new Br(\"\", r, null, null, null) : new Br(Or(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n        }));\n      }\n      eachChild(t) {\n        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          t.push(e.content.serialize());\n          const r = {};\n          e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n        }\n        return t;\n      }\n    }\n    class Hr {\n      constructor(t, e, r, n) {\n        this._imageWarnHistory = {}, this.type = Ar, this.namePrimary = t, this.nameSecondary = e, r && (this.paramsPrimary = r.params, this.iconsetIdPrimary = r.iconset ? r.iconset.id : void 0), n && (this.paramsSecondary = n.params, this.iconsetIdSecondary = n.iconset ? n.iconset.id : void 0);\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected two or more arguments.\");\n        let r = 1;\n        const n = [];\n        function i() {\n          if (r < t.length) {\n            const i = e.parse(t[r], r++, yr);\n            return i ? (n.push({\n              image: i,\n              options: {}\n            }), !0) : (e.error(n.length ? \"Secondary image variant is not a string.\" : \"No image name provided.\"), !1);\n          }\n          return !0;\n        }\n        function s() {\n          if (r < t.length) {\n            const s = t[r];\n            if (null === (i = s) || \"object\" != typeof i || Array.isArray(i)) return !0;\n            const o = s.params,\n              a = s.iconset,\n              l = e.concat(r);\n            if (!o && !a) return r++, !0;\n            if (o) {\n              if (\"object\" != typeof o || o.constructor !== Object) return l.error('Image options \"params\" should be an object'), !1;\n              const t = {},\n                e = l.concat(void 0, \"params\");\n              for (const r in o) {\n                if (!r) return e.error(\"Image parameter name should be non-empty\"), !1;\n                const n = e.concat(void 0, r).parse(o[r], void 0, xr, void 0, {\n                  typeAnnotation: \"coerce\"\n                });\n                if (!n) return !1;\n                t[r] = n;\n              }\n              n[n.length - 1].options.params = t;\n            }\n            if (a) {\n              if (\"object\" != typeof a || a.constructor !== Object) return l.error('Image options \"iconset\" should be an object'), !1;\n              if (!a.id) return l.error('Image options \"iconset\" should have an \"id\" property'), !1;\n              n[n.length - 1].options.iconset = a;\n            }\n            return r++, !0;\n          }\n          var i;\n          return !0;\n        }\n        for (let t = 0; t < 2; t++) if (!i() || !s()) return;\n        return new Hr(n[0].image, n[1] ? n[1].image : void 0, n[0].options, n[1] ? n[1].options : void 0);\n      }\n      evaluateParams(t, e) {\n        const r = {};\n        if (e) {\n          for (const n in e) if (e[n]) try {\n            r[n] = e[n].evaluate(t);\n          } catch (t) {\n            continue;\n          }\n          if (0 !== Object.keys(r).length) return {\n            params: r\n          };\n        }\n      }\n      evaluate(t) {\n        const e = {\n            name: this.namePrimary.evaluate(t),\n            iconsetId: this.iconsetIdPrimary\n          },\n          r = this.nameSecondary ? {\n            name: this.nameSecondary.evaluate(t),\n            iconsetId: this.iconsetIdSecondary\n          } : void 0,\n          n = Cr.build(e, r, this.paramsPrimary ? this.evaluateParams(t, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t, this.paramsSecondary) : void 0);\n        if (n && t.availableImages) {\n          const e = n.getPrimary().id;\n          if (n.available = t.availableImages.some(t => er.isEqual(t, e)), n.available) {\n            const e = n.getSecondary() ? n.getSecondary().id : null;\n            e && (n.available = t.availableImages.some(t => er.isEqual(t, e)));\n          }\n        }\n        return n;\n      }\n      eachChild(t) {\n        if (t(this.namePrimary), this.paramsPrimary) for (const e in this.paramsPrimary) this.paramsPrimary[e] && t(this.paramsPrimary[e]);\n        if (this.nameSecondary && (t(this.nameSecondary), this.paramsSecondary)) for (const e in this.paramsSecondary) this.paramsSecondary[e] && t(this.paramsSecondary[e]);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serializeOptions(t, e) {\n        const r = {};\n        if (e && (r.iconset = {\n          id: e\n        }), t) {\n          r.params = {};\n          for (const e in t) t[e] && (r.params[e] = t[e].serialize());\n        }\n        return Object.keys(r).length > 0 ? r : void 0;\n      }\n      serialize() {\n        const t = [\"image\", this.namePrimary.serialize()];\n        if (this.paramsPrimary || this.iconsetIdPrimary) {\n          const e = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);\n          e && t.push(e);\n        }\n        if (this.nameSecondary && (t.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {\n          const e = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);\n          e && t.push(e);\n        }\n        return t;\n      }\n    }\n    function qr(t) {\n      return Zr(t) ? \"string\" : Wr(t) ? \"number\" : Yr(t) ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : Xr(t) ? \"object\" : typeof t;\n    }\n    function Xr(t) {\n      return null != t && !Array.isArray(t) && \"function\" != typeof t && !(t instanceof String || t instanceof Number || t instanceof Boolean) && \"object\" == typeof t;\n    }\n    function Zr(t) {\n      return \"string\" == typeof t || t instanceof String;\n    }\n    function Wr(t) {\n      return \"number\" == typeof t || t instanceof Number;\n    }\n    function Yr(t) {\n      return \"boolean\" == typeof t || t instanceof Boolean;\n    }\n    const Kr = {\n      \"to-boolean\": gr,\n      \"to-color\": xr,\n      \"to-number\": mr,\n      \"to-string\": yr\n    };\n    class Jr {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[0],\n          n = [];\n        let i = fr;\n        if (\"to-array\" === r) {\n          if (!Array.isArray(t[1])) return null;\n          const r = t[1].length;\n          if (e.expectedType) {\n            if (\"array\" !== e.expectedType.kind) return e.error(\"Expected \".concat(e.expectedType.kind, \" but found array.\"));\n            i = Mr(e.expectedType.itemType, r);\n          } else {\n            if (!(r > 0 && Rr(t[1][0]))) return null;\n            i = Mr(Lr(t[1][0]), r);\n          }\n          for (let s = 0; s < r; s++) {\n            const r = t[1][s];\n            let o;\n            if (Array.isArray(r)) o = e.parse(r, void 0, i.itemType);else {\n              const t = qr(r);\n              if (t !== i.itemType.kind) return e.error(\"Expected \".concat(i.itemType.kind, \" but found \").concat(t, \".\"));\n              o = e.registry.literal.parse([\"literal\", void 0 === r ? null : r], e);\n            }\n            if (!o) return null;\n            n.push(o);\n          }\n        } else {\n          if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n          i = Kr[r];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], r, br);\n            if (!i) return null;\n            n.push(i);\n          }\n        }\n        return new Jr(i, n);\n      }\n      evaluate(t) {\n        if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n        if (\"color\" === this.type.kind) {\n          let e, r;\n          for (const n of this.args) {\n            if (e = n.evaluate(t), r = null, e instanceof sr) return e;\n            if (\"string\" == typeof e) {\n              const r = t.parseColor(e);\n              if (r) return r;\n            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? \"Invalid rbga value \".concat(JSON.stringify(e), \": expected an array containing either three or four numeric values.\") : Dr(e[0], e[1], e[2], e[3]), !r)) return new sr(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n          }\n          throw new Nr(r || \"Could not parse color from value '\".concat(\"string\" == typeof e ? e : String(JSON.stringify(e)), \"'\"));\n        }\n        if (\"number\" === this.type.kind) {\n          let e = null;\n          for (const r of this.args) {\n            if (e = r.evaluate(t), null === e) return 0;\n            const n = Number(e);\n            if (!isNaN(n)) return n;\n          }\n          throw new Nr(\"Could not convert \".concat(JSON.stringify(e), \" to number.\"));\n        }\n        return \"formatted\" === this.type.kind ? Vr.fromString(Or(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? Cr.build(Or(this.args[0].evaluate(t))) : \"array\" === this.type.kind ? this.args.map(e => e.evaluate(t)) : Or(this.args[0].evaluate(t));\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        if (\"formatted\" === this.type.kind) return new Gr([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n        if (\"resolvedImage\" === this.type.kind) return new Hr(this.args[0]).serialize();\n        const t = \"array\" === this.type.kind ? [] : [\"to-\".concat(this.type.kind)];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    const Qr = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n    class tn {\n      constructor(t, e, r) {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t, this.options = e, this.iconImageUseTheme = r;\n      }\n      id() {\n        return this.feature && void 0 !== this.feature.id ? this.feature.id : null;\n      }\n      geometryType() {\n        return this.feature ? \"number\" == typeof this.feature.type ? Qr[this.feature.type] : this.feature.type : null;\n      }\n      geometry() {\n        return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n      }\n      canonicalID() {\n        return this.canonical;\n      }\n      properties() {\n        return this.feature && this.feature.properties || {};\n      }\n      measureLight(t) {\n        return this.globals.brightness || 0;\n      }\n      distanceFromCenter() {\n        if (this.featureTileCoord && this.featureDistanceData) {\n          const t = this.featureDistanceData.center,\n            e = this.featureDistanceData.scale,\n            {\n              x: r,\n              y: n\n            } = this.featureTileCoord;\n          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);\n        }\n        return 0;\n      }\n      parseColor(t) {\n        let e = this._parseColorCache[t];\n        return e || (e = this._parseColorCache[t] = sr.parse(t)), e;\n      }\n      getConfig(t) {\n        return this.options ? this.options.get(t) : null;\n      }\n    }\n    class en {\n      constructor(t, e, r, n, i) {\n        this.name = t, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;\n      }\n      evaluate(t) {\n        if (!this._evaluate) {\n          const t = en.definitions[this.name];\n          this._evaluate = Array.isArray(t) ? t[2] : t.overloads[this._overloadIndex][1];\n        }\n        return this._evaluate(t, this.args);\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [this.name].concat(this.args.map(t => t.serialize()));\n      }\n      static parse(t, e) {\n        const r = t[0],\n          n = en.definitions[r];\n        if (!n) return e.error(\"Unknown expression \\\"\".concat(r, \"\\\". If you wanted a literal array, use [\\\"literal\\\", [...]].\"), 0);\n        const i = Array.isArray(n) ? n[0] : n.type,\n          s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n          o = [];\n        let a = null,\n          l = -1;\n        for (const [n, u] of s) {\n          if (Array.isArray(n) && n.length !== t.length - 1) continue;\n          o.push(n), l++, a = new Ai(e.registry, e.path, null, e.scope, void 0, e._scope, e.options, e.iconImageUseTheme);\n          const s = [];\n          let c = !1;\n          for (let e = 1; e < t.length; e++) {\n            const r = t[e],\n              i = Array.isArray(n) ? n[e - 1] : n.type,\n              o = a.parse(r, 1 + s.length, i);\n            if (!o) {\n              c = !0;\n              break;\n            }\n            s.push(o);\n          }\n          if (!c) if (Array.isArray(n) && n.length !== s.length) a.error(\"Expected \".concat(n.length, \" arguments, but found \").concat(s.length, \" instead.\"));else {\n            for (let t = 0; t < s.length; t++) {\n              const e = Array.isArray(n) ? n[t] : n.type,\n                r = s[t];\n              a.concat(t + 1).checkSubtype(e, r.type);\n            }\n            if (0 === a.errors.length) return new en(r, i, u, s, l);\n          }\n        }\n        if (1 === o.length) e.errors.push(...a.errors);else {\n          const r = (o.length ? o : s.map(_ref2 => {\n              let [t] = _ref2;\n              return t;\n            })).map(rn).join(\" | \"),\n            n = [];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], 1 + n.length);\n            if (!i) return null;\n            n.push(Ir(i.type));\n          }\n          e.error(\"Expected arguments of type \".concat(r, \", but found (\").concat(n.join(\", \"), \") instead.\"));\n        }\n        return null;\n      }\n      static register(t, e) {\n        en.definitions = e;\n        for (const r in e) t[r] = en;\n      }\n    }\n    function rn(t) {\n      return Array.isArray(t) ? \"(\".concat(t.map(Ir).join(\", \"), \")\") : \"(\".concat(Ir(t.type), \"...)\");\n    }\n    class nn {\n      constructor(t, e, r) {\n        this.type = wr, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected one argument.\");\n        const r = t[1];\n        if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n        const n = void 0 === r[\"case-sensitive\"] ? e.parse(!1, 1, gr) : e.parseObjectValue(r[\"case-sensitive\"], 1, \"case-sensitive\", gr);\n        if (!n) return null;\n        const i = void 0 === r[\"diacritic-sensitive\"] ? e.parse(!1, 1, gr) : e.parseObjectValue(r[\"diacritic-sensitive\"], 1, \"diacritic-sensitive\", gr);\n        if (!i) return null;\n        let s = null;\n        return r.locale && (s = e.parseObjectValue(r.locale, 1, \"locale\", yr), !s) ? null : new nn(n, i, s);\n      }\n      evaluate(t) {\n        return new Tr(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n      }\n      eachChild(t) {\n        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n      }\n    }\n    function sn(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : t.length - 1;\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : an;\n      for (; n > r;) {\n        if (n - r > 600) {\n          const s = n - r + 1,\n            o = e - r + 1,\n            a = Math.log(s),\n            l = .5 * Math.exp(2 * a / 3),\n            u = .5 * Math.sqrt(a * l * (s - l) / s) * (o - s / 2 < 0 ? -1 : 1);\n          sn(t, e, Math.max(r, Math.floor(e - o * l / s + u)), Math.min(n, Math.floor(e + (s - o) * l / s + u)), i);\n        }\n        const s = t[e];\n        let o = r,\n          a = n;\n        for (on(t, r, e), i(t[n], s) > 0 && on(t, r, n); o < a;) {\n          for (on(t, o, a), o++, a--; i(t[o], s) < 0;) o++;\n          for (; i(t[a], s) > 0;) a--;\n        }\n        0 === i(t[r], s) ? on(t, r, a) : (a++, on(t, a, n)), a <= e && (r = a + 1), e <= a && (n = a - 1);\n      }\n    }\n    function on(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function an(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function ln(t) {\n      let e = 0;\n      for (let r, n, i = 0, s = t.length, o = s - 1; i < s; o = i++) r = t[i], n = t[o], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function un(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n    function cn(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n    function hn(t, e, r) {\n      const n = t[0] - e[0],\n        i = t[1] - e[1],\n        s = t[0] - r[0],\n        o = t[1] - r[1];\n      return n * o - s * i == 0 && n * s <= 0 && i * o <= 0;\n    }\n    function pn(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      let n = !1;\n      for (let a = 0, l = e.length; a < l; a++) {\n        const l = e[a];\n        for (let e = 0, a = l.length, u = a - 1; e < a; u = e++) {\n          const a = l[u],\n            c = l[e];\n          if (hn(t, a, c)) return r;\n          (s = a)[1] > (i = t)[1] != (o = c)[1] > i[1] && i[0] < (o[0] - s[0]) * (i[1] - s[1]) / (o[1] - s[1]) + s[0] && (n = !n);\n        }\n      }\n      var i, s, o;\n      return n;\n    }\n    function dn(t, e, r, n) {\n      const i = n[0] - r[0],\n        s = n[1] - r[1],\n        o = (t[0] - r[0]) * s - i * (t[1] - r[1]),\n        a = (e[0] - r[0]) * s - i * (e[1] - r[1]);\n      return o > 0 && a < 0 || o < 0 && a > 0;\n    }\n    function fn(t, e, r, n) {\n      return 0 != (i = [n[0] - r[0], n[1] - r[1]])[0] * (s = [e[0] - t[0], e[1] - t[1]])[1] - i[1] * s[0] && !(!dn(t, e, r, n) || !dn(r, n, t, e));\n      var i, s;\n    }\n    function mn(t) {\n      const e = new wt(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),\n        r = new wt(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n      for (const n of t[0]) e.x > n.x && (e.x = n.x), e.y > n.y && (e.y = n.y), r.x < n.x && (r.x = n.x), r.y < n.y && (r.y = n.y);\n      return {\n        min: e,\n        max: r\n      };\n    }\n    const yn = 8192;\n    function gn(t, e) {\n      const r = (180 + t[0]) / 360,\n        n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n        i = Math.pow(2, e.z);\n      return [Math.round(r * i * yn), Math.round(n * i * yn)];\n    }\n    function xn(t, e) {\n      for (let r = 0; r < e.length; r++) if (pn(t, e[r])) return !0;\n      return !1;\n    }\n    function vn(t, e, r) {\n      for (const n of r) for (let r = 0, i = n.length, s = i - 1; r < i; s = r++) if (fn(t, e, n[s], n[r])) return !0;\n      return !1;\n    }\n    function bn(t, e) {\n      for (let r = 0; r < t.length; ++r) if (!pn(t[r], e)) return !1;\n      for (let r = 0; r < t.length - 1; ++r) if (vn(t[r], t[r + 1], e)) return !1;\n      return !0;\n    }\n    function wn(t, e) {\n      for (let r = 0; r < e.length; r++) if (bn(t, e[r])) return !0;\n      return !1;\n    }\n    function _n(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const s = [];\n        for (let n = 0; n < t[i].length; n++) {\n          const o = gn(t[i][n], r);\n          un(e, o), s.push(o);\n        }\n        n.push(s);\n      }\n      return n;\n    }\n    function An(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const s = _n(t[i], e, r);\n        n.push(s);\n      }\n      return n;\n    }\n    function Mn(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        const e = .5 * n;\n        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n      }\n      un(e, t);\n    }\n    function In(t, e, r, n) {\n      const i = Math.pow(2, n.z) * yn,\n        s = [n.x * yn, n.y * yn],\n        o = [];\n      if (!t) return o;\n      for (const n of t) for (const t of n) {\n        const n = [t.x + s[0], t.y + s[1]];\n        Mn(n, e, r, i), o.push(n);\n      }\n      return o;\n    }\n    function Sn(t, e, r, n) {\n      const i = Math.pow(2, n.z) * yn,\n        s = [n.x * yn, n.y * yn],\n        o = [];\n      if (!t) return o;\n      for (const r of t) {\n        const t = [];\n        for (const n of r) {\n          const r = [n.x + s[0], n.y + s[1]];\n          un(e, r), t.push(r);\n        }\n        o.push(t);\n      }\n      if (e[2] - e[0] <= i / 2) {\n        (a = e)[0] = a[1] = 1 / 0, a[2] = a[3] = -1 / 0;\n        for (const t of o) for (const n of t) Mn(n, e, r, i);\n      }\n      var a;\n      return o;\n    }\n    class Pn {\n      constructor(t, e) {\n        this.type = gr, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"'within' expression requires exactly one argument, but found \".concat(t.length - 1, \" instead.\"));\n        if (Rr(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n            const r = e.features[t].geometry.type;\n            if (\"Polygon\" === r || \"MultiPolygon\" === r) return new Pn(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            const t = e.geometry.type;\n            if (\"Polygon\" === t || \"MultiPolygon\" === t) return new Pn(e, e.geometry);\n          } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new Pn(e, e);\n        }\n        return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n      }\n      evaluate(t) {\n        if (null != t.geometry() && null != t.canonicalID()) {\n          if (\"Point\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const s = _n(e.coordinates, n, i),\n                o = In(t.geometry(), r, n, i);\n              if (!cn(r, n)) return !1;\n              for (const t of o) if (!pn(t, s)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const s = An(e.coordinates, n, i),\n                o = In(t.geometry(), r, n, i);\n              if (!cn(r, n)) return !1;\n              for (const t of o) if (!xn(t, s)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const s = _n(e.coordinates, n, i),\n                o = Sn(t.geometry(), r, n, i);\n              if (!cn(r, n)) return !1;\n              for (const t of o) if (!bn(t, s)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const s = An(e.coordinates, n, i),\n                o = Sn(t.geometry(), r, n, i);\n              if (!cn(r, n)) return !1;\n              for (const t of o) if (!wn(t, s)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n        }\n        return !1;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"within\", this.geojson];\n      }\n    }\n    const kn = {\n        kilometers: 1,\n        miles: 1e3 / 1609.344,\n        nauticalmiles: 1e3 / 1852,\n        meters: 1e3,\n        metres: 1e3,\n        yards: 1e3 / .9144,\n        feet: 1e3 / .3048,\n        inches: 1e3 / .0254\n      },\n      zn = 1 / 298.257223563,\n      En = zn * (2 - zn),\n      Tn = Math.PI / 180;\n    class Bn {\n      static fromTile(t, e, r) {\n        const n = Math.PI * (1 - 2 * (t + .5) / Math.pow(2, e)),\n          i = Math.atan(.5 * (Math.exp(n) - Math.exp(-n))) / Tn;\n        return new Bn(i, r);\n      }\n      static get units() {\n        return kn;\n      }\n      constructor(t, e) {\n        if (void 0 === t) throw new Error(\"No latitude given.\");\n        if (e && !kn[e]) throw new Error(\"Unknown unit \".concat(e, \". Use one of: \").concat(Object.keys(kn).join(\", \")));\n        const r = 6378.137 * Tn * (e ? kn[e] : 1),\n          n = Math.cos(t * Tn),\n          i = 1 / (1 - En * (1 - n * n)),\n          s = Math.sqrt(i);\n        this.kx = r * s * n, this.ky = r * s * i * (1 - En);\n      }\n      distance(t, e) {\n        const r = Cn(t[0] - e[0]) * this.kx,\n          n = (t[1] - e[1]) * this.ky;\n        return Math.sqrt(r * r + n * n);\n      }\n      bearing(t, e) {\n        const r = Cn(e[0] - t[0]) * this.kx;\n        return Math.atan2(r, (e[1] - t[1]) * this.ky) / Tn;\n      }\n      destination(t, e, r) {\n        const n = r * Tn;\n        return this.offset(t, Math.sin(n) * e, Math.cos(n) * e);\n      }\n      offset(t, e, r) {\n        return [t[0] + e / this.kx, t[1] + r / this.ky];\n      }\n      lineDistance(t) {\n        let e = 0;\n        for (let r = 0; r < t.length - 1; r++) e += this.distance(t[r], t[r + 1]);\n        return e;\n      }\n      area(t) {\n        let e = 0;\n        for (let r = 0; r < t.length; r++) {\n          const n = t[r];\n          for (let t = 0, i = n.length, s = i - 1; t < i; s = t++) e += Cn(n[t][0] - n[s][0]) * (n[t][1] + n[s][1]) * (r ? -1 : 1);\n        }\n        return Math.abs(e) / 2 * this.kx * this.ky;\n      }\n      along(t, e) {\n        let r = 0;\n        if (e <= 0) return t[0];\n        for (let n = 0; n < t.length - 1; n++) {\n          const i = t[n],\n            s = t[n + 1],\n            o = this.distance(i, s);\n          if (r += o, r > e) return Fn(i, s, (e - (r - o)) / o);\n        }\n        return t[t.length - 1];\n      }\n      pointToSegmentDistance(t, e, r) {\n        let [n, i] = e,\n          s = Cn(r[0] - n) * this.kx,\n          o = (r[1] - i) * this.ky;\n        if (0 !== s || 0 !== o) {\n          const e = (Cn(t[0] - n) * this.kx * s + (t[1] - i) * this.ky * o) / (s * s + o * o);\n          e > 1 ? (n = r[0], i = r[1]) : e > 0 && (n += s / this.kx * e, i += o / this.ky * e);\n        }\n        return s = Cn(t[0] - n) * this.kx, o = (t[1] - i) * this.ky, Math.sqrt(s * s + o * o);\n      }\n      pointOnLine(t, e) {\n        let r = 1 / 0,\n          n = t[0][0],\n          i = t[0][1],\n          s = 0,\n          o = 0;\n        for (let a = 0; a < t.length - 1; a++) {\n          let l = t[a][0],\n            u = t[a][1],\n            c = Cn(t[a + 1][0] - l) * this.kx,\n            h = (t[a + 1][1] - u) * this.ky,\n            p = 0;\n          0 === c && 0 === h || (p = (Cn(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t[a + 1][0], u = t[a + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = Cn(e[0] - l) * this.kx, h = (e[1] - u) * this.ky;\n          const d = c * c + h * h;\n          d < r && (r = d, n = l, i = u, s = a, o = p);\n        }\n        return {\n          point: [n, i],\n          index: s,\n          t: Math.max(0, Math.min(1, o))\n        };\n      }\n      lineSlice(t, e, r) {\n        let n = this.pointOnLine(r, t),\n          i = this.pointOnLine(r, e);\n        if (n.index > i.index || n.index === i.index && n.t > i.t) {\n          const t = n;\n          n = i, i = t;\n        }\n        const s = [n.point],\n          o = n.index + 1,\n          a = i.index;\n        !Vn(r[o], s[0]) && o <= a && s.push(r[o]);\n        for (let t = o + 1; t <= a; t++) s.push(r[t]);\n        return Vn(r[a], i.point) || s.push(i.point), s;\n      }\n      lineSliceAlong(t, e, r) {\n        let n = 0;\n        const i = [];\n        for (let s = 0; s < r.length - 1; s++) {\n          const o = r[s],\n            a = r[s + 1],\n            l = this.distance(o, a);\n          if (n += l, n > t && 0 === i.length && i.push(Fn(o, a, (t - (n - l)) / l)), n >= e) return i.push(Fn(o, a, (e - (n - l)) / l)), i;\n          n > t && i.push(a);\n        }\n        return i;\n      }\n      bufferPoint(t, e) {\n        const r = e / this.ky,\n          n = e / this.kx;\n        return [t[0] - n, t[1] - r, t[0] + n, t[1] + r];\n      }\n      bufferBBox(t, e) {\n        const r = e / this.ky,\n          n = e / this.kx;\n        return [t[0] - n, t[1] - r, t[2] + n, t[3] + r];\n      }\n      insideBBox(t, e) {\n        return Cn(t[0] - e[0]) >= 0 && Cn(t[0] - e[2]) <= 0 && t[1] >= e[1] && t[1] <= e[3];\n      }\n    }\n    function Vn(t, e) {\n      return t[0] === e[0] && t[1] === e[1];\n    }\n    function Fn(t, e, r) {\n      const n = Cn(e[0] - t[0]);\n      return [t[0] + n * r, t[1] + (e[1] - t[1]) * r];\n    }\n    function Cn(t) {\n      for (; t < -180;) t += 360;\n      for (; t > 180;) t -= 360;\n      return t;\n    }\n    class Dn {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (t, e) => t < e ? -1 : t > e ? 1 : 0;\n        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);\n      }\n      push(t) {\n        this.data.push(t), this._up(this.length++);\n      }\n      pop() {\n        if (0 === this.length) return;\n        const t = this.data[0],\n          e = this.data.pop();\n        return --this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n      peek() {\n        return this.data[0];\n      }\n      _up(t) {\n        const {\n            data: e,\n            compare: r\n          } = this,\n          n = e[t];\n        for (; t > 0;) {\n          const i = t - 1 >> 1,\n            s = e[i];\n          if (r(n, s) >= 0) break;\n          e[t] = s, t = i;\n        }\n        e[t] = n;\n      }\n      _down(t) {\n        const {\n            data: e,\n            compare: r\n          } = this,\n          n = this.length >> 1,\n          i = e[t];\n        for (; t < n;) {\n          let n = 1 + (t << 1);\n          const s = n + 1;\n          if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break;\n          e[t] = e[n], t = n;\n        }\n        e[t] = i;\n      }\n    }\n    var Rn = 8192;\n    function Ln(t, e) {\n      return e.dist - t.dist;\n    }\n    const On = 100,\n      Un = 50;\n    function Nn(t) {\n      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      if (e.length !== t.length) return !1;\n      for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n      return !0;\n    }\n    function jn(t) {\n      return t[1] - t[0] + 1;\n    }\n    function $n(t, e) {\n      const r = t[1] >= t[0] && t[1] < e;\n      return r || console.warn(\"Distance Expression: Index is out of range\"), r;\n    }\n    function Gn(t, e) {\n      if (t[0] > t[1]) return [null, null];\n      const r = jn(t);\n      if (e) {\n        if (2 === r) return [t, null];\n        const e = Math.floor(r / 2);\n        return [[t[0], t[0] + e], [t[0] + e, t[1]]];\n      }\n      {\n        if (1 === r) return [t, null];\n        const e = Math.floor(r / 2) - 1;\n        return [[t[0], t[0] + e], [t[0] + e + 1, t[1]]];\n      }\n    }\n    function Hn(t, e) {\n      const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      if (!$n(e, t.length)) return r;\n      for (let n = e[0]; n <= e[1]; ++n) un(r, t[n]);\n      return r;\n    }\n    function qn(t) {\n      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      for (let r = 0; r < t.length; ++r) for (let n = 0; n < t[r].length; ++n) un(e, t[r][n]);\n      return e;\n    }\n    function Xn(t, e, r) {\n      if (Nn(t) || Nn(e)) return NaN;\n      let n = 0,\n        i = 0;\n      return t[2] < e[0] && (n = e[0] - t[2]), t[0] > e[2] && (n = t[0] - e[2]), t[1] > e[3] && (i = t[1] - e[3]), t[3] < e[1] && (i = e[1] - t[3]), r.distance([0, 0], [n, i]);\n    }\n    function Zn(t) {\n      return 360 * t - 180;\n    }\n    function Wn(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function Yn(t, e) {\n      const r = Math.pow(2, e.z),\n        n = (t.y / Rn + e.y) / r;\n      return [Zn((t.x / Rn + e.x) / r), Wn(n)];\n    }\n    function Kn(t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; ++n) r.push(Yn(t[n], e));\n      return r;\n    }\n    function Jn(t, e, r) {\n      const n = r.pointOnLine(e, t).point;\n      return r.distance(t, n);\n    }\n    function Qn(t, e, r, n, i) {\n      const s = r.slice(n[0], n[1] + 1);\n      let o = 1 / 0;\n      for (let r = e[0]; r <= e[1]; ++r) if (0 === (o = Math.min(o, Jn(t[r], s, i)))) return 0;\n      return o;\n    }\n    function ti(t, e, r, n, i) {\n      const s = Math.min(i.pointToSegmentDistance(t, r, n), i.pointToSegmentDistance(e, r, n)),\n        o = Math.min(i.pointToSegmentDistance(r, t, e), i.pointToSegmentDistance(n, t, e));\n      return Math.min(s, o);\n    }\n    function ei(t, e, r, n, i) {\n      if (!$n(e, t.length) || !$n(n, r.length)) return NaN;\n      let s = 1 / 0;\n      for (let o = e[0]; o < e[1]; ++o) for (let e = n[0]; e < n[1]; ++e) {\n        if (fn(t[o], t[o + 1], r[e], r[e + 1])) return 0;\n        s = Math.min(s, ti(t[o], t[o + 1], r[e], r[e + 1], i));\n      }\n      return s;\n    }\n    function ri(t, e, r, n, i) {\n      if (!$n(e, t.length) || !$n(n, r.length)) return NaN;\n      let s = 1 / 0;\n      for (let o = e[0]; o <= e[1]; ++o) for (let e = n[0]; e <= n[1]; ++e) if (0 === (s = Math.min(s, i.distance(t[o], r[e])))) return s;\n      return s;\n    }\n    function ni(t, e, r) {\n      if (pn(t, e, !0)) return 0;\n      let n = 1 / 0;\n      for (const i of e) {\n        const e = i.length;\n        if (e < 2) return console.warn(\"Distance Expression: Invalid polygon!\"), NaN;\n        if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t, i[e - 1], i[0])))) return n;\n        if (0 === (n = Math.min(n, Jn(t, i, r)))) return n;\n      }\n      return n;\n    }\n    function ii(t, e, r, n) {\n      if (!$n(e, t.length)) return NaN;\n      for (let n = e[0]; n <= e[1]; ++n) if (pn(t[n], r, !0)) return 0;\n      let i = 1 / 0;\n      for (let s = e[0]; s < e[1]; ++s) for (const e of r) for (let r = 0, o = e.length, a = o - 1; r < o; a = r++) {\n        if (fn(t[s], t[s + 1], e[a], e[r])) return 0;\n        i = Math.min(i, ti(t[s], t[s + 1], e[a], e[r], n));\n      }\n      return i;\n    }\n    function si(t, e) {\n      for (const r of t) for (let t = 0; t <= r.length - 1; ++t) if (pn(r[t], e, !0)) return !0;\n      return !1;\n    }\n    function oi(t, e, r) {\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1 / 0;\n      const i = qn(t),\n        s = qn(e);\n      if (n !== 1 / 0 && Xn(i, s, r) >= n) return n;\n      if (cn(i, s)) {\n        if (si(t, e)) return 0;\n      } else if (si(e, t)) return 0;\n      let o = n;\n      for (const n of t) for (let t = 0, i = n.length, s = i - 1; t < i; s = t++) for (const i of e) for (let e = 0, a = i.length, l = a - 1; e < a; l = e++) {\n        if (fn(n[s], n[t], i[l], i[e])) return 0;\n        o = Math.min(o, ti(n[s], n[t], i[l], i[e], r));\n      }\n      return o;\n    }\n    function ai(t, e, r, n, i, s, o) {\n      if (null === s || null === o) return;\n      const a = Xn(Hn(n, s), Hn(i, o), r);\n      a < e && t.push({\n        dist: a,\n        range1: s,\n        range2: o\n      });\n    }\n    function li(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1 / 0;\n      let s = Math.min(n.distance(t[0], r[0][0]), i);\n      if (0 === s) return s;\n      const o = new Dn([{\n          dist: 0,\n          range1: [0, t.length - 1],\n          range2: [0, 0]\n        }], Ln),\n        a = e ? Un : On,\n        l = qn(r);\n      for (; o.length;) {\n        const i = o.pop();\n        if (i.dist >= s) continue;\n        const u = i.range1;\n        if (jn(u) <= a) {\n          if (!$n(u, t.length)) return NaN;\n          if (e) {\n            const e = ii(t, u, r, n);\n            if (0 === (s = Math.min(s, e))) return s;\n          } else for (let e = u[0]; e <= u[1]; ++e) {\n            const i = ni(t[e], r, n);\n            if (0 === (s = Math.min(s, i))) return s;\n          }\n        } else {\n          const r = Gn(u, e);\n          if (null !== r[0]) {\n            const e = Xn(Hn(t, r[0]), l, n);\n            e < s && o.push({\n              dist: e,\n              range1: r[0],\n              range2: [0, 0]\n            });\n          }\n          if (null !== r[1]) {\n            const e = Xn(Hn(t, r[1]), l, n);\n            e < s && o.push({\n              dist: e,\n              range1: r[1],\n              range2: [0, 0]\n            });\n          }\n        }\n      }\n      return s;\n    }\n    function ui(t, e, r, n, i) {\n      let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1 / 0;\n      let o = Math.min(s, i.distance(t[0], r[0]));\n      if (0 === o) return o;\n      const a = new Dn([{\n          dist: 0,\n          range1: [0, t.length - 1],\n          range2: [0, r.length - 1]\n        }], Ln),\n        l = e ? Un : On,\n        u = n ? Un : On;\n      for (; a.length;) {\n        const s = a.pop();\n        if (s.dist >= o) continue;\n        const c = s.range1,\n          h = s.range2;\n        if (jn(c) <= l && jn(h) <= u) {\n          if (!$n(c, t.length) || !$n(h, r.length)) return NaN;\n          if (e && n ? o = Math.min(o, ei(t, c, r, h, i)) : e || n ? e && !n ? o = Math.min(o, Qn(r, h, t, c, i)) : !e && n && (o = Math.min(o, Qn(t, c, r, h, i))) : o = Math.min(o, ri(t, c, r, h, i)), 0 === o) return o;\n        } else {\n          const s = Gn(c, e),\n            l = Gn(h, n);\n          ai(a, o, i, t, r, s[0], l[0]), ai(a, o, i, t, r, s[0], l[1]), ai(a, o, i, t, r, s[1], l[0]), ai(a, o, i, t, r, s[1], l[1]);\n        }\n      }\n      return o;\n    }\n    function ci(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1 / 0;\n      let s = i;\n      const o = Hn(t, [0, t.length - 1]);\n      for (const i of r) if (!(s !== 1 / 0 && Xn(o, Hn(i, [0, i.length - 1]), n) >= s) && (s = Math.min(s, ui(t, e, i, !0, n, s)), 0 === s)) return s;\n      return s;\n    }\n    function hi(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1 / 0;\n      let s = i;\n      const o = Hn(t, [0, t.length - 1]);\n      for (const i of r) {\n        if (s !== 1 / 0 && Xn(o, qn(i), n) >= s) continue;\n        const r = li(t, e, i, n, s);\n        if (isNaN(r)) return r;\n        if (0 === (s = Math.min(s, r))) return s;\n      }\n      return s;\n    }\n    function pi(t) {\n      return \"Point\" === t || \"MultiPoint\" === t || \"LineString\" === t || \"MultiLineString\" === t || \"Polygon\" === t || \"MultiPolygon\" === t;\n    }\n    class di {\n      constructor(t, e) {\n        this.type = mr, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"'distance' expression requires either one argument, but found ' \".concat(t.length - 1, \" instead.\"));\n        if (Rr(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) {\n            for (let t = 0; t < e.features.length; ++t) if (pi(e.features[t].geometry.type)) return new di(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            if (pi(e.geometry.type)) return new di(e, e.geometry);\n          } else if (pi(e.type)) return new di(e, e);\n        }\n        return e.error(\"'distance' expression needs to be an array with format ['Distance', GeoJSONObj].\");\n      }\n      evaluate(t) {\n        const e = t.geometry(),\n          r = t.canonicalID();\n        if (null != e && null != r) {\n          if (\"Point\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of t) for (const t of r) n.push(Yn(t, e));\n            const i = new Bn(n[0][1], \"meters\");\n            return \"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type ? ui(n, !1, \"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, i) : \"MultiLineString\" === r.type ? ci(n, !1, r.coordinates, i) : \"Polygon\" === r.type || \"MultiPolygon\" === r.type ? hi(n, !1, \"Polygon\" === r.type ? [r.coordinates] : r.coordinates, i) : null;\n          }(e, r, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of t) {\n              const t = [];\n              for (const n of r) t.push(Yn(n, e));\n              n.push(t);\n            }\n            const i = new Bn(n[0][0][1], \"meters\");\n            if (\"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type) return ci(\"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, n, i);\n            if (\"MultiLineString\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < r.coordinates.length; e++) {\n                const s = ci(r.coordinates[e], !0, n, i, t);\n                if (isNaN(s)) return s;\n                if (0 === (t = Math.min(t, s))) return t;\n              }\n              return t;\n            }\n            if (\"Polygon\" === r.type || \"MultiPolygon\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < n.length; e++) {\n                const s = hi(n[e], !0, \"Polygon\" === r.type ? [r.coordinates] : r.coordinates, i, t);\n                if (isNaN(s)) return s;\n                if (0 === (t = Math.min(t, s))) return t;\n              }\n              return t;\n            }\n            return null;\n          }(e, r, this.geometries);\n          if (\"Polygon\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of function (t, e) {\n              const r = t.length;\n              if (r <= 1) return [t];\n              const n = [];\n              let i, s;\n              for (let e = 0; e < r; e++) {\n                const r = ln(t[e]);\n                0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n              }\n              return i && n.push(i), n;\n            }(t)) {\n              const t = [];\n              for (let n = 0; n < r.length; ++n) t.push(Kn(r[n], e));\n              n.push(t);\n            }\n            const i = new Bn(n[0][0][0][1], \"meters\");\n            if (\"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type) return hi(\"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, n, i);\n            if (\"MultiLineString\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < r.coordinates.length; e++) {\n                const s = hi(r.coordinates[e], !0, n, i, t);\n                if (isNaN(s)) return s;\n                if (0 === (t = Math.min(t, s))) return t;\n              }\n              return t;\n            }\n            return \"Polygon\" === r.type || \"MultiPolygon\" === r.type ? function (t, e, r) {\n              let n = 1 / 0;\n              for (const i of t) for (const t of e) {\n                const e = oi(i, t, r, n);\n                if (isNaN(e)) return e;\n                if (0 === (n = Math.min(n, e))) return n;\n              }\n              return n;\n            }(\"Polygon\" === r.type ? [r.coordinates] : r.coordinates, n, i) : null;\n          }(e, r, this.geometries);\n          console.warn(\"Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.\");\n        } else console.warn(\"Distance Expression: requirs valid feature and canonical information.\");\n        return null;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"distance\", this.geojson];\n      }\n    }\n    function fi(t) {\n      if (t instanceof en) {\n        if (\"get\" === t.name && 1 === t.args.length) return !1;\n        if (\"feature-state\" === t.name) return !1;\n        if (\"has\" === t.name && 1 === t.args.length) return !1;\n        if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n      if (t instanceof Pn) return !1;\n      if (t instanceof di) return !1;\n      if (t instanceof wi) return t.featureConstant;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !fi(t) && (e = !1);\n      }), e;\n    }\n    function mi(t) {\n      if (t instanceof en && \"feature-state\" === t.name) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !mi(t) && (e = !1);\n      }), e;\n    }\n    function yi(t) {\n      if (t instanceof wi) return new Set([t.key]);\n      let e = new Set();\n      return t.eachChild(t => {\n        e = new Set([...e, ...yi(t)]);\n      }), e;\n    }\n    function gi(t, e) {\n      if (t instanceof en && e.indexOf(t.name) >= 0) return !1;\n      let r = !0;\n      return t.eachChild(t => {\n        r && !gi(t, e) && (r = !1);\n      }), r;\n    }\n    function xi(t, e, r) {\n      return [t, e, r].filter(Boolean).join(\"\u001f\");\n    }\n    function vi(t, e) {\n      switch (t) {\n        case \"string\":\n          return Or(e);\n        case \"number\":\n          return +e;\n        case \"boolean\":\n          return !!e;\n        case \"color\":\n          return sr.parse(e);\n        case \"formatted\":\n          return Vr.fromString(Or(e));\n        case \"resolvedImage\":\n          return Cr.build(Or(e));\n      }\n      return e;\n    }\n    function bi(t, e, r, n) {\n      return void 0 !== n && (t = n * Math.round(t / n)), void 0 !== e && t < e && (t = e), void 0 !== r && t > r && (t = r), t;\n    }\n    class wi {\n      constructor(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n        this.type = t, this.key = e, this.scope = r, this.featureConstant = n;\n      }\n      static parse(t, e) {\n        let r = e.expectedType;\n        if (null == r && (r = br), t.length < 2 || t.length > 3) return e.error(\"Invalid number of arguments for 'config' expression.\");\n        const n = e.parse(t[1], 1);\n        if (!(n instanceof Ur)) return e.error(\"Key name of 'config' expression must be a string literal.\");\n        let i,\n          s = !0;\n        const o = Or(n.value);\n        if (t.length >= 3) {\n          const r = e.parse(t[2], 2);\n          if (!(r instanceof Ur)) return e.error(\"Scope of 'config' expression must be a string literal.\");\n          i = Or(r.value);\n        }\n        if (e.options) {\n          const t = xi(o, i, e._scope),\n            r = e.options.get(t);\n          r && (s = fi(r.value || r.default));\n        }\n        return new wi(r, o, i, s);\n      }\n      evaluate(t) {\n        const e = xi(this.key, this.scope, t.scope),\n          r = t.getConfig(e);\n        if (!r) return null;\n        const {\n            type: n,\n            value: i,\n            values: s,\n            minValue: o,\n            maxValue: a,\n            stepValue: l\n          } = r,\n          u = r.default.evaluate(t);\n        let c = u;\n        if (i) {\n          const e = t.scope;\n          t.scope = (e || \"\").split(\"\u001f\").slice(1).join(\"\u001f\"), c = i.evaluate(t), t.scope = e;\n        }\n        return n && (c = vi(n, c)), void 0 === c || void 0 === o && void 0 === a && void 0 === l || (\"number\" == typeof c ? c = bi(c, o, a, l) : Array.isArray(c) && (c = c.map(t => \"number\" == typeof t ? bi(t, o, a, l) : t))), void 0 !== i && void 0 !== c && s && !s.includes(c) && (c = u, n && (c = vi(n, c))), (n && n !== this.type || void 0 !== c && !Er(Lr(c), this.type)) && (c = vi(this.type.kind, c)), c;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"config\", this.key];\n        return this.scope && t.concat(this.scope), t;\n      }\n    }\n    class _i {\n      constructor(t, e) {\n        this.type = e.type, this.name = t, this.boundExpression = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n        const r = t[1];\n        return e.scope.has(r) ? new _i(r, e.scope.get(r)) : e.error(\"Unknown variable \\\"\".concat(r, \"\\\". Make sure \\\"\").concat(r, \"\\\" has been bound in an enclosing \\\"let\\\" expression before using it.\"), 1);\n      }\n      evaluate(t) {\n        return this.boundExpression.evaluate(t);\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"var\", this.name];\n      }\n    }\n    class Ai {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        let r = arguments.length > 2 ? arguments[2] : undefined;\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new dr();\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n        let s = arguments.length > 5 ? arguments[5] : undefined;\n        let o = arguments.length > 6 ? arguments[6] : undefined;\n        let a = arguments.length > 7 ? arguments[7] : undefined;\n        this.registry = t, this.path = e, this.key = e.map(t => \"string\" == typeof t ? \"['\".concat(t, \"']\") : \"[\".concat(t, \"]\")).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r, this._scope = s, this.options = o, this.iconImageUseTheme = a;\n      }\n      parse(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        return e || r ? this.concat(e, null, r, n)._parse(t, i) : this._parse(t, i);\n      }\n      parseObjectValue(t, e, r, n, i) {\n        let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        return this.concat(e, r, n, i)._parse(t, s);\n      }\n      _parse(t, e) {\n        function r(t, e, r) {\n          return \"assert\" === r ? new $r(e, [t]) : \"coerce\" === r ? new Jr(e, [t]) : t;\n        }\n        if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n          const n = \"string\" == typeof t[0] ? this.registry[t[0]] : void 0;\n          if (n) {\n            let i = n.parse(t, this);\n            if (!i) return null;\n            if (this.expectedType) {\n              const t = this.expectedType,\n                n = i.type;\n              if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== n.kind) {\n                if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== n.kind && \"string\" !== n.kind) {\n                  if (this.checkSubtype(t, n)) return null;\n                } else i = r(i, t, e.typeAnnotation || \"coerce\");\n              } else i = r(i, t, e.typeAnnotation || \"assert\");\n            }\n            if (!(i instanceof Ur) && \"resolvedImage\" !== i.type.kind && Mi(i)) {\n              const t = new tn(this._scope, this.options, this.iconImageUseTheme);\n              try {\n                i = new Ur(i.type, i.evaluate(t));\n              } catch (t) {\n                return this.error(t.message), null;\n              }\n            }\n            return i;\n          }\n          return Jr.parse([\"to-array\", t], this);\n        }\n        return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : \"Expected an array, but found \".concat(typeof t, \" instead.\"));\n      }\n      concat(t, e, r, n) {\n        let i = \"number\" == typeof t ? this.path.concat(t) : this.path;\n        i = \"string\" == typeof e ? i.concat(e) : i;\n        const s = n ? this.scope.concat(n) : this.scope;\n        return new Ai(this.registry, i, r || null, s, this.errors, this._scope, this.options, this.iconImageUseTheme);\n      }\n      error(t) {\n        for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          e[_key - 1] = arguments[_key];\n        }\n        const r = \"\".concat(this.key).concat(e.map(t => \"[\".concat(t, \"]\")).join(\"\"));\n        this.errors.push(new pr(r, t));\n      }\n      checkSubtype(t, e) {\n        const r = Pr(t, e);\n        return r && this.error(r), r;\n      }\n    }\n    function Mi(t) {\n      if (t instanceof _i) return Mi(t.boundExpression);\n      if (t instanceof en && \"error\" === t.name) return !1;\n      if (t instanceof nn) return !1;\n      if (t instanceof Pn) return !1;\n      if (t instanceof di) return !1;\n      if (t instanceof wi) return !1;\n      const e = t instanceof Jr || t instanceof $r;\n      let r = !0;\n      return t.eachChild(t => {\n        r = e ? r && Mi(t) : r && t instanceof Ur;\n      }), !!r && fi(t) && gi(t, [\"zoom\", \"heatmap-density\", \"worldview\", \"line-progress\", \"raster-value\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\", \"measure-light\", \"raster-particle-speed\"]);\n    }\n    function Ii(t, e) {\n      const r = t.length - 1;\n      let n,\n        i,\n        s = 0,\n        o = r,\n        a = 0;\n      for (; s <= o;) if (a = Math.floor((s + o) / 2), n = t[a], i = t[a + 1], n <= e) {\n        if (a === r || e < i) return a;\n        s = a + 1;\n      } else {\n        if (!(n > e)) throw new Nr(\"Input is not a number.\");\n        o = a - 1;\n      }\n      return 0;\n    }\n    class Si {\n      constructor(t, e, r) {\n        this.type = t, this.input = e, this.labels = [], this.outputs = [];\n        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n      }\n      static parse(t, e) {\n        if (t.length - 1 < 4) return e.error(\"Expected at least 4 arguments, but found only \".concat(t.length - 1, \".\"));\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        const r = e.parse(t[1], 1, mr);\n        if (!r) return null;\n        const n = [];\n        let i = null;\n        e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n        for (let r = 1; r < t.length; r += 2) {\n          const s = 1 === r ? -1 / 0 : t[r],\n            o = t[r + 1],\n            a = r,\n            l = r + 1;\n          if (\"number\" != typeof s) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a);\n          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', a);\n          const u = e.parse(o, l, i);\n          if (!u) return null;\n          i = i || u.type, n.push([s, u]);\n        }\n        return new Si(i, r, n);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Ii(e, n)].evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"step\", this.input.serialize()];\n        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n        return t;\n      }\n    }\n    const Pi = .95047,\n      ki = 1.08883,\n      zi = 4 / 29,\n      Ei = 6 / 29,\n      Ti = 3 * Ei * Ei,\n      Bi = Ei * Ei * Ei,\n      Vi = Math.PI / 180,\n      Fi = 180 / Math.PI;\n    function Ci(t) {\n      return t > Bi ? Math.pow(t, 1 / 3) : t / Ti + zi;\n    }\n    function Di(t) {\n      return t > Ei ? t * t * t : Ti * (t - zi);\n    }\n    function Ri(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n    function Li(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n    function Oi(t) {\n      const e = Li(t.r),\n        r = Li(t.g),\n        n = Li(t.b),\n        i = Ci((.4124564 * e + .3575761 * r + .1804375 * n) / Pi),\n        s = Ci((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * s - 16,\n        a: 500 * (i - s),\n        b: 200 * (s - Ci((.0193339 * e + .119192 * r + .9503041 * n) / ki)),\n        alpha: t.a\n      };\n    }\n    function Ui(t) {\n      let e = (t.l + 16) / 116,\n        r = isNaN(t.a) ? e : e + t.a / 500,\n        n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * Di(e), r = Pi * Di(r), n = ki * Di(n), new sr(Ri(3.2404542 * r - 1.5371385 * e - .4985314 * n), Ri(-.969266 * r + 1.8760108 * e + .041556 * n), Ri(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n    function Ni(t, e, r) {\n      const n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n    const ji = {\n        forward: Oi,\n        reverse: Ui,\n        interpolate: function (t, e, r) {\n          return {\n            l: ur(t.l, e.l, r),\n            a: ur(t.a, e.a, r),\n            b: ur(t.b, e.b, r),\n            alpha: ur(t.alpha, e.alpha, r)\n          };\n        }\n      },\n      $i = {\n        forward: function (t) {\n          const {\n              l: e,\n              a: r,\n              b: n\n            } = Oi(t),\n            i = Math.atan2(n, r) * Fi;\n          return {\n            h: i < 0 ? i + 360 : i,\n            c: Math.sqrt(r * r + n * n),\n            l: e,\n            alpha: t.a\n          };\n        },\n        reverse: function (t) {\n          const e = t.h * Vi,\n            r = t.c;\n          return Ui({\n            l: t.l,\n            a: Math.cos(e) * r,\n            b: Math.sin(e) * r,\n            alpha: t.alpha\n          });\n        },\n        interpolate: function (t, e, r) {\n          return {\n            h: Ni(t.h, e.h, r),\n            c: ur(t.c, e.c, r),\n            l: ur(t.l, e.l, r),\n            alpha: ur(t.alpha, e.alpha, r)\n          };\n        }\n      };\n    var Gi = Object.freeze({\n      __proto__: null,\n      hcl: $i,\n      lab: ji\n    });\n    class Hi {\n      constructor(t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n      }\n      static interpolationFactor(t, e, r, n) {\n        let i = 0;\n        if (\"exponential\" === t.name) i = qi(e, t.base, r, n);else if (\"linear\" === t.name) i = qi(e, 1, r, n);else if (\"cubic-bezier\" === t.name) {\n          const s = t.controlPoints;\n          i = new bt(s[0], s[1], s[2], s[3]).solve(qi(e, 1, r, n));\n        }\n        return i;\n      }\n      static parse(t, e) {\n        let [r, n, i, ...s] = t;\n        if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n        if (\"linear\" === n[0]) n = {\n          name: \"linear\"\n        };else if (\"exponential\" === n[0]) {\n          const t = n[1];\n          if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n          n = {\n            name: \"exponential\",\n            base: t\n          };\n        } else {\n          if (\"cubic-bezier\" !== n[0]) return e.error(\"Unknown interpolation type \".concat(String(n[0])), 1, 0);\n          {\n            const t = n.slice(1);\n            if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n            n = {\n              name: \"cubic-bezier\",\n              controlPoints: t\n            };\n          }\n        }\n        if (t.length - 1 < 4) return e.error(\"Expected at least 4 arguments, but found only \".concat(t.length - 1, \".\"));\n        if (t.length - 1 > 3 && (t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        if (i = e.parse(i, 2, mr), !i) return null;\n        const o = [];\n        let a = null;\n        \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? a = xr : e.expectedType && \"value\" !== e.expectedType.kind && (a = e.expectedType);\n        for (let t = 0; t < s.length; t += 2) {\n          const r = s[t],\n            n = s[t + 1],\n            i = t + 3,\n            l = t + 4;\n          if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n          if (o.length && o[o.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n          const u = e.parse(n, l, a);\n          if (!u) return null;\n          a = a || u.type, o.push([r, u]);\n        }\n        return \"number\" === a.kind || \"color\" === a.kind || \"array\" === a.kind && \"number\" === a.itemType.kind && \"number\" == typeof a.N ? new Hi(a, r, n, i, o) : e.error(\"Type \".concat(Ir(a), \" is not interpolatable.\"));\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n        const s = Ii(e, n),\n          o = Hi.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),\n          a = r[s].evaluate(t),\n          l = r[s + 1].evaluate(t);\n        return \"interpolate\" === this.operator ? hr[this.type.kind.toLowerCase()](a, l, o) : \"interpolate-hcl\" === this.operator ? $i.reverse($i.interpolate($i.forward(a), $i.forward(l), o)) : ji.reverse(ji.interpolate(ji.forward(a), ji.forward(l), o));\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        let t;\n        t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\", ...this.interpolation.controlPoints];\n        const e = [this.operator, t, this.input.serialize()];\n        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n        return e;\n      }\n    }\n    function qi(t, e, r, n) {\n      const i = n - r,\n        s = t - r;\n      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n    }\n    class Xi {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n        let r = null;\n        const n = e.expectedType;\n        n && \"value\" !== n.kind && (r = n);\n        const i = [];\n        for (const n of t.slice(1)) {\n          const t = e.parse(n, 1 + i.length, r, void 0, {\n            typeAnnotation: \"omit\"\n          });\n          if (!t) return null;\n          r = r || t.type, i.push(t);\n        }\n        const s = n && i.some(t => Pr(n, t.type));\n        return new Xi(s ? br : r, i);\n      }\n      evaluate(t) {\n        let e,\n          r = null,\n          n = 0;\n        for (const i of this.args) {\n          if (n++, r = i.evaluate(t), r && r instanceof Cr && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;\n          if (null !== r) break;\n        }\n        return r;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"coalesce\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    class Zi {\n      constructor(t, e) {\n        this.type = e.type, this.bindings = [].concat(t), this.result = e;\n      }\n      evaluate(t) {\n        return this.result.evaluate(t);\n      }\n      eachChild(t) {\n        for (const e of this.bindings) t(e[1]);\n        t(this.result);\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(\"Expected at least 3 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = [];\n        for (let n = 1; n < t.length - 1; n += 2) {\n          const i = t[n];\n          if (\"string\" != typeof i) return e.error(\"Expected string, but found \".concat(typeof i, \" instead.\"), n);\n          if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n          const s = e.parse(t[n + 1], n + 1);\n          if (!s) return null;\n          r.push([i, s]);\n        }\n        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n        return n ? new Zi(r, n) : null;\n      }\n      outputDefined() {\n        return this.result.outputDefined();\n      }\n      serialize() {\n        const t = [\"let\"];\n        for (const [e, r] of this.bindings) t.push(e, r.serialize());\n        return t.push(this.result.serialize()), t;\n      }\n    }\n    class Wi {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected 2 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1, mr),\n          n = e.parse(t[2], 2, Mr(e.expectedType || br));\n        return r && n ? new Wi(n.type.itemType, r, n) : null;\n      }\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n        if (e < 0) throw new Nr(\"Array index out of bounds: negative index\");\n        if (e >= r.length) throw new Nr(\"Array index out of bounds: index exceeds array size\");\n        if (e !== Math.floor(e)) throw new Nr(\"Array index must be an integer. Use at-interpolated for fractional indices\");\n        return r[e];\n      }\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n      }\n    }\n    class Yi {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected 2 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1, mr),\n          n = e.parse(t[2], 2, Mr(e.expectedType || br));\n        return r && n ? new Yi(n.type.itemType, r, n) : null;\n      }\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n        if (e < 0) throw new Nr(\"Array index out of bounds: \".concat(e, \" < 0.\"));\n        if (e > r.length - 1) throw new Nr(\"Array index out of bounds: \".concat(e, \" > \").concat(r.length - 1, \".\"));\n        if (e === Math.floor(e)) return r[e];\n        const n = Math.floor(e),\n          i = Math.ceil(e),\n          s = r[n],\n          o = r[i];\n        if (\"number\" != typeof s || \"number\" != typeof o) throw new Nr(\"Cannot interpolate between non-number values at index \".concat(e, \".\"));\n        const a = e - n;\n        return s * (1 - a) + o * a;\n      }\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"at-interpolated\", this.index.serialize(), this.input.serialize()];\n      }\n    }\n    class Ki {\n      constructor(t, e) {\n        this.type = gr, this.needle = t, this.haystack = e;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected 2 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1, br),\n          n = e.parse(t[2], 2, br);\n        return r && n ? kr(r.type, [gr, yr, mr, fr, br]) ? new Ki(r, n) : e.error(\"Expected first argument to be of type boolean, string, number or null, but found \".concat(Ir(r.type), \" instead\")) : null;\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (null == r) return !1;\n        if (!zr(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new Nr(\"Expected first argument to be of type boolean, string, number or null, but found \".concat(Ir(Lr(e)), \" instead.\"));\n        if (!zr(r, [\"string\", \"array\"])) throw new Nr(\"Expected second argument to be of type array or string, but found \".concat(Ir(Lr(r)), \" instead.\"));\n        return r.indexOf(e) >= 0;\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack);\n      }\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    class Ji {\n      constructor(t, e, r) {\n        this.type = mr, this.needle = t, this.haystack = e, this.fromIndex = r;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(\"Expected 3 or 4 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1, br),\n          n = e.parse(t[2], 2, br);\n        if (!r || !n) return null;\n        if (!kr(r.type, [gr, yr, mr, fr, br])) return e.error(\"Expected first argument to be of type boolean, string, number or null, but found \".concat(Ir(r.type), \" instead\"));\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, mr);\n          return i ? new Ji(r, n, i) : null;\n        }\n        return new Ji(r, n);\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (!zr(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new Nr(\"Expected first argument to be of type boolean, string, number or null, but found \".concat(Ir(Lr(e)), \" instead.\"));\n        if (!zr(r, [\"string\", \"array\"])) throw new Nr(\"Expected second argument to be of type array or string, but found \".concat(Ir(Lr(r)), \" instead.\"));\n        if (this.fromIndex) {\n          const n = this.fromIndex.evaluate(t);\n          return r.indexOf(e, n);\n        }\n        return r.indexOf(e);\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.fromIndex && void 0 !== this.fromIndex) {\n          const t = this.fromIndex.serialize();\n          return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n        }\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    class Qi {\n      constructor(t, e, r, n, i, s) {\n        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;\n      }\n      static parse(t, e) {\n        if (t.length < 5) return e.error(\"Expected at least 4 arguments, but found only \".concat(t.length - 1, \".\"));\n        if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n        let r, n;\n        e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n        const i = {},\n          s = [];\n        for (let o = 2; o < t.length - 1; o += 2) {\n          let a = t[o];\n          const l = t[o + 1];\n          Array.isArray(a) || (a = [a]);\n          const u = e.concat(o);\n          if (0 === a.length) return u.error(\"Expected at least one branch label.\");\n          for (const t of a) {\n            if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n            if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(\"Branch labels must be integers no larger than \".concat(Number.MAX_SAFE_INTEGER, \".\"));\n            if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n            if (r) {\n              if (u.checkSubtype(r, Lr(t))) return null;\n            } else r = Lr(t);\n            if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n            i[String(t)] = s.length;\n          }\n          const c = e.parse(l, o, n);\n          if (!c) return null;\n          n = n || c.type, s.push(c);\n        }\n        const o = e.parse(t[1], 1, br);\n        if (!o) return null;\n        const a = e.parse(t[t.length - 1], t.length - 1, n);\n        return a ? \"value\" !== o.type.kind && e.concat(1).checkSubtype(r, o.type) ? null : new Qi(r, n, o, i, s, a) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        return (Er(Lr(e), this.inputType) && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input), this.outputs.forEach(t), t(this.otherwise);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"match\", this.input.serialize()],\n          e = Object.keys(this.cases).sort(),\n          r = [],\n          n = {};\n        for (const t of e) {\n          const e = n[this.cases[t]];\n          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n        }\n        const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n        return t.push(this.otherwise.serialize()), t;\n      }\n    }\n    class ts {\n      constructor(t, e, r) {\n        this.type = t, this.branches = e, this.otherwise = r;\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(\"Expected at least 3 arguments, but found only \".concat(t.length - 1, \".\"));\n        if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n        let r;\n        e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n        const n = [];\n        for (let i = 1; i < t.length - 1; i += 2) {\n          const s = e.parse(t[i], i, gr);\n          if (!s) return null;\n          const o = e.parse(t[i + 1], i + 1, r);\n          if (!o) return null;\n          n.push([s, o]), r = r || o.type;\n        }\n        const i = e.parse(t[t.length - 1], t.length - 1, r);\n        return i ? new ts(r, n, i) : null;\n      }\n      evaluate(t) {\n        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n        return this.otherwise.evaluate(t);\n      }\n      eachChild(t) {\n        for (const [e, r] of this.branches) t(e), t(r);\n        t(this.otherwise);\n      }\n      outputDefined() {\n        return this.branches.every(_ref3 => {\n          let [t, e] = _ref3;\n          return e.outputDefined();\n        }) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"case\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    class es {\n      constructor(t, e, r, n) {\n        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(\"Expected 3 or 4 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1, br),\n          n = e.parse(t[2], 2, mr);\n        if (!r || !n) return null;\n        if (!kr(r.type, [Mr(br), yr, br])) return e.error(\"Expected first argument to be of type array or string, but found \".concat(Ir(r.type), \" instead\"));\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, mr);\n          return i ? new es(r.type, r, n, i) : null;\n        }\n        return new es(r.type, r, n);\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n          r = this.beginIndex.evaluate(t);\n        if (!zr(e, [\"string\", \"array\"])) throw new Nr(\"Expected first argument to be of type array or string, but found \".concat(Ir(Lr(e)), \" instead.\"));\n        if (this.endIndex) {\n          const n = this.endIndex.evaluate(t);\n          return e.slice(r, n);\n        }\n        return e.slice(r);\n      }\n      eachChild(t) {\n        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.endIndex && void 0 !== this.endIndex) {\n          const t = this.endIndex.serialize();\n          return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n        }\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n      }\n    }\n    class rs {\n      constructor(t, e) {\n        this.type = Mr(yr), this.str = t, this.delimiter = e;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected 2 arguments, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1, yr),\n          n = e.parse(t[2], 2, yr);\n        return r && n ? new rs(r, n) : void 0;\n      }\n      evaluate(t) {\n        const e = this.str.evaluate(t),\n          r = this.delimiter.evaluate(t);\n        return e.split(r);\n      }\n      eachChild(t) {\n        t(this.str), t(this.delimiter);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"split\", this.str.serialize(), this.delimiter.serialize()];\n      }\n    }\n    function ns(t, e) {\n      return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n    }\n    function is(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n    function ss(t, e, r) {\n      const n = \"==\" !== t && \"!=\" !== t;\n      return class i {\n        constructor(t, e, r) {\n          this.type = gr, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n        }\n        static parse(t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n          const r = t[0];\n          let s = e.parse(t[1], 1, br);\n          if (!s) return null;\n          if (!ns(r, s.type)) return e.concat(1).error(\"\\\"\".concat(r, \"\\\" comparisons are not supported for type '\").concat(Ir(s.type), \"'.\"));\n          let o = e.parse(t[2], 2, br);\n          if (!o) return null;\n          if (!ns(r, o.type)) return e.concat(2).error(\"\\\"\".concat(r, \"\\\" comparisons are not supported for type '\").concat(Ir(o.type), \"'.\"));\n          if (s.type.kind !== o.type.kind && \"value\" !== s.type.kind && \"value\" !== o.type.kind) return e.error(\"Cannot compare types '\".concat(Ir(s.type), \"' and '\").concat(Ir(o.type), \"'.\"));\n          n && (\"value\" === s.type.kind && \"value\" !== o.type.kind ? s = new $r(o.type, [s]) : \"value\" !== s.type.kind && \"value\" === o.type.kind && (o = new $r(s.type, [o])));\n          let a = null;\n          if (4 === t.length) {\n            if (\"string\" !== s.type.kind && \"string\" !== o.type.kind && \"value\" !== s.type.kind && \"value\" !== o.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n            if (a = e.parse(t[3], 3, wr), !a) return null;\n          }\n          return new i(s, o, a);\n        }\n        evaluate(i) {\n          const s = this.lhs.evaluate(i),\n            o = this.rhs.evaluate(i);\n          if (n && this.hasUntypedArgument) {\n            const e = Lr(s),\n              r = Lr(o);\n            if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new Nr(\"Expected arguments for \\\"\".concat(t, \"\\\" to be (string, string) or (number, number), but found (\").concat(e.kind, \", \").concat(r.kind, \") instead.\"));\n          }\n          if (this.collator && !n && this.hasUntypedArgument) {\n            const t = Lr(s),\n              r = Lr(o);\n            if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, s, o);\n          }\n          return this.collator ? r(i, s, o, this.collator.evaluate(i)) : e(i, s, o);\n        }\n        eachChild(t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }\n        outputDefined() {\n          return !0;\n        }\n        serialize() {\n          const e = [t];\n          return this.eachChild(t => {\n            e.push(t.serialize());\n          }), e;\n        }\n      };\n    }\n    const os = ss(\"==\", function (t, e, r) {\n        return e === r;\n      }, is),\n      as = ss(\"!=\", function (t, e, r) {\n        return e !== r;\n      }, function (t, e, r, n) {\n        return !is(0, e, r, n);\n      }),\n      ls = ss(\"<\", function (t, e, r) {\n        return e < r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) < 0;\n      }),\n      us = ss(\">\", function (t, e, r) {\n        return e > r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) > 0;\n      }),\n      cs = ss(\"<=\", function (t, e, r) {\n        return e <= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) <= 0;\n      }),\n      hs = ss(\">=\", function (t, e, r) {\n        return e >= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) >= 0;\n      });\n    class ps {\n      constructor(t, e, r, n, i, s) {\n        this.type = yr, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, mr);\n        if (!r) return null;\n        const n = t[2];\n        if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n        let i = null;\n        if (n.locale && (i = e.parseObjectValue(n.locale, 2, \"locale\", yr), !i)) return null;\n        let s = null;\n        if (n.currency && (s = e.parseObjectValue(n.currency, 2, \"currency\", yr), !s)) return null;\n        let o = null;\n        if (n.unit && (o = e.parseObjectValue(n.unit, 2, \"unit\", yr), !o)) return null;\n        let a = null;\n        if (n[\"min-fraction-digits\"] && (a = e.parseObjectValue(n[\"min-fraction-digits\"], 2, \"min-fraction-digits\", mr), !a)) return null;\n        let l = null;\n        return n[\"max-fraction-digits\"] && (l = e.parseObjectValue(n[\"max-fraction-digits\"], 2, \"max-fraction-digits\", mr), !l) ? null : new ps(r, i, s, o, a, l);\n      }\n      evaluate(t) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n          style: (this.currency ? \"currency\" : this.unit && \"unit\") || \"decimal\",\n          currency: this.currency ? this.currency.evaluate(t) : void 0,\n          unit: this.unit ? this.unit.evaluate(t) : void 0,\n          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n        }).format(this.number.evaluate(t));\n      }\n      eachChild(t) {\n        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n      }\n    }\n    class ds {\n      constructor(t) {\n        this.type = mr, this.input = t;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected 1 argument, but found \".concat(t.length - 1, \" instead.\"));\n        const r = e.parse(t[1], 1);\n        return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(\"Expected argument of type string or array, but found \".concat(Ir(r.type), \" instead.\")) : new ds(r) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        if (\"string\" == typeof e) return e.length;\n        if (Array.isArray(e)) return e.length;\n        throw new Nr(\"Expected value to be of type string or array, but found \".concat(Ir(Lr(e)), \" instead.\"));\n      }\n      eachChild(t) {\n        t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"length\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    function fs(t) {\n      return function () {\n        t = 1831565813 + (t |= 0) | 0;\n        let e = Math.imul(t ^ t >>> 15, 1 | t);\n        return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;\n      };\n    }\n    const ms = {\n      \"==\": os,\n      \"!=\": as,\n      \">\": us,\n      \"<\": ls,\n      \">=\": hs,\n      \"<=\": cs,\n      array: $r,\n      at: Wi,\n      \"at-interpolated\": Yi,\n      boolean: $r,\n      case: ts,\n      coalesce: Xi,\n      collator: nn,\n      format: Gr,\n      image: Hr,\n      in: Ki,\n      \"index-of\": Ji,\n      interpolate: Hi,\n      \"interpolate-hcl\": Hi,\n      \"interpolate-lab\": Hi,\n      length: ds,\n      let: Zi,\n      literal: Ur,\n      match: Qi,\n      number: $r,\n      \"number-format\": ps,\n      object: $r,\n      slice: es,\n      step: Si,\n      string: $r,\n      \"to-boolean\": Jr,\n      \"to-color\": Jr,\n      \"to-number\": Jr,\n      \"to-string\": Jr,\n      var: _i,\n      within: Pn,\n      distance: di,\n      config: wi,\n      split: rs\n    };\n    function ys(t, _ref4) {\n      let [e, r, n, i] = _ref4;\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n        o = Dr(e, r, n, s);\n      if (o) throw new Nr(o);\n      return new sr(e / 255, r / 255, n / 255, s);\n    }\n    function gs(t, _ref5) {\n      let [e, r, n, i] = _ref5;\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n        o = function (t, e, r, n) {\n          return \"number\" == typeof t && t >= 0 && t <= 360 ? \"number\" == typeof e && e >= 0 && e <= 100 && \"number\" == typeof r && r >= 0 && r <= 100 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : \"Invalid hsla value [\".concat([t, e, r, n].join(\", \"), \"]: 'a' must be between 0 and 1.\") : \"Invalid hsla value [\".concat((\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \"), \"]: 's', and 'l' must be between 0 and 100.\") : \"Invalid hsla value [\".concat((\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \"), \"]: 'h' must be between 0 and 360.\");\n        }(e, r, n, s);\n      if (o) throw new Nr(o);\n      const a = \"hsla(\".concat(e, \", \").concat(r, \"%, \").concat(n, \"%, \").concat(s, \")\"),\n        l = sr.parse(a);\n      if (!l) throw new Nr(\"Failed to parse HSLA color: \".concat(a));\n      return l;\n    }\n    function xs(t, e) {\n      return t in e;\n    }\n    function vs(t, e) {\n      const r = e[t];\n      return void 0 === r ? null : r;\n    }\n    function bs(t) {\n      return {\n        type: t\n      };\n    }\n    function ws(t) {\n      return {\n        result: \"success\",\n        value: t\n      };\n    }\n    function _s(t) {\n      return {\n        result: \"error\",\n        value: t\n      };\n    }\n    function As(t, e) {\n      return !!t && !!t.parameters && t.parameters.indexOf(e) > -1;\n    }\n    function Ms(t) {\n      return \"data-driven\" === t[\"property-type\"];\n    }\n    function Is(t) {\n      return As(t.expression, \"measure-light\");\n    }\n    function Ss(t) {\n      return As(t.expression, \"zoom\");\n    }\n    function Ps(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n    function ks(t) {\n      return \"object\" == typeof t && null !== t && !Array.isArray(t);\n    }\n    function zs(t) {\n      return t;\n    }\n    function Es(t, e) {\n      const r = \"color\" === e.type,\n        n = t.stops && \"object\" == typeof t.stops[0][0],\n        i = n || !(n || void 0 !== t.property),\n        s = t.type || (Ps(e) ? \"exponential\" : \"interval\");\n      if (r && ((t = Object.assign({}, t)).stops && (t.stops = t.stops.map(t => [t[0], sr.parse(t[1])])), t.default = sr.parse(t.default ? t.default : e.default)), t.colorSpace && \"rgb\" !== t.colorSpace && !Gi[t.colorSpace]) throw new Error(\"Unknown color space: \".concat(t.colorSpace));\n      let o, a, l;\n      if (\"exponential\" === s) o = Fs;else if (\"interval\" === s) o = Vs;else if (\"categorical\" === s) {\n        o = Bs, a = Object.create(null);\n        for (const e of t.stops) a[e[0]] = e[1];\n        l = typeof t.stops[0][0];\n      } else {\n        if (\"identity\" !== s) throw new Error(\"Unknown function type \\\"\".concat(s, \"\\\"\"));\n        o = Cs;\n      }\n      if (n) {\n        const r = {},\n          n = [];\n        for (let e = 0; e < t.stops.length; e++) {\n          const i = t.stops[e],\n            s = i[0].zoom;\n          void 0 === r[s] && (r[s] = {\n            zoom: s,\n            type: t.type,\n            property: t.property,\n            default: t.default,\n            stops: []\n          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);\n        }\n        const i = [];\n        for (const t of n) i.push([r[t].zoom, Es(r[t], e)]);\n        const s = {\n          name: \"linear\"\n        };\n        return {\n          kind: \"composite\",\n          interpolationType: s,\n          interpolationFactor: Hi.interpolationFactor.bind(void 0, s),\n          zoomStops: i.map(t => t[0]),\n          evaluate: (_ref6, n) => {\n            let {\n              zoom: r\n            } = _ref6;\n            return Fs({\n              stops: i,\n              base: t.base\n            }, e, r).evaluate(r, n);\n          }\n        };\n      }\n      if (i) {\n        const r = \"exponential\" === s ? {\n          name: \"exponential\",\n          base: void 0 !== t.base ? t.base : 1\n        } : null;\n        return {\n          kind: \"camera\",\n          interpolationType: r,\n          interpolationFactor: Hi.interpolationFactor.bind(void 0, r),\n          zoomStops: t.stops.map(t => t[0]),\n          evaluate: _ref7 => {\n            let {\n              zoom: r\n            } = _ref7;\n            return o(t, e, r, a, l);\n          }\n        };\n      }\n      return {\n        kind: \"source\",\n        evaluate(r, n) {\n          const i = n && n.properties ? n.properties[t.property] : void 0;\n          return void 0 === i ? Ts(t.default, e.default) : o(t, e, i, a, l);\n        }\n      };\n    }\n    function Ts(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n    function Bs(t, e, r, n, i) {\n      return Ts(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n    function Vs(t, e, r) {\n      if (!Wr(r)) return Ts(t.default, e.default);\n      const n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      const i = Ii(t.stops.map(t => t[0]), r);\n      return t.stops[i][1];\n    }\n    function Fs(t, e, r) {\n      const n = void 0 !== t.base ? t.base : 1;\n      if (!Wr(r)) return Ts(t.default, e.default);\n      const i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n      const s = Ii(t.stops.map(t => t[0]), r),\n        o = function (t, e, r, n) {\n          const i = n - r,\n            s = t - r;\n          return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n        }(r, n, t.stops[s][0], t.stops[s + 1][0]),\n        a = t.stops[s][1],\n        l = t.stops[s + 1][1];\n      let u = hr[e.type] || zs;\n      if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n        const e = Gi[t.colorSpace];\n        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), o));\n      }\n      return \"function\" == typeof a.evaluate ? {\n        evaluate() {\n          for (var _len2 = arguments.length, t = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            t[_key2] = arguments[_key2];\n          }\n          const e = a.evaluate.apply(void 0, t),\n            r = l.evaluate.apply(void 0, t);\n          if (void 0 !== e && void 0 !== r) return u(e, r, o);\n        }\n      } : u(a, l, o);\n    }\n    function Cs(t, e, r) {\n      return \"color\" === e.type ? r = sr.parse(r) : \"formatted\" === e.type ? r = Vr.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = Cr.build(r.toString()) : qr(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), Ts(r, t.default, e.default);\n    }\n    en.register(ms, {\n      error: [{\n        kind: \"error\"\n      }, [yr], (t, _ref8) => {\n        let [e] = _ref8;\n        throw new Nr(e.evaluate(t));\n      }],\n      typeof: [yr, [br], (t, _ref9) => {\n        let [e] = _ref9;\n        return Ir(Lr(e.evaluate(t)));\n      }],\n      \"to-rgba\": [Mr(mr, 4), [xr], (t, _ref0) => {\n        let [e] = _ref0;\n        return e.evaluate(t).toNonPremultipliedRenderColor(null).toArray();\n      }],\n      \"to-hsla\": [Mr(mr, 4), [xr], (t, _ref1) => {\n        let [e] = _ref1;\n        return e.evaluate(t).toNonPremultipliedRenderColor(null).toHslaArray();\n      }],\n      rgb: [xr, [mr, mr, mr], ys],\n      rgba: [xr, [mr, mr, mr, mr], ys],\n      hsl: [xr, [mr, mr, mr], gs],\n      hsla: [xr, [mr, mr, mr, mr], gs],\n      has: {\n        type: gr,\n        overloads: [[[yr], (t, _ref10) => {\n          let [e] = _ref10;\n          return xs(e.evaluate(t), t.properties());\n        }], [[yr, vr], (t, _ref11) => {\n          let [e, r] = _ref11;\n          return xs(e.evaluate(t), r.evaluate(t));\n        }]]\n      },\n      get: {\n        type: br,\n        overloads: [[[yr], (t, _ref12) => {\n          let [e] = _ref12;\n          return vs(e.evaluate(t), t.properties());\n        }], [[yr, vr], (t, _ref13) => {\n          let [e, r] = _ref13;\n          return vs(e.evaluate(t), r.evaluate(t));\n        }]]\n      },\n      \"feature-state\": [br, [yr], (t, _ref14) => {\n        let [e] = _ref14;\n        return vs(e.evaluate(t), t.featureState || {});\n      }],\n      properties: [vr, [], t => t.properties()],\n      \"geometry-type\": [yr, [], t => t.geometryType()],\n      worldview: [yr, [], t => t.globals.worldview || \"\"],\n      id: [br, [], t => t.id()],\n      zoom: [mr, [], t => t.globals.zoom],\n      pitch: [mr, [], t => t.globals.pitch || 0],\n      \"distance-from-center\": [mr, [], t => t.distanceFromCenter()],\n      \"measure-light\": [mr, [yr], (t, _ref15) => {\n        let [e] = _ref15;\n        return t.measureLight(e.evaluate(t));\n      }],\n      \"heatmap-density\": [mr, [], t => t.globals.heatmapDensity || 0],\n      \"line-progress\": [mr, [], t => t.globals.lineProgress || 0],\n      \"raster-value\": [mr, [], t => t.globals.rasterValue || 0],\n      \"raster-particle-speed\": [mr, [], t => t.globals.rasterParticleSpeed || 0],\n      \"sky-radial-progress\": [mr, [], t => t.globals.skyRadialProgress || 0],\n      accumulated: [br, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n      \"+\": [mr, bs(mr), (t, e) => {\n        let r = 0;\n        for (const n of e) r += n.evaluate(t);\n        return r;\n      }],\n      \"*\": [mr, bs(mr), (t, e) => {\n        let r = 1;\n        for (const n of e) r *= n.evaluate(t);\n        return r;\n      }],\n      \"-\": {\n        type: mr,\n        overloads: [[[mr, mr], (t, _ref16) => {\n          let [e, r] = _ref16;\n          return e.evaluate(t) - r.evaluate(t);\n        }], [[mr], (t, _ref17) => {\n          let [e] = _ref17;\n          return -e.evaluate(t);\n        }]]\n      },\n      \"/\": [mr, [mr, mr], (t, _ref18) => {\n        let [e, r] = _ref18;\n        return e.evaluate(t) / r.evaluate(t);\n      }],\n      \"%\": [mr, [mr, mr], (t, _ref19) => {\n        let [e, r] = _ref19;\n        return e.evaluate(t) % r.evaluate(t);\n      }],\n      ln2: [mr, [], () => Math.LN2],\n      pi: [mr, [], () => Math.PI],\n      e: [mr, [], () => Math.E],\n      \"^\": [mr, [mr, mr], (t, _ref20) => {\n        let [e, r] = _ref20;\n        return Math.pow(e.evaluate(t), r.evaluate(t));\n      }],\n      sqrt: [mr, [mr], (t, _ref21) => {\n        let [e] = _ref21;\n        return Math.sqrt(e.evaluate(t));\n      }],\n      log10: [mr, [mr], (t, _ref22) => {\n        let [e] = _ref22;\n        return Math.log(e.evaluate(t)) / Math.LN10;\n      }],\n      ln: [mr, [mr], (t, _ref23) => {\n        let [e] = _ref23;\n        return Math.log(e.evaluate(t));\n      }],\n      log2: [mr, [mr], (t, _ref24) => {\n        let [e] = _ref24;\n        return Math.log2(e.evaluate(t));\n      }],\n      sin: [mr, [mr], (t, _ref25) => {\n        let [e] = _ref25;\n        return Math.sin(e.evaluate(t));\n      }],\n      cos: [mr, [mr], (t, _ref26) => {\n        let [e] = _ref26;\n        return Math.cos(e.evaluate(t));\n      }],\n      tan: [mr, [mr], (t, _ref27) => {\n        let [e] = _ref27;\n        return Math.tan(e.evaluate(t));\n      }],\n      asin: [mr, [mr], (t, _ref28) => {\n        let [e] = _ref28;\n        return Math.asin(e.evaluate(t));\n      }],\n      acos: [mr, [mr], (t, _ref29) => {\n        let [e] = _ref29;\n        return Math.acos(e.evaluate(t));\n      }],\n      atan: [mr, [mr], (t, _ref30) => {\n        let [e] = _ref30;\n        return Math.atan(e.evaluate(t));\n      }],\n      min: [mr, bs(mr), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n      max: [mr, bs(mr), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n      abs: [mr, [mr], (t, _ref31) => {\n        let [e] = _ref31;\n        return Math.abs(e.evaluate(t));\n      }],\n      round: [mr, [mr], (t, _ref32) => {\n        let [e] = _ref32;\n        const r = e.evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [mr, [mr], (t, _ref33) => {\n        let [e] = _ref33;\n        return Math.floor(e.evaluate(t));\n      }],\n      ceil: [mr, [mr], (t, _ref34) => {\n        let [e] = _ref34;\n        return Math.ceil(e.evaluate(t));\n      }],\n      \"filter-==\": [gr, [yr, br], (t, _ref35) => {\n        let [e, r] = _ref35;\n        return t.properties()[e.value] === r.value;\n      }],\n      \"filter-id-==\": [gr, [br], (t, _ref36) => {\n        let [e] = _ref36;\n        return t.id() === e.value;\n      }],\n      \"filter-type-==\": [gr, [yr], (t, _ref37) => {\n        let [e] = _ref37;\n        return t.geometryType() === e.value;\n      }],\n      \"filter-<\": [gr, [yr, br], (t, _ref38) => {\n        let [e, r] = _ref38;\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      \"filter-id-<\": [gr, [br], (t, _ref39) => {\n        let [e] = _ref39;\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r < n;\n      }],\n      \"filter->\": [gr, [yr, br], (t, _ref40) => {\n        let [e, r] = _ref40;\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      \"filter-id->\": [gr, [br], (t, _ref41) => {\n        let [e] = _ref41;\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r > n;\n      }],\n      \"filter-<=\": [gr, [yr, br], (t, _ref42) => {\n        let [e, r] = _ref42;\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      \"filter-id-<=\": [gr, [br], (t, _ref43) => {\n        let [e] = _ref43;\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r <= n;\n      }],\n      \"filter->=\": [gr, [yr, br], (t, _ref44) => {\n        let [e, r] = _ref44;\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      \"filter-id->=\": [gr, [br], (t, _ref45) => {\n        let [e] = _ref45;\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r >= n;\n      }],\n      \"filter-has\": [gr, [br], (t, _ref46) => {\n        let [e] = _ref46;\n        return e.value in t.properties();\n      }],\n      \"filter-has-id\": [gr, [], t => null !== t.id() && void 0 !== t.id()],\n      \"filter-type-in\": [gr, [Mr(yr)], (t, _ref47) => {\n        let [e] = _ref47;\n        return e.value.indexOf(t.geometryType()) >= 0;\n      }],\n      \"filter-id-in\": [gr, [Mr(br)], (t, _ref48) => {\n        let [e] = _ref48;\n        return e.value.indexOf(t.id()) >= 0;\n      }],\n      \"filter-in-small\": [gr, [yr, Mr(br)], (t, _ref49) => {\n        let [e, r] = _ref49;\n        return r.value.indexOf(t.properties()[e.value]) >= 0;\n      }],\n      \"filter-in-large\": [gr, [yr, Mr(br)], (t, _ref50) => {\n        let [e, r] = _ref50;\n        return function (t, e, r, n) {\n          for (; r <= n;) {\n            const i = r + n >> 1;\n            if (e[i] === t) return !0;\n            e[i] > t ? n = i - 1 : r = i + 1;\n          }\n          return !1;\n        }(t.properties()[e.value], r.value, 0, r.value.length - 1);\n      }],\n      all: {\n        type: gr,\n        overloads: [[[gr, gr], (t, _ref51) => {\n          let [e, r] = _ref51;\n          return e.evaluate(t) && r.evaluate(t);\n        }], [bs(gr), (t, e) => {\n          for (const r of e) if (!r.evaluate(t)) return !1;\n          return !0;\n        }]]\n      },\n      any: {\n        type: gr,\n        overloads: [[[gr, gr], (t, _ref52) => {\n          let [e, r] = _ref52;\n          return e.evaluate(t) || r.evaluate(t);\n        }], [bs(gr), (t, e) => {\n          for (const r of e) if (r.evaluate(t)) return !0;\n          return !1;\n        }]]\n      },\n      \"!\": [gr, [gr], (t, _ref53) => {\n        let [e] = _ref53;\n        return !e.evaluate(t);\n      }],\n      \"is-supported-script\": [gr, [yr], (t, _ref54) => {\n        let [e] = _ref54;\n        const r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e.evaluate(t));\n      }],\n      upcase: [yr, [yr], (t, _ref55) => {\n        let [e] = _ref55;\n        return e.evaluate(t).toUpperCase();\n      }],\n      downcase: [yr, [yr], (t, _ref56) => {\n        let [e] = _ref56;\n        return e.evaluate(t).toLowerCase();\n      }],\n      concat: [yr, bs(br), (t, e) => e.map(e => Or(e.evaluate(t))).join(\"\")],\n      \"resolved-locale\": [yr, [wr], (t, _ref57) => {\n        let [e] = _ref57;\n        return e.evaluate(t).resolvedLocale();\n      }],\n      random: [mr, [mr, mr, br], (t, e) => {\n        const [r, n, i] = e.map(e => e.evaluate(t));\n        if (r > n) return r;\n        if (r === n) return r;\n        let s;\n        if (\"string\" == typeof i) s = function (t) {\n          let e = 0;\n          if (0 === t.length) return e;\n          for (let r = 0; r < t.length; r++) e = (e << 5) - e + t.charCodeAt(r), e |= 0;\n          return e;\n        }(i);else {\n          if (\"number\" != typeof i) throw new Nr(\"Invalid seed input: \".concat(i));\n          s = i;\n        }\n        return r + fs(s)() * (n - r);\n      }]\n    });\n    class Ds {\n      constructor(t, e, r, n, i) {\n        this.expression = t, this._warningHistory = {}, this._evaluator = new tn(r, n, i), this._defaultValue = e ? function (t) {\n          return \"color\" === t.type && (ks(t.default) || Array.isArray(t.default)) ? new sr(0, 0, 0, 0) : \"color\" === t.type ? sr.parse(t.default) || null : void 0 === t.default ? null : t.default;\n        }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null, this.configDependencies = yi(t);\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s, o, a) {\n        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = a || null, this.expression.evaluate(this._evaluator);\n      }\n      evaluate(t, e, r, n, i, s, o, a, l) {\n        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = o || null, this._evaluator.featureDistanceData = a || null, this._evaluator.iconImageUseTheme = l || null;\n        try {\n          const t = this.expression.evaluate(this._evaluator);\n          if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n          if (this._enumValues && !(t in this._enumValues)) throw new Nr(\"Expected value to be one of \".concat(Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \"), \", but found \").concat(JSON.stringify(t), \" instead.\"));\n          return t;\n        } catch (t) {\n          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(\"Failed to evaluate expression \\\"\".concat(JSON.stringify(this.expression.serialize()), \"\\\". \").concat(t.message))), this._defaultValue;\n        }\n      }\n    }\n    function Rs(t) {\n      return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in ms;\n    }\n    function Ls(t, e, r, n, i) {\n      const s = new Ai(ms, [], e ? function (t) {\n          const e = {\n            color: xr,\n            string: yr,\n            number: mr,\n            enum: yr,\n            boolean: gr,\n            formatted: _r,\n            resolvedImage: Ar\n          };\n          return \"array\" === t.type ? Mr(e[t.value] || br, t.length) : e[t.type];\n        }(e) : void 0, void 0, void 0, r, n, i),\n        o = s.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n          typeAnnotation: \"coerce\"\n        } : void 0);\n      return o ? ws(new Ds(o, e, r, n, i)) : _s(s.errors);\n    }\n    class Os {\n      constructor(t, e, r, n) {\n        this.kind = t, this._styleExpression = e, this.isLightConstant = r, this.isLineProgressConstant = n, this.isStateDependent = \"constant\" !== t && !mi(e.expression), this.configDependencies = yi(e.expression);\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n      evaluate(t, e, r, n, i, s, o) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s, void 0, void 0, o);\n      }\n    }\n    class Us {\n      constructor(t, e, r, n, i, s) {\n        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !mi(e.expression), this.isLightConstant = i, this.isLineProgressConstant = s, this.configDependencies = yi(e.expression), this.interpolationType = n;\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n      interpolationFactor(t, e, r) {\n        return this.interpolationType ? Hi.interpolationFactor(this.interpolationType, t, e, r) : 0;\n      }\n    }\n    function Ns(t, e, r, n, i) {\n      if (\"error\" === (t = Ls(t, e, r, n, i)).result) return t;\n      const s = t.value.expression,\n        o = fi(s);\n      if (!o && !Ms(e)) return _s([new pr(\"\", \"data expressions not supported\")]);\n      const a = gi(s, [\"zoom\", \"pitch\", \"distance-from-center\"]);\n      if (!a && !Ss(e)) return _s([new pr(\"\", \"zoom expressions not supported\")]);\n      const l = gi(s, [\"measure-light\"]);\n      if (!l && !Is(e)) return _s([new pr(\"\", \"measure-light expression not supported\")]);\n      const u = gi(s, [\"line-progress\"]);\n      if (!u && !function (t) {\n        return As(t.expression, \"line-progress\");\n      }(e)) return _s([new pr(\"\", \"line-progress expression not supported\")]);\n      const c = e.expression && e.expression.relaxZoomRestriction,\n        h = $s(s);\n      return h || a || c ? h instanceof pr ? _s([h]) : h instanceof Hi && !Ps(e) ? _s([new pr(\"\", '\"interpolate\" expressions cannot be used with this property')]) : ws(h ? new Us(o && u ? \"camera\" : \"composite\", t.value, h.labels, h instanceof Hi ? h.interpolation : void 0, l, u) : new Os(o && u ? \"constant\" : \"source\", t.value, l, u)) : _s([new pr(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression, or in the properties of atmosphere.')]);\n    }\n    class js {\n      constructor(t, e) {\n        this._parameters = t, this._specification = e, Object.assign(this, Es(this._parameters, this._specification));\n      }\n      static deserialize(t) {\n        return new js(t._parameters, t._specification);\n      }\n      static serialize(t) {\n        return {\n          _parameters: t._parameters,\n          _specification: t._specification\n        };\n      }\n    }\n    function $s(t) {\n      let e = null;\n      if (t instanceof Zi) e = $s(t.result);else if (t instanceof Xi) {\n        for (const r of t.args) if (e = $s(r), e) break;\n      } else (t instanceof Si || t instanceof Hi) && t.input instanceof en && \"zoom\" === t.input.name && (e = t);\n      return e instanceof pr || t.eachChild(t => {\n        const r = $s(t);\n        r instanceof pr ? e = r : e && r && e !== r && (e = new pr(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), e;\n    }\n    var Gs,\n      Hs,\n      qs = function () {\n        if (Hs) return Gs;\n        Hs = 1, Gs = e;\n        var t = 3;\n        function e(e, r, n) {\n          var i = this.cells = [];\n          if (e instanceof ArrayBuffer) {\n            this.arrayBuffer = e;\n            var s = new Int32Array(this.arrayBuffer);\n            e = s[0], this.d = (r = s[1]) + 2 * (n = s[2]);\n            for (var o = 0; o < this.d * this.d; o++) {\n              var a = s[t + o],\n                l = s[t + o + 1];\n              i.push(a === l ? null : s.subarray(a, l));\n            }\n            var u = s[t + i.length + 1];\n            this.keys = s.subarray(s[t + i.length], u), this.bboxes = s.subarray(u), this.insert = this._insertReadonly;\n          } else {\n            this.d = r + 2 * n;\n            for (var c = 0; c < this.d * this.d; c++) i.push([]);\n            this.keys = [], this.bboxes = [];\n          }\n          this.n = r, this.extent = e, this.padding = n, this.scale = r / e, this.uid = 0;\n          var h = n / r * e;\n          this.min = -h, this.max = e + h;\n        }\n        return e.prototype.insert = function (t, e, r, n, i) {\n          this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n        }, e.prototype._insertReadonly = function () {\n          throw \"Cannot insert into a GridIndex created from an ArrayBuffer.\";\n        }, e.prototype._insertCell = function (t, e, r, n, i, s) {\n          this.cells[i].push(s);\n        }, e.prototype.query = function (t, e, r, n, i) {\n          var s = this.min,\n            o = this.max;\n          if (t <= s && e <= s && o <= r && o <= n && !i) return Array.prototype.slice.call(this.keys);\n          var a = [];\n          return this._forEachCell(t, e, r, n, this._queryCell, a, {}, i), a;\n        }, e.prototype._queryCell = function (t, e, r, n, i, s, o, a) {\n          var l = this.cells[i];\n          if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {\n            var p = l[h];\n            if (void 0 === o[p]) {\n              var d = 4 * p;\n              (a ? a(c[d + 0], c[d + 1], c[d + 2], c[d + 3]) : t <= c[d + 2] && e <= c[d + 3] && r >= c[d + 0] && n >= c[d + 1]) ? (o[p] = !0, s.push(u[p])) : o[p] = !1;\n            }\n          }\n        }, e.prototype._forEachCell = function (t, e, r, n, i, s, o, a) {\n          for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var d = u; d <= h; d++) {\n            var f = this.d * d + p;\n            if ((!a || a(this._convertFromCellCoord(p), this._convertFromCellCoord(d), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(d + 1))) && i.call(this, t, e, r, n, f, s, o, a)) return;\n          }\n        }, e.prototype._convertFromCellCoord = function (t) {\n          return (t - this.padding) / this.scale;\n        }, e.prototype._convertToCellCoord = function (t) {\n          return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n        }, e.prototype.toArrayBuffer = function () {\n          if (this.arrayBuffer) return this.arrayBuffer;\n          for (var e = this.cells, r = t + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++) n += this.cells[i].length;\n          var s = new Int32Array(r + n + this.keys.length + this.bboxes.length);\n          s[0] = this.extent, s[1] = this.n, s[2] = this.padding;\n          for (var o = r, a = 0; a < e.length; a++) {\n            var l = e[a];\n            s[t + a] = o, s.set(l, o), o += l.length;\n          }\n          return s[t + e.length] = o, s.set(this.keys, o), s[t + e.length + 1] = o += this.keys.length, s.set(this.bboxes, o), o += this.bboxes.length, s.buffer;\n        }, Gs;\n      }(),\n      Xs = xt(qs);\n    const Zs = {};\n    function Ws(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      Object.defineProperty(t, \"_classRegistryKey\", {\n        value: e,\n        writable: !1\n      }), Zs[e] = {\n        klass: t,\n        omit: r.omit || []\n      };\n    }\n    Ws(Object, \"Object\"), Xs.serialize = function (t, e) {\n      const r = t.toArrayBuffer();\n      return e && e.add(r), {\n        buffer: r\n      };\n    }, Xs.deserialize = function (t) {\n      return new Xs(t.buffer);\n    }, Object.defineProperty(Xs, \"name\", {\n      value: \"Grid\"\n    }), Ws(Xs, \"Grid\"), delete wt.prototype.constructor, \"undefined\" != typeof DOMMatrix && Ws(DOMMatrix, \"DOMMatrix\"), Ws(sr, \"Color\"), Ws(Error, \"Error\"), Ws(Vr, \"Formatted\"), Ws(Br, \"FormattedSection\"), Ws(Ve, \"AJAXError\"), Ws(Cr, \"ResolvedImage\"), Ws(js, \"StylePropertyFunction\"), Ws(Ds, \"StyleExpression\", {\n      omit: [\"_evaluator\"]\n    }), Ws(er, \"ImageId\"), Ws(Fr, \"ImageVariant\"), Ws(Us, \"ZoomDependentExpression\"), Ws(Os, \"ZoomConstantExpression\"), Ws(en, \"CompoundExpression\", {\n      omit: [\"_evaluate\"]\n    });\n    for (const t in ms) Zs[ms[t]._classRegistryKey] || Ws(ms[t], \"Expression\".concat(t));\n    function Ys(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n    function Ks(t) {\n      return self.ImageBitmap && t instanceof ImageBitmap;\n    }\n    function Js(t, e) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (Ys(t) || Ks(t)) return e && e.add(t), t;\n      if (ArrayBuffer.isView(t)) return e && e.add(t.buffer), t;\n      if (t instanceof ImageData) return e && e.add(t.data.buffer), t;\n      if (Array.isArray(t)) {\n        const r = [];\n        for (const n of t) r.push(Js(n, e));\n        return r;\n      }\n      if (t instanceof Map) {\n        const r = {\n          $name: \"Map\",\n          entries: []\n        };\n        for (const [n, i] of t.entries()) r.entries.push(Js(n), Js(i, e));\n        return r;\n      }\n      if (t instanceof Set) {\n        const e = {\n          $name: \"Set\"\n        };\n        let r = 0;\n        for (const n of t.values()) e[++r] = Js(n);\n        return e;\n      }\n      if (t instanceof DOMMatrix) {\n        const e = {\n            $name: \"DOMMatrix\"\n          },\n          r = [\"is2D\", \"m11\", \"m12\", \"m13\", \"m14\", \"m21\", \"m22\", \"m23\", \"m24\", \"m31\", \"m32\", \"m33\", \"m34\", \"m41\", \"m42\", \"m43\", \"m44\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n        for (const n of r) e[n] = t[n];\n        return e;\n      }\n      if (\"bigint\" == typeof t) return {\n        $name: \"BigInt\",\n        value: t.toString()\n      };\n      if (\"object\" == typeof t) {\n        const r = t.constructor,\n          n = r._classRegistryKey;\n        if (!n) throw new Error(\"Can't serialize object of unregistered class \\\"\".concat(r.name, \"\\\".\"));\n        const i = r.serialize ? r.serialize(t, e) : {};\n        if (!r.serialize) {\n          for (const r in t) t.hasOwnProperty(r) && (Zs[n].omit.indexOf(r) >= 0 || (i[r] = Js(t[r], e)));\n          t instanceof Error && (i.message = t.message);\n        }\n        if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n        return \"Object\" !== n && (i.$name = n), i;\n      }\n      throw new Error(\"can't serialize object of type \" + typeof t);\n    }\n    function Qs(t) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Ys(t) || Ks(t) || ArrayBuffer.isView(t) || t instanceof ImageData) return t;\n      if (Array.isArray(t)) return t.map(Qs);\n      if (\"object\" == typeof t) {\n        const e = t.$name || \"Object\";\n        if (\"Map\" === e) {\n          const e = t.entries || [],\n            r = new Map();\n          for (let t = 0; t < e.length; t += 2) r.set(Qs(e[t]), Qs(e[t + 1]));\n          return r;\n        }\n        if (\"Set\" === e) {\n          const e = new Set();\n          for (const r of Object.keys(t)) \"$name\" !== r && e.add(Qs(t[r]));\n          return e;\n        }\n        if (\"DOMMatrix\" === e) {\n          let e;\n          return e = t.is2D ? [t.a, t.b, t.c, t.d, t.e, t.f] : [t.m11, t.m12, t.m13, t.m14, t.m21, t.m22, t.m23, t.m24, t.m31, t.m32, t.m33, t.m34, t.m41, t.m42, t.m43, t.m44], new DOMMatrix(e);\n        }\n        if (\"BigInt\" === e) return BigInt(t.value);\n        const {\n          klass: r\n        } = Zs[e];\n        if (!r) throw new Error(\"Can't deserialize unregistered class \\\"\".concat(e, \"\\\".\"));\n        if (r.deserialize) return r.deserialize(t);\n        const n = Object.create(r.prototype);\n        for (const e of Object.keys(t)) \"$name\" !== e && (n[e] = Qs(t[e]));\n        return n;\n      }\n      throw new Error(\"can't deserialize object of type \" + typeof t);\n    }\n    const to = {\n      \"Latin-1 Supplement\": t => t >= 128 && t <= 255,\n      Arabic: t => t >= 1536 && t <= 1791,\n      \"Arabic Supplement\": t => t >= 1872 && t <= 1919,\n      \"Arabic Extended-A\": t => t >= 2208 && t <= 2303,\n      \"Hangul Jamo\": t => t >= 4352 && t <= 4607,\n      \"Unified Canadian Aboriginal Syllabics\": t => t >= 5120 && t <= 5759,\n      Khmer: t => t >= 6016 && t <= 6143,\n      \"Unified Canadian Aboriginal Syllabics Extended\": t => t >= 6320 && t <= 6399,\n      \"General Punctuation\": t => t >= 8192 && t <= 8303,\n      \"Letterlike Symbols\": t => t >= 8448 && t <= 8527,\n      \"Number Forms\": t => t >= 8528 && t <= 8591,\n      \"Miscellaneous Technical\": t => t >= 8960 && t <= 9215,\n      \"Control Pictures\": t => t >= 9216 && t <= 9279,\n      \"Optical Character Recognition\": t => t >= 9280 && t <= 9311,\n      \"Enclosed Alphanumerics\": t => t >= 9312 && t <= 9471,\n      \"Geometric Shapes\": t => t >= 9632 && t <= 9727,\n      \"Miscellaneous Symbols\": t => t >= 9728 && t <= 9983,\n      \"Miscellaneous Symbols and Arrows\": t => t >= 11008 && t <= 11263,\n      \"CJK Radicals Supplement\": t => t >= 11904 && t <= 12031,\n      \"Kangxi Radicals\": t => t >= 12032 && t <= 12255,\n      \"Ideographic Description Characters\": t => t >= 12272 && t <= 12287,\n      \"CJK Symbols and Punctuation\": t => t >= 12288 && t <= 12351,\n      Hiragana: t => t >= 12352 && t <= 12447,\n      Katakana: t => t >= 12448 && t <= 12543,\n      Bopomofo: t => t >= 12544 && t <= 12591,\n      \"Hangul Compatibility Jamo\": t => t >= 12592 && t <= 12687,\n      Kanbun: t => t >= 12688 && t <= 12703,\n      \"Bopomofo Extended\": t => t >= 12704 && t <= 12735,\n      \"CJK Strokes\": t => t >= 12736 && t <= 12783,\n      \"Katakana Phonetic Extensions\": t => t >= 12784 && t <= 12799,\n      \"Enclosed CJK Letters and Months\": t => t >= 12800 && t <= 13055,\n      \"CJK Compatibility\": t => t >= 13056 && t <= 13311,\n      \"CJK Unified Ideographs Extension A\": t => t >= 13312 && t <= 19903,\n      \"Yijing Hexagram Symbols\": t => t >= 19904 && t <= 19967,\n      \"CJK Unified Ideographs\": t => t >= 19968 && t <= 40959,\n      \"Yi Syllables\": t => t >= 40960 && t <= 42127,\n      \"Yi Radicals\": t => t >= 42128 && t <= 42191,\n      \"Hangul Jamo Extended-A\": t => t >= 43360 && t <= 43391,\n      \"Hangul Syllables\": t => t >= 44032 && t <= 55215,\n      \"Hangul Jamo Extended-B\": t => t >= 55216 && t <= 55295,\n      \"Private Use Area\": t => t >= 57344 && t <= 63743,\n      \"CJK Compatibility Ideographs\": t => t >= 63744 && t <= 64255,\n      \"Arabic Presentation Forms-A\": t => t >= 64336 && t <= 65023,\n      \"Vertical Forms\": t => t >= 65040 && t <= 65055,\n      \"CJK Compatibility Forms\": t => t >= 65072 && t <= 65103,\n      \"Small Form Variants\": t => t >= 65104 && t <= 65135,\n      \"Arabic Presentation Forms-B\": t => t >= 65136 && t <= 65279,\n      \"Halfwidth and Fullwidth Forms\": t => t >= 65280 && t <= 65519,\n      Osage: t => t >= 66736 && t <= 66815,\n      \"CJK Unified Ideographs Extension B\": t => t >= 131072 && t <= 173791\n    };\n    function eo(t) {\n      for (const e of t) if (io(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    function ro(t) {\n      for (const e of t) if (!no(e.charCodeAt(0))) return !1;\n      return !0;\n    }\n    function no(t) {\n      return !(to.Arabic(t) || to[\"Arabic Supplement\"](t) || to[\"Arabic Extended-A\"](t) || to[\"Arabic Presentation Forms-A\"](t) || to[\"Arabic Presentation Forms-B\"](t));\n    }\n    function io(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(to[\"Bopomofo Extended\"](t) || to.Bopomofo(t) || to[\"CJK Compatibility Forms\"](t) && !(t >= 65097 && t <= 65103) || to[\"CJK Compatibility Ideographs\"](t) || to[\"CJK Compatibility\"](t) || to[\"CJK Radicals Supplement\"](t) || to[\"CJK Strokes\"](t) || !(!to[\"CJK Symbols and Punctuation\"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || to[\"CJK Unified Ideographs Extension A\"](t) || to[\"CJK Unified Ideographs\"](t) || to[\"Enclosed CJK Letters and Months\"](t) || to[\"Hangul Compatibility Jamo\"](t) || to[\"Hangul Jamo Extended-A\"](t) || to[\"Hangul Jamo Extended-B\"](t) || to[\"Hangul Jamo\"](t) || to[\"Hangul Syllables\"](t) || to.Hiragana(t) || to[\"Ideographic Description Characters\"](t) || to.Kanbun(t) || to[\"Kangxi Radicals\"](t) || to[\"Katakana Phonetic Extensions\"](t) || to.Katakana(t) && 12540 !== t || !(!to[\"Halfwidth and Fullwidth Forms\"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!to[\"Small Form Variants\"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || to[\"Unified Canadian Aboriginal Syllabics\"](t) || to[\"Unified Canadian Aboriginal Syllabics Extended\"](t) || to[\"Vertical Forms\"](t) || to[\"Yijing Hexagram Symbols\"](t) || to[\"Yi Syllables\"](t) || to[\"Yi Radicals\"](t))));\n    }\n    function so(t) {\n      return !(io(t) || function (t) {\n        return !!(to[\"Latin-1 Supplement\"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || to[\"General Punctuation\"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || to[\"Letterlike Symbols\"](t) || to[\"Number Forms\"](t) || to[\"Miscellaneous Technical\"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || to[\"Control Pictures\"](t) && 9251 !== t || to[\"Optical Character Recognition\"](t) || to[\"Enclosed Alphanumerics\"](t) || to[\"Geometric Shapes\"](t) || to[\"Miscellaneous Symbols\"](t) && !(t >= 9754 && t <= 9759) || to[\"Miscellaneous Symbols and Arrows\"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || to[\"CJK Symbols and Punctuation\"](t) || to.Katakana(t) || to[\"Private Use Area\"](t) || to[\"CJK Compatibility Forms\"](t) || to[\"Small Form Variants\"](t) || to[\"Halfwidth and Fullwidth Forms\"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n    function oo(t) {\n      return to.Arabic(t) || to[\"Arabic Supplement\"](t) || to[\"Arabic Extended-A\"](t) || to[\"Arabic Presentation Forms-A\"](t) || to[\"Arabic Presentation Forms-B\"](t);\n    }\n    function ao(t) {\n      return t >= 1424 && t <= 2303 || to[\"Arabic Presentation Forms-A\"](t) || to[\"Arabic Presentation Forms-B\"](t);\n    }\n    function lo(t, e) {\n      return !(!e && ao(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || to.Khmer(t));\n    }\n    function uo(t) {\n      for (const e of t) if (ao(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    const co = {\n      unavailable: \"unavailable\",\n      deferred: \"deferred\",\n      loading: \"loading\",\n      parsing: \"parsing\",\n      parsed: \"parsed\",\n      loaded: \"loaded\",\n      error: \"error\"\n    };\n    let ho = null,\n      po = co.unavailable,\n      fo = null;\n    const mo = function (t) {\n      t && \"string\" == typeof t && t.indexOf(\"NetworkError\") > -1 && (po = co.error), ho && ho(t);\n    };\n    function yo() {\n      go.fire(new Ye(\"pluginStateChange\", {\n        pluginStatus: po,\n        pluginURL: fo\n      }));\n    }\n    const go = new tr(),\n      xo = function () {\n        return po;\n      },\n      vo = function () {\n        if (po !== co.deferred || !fo) throw new Error(\"rtl-text-plugin cannot be downloaded unless a pluginURL is specified\");\n        po = co.loading, yo(), fo && De({\n          url: fo\n        }, t => {\n          t ? mo(t) : (po = co.loaded, yo());\n        });\n      },\n      bo = {\n        applyArabicShaping: null,\n        processBidirectionalText: null,\n        processStyledBidirectionalText: null,\n        isLoaded: () => po === co.loaded || null != bo.applyArabicShaping,\n        isLoading: () => po === co.loading,\n        setState(t) {\n          po = t.pluginStatus, fo = t.pluginURL;\n        },\n        isParsing: () => po === co.parsing,\n        isParsed: () => po === co.parsed,\n        getPluginURL: () => fo\n      };\n    class wo {\n      constructor(t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness, this.worldview = e.worldview) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);\n      }\n      isSupportedScript(t) {\n        return function (t, e) {\n          for (const r of t) if (!lo(r.charCodeAt(0), e)) return !1;\n          return !0;\n        }(t, bo.isLoaded());\n      }\n    }\n    class _o {\n      constructor(t, e, r, n, i) {\n        this.property = t, this.value = e, this.expression = function (t, e, r, n, i) {\n          if (ks(t)) return new js(t, e);\n          if (Rs(t) || Array.isArray(t) && t.length > 0) {\n            const s = Ns(t, e, r, n, i);\n            if (\"error\" === s.result) throw new Error(s.value.map(t => \"\".concat(t.key, \": \").concat(t.message)).join(\", \"));\n            return s.value;\n          }\n          {\n            let r = t;\n            return \"string\" == typeof t && \"color\" === e.type && (r = sr.parse(t)), {\n              kind: \"constant\",\n              configDependencies: new Set(),\n              evaluate: () => r\n            };\n          }\n        }(void 0 === e ? t.specification.default : e, t.specification, r, n, i);\n      }\n      isDataDriven() {\n        return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return this.property.possiblyEvaluate(this, t, e, r, n);\n      }\n    }\n    class Ao {\n      constructor(t, e, r, n) {\n        this.property = t, this.value = new _o(t, void 0, e, r, n);\n      }\n      transitioned(t, e) {\n        return new Io(this.property, this.value, e, Object.assign({}, t.transition, this.transition), t.now);\n      }\n      untransitioned() {\n        return new Io(this.property, this.value, null, {}, 0);\n      }\n    }\n    class Mo {\n      constructor(t, e, r, n) {\n        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this._iconImageUseTheme = n, this.configDependencies = new Set();\n      }\n      getValue(t) {\n        return Nt(this._values[t].value.value);\n      }\n      setValue(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new Ao(this._values[t].property, this._scope, this._options, this._iconImageUseTheme)), this._values[t].value = new _o(this._values[t].property, null === e ? void 0 : Nt(e), this._scope, this._options, this._iconImageUseTheme), this._values[t].value.expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[t].value.expression.configDependencies]));\n      }\n      setTransitionOrValue(t, e) {\n        e && (this._options = e);\n        const r = this._properties.properties;\n        if (t) for (const e in t) {\n          const n = t[e];\n          if (e.endsWith(\"-transition\")) {\n            const t = e.slice(0, -11);\n            r[t] && this.setTransition(t, n);\n          } else r.hasOwnProperty(e) && this.setValue(e, n);\n        }\n      }\n      getTransition(t) {\n        return Nt(this._values[t].transition);\n      }\n      setTransition(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new Ao(this._values[t].property)), this._values[t].transition = Nt(e) || void 0;\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n          const n = this.getTransition(e);\n          void 0 !== n && (t[\"\".concat(e, \"-transition\")] = n);\n        }\n        return t;\n      }\n      transitioned(t, e) {\n        const r = new So(this._properties);\n        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n        return r;\n      }\n      untransitioned() {\n        const t = new So(this._properties);\n        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n        return t;\n      }\n    }\n    class Io {\n      constructor(t, e, r, n, i) {\n        const s = n.delay || 0,\n          o = n.duration || 0;\n        i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + o, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = t.now || 0,\n          i = this.value.possiblyEvaluate(t, e, r),\n          s = this.prior;\n        if (s) {\n          if (n > this.end) return this.prior = null, i;\n          if (this.value.isDataDriven()) return this.prior = null, i;\n          if (n < this.begin) return s.possiblyEvaluate(t, e, r);\n          {\n            const o = (n - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, kt(o));\n          }\n        }\n        return i;\n      }\n    }\n    class So {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new zo(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n      hasTransition() {\n        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n        return !1;\n      }\n    }\n    class Po {\n      constructor(t, e, r, n) {\n        this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._scope = e, this._options = r, this._iconImageUseTheme = n, this.configDependencies = new Set();\n      }\n      getValue(t) {\n        return Nt(this._values[t].value);\n      }\n      setValue(t, e) {\n        this._values[t] = new _o(this._values[t].property, null === e ? void 0 : Nt(e), this._scope, this._options, this._iconImageUseTheme), this._values[t].expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[t].expression.configDependencies]));\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n        }\n        return t;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        const i = new zo(this._properties);\n        for (const s of Object.keys(this._values)) i._values[s] = this._values[s].possiblyEvaluate(t, e, r, n);\n        return i;\n      }\n    }\n    class ko {\n      constructor(t, e, r, n) {\n        this.property = t, this.value = e, this.parameters = r, this.iconImageUseTheme = n;\n      }\n      isConstant() {\n        return \"constant\" === this.value.kind;\n      }\n      constantOr(t) {\n        return \"constant\" === this.value.kind ? this.value.value : t;\n      }\n      evaluate(t, e, r, n) {\n        return this.property.evaluate(this.value, this.parameters, t, e, r, n, this.iconImageUseTheme);\n      }\n    }\n    class zo {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n      }\n      get(t) {\n        return this._values[t];\n      }\n    }\n    class Eo {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return t.expression.evaluate(e);\n      }\n      interpolate(t, e, r) {\n        const n = hr[this.specification.type];\n        return n ? n(t, e, r) : t;\n      }\n    }\n    class To {\n      constructor(t, e) {\n        this.specification = t, this.overrides = e;\n      }\n      possiblyEvaluate(t, e, r, n, i) {\n        return \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? new ko(this, {\n          kind: \"constant\",\n          value: t.expression.evaluate(e, null, {}, r, n, void 0, i)\n        }, e) : new ko(this, t.expression, e, i);\n      }\n      interpolate(t, e, r) {\n        if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n        if (void 0 === t.value.value || void 0 === e.value.value) return new ko(this, {\n          kind: \"constant\",\n          value: void 0\n        }, t.parameters);\n        const n = hr[this.specification.type];\n        return n ? new ko(this, {\n          kind: \"constant\",\n          value: n(t.value.value, e.value.value, r)\n        }, t.parameters) : t;\n      }\n      evaluate(t, e, r, n, i, s, o) {\n        return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, s, void 0, o);\n      }\n    }\n    class Bo {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return !!t.expression.evaluate(e, null, {}, r, n);\n      }\n      interpolate() {\n        return !1;\n      }\n    }\n    class Vo {\n      constructor(t) {\n        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n        const e = new wo(0, {});\n        for (const r in t) {\n          const n = t[r];\n          n.specification.overridable && this.overridableProperties.push(r);\n          const i = this.defaultPropertyValues[r] = new _o(n, void 0),\n            s = this.defaultTransitionablePropertyValues[r] = new Ao(n);\n          this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);\n        }\n      }\n    }\n    Ws(To, \"DataDrivenProperty\"), Ws(Eo, \"DataConstantProperty\"), Ws(Bo, \"ColorRampProperty\");\n    var Fo = JSON.parse('{\"$version\":8,\"$root\":{\"version\":{\"type\":\"enum\",\"values\":[8]},\"fragment\":{\"type\":\"boolean\"},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360},\"pitch\":{\"type\":\"number\",\"default\":0},\"light\":{\"type\":\"light\"},\"lights\":{\"type\":\"array\",\"value\":\"light-3d\"},\"terrain\":{\"type\":\"terrain\",\"optional\":true},\"fog\":{\"type\":\"fog\"},\"snow\":{\"type\":\"snow\"},\"rain\":{\"type\":\"rain\"},\"camera\":{\"type\":\"camera\"},\"color-theme\":{\"type\":\"colorTheme\"},\"indoor\":{\"type\":\"indoor\"},\"imports\":{\"type\":\"array\",\"value\":\"import\"},\"iconsets\":{\"type\":\"iconsets\"},\"schema\":{\"type\":\"schema\"},\"sources\":{\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\",\"default\":\"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"type\":\"array\",\"value\":\"layer\"},\"models\":{\"type\":\"models\"},\"featuresets\":{\"type\":\"featuresets\"}},\"featuresets\":{\"*\":{\"type\":\"featureset\"}},\"featureset\":{\"metadata\":{\"type\":\"*\"},\"selectors\":{\"type\":\"array\",\"value\":\"selector\"}},\"selector\":{\"layer\":{\"type\":\"string\"},\"properties\":{\"type\":\"selectorProperty\"},\"featureNamespace\":{\"type\":\"string\"},\"_uniqueFeatureID\":{\"type\":\"boolean\"}},\"selectorProperty\":{\"*\":{\"type\":\"*\"}},\"model\":{\"type\":\"string\"},\"import\":{\"id\":{\"type\":\"string\"},\"url\":{\"type\":\"string\"},\"config\":{\"type\":\"config\"},\"data\":{\"type\":\"$root\"},\"color-theme\":{\"type\":\"colorTheme\",\"optional\":true}},\"config\":{\"*\":{\"type\":\"*\"}},\"schema\":{\"*\":{\"type\":\"option\"}},\"option\":{\"default\":{\"type\":\"*\",\"expression\":{}},\"type\":{\"type\":\"enum\",\"values\":{\"string\":1,\"number\":1,\"boolean\":1,\"color\":1}},\"array\":{\"type\":\"boolean\"},\"minValue\":{\"type\":\"number\"},\"maxValue\":{\"type\":\"number\"},\"stepValue\":{\"type\":\"number\"},\"values\":{\"type\":\"array\",\"value\":\"*\"},\"metadata\":{\"type\":\"*\"}},\"models\":{\"*\":{\"type\":\"model\"}},\"light-3d\":{\"id\":{\"type\":\"string\"},\"properties\":{\"type\":\"properties\"},\"type\":{\"type\":\"enum\",\"values\":{\"ambient\":{},\"directional\":{},\"flat\":{}}}},\"properties\":[\"properties_light_directional\",\"properties_light_ambient\",\"properties_light_flat\"],\"properties_light_directional\":{\"direction\":{\"type\":\"array\",\"default\":[210,30],\"minimum\":[0,0],\"maximum\":[360,90],\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"cast-shadows\":{\"type\":\"boolean\",\"default\":false},\"shadow-quality\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"parameters\":[\"zoom\"]}},\"shadow-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_ambient\":{\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_flat\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"iconsets\":{\"*\":{\"type\":\"iconset\"}},\"iconset\":[\"iconset_sprite\",\"iconset_source\"],\"iconset_sprite\":{\"type\":{\"type\":\"enum\",\"values\":{\"sprite\":1}},\"url\":{\"type\":\"string\"}},\"iconset_source\":{\"type\":{\"type\":\"enum\",\"values\":{\"source\":1}},\"source\":{\"type\":\"string\"}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_raster_array\",\"source_geojson\",\"source_video\",\"source_image\",\"source_model\"],\"source_vector\":{\"type\":{\"type\":\"enum\",\"values\":{\"vector\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster-dem\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":1,\"mapbox\":1},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_array\":{\"type\":{\"type\":\"enum\",\"values\":{\"raster-array\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"extra_bounds\":{\"type\":\"array\",\"value\":{\"type\":\"array\",\"value\":\"number\",\"length\":4}},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"rasterLayers\":{\"type\":\"*\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"type\":\"enum\",\"values\":{\"geojson\":1}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"},\"dynamic\":{\"type\":\"boolean\",\"default\":false}},\"source_video\":{\"type\":{\"type\":\"enum\",\"values\":{\"video\":1}},\"urls\":{\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"type\":\"enum\",\"values\":{\"image\":1}},\"url\":{\"type\":\"string\"},\"coordinates\":{\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"modelNodeOverride\":{\"orientation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360}},\"modelNodeOverrides\":{\"*\":{\"type\":\"modelNodeOverride\"}},\"modelMaterialOverride\":{\"model-color\":{\"type\":\"color\"},\"model-color-mix-intensity\":{\"type\":\"number\"},\"model-opacity\":{\"type\":\"number\"},\"model-emissive-strength\":{\"type\":\"number\"}},\"modelMaterialOverrides\":{\"*\":{\"type\":\"modelMaterialOverride\"}},\"modelSourceModel\":{\"uri\":{\"type\":\"string\"},\"position\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[-180,-90],\"maximum\":[180,90]},\"orientation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360},\"nodeOverrides\":{\"type\":\"modelNodeOverrides\"},\"materialOverrides\":{\"type\":\"modelMaterialOverrides\"},\"nodeOverrideNames\":{\"type\":\"array\",\"value\":\"string\"},\"materialOverrideNames\":{\"type\":\"array\",\"value\":\"string\"},\"featureProperties\":{\"type\":\"*\"}},\"modelSourceModels\":{\"*\":{\"type\":\"modelSourceModel\"}},\"source_model\":{\"type\":{\"type\":\"enum\",\"values\":{\"model\":1,\"batched-model\":1}},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"models\":{\"type\":\"modelSourceModels\"}},\"layer\":{\"id\":{\"type\":\"string\"},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"building\":{},\"raster\":{},\"raster-particle\":{},\"hillshade\":{},\"model\":{},\"background\":{},\"sky\":{},\"slot\":{},\"clip\":{}}},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"slot\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"},\"appearances\":{\"type\":\"array\",\"value\":\"appearance\",\"supported-layer-types\":[\"symbol\"]}},\"appearance\":{\"condition\":{\"type\":\"boolean\",\"expression\":{\"parameters\":[\"zoom\",\"pitch\",\"feature\",\"feature-state\",\"measure-light\",\"distance-from-center\"]},\"property-type\":\"data-driven\"},\"name\":{\"type\":\"string\"},\"properties\":{\"type\":\"*\"}},\"layout\":[\"layout_clip\",\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_building\",\"layout_symbol\",\"layout_raster\",\"layout_raster-particle\",\"layout_hillshade\",\"layout_background\",\"layout_sky\",\"layout_model\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_model\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"model-id\":{\"type\":\"string\",\"default\":\"\",\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}}},\"layout_clip\":{\"clip-layer-types\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"model\":1,\"symbol\":1},\"default\":[],\"expression\":{}},\"clip-layer-scope\":{\"type\":\"array\",\"value\":\"string\",\"default\":[],\"expression\":{}}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"fill-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-base\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"fill-construct-bridge-guard-rail\":{\"type\":\"boolean\",\"default\":\"true\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"circle-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"fill-extrusion-edge-radius\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}}},\"layout_building\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"building-facade\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"feature\"]},\"property-type\":\"data-driven\"},\"building-facade-floors\":{\"type\":\"number\",\"minimum\":1,\"maximum\":200,\"default\":3,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"feature\"]}},\"building-facade-unit-width\":{\"type\":\"number\",\"minimum\":1,\"maximum\":20,\"default\":3.1,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"feature\"]}},\"building-facade-window\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":0.1,\"maximum\":1,\"default\":[0.9,0.9],\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"feature\"]}},\"building-roof-shape\":{\"type\":\"enum\",\"values\":{\"flat\":1,\"hipped\":1,\"gabled\":1,\"parapet\":1,\"mansard\":1,\"skillion\":1,\"pyramidal\":1},\"default\":\"flat\",\"expression\":{\"parameters\":[\"feature\"]},\"property-type\":\"data-driven\"},\"building-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{},\"property-type\":\"data-driven\"},\"building-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{},\"property-type\":\"data-driven\"},\"building-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"building-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"building-flip-roof-orientation\":{\"property-type\":\"data-driven\",\"type\":\"boolean\",\"default\":false,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":1,\"round\":1,\"square\":1},\"default\":\"butt\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":1,\"round\":1,\"miter\":1,\"none\":1},\"default\":\"miter\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-z-offset\":{\"type\":\"number\",\"default\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"none\",\"expression\":{}},\"line-cross-slope\":{\"type\":\"number\",\"expression\":{}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}},\"line-width-unit\":{\"type\":\"enum\",\"values\":{\"pixels\":1,\"meters\":1},\"default\":\"pixels\",\"expression\":{\"parameters\":[\"zoom\"]}}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":1,\"line\":1,\"line-center\":1},\"default\":\"point\",\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"viewport-y\":1,\"source\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-z-elevate\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"symbol-elevation-reference\":{\"type\":\"enum\",\"values\":{\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"ground\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":0.1,\"maximum\":10,\"expression\":{}},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":1,\"width\":1,\"height\":1,\"both\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"appearance\":true,\"use-theme\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"appearance\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]}},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":0.1,\"maximum\":10,\"expression\":{}},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"left\":1,\"center\":1,\"right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"default\":0,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":1,\"vertical\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":1,\"uppercase\":1,\"lowercase\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]}},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_raster-particle\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{}}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_hillshade\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster-particle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_clip\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_model\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_building\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":1,\"!=\":1,\">\":1,\">=\":1,\"<\":1,\"<=\":1,\"in\":1,\"!in\":1,\"all\":1,\"any\":1,\"none\":1,\"has\":1,\"!has\":1}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":1,\"LineString\":1,\"Polygon\":1}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":1,\"exponential\":1,\"interval\":1,\"categorical\":1},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":1,\"lab\":1,\"hcl\":1},\"default\":\"rgb\"},\"default\":{\"type\":\"*\"}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"high-color\":{\"type\":\"color\",\"default\":\"#245cdf\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"space-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,\"#010b19\",7,\"#367ab9\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,0.2,7,0.1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"star-intensity\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],5,0.35,6,0],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vertical-range\":{\"type\":\"array\",\"default\":[0,0],\"minimum\":0,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}}},\"snow\":{\"density\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.85],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.3],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"default\":0.4,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,50],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"flake-size\":{\"type\":\"number\",\"default\":0.71,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"rain\":{\"density\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.5],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#03113d\",0.3,\"#a8adbc\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"opacity\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,0.88,1,0.7],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#001736\",0.3,\"#464646\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"use-theme\":true,\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"default\":0.57,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,80],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"droplet-size\":{\"type\":\"array\",\"default\":[2.6,18.2],\"minimum\":0,\"maximum\":50,\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"distortion-strength\":{\"type\":\"number\",\"default\":0.7,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"camera\":{\"camera-projection\":{\"type\":\"enum\",\"values\":{\"perspective\":1,\"orthographic\":1},\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"default\":\"perspective\"}},\"colorTheme\":{\"data\":{\"type\":\"string\",\"expression\":{}}},\"indoor\":{\"floorplanFeaturesetId\":{\"type\":\"string\",\"expression\":{}},\"buildingFeaturesetId\":{\"type\":\"string\",\"expression\":{}}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"use-theme\":true,\"transition\":true},\"intensity\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":1,\"equalEarth\":1,\"equirectangular\":1,\"lambertConformalConic\":1,\"mercator\":1,\"naturalEarth\":1,\"winkelTripel\":1,\"globe\":1},\"default\":\"mercator\"},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":[-180,-90],\"maximum\":[180,90]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"minimum\":[-90,-90],\"maximum\":[90,90]}},\"terrain\":{\"source\":{\"type\":\"string\"},\"exaggeration\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_building\",\"paint_symbol\",\"paint_raster\",\"paint_raster-particle\",\"paint_hillshade\",\"paint_background\",\"paint_sky\",\"paint_model\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-bridge-guard-rail-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-tunnel-structure-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height-alignment\":{\"type\":\"enum\",\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"flat\"},\"fill-extrusion-base-alignment\":{\"type\":\"enum\",\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"terrain\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-wall-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-flood-light-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-vertical-scale\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-rounded-roof\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"fill-extrusion-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-line-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-cast-shadows\":{\"type\":\"boolean\",\"default\":true}},\"paint_building\":{\"building-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"parameters\":[]},\"transition\":true},\"building-ambient-occlusion-ground-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-radius\":{\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"building-ambient-occlusion-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-vertical-scale\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"building-cast-shadows\":{\"type\":\"boolean\",\"default\":true},\"building-color\":{\"type\":\"color\",\"default\":\"rgba(193, 154, 127, 1)\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"building-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"building-facade-emissive-chance\":{\"type\":\"number\",\"default\":0.35,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"measure-light\",\"zoom\"]}},\"building-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"building-flood-light-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"building-flood-light-intensity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"building-flood-light-ground-attenuation\":{\"type\":\"number\",\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-gradient\":{\"type\":\"color\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]}},\"line-trim-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1]},\"line-trim-fade-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-trim-color\":{\"type\":\"color\",\"default\":\"transparent\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"line-border-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-border-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-occlusion-opacity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]}},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]}},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-image-cross-fade\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"overridable\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]}},\"icon-color-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{}},\"icon-color-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{}},\"icon-color-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"icon-color-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"symbol-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color\":{\"type\":\"color\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-value\"]}},\"raster-color-mix\":{\"type\":\"array\",\"default\":[0.2126,0.7152,0.0722,0],\"length\":4,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color-range\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":1,\"nearest\":1},\"default\":\"linear\",\"expression\":{\"parameters\":[\"zoom\"]}},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"raster-array-band\":{\"type\":\"string\"},\"raster-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_raster-particle\":{\"raster-particle-array-band\":{\"type\":\"string\"},\"raster-particle-count\":{\"type\":\"number\",\"default\":512,\"minimum\":1},\"raster-particle-color\":{\"type\":\"color\",\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-particle-speed\"]}},\"raster-particle-max-speed\":{\"type\":\"number\",\"default\":1,\"minimum\":1},\"raster-particle-speed-factor\":{\"type\":\"number\",\"default\":0.2,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-particle-fade-opacity-factor\":{\"type\":\"number\",\"default\":0.98,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-particle-reset-rate-factor\":{\"type\":\"number\",\"default\":0.8,\"minimum\":0,\"maximum\":1},\"raster-particle-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]}},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"hillshade-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_background\":{\"background-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[]}},\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"use-theme\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"background-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\"]}},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"background-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":1,\"atmosphere\":1},\"default\":\"atmosphere\",\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"maximum\":100},\"sky-gradient-center\":{\"type\":\"array\",\"value\":\"number\",\"default\":[0,0],\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-gradient-radius\":{\"type\":\"number\",\"default\":90,\"minimum\":0,\"maximum\":180,\"expression\":{\"parameters\":[\"zoom\"]}},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"use-theme\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]}},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\",\"use-theme\":true},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\",\"use-theme\":true},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}}},\"paint_model\":{\"model-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"property-type\":\"data-driven\"},\"model-rotation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-scale\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[1,1,1],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-translation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\",\"zoom\"]},\"use-theme\":true,\"transition\":true},\"model-color-mix-intensity\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-type\":{\"type\":\"enum\",\"values\":{\"common-3d\":1,\"location-indicator\":1},\"default\":\"common-3d\"},\"model-cast-shadows\":{\"type\":\"boolean\",\"default\":true},\"model-receive-shadows\":{\"type\":\"boolean\",\"default\":true},\"model-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"model-emissive-strength\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-roughness\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]},\"transition\":true},\"model-height-based-emissive-strength-multiplier\":{\"type\":\"array\",\"default\":[1,1,1,1,0],\"length\":5,\"value\":\"number\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{}},\"model-front-cutoff\":{\"type\":\"array\",\"value\":\"number\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"length\":3,\"default\":[0,0,1],\"minimum\":[0,0,0],\"maximum\":[1,1,1]},\"model-elevation-reference\":{\"type\":\"enum\",\"values\":{\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"ground\",\"expression\":{}}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0}},\"promoteId\":{\"*\":{\"type\":\"*\"}}}');\n    function Co(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n    function Do(t) {\n      if (Array.isArray(t)) return t.map(Do);\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        const e = {};\n        for (const r in t) e[r] = Do(t[r]);\n        return e;\n      }\n      return Co(t);\n    }\n    function Ro(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n      switch (t[0]) {\n        case \"has\":\n          return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n        case \"in\":\n          return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n        case \"!in\":\n        case \"!has\":\n        case \"none\":\n          return !1;\n        case \"==\":\n        case \"!=\":\n        case \">\":\n        case \">=\":\n        case \"<\":\n        case \"<=\":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n        case \"any\":\n        case \"all\":\n          for (const e of t.slice(1)) if (!Ro(e) && \"boolean\" != typeof e) return !1;\n          return !0;\n        default:\n          return !0;\n      }\n    }\n    function Lo(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"fill\";\n      if (null == t) return {\n        filter: () => !0,\n        needGeometry: !1,\n        needFeature: !1\n      };\n      Ro(t) || (t = Ho(t));\n      const i = t;\n      let s = !0;\n      try {\n        s = function (t) {\n          if (!No(t)) return t;\n          let e = Do(t);\n          return Uo(e), e = Oo(e), e;\n        }(i);\n      } catch (t) {\n        console.warn(\"Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n\".concat(JSON.stringify(i, null, 2), \"\\n        \"));\n      }\n      let o = null,\n        a = null;\n      if (\"background\" !== n && \"sky\" !== n && \"slot\" !== n) {\n        a = Fo[\"filter_\".concat(n)];\n        const t = Ls(s, a, e, r);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => \"\".concat(t.key, \": \").concat(t.message)).join(\", \"));\n        o = (e, r, n) => t.value.evaluate(e, r, {}, n);\n      }\n      let l = null,\n        u = null;\n      if (s !== i) {\n        const t = Ls(i, a, e, r);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => \"\".concat(t.key, \": \").concat(t.message)).join(\", \"));\n        l = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), u = !fi(t.value.expression);\n      }\n      return {\n        filter: o,\n        dynamicFilter: l || void 0,\n        needGeometry: Go(s),\n        needFeature: !!u\n      };\n    }\n    function Oo(t) {\n      if (!Array.isArray(t)) return t;\n      const e = function (t) {\n        if (jo.has(t[0])) for (let e = 1; e < t.length; e++) if (No(t[e])) return !0;\n        return t;\n      }(t);\n      return !0 === e ? e : e.map(t => Oo(t));\n    }\n    function Uo(t) {\n      let e = !1;\n      const r = [];\n      if (\"case\" === t[0]) {\n        for (let n = 1; n < t.length - 1; n += 2) e = e || No(t[n]), r.push(t[n + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"match\" === t[0]) {\n        e = e || No(t[1]);\n        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"step\" === t[0]) {\n        e = e || No(t[1]);\n        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);\n      }\n      e && (t.length = 0, t.push(\"any\", ...r));\n      for (let e = 1; e < t.length; e++) Uo(t[e]);\n    }\n    function No(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"pitch\" === (e = t[0]) || \"distance-from-center\" === e) return !0;\n      var e;\n      for (let e = 1; e < t.length; e++) if (No(t[e])) return !0;\n      return !1;\n    }\n    const jo = new Set([\"in\", \"==\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"to-boolean\"]);\n    function $o(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function Go(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"within\" === t[0] || \"distance\" === t[0]) return !0;\n      for (let e = 1; e < t.length; e++) if (Go(t[e])) return !0;\n      return !1;\n    }\n    function Ho(t) {\n      if (!t) return !0;\n      const e = t[0];\n      return t.length <= 1 ? \"any\" !== e : \"==\" === e ? qo(t[1], t[2], \"==\") : \"!=\" === e ? Wo(qo(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? qo(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(Ho))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(Ho)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(Ho).map(Wo)) : \"in\" === e ? Xo(t[1], t.slice(2)) : \"!in\" === e ? Wo(Xo(t[1], t.slice(2))) : \"has\" === e ? Zo(t[1]) : \"!has\" !== e || Wo(Zo(t[1]));\n      var r;\n    }\n    function qo(t, e, r) {\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-\".concat(r), e];\n        case \"$id\":\n          return [\"filter-id-\".concat(r), e];\n        default:\n          return [\"filter-\".concat(r), t, e];\n      }\n    }\n    function Xo(t, e) {\n      if (0 === e.length) return !1;\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-in\", [\"literal\", e]];\n        case \"$id\":\n          return [\"filter-id-in\", [\"literal\", e]];\n        default:\n          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort($o)]] : [\"filter-in-small\", t, [\"literal\", e]];\n      }\n    }\n    function Zo(t) {\n      switch (t) {\n        case \"$type\":\n          return !0;\n        case \"$id\":\n          return [\"filter-has-id\"];\n        default:\n          return [\"filter-has\", t];\n      }\n    }\n    function Wo(t) {\n      return [\"!\", t];\n    }\n    const Yo = \"\u001f\";\n    function Ko(t, e) {\n      return e ? \"\".concat(t).concat(Yo).concat(e) : t;\n    }\n    let Jo;\n    const Qo = () => Jo || (Jo = new Vo({\n      \"icon-size\": new To(Fo.layout_symbol[\"icon-size\"]),\n      \"icon-image\": new To(Fo.layout_symbol[\"icon-image\"]),\n      \"icon-rotate\": new To(Fo.layout_symbol[\"icon-rotate\"]),\n      \"icon-offset\": new To(Fo.layout_symbol[\"icon-offset\"])\n    }));\n    class ta {\n      constructor(t, e, r, n, i, s) {\n        const o = Ls(t, Fo.appearance.condition);\n        if (\"success\" === o.result && (this.condition = o.value), this.name = e, r) {\n          this.properties = new zo(Qo()), this.unevaluatedLayout = new Po(Qo(), n, i, s);\n          for (const t in r) this.unevaluatedLayout.setValue(t, r[t]);\n        }\n      }\n      isActive(t) {\n        return !(this.condition || !t.isHidden || \"hidden\" !== this.name) || this.condition.evaluate(t.globals, t.feature, t.featureState, t.canonical);\n      }\n      getCondition() {\n        return this.condition;\n      }\n      getName() {\n        return this.name;\n      }\n      getProperty(t) {\n        return this.properties.get(t);\n      }\n      getUnevaluatedProperties() {\n        return this.unevaluatedLayout;\n      }\n      serialize() {\n        const t = {};\n        return t.condition = this.condition.expression.serialize(), this.name && (t.name = this.name), this.properties && (t.properties = this.properties), t;\n      }\n    }\n    const ea = \"-transition\",\n      ra = new Set([\"fill\", \"line\", \"background\", \"hillshade\", \"raster\"]);\n    class na extends tr {\n      constructor(t, e, r, n, i, s) {\n        if (super(), this.id = t.id, this.fqid = Ko(this.id, r), this.type = t.type, this.scope = r, this.lut = n, this.options = i, this.iconImageUseTheme = s, this.appearances = new Array(), this._featureFilter = {\n          filter: () => !0,\n          needGeometry: !1,\n          needFeature: !1\n        }, this._filterCompiled = !1, this.configDependencies = new Set(), \"custom\" !== t.type) {\n          if (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type && \"background\" !== t.type && \"sky\" !== t.type && \"slot\" !== t.type) {\n            this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter;\n            const e = Ls(this.filter, Fo[\"filter_\".concat(t.type)]);\n            \"error\" !== e.result && (this.configDependencies = new Set([...this.configDependencies, ...e.value.configDependencies]));\n          }\n          if (t.slot && (this.slot = t.slot), t.appearances && t.appearances.forEach(t => {\n            this.appearances.push(new ta(t.condition, t.name, t.properties, this.scope, i, this.iconImageUseTheme));\n          }), e.layout && (this._unevaluatedLayout = new Po(e.layout, this.scope, i, this.iconImageUseTheme), this.configDependencies = new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), e.paint) {\n            this._transitionablePaint = new Mo(e.paint, this.scope, i);\n            for (const e in t.paint) this.setPaintProperty(e, t.paint[e]);\n            for (const e in t.layout) this.setLayoutProperty(e, t.layout[e]);\n            this.configDependencies = new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new zo(e.paint);\n          }\n        }\n      }\n      onAdd(t) {}\n      onRemove(t) {}\n      isDraped(t) {\n        return !this.is3D(!0) && ra.has(this.type);\n      }\n      getLayoutProperty(t) {\n        return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }\n      setLayoutProperty(t, e) {\n        if (\"custom\" === this.type && \"visibility\" === t) return void (this.visibility = e);\n        const r = this._unevaluatedLayout;\n        r._properties.properties[t] && (r.setValue(t, e), this.configDependencies = new Set([...this.configDependencies, ...r.configDependencies]), \"visibility\" === t && this.possiblyEvaluateVisibility());\n      }\n      possiblyEvaluateVisibility() {\n        this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({\n          zoom: 0\n        }));\n      }\n      getPaintProperty(t) {\n        return t.endsWith(ea) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);\n      }\n      setPaintProperty(t, e) {\n        const r = this._transitionablePaint,\n          n = r._properties.properties;\n        if (t.endsWith(ea)) {\n          const i = t.slice(0, -11);\n          return n[i] && r.setTransition(i, e || void 0), !1;\n        }\n        if (!n[t]) return !1;\n        const i = r._values[t],\n          s = i.value.isDataDriven(),\n          o = i.value;\n        r.setValue(t, e), this.configDependencies = new Set([...this.configDependencies, ...r.configDependencies]), this._handleSpecialPaintPropertyUpdate(t);\n        const a = r._values[t].value,\n          l = a.isDataDriven(),\n          u = t.endsWith(\"pattern\") || \"line-dasharray\" === t;\n        return l || s || u || this._handleOverridablePaintPropertyUpdate(t, o, a);\n      }\n      _handleSpecialPaintPropertyUpdate(t) {}\n      getProgramIds() {\n        return null;\n      }\n      getDefaultProgramParams(t, e, r) {\n        return null;\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !1;\n      }\n      isHidden(t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n      }\n      updateTransitions(t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }\n      hasTransition() {\n        return this._transitioningPaint.hasTransition();\n      }\n      recalculate(t, e) {\n        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e, this.iconImageUseTheme)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }\n      serialize() {\n        const t = {\n          id: this.id,\n          type: this.type,\n          slot: this.slot,\n          source: this.source,\n          \"source-layer\": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        };\n        return 0 !== this.appearances.length && (t.appearances = this.appearances.map(t => t.serialize())), Ut(t, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n      }\n      is3D(t) {\n        return !1;\n      }\n      hasElevation() {\n        return !1;\n      }\n      isSky() {\n        return !1;\n      }\n      isTileClipped() {\n        return !1;\n      }\n      hasOffscreenPass() {\n        return !1;\n      }\n      hasShadowPass() {\n        return !1;\n      }\n      canCastShadows() {\n        return !1;\n      }\n      hasLightBeamPass() {\n        return !1;\n      }\n      cutoffRange() {\n        return 0;\n      }\n      tileCoverLift() {\n        return 0;\n      }\n      resize() {}\n      _clear() {}\n      isStateDependent() {\n        for (const t in this.paint._values) {\n          const e = this.paint.get(t);\n          if (e instanceof ko && Ms(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n        return !1;\n      }\n      compileFilter(t) {\n        this._filterCompiled || (this._featureFilter = Lo(this.filter, this.scope, t), this._filterCompiled = !0);\n      }\n      invalidateCompiledFilter() {\n        this._filterCompiled = !1;\n      }\n      dynamicFilter() {\n        return this._featureFilter.dynamicFilter;\n      }\n      dynamicFilterNeedsFeature() {\n        return this._featureFilter.needFeature;\n      }\n      getLayerRenderingStats() {\n        return this._stats;\n      }\n      resetLayerRenderingStats(t) {\n        this._stats && (\"shadow\" === t.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);\n      }\n      getAppearances() {\n        return this.appearances;\n      }\n      queryRadius(t) {}\n      queryIntersectsFeature(t, e, r, n, i, s, o, a, l) {}\n    }\n    const ia = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    };\n    class sa {\n      constructor(t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      }\n    }\n    class oa {\n      constructor() {\n        this.capacity = -1, this.resize(0);\n      }\n      static serialize(t, e) {\n        return t._trim(), e && e.add(t.arrayBuffer), {\n          length: t.length,\n          arrayBuffer: t.arrayBuffer\n        };\n      }\n      static deserialize(t) {\n        const e = Object.create(this.prototype);\n        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n      }\n      _trim() {\n        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n      }\n      clear() {\n        this.length = 0;\n      }\n      resize(t) {\n        this.reserve(t), this.length = t;\n      }\n      reserve(t) {\n        if (t > this.capacity) {\n          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n          const e = this.uint8;\n          this._refreshViews(), e && this.uint8.set(e);\n        }\n      }\n      _refreshViews() {\n        throw new Error(\"StructArray#_refreshViews() must be implemented by each concrete StructArray layout\");\n      }\n      emplace() {\n        throw new Error(\"StructArray#emplace() must be implemented by each concrete StructArray layout\");\n      }\n      emplaceBack() {\n        throw new Error(\"StructArray#emplaceBack() must be implemented by each concrete StructArray layout\");\n      }\n      destroy() {\n        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;\n      }\n    }\n    function aa(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      let r = 0,\n        n = 0;\n      return {\n        members: t.map(t => {\n          const i = ia[t.type].BYTES_PER_ELEMENT,\n            s = r = la(r, Math.max(e, i)),\n            o = t.components || 1;\n          return n = Math.max(n, i), r += i * o, {\n            name: t.name,\n            type: t.type,\n            components: o,\n            offset: s\n          };\n        }),\n        size: la(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n    function la(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n    class ua extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }\n    }\n    ua.prototype.bytesPerElement = 4, Ws(ua, \"StructArrayLayout2i4\");\n    class ca extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n    }\n    ca.prototype.bytesPerElement = 6, Ws(ca, \"StructArrayLayout3i6\");\n    class ha extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;\n      }\n    }\n    ha.prototype.bytesPerElement = 8, Ws(ha, \"StructArrayLayout4i8\");\n    class pa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }\n    }\n    pa.prototype.bytesPerElement = 4, Ws(pa, \"StructArrayLayout1f4\");\n    class da extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 4 * t,\n          s = 2 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.float32[s + 1] = n, t;\n      }\n    }\n    da.prototype.bytesPerElement = 8, Ws(da, \"StructArrayLayout2i1f8\");\n    class fa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 4 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n    }\n    fa.prototype.bytesPerElement = 8, Ws(fa, \"StructArrayLayout3i8\");\n    class ma extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const o = 5 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, t;\n      }\n    }\n    ma.prototype.bytesPerElement = 10, Ws(ma, \"StructArrayLayout5i10\");\n    class ya extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s, o);\n      }\n      emplace(t, e, r, n, i, s, o, a) {\n        const l = 6 * t,\n          u = 12 * t,\n          c = 3 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = o, this.float32[c + 2] = a, t;\n      }\n    }\n    ya.prototype.bytesPerElement = 12, Ws(ya, \"StructArrayLayout2i4ub1f12\");\n    class ga extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }\n    }\n    ga.prototype.bytesPerElement = 12, Ws(ga, \"StructArrayLayout3f12\");\n    class xa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const o = 6 * t,\n          a = 3 * t;\n        return this.uint16[o + 0] = e, this.uint16[o + 1] = r, this.uint16[o + 2] = n, this.uint16[o + 3] = i, this.float32[a + 2] = s, t;\n      }\n    }\n    xa.prototype.bytesPerElement = 12, Ws(xa, \"StructArrayLayout4ui1f12\");\n    class va extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t;\n      }\n    }\n    va.prototype.bytesPerElement = 8, Ws(va, \"StructArrayLayout4ui8\");\n    class ba extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, o) {\n        const a = 6 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = s, this.int16[a + 5] = o, t;\n      }\n    }\n    ba.prototype.bytesPerElement = 12, Ws(ba, \"StructArrayLayout6i12\");\n    class wa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h) {\n        const p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, o, a, l, u, c, h);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u, c, h, p) {\n        const d = 12 * t;\n        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.uint16[d + 4] = s, this.uint16[d + 5] = o, this.uint16[d + 6] = a, this.uint16[d + 7] = l, this.int16[d + 8] = u, this.int16[d + 9] = c, this.int16[d + 10] = h, this.int16[d + 11] = p, t;\n      }\n    }\n    wa.prototype.bytesPerElement = 24, Ws(wa, \"StructArrayLayout4i4ui4i24\");\n    class _a extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, o) {\n        const a = 10 * t,\n          l = 5 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = o, t;\n      }\n    }\n    _a.prototype.bytesPerElement = 20, Ws(_a, \"StructArrayLayout3i3f20\");\n    class Aa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;\n      }\n    }\n    Aa.prototype.bytesPerElement = 16, Ws(Aa, \"StructArrayLayout4f16\");\n    class Ma extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }\n    }\n    Ma.prototype.bytesPerElement = 4, Ws(Ma, \"StructArrayLayout1ul4\");\n    class Ia extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }\n    }\n    Ia.prototype.bytesPerElement = 4, Ws(Ia, \"StructArrayLayout2ui4\");\n    class Sa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h, p) {\n        const d = this.length;\n        return this.resize(d + 1), this.emplace(d, t, e, r, n, i, s, o, a, l, u, c, h, p);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u, c, h, p, d) {\n        const f = 20 * t,\n          m = 10 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.int16[f + 4] = s, this.float32[m + 3] = o, this.float32[m + 4] = a, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[f + 14] = c, this.uint32[m + 8] = h, this.uint16[f + 18] = p, this.uint16[f + 19] = d, t;\n      }\n    }\n    Sa.prototype.bytesPerElement = 40, Ws(Sa, \"StructArrayLayout5i4f1i1ul2ui40\");\n    class Pa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s, o);\n      }\n      emplace(t, e, r, n, i, s, o, a) {\n        const l = 8 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = o, this.int16[l + 7] = a, t;\n      }\n    }\n    Pa.prototype.bytesPerElement = 16, Ws(Pa, \"StructArrayLayout3i2i2i16\");\n    class ka extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const o = 4 * t,\n          a = 8 * t;\n        return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.int16[a + 6] = i, this.int16[a + 7] = s, t;\n      }\n    }\n    ka.prototype.bytesPerElement = 16, Ws(ka, \"StructArrayLayout2f1f2i16\");\n    class za extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, o) {\n        const a = 20 * t,\n          l = 5 * t;\n        return this.uint8[a + 0] = e, this.uint8[a + 1] = r, this.float32[l + 1] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = o, t;\n      }\n    }\n    za.prototype.bytesPerElement = 20, Ws(za, \"StructArrayLayout2ub4f20\");\n    class Ea extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }\n    }\n    Ea.prototype.bytesPerElement = 6, Ws(Ea, \"StructArrayLayout3ui6\");\n    class Ta extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b) {\n        const w = this.length;\n        return this.resize(w + 1), this.emplace(w, t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w) {\n        const _ = 30 * t,\n          A = 15 * t,\n          M = 60 * t;\n        return this.int16[_ + 0] = e, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = o, this.uint16[_ + 9] = a, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = d, this.float32[A + 10] = f, this.float32[A + 11] = m, this.uint8[M + 48] = y, this.uint8[M + 49] = g, this.uint8[M + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[M + 58] = w, t;\n      }\n    }\n    Ta.prototype.bytesPerElement = 60, Ws(Ta, \"StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60\");\n    class Ba extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, k, z, E, T, B) {\n        const V = this.length;\n        return this.resize(V + 1), this.emplace(V, t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, k, z, E, T, B);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, k, z, E, T, B, V) {\n        const F = 20 * t,\n          C = 40 * t,\n          D = 80 * t;\n        return this.float32[F + 0] = e, this.float32[F + 1] = r, this.int16[C + 4] = n, this.int16[C + 5] = i, this.int16[C + 6] = s, this.int16[C + 7] = o, this.int16[C + 8] = a, this.int16[C + 9] = l, this.int16[C + 10] = u, this.int16[C + 11] = c, this.int16[C + 12] = h, this.uint16[C + 13] = p, this.uint16[C + 14] = d, this.uint16[C + 15] = f, this.uint16[C + 16] = m, this.uint16[C + 17] = y, this.uint16[C + 18] = g, this.uint16[C + 19] = x, this.uint16[C + 20] = v, this.uint16[C + 21] = b, this.uint16[C + 22] = w, this.uint16[C + 23] = _, this.uint16[C + 24] = A, this.uint16[C + 25] = M, this.uint16[C + 26] = I, this.uint16[C + 27] = S, this.uint32[F + 14] = P, this.float32[F + 15] = k, this.float32[F + 16] = z, this.float32[F + 17] = E, this.float32[F + 18] = T, this.uint8[D + 76] = B, this.uint16[C + 39] = V, t;\n      }\n    }\n    Ba.prototype.bytesPerElement = 80, Ws(Ba, \"StructArrayLayout2f9i15ui1ul4f1ub1ui80\");\n    class Va extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, o) {\n        const a = 6 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, this.float32[a + 5] = o, t;\n      }\n    }\n    Va.prototype.bytesPerElement = 24, Ws(Va, \"StructArrayLayout6f24\");\n    class Fa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const o = 5 * t;\n        return this.float32[o + 0] = e, this.float32[o + 1] = r, this.float32[o + 2] = n, this.float32[o + 3] = i, this.float32[o + 4] = s, t;\n      }\n    }\n    Fa.prototype.bytesPerElement = 20, Ws(Fa, \"StructArrayLayout5f20\");\n    class Ca extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s, o);\n      }\n      emplace(t, e, r, n, i, s, o, a) {\n        const l = 7 * t;\n        return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = o, this.float32[l + 6] = a, t;\n      }\n    }\n    Ca.prototype.bytesPerElement = 28, Ws(Ca, \"StructArrayLayout7f28\");\n    class Da extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l, u, c) {\n        const h = this.length;\n        return this.resize(h + 1), this.emplace(h, t, e, r, n, i, s, o, a, l, u, c);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u, c, h) {\n        const p = 11 * t;\n        return this.float32[p + 0] = e, this.float32[p + 1] = r, this.float32[p + 2] = n, this.float32[p + 3] = i, this.float32[p + 4] = s, this.float32[p + 5] = o, this.float32[p + 6] = a, this.float32[p + 7] = l, this.float32[p + 8] = u, this.float32[p + 9] = c, this.float32[p + 10] = h, t;\n      }\n    }\n    Da.prototype.bytesPerElement = 44, Ws(Da, \"StructArrayLayout11f44\");\n    class Ra extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l) {\n        const u = this.length;\n        return this.resize(u + 1), this.emplace(u, t, e, r, n, i, s, o, a, l);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u) {\n        const c = 9 * t;\n        return this.float32[c + 0] = e, this.float32[c + 1] = r, this.float32[c + 2] = n, this.float32[c + 3] = i, this.float32[c + 4] = s, this.float32[c + 5] = o, this.float32[c + 6] = a, this.float32[c + 7] = l, this.float32[c + 8] = u, t;\n      }\n    }\n    Ra.prototype.bytesPerElement = 36, Ws(Ra, \"StructArrayLayout9f36\");\n    class La extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }\n    }\n    La.prototype.bytesPerElement = 8, Ws(La, \"StructArrayLayout2f8\");\n    class Oa extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 6 * t;\n        return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;\n      }\n    }\n    Oa.prototype.bytesPerElement = 12, Ws(Oa, \"StructArrayLayout1ul3ui12\");\n    class Ua extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }\n    }\n    Ua.prototype.bytesPerElement = 2, Ws(Ua, \"StructArrayLayout1ui2\");\n    class Na extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m) {\n        const y = this.length;\n        return this.resize(y + 1), this.emplace(y, t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m);\n      }\n      emplace(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y) {\n        const g = 16 * t;\n        return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = s, this.float32[g + 5] = o, this.float32[g + 6] = a, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = d, this.float32[g + 13] = f, this.float32[g + 14] = m, this.float32[g + 15] = y, t;\n      }\n    }\n    Na.prototype.bytesPerElement = 64, Ws(Na, \"StructArrayLayout16f64\");\n    class ja extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, o) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s, o);\n      }\n      emplace(t, e, r, n, i, s, o, a) {\n        const l = 10 * t,\n          u = 5 * t;\n        return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = s, this.float32[u + 3] = o, this.float32[u + 4] = a, t;\n      }\n    }\n    ja.prototype.bytesPerElement = 20, Ws(ja, \"StructArrayLayout4ui3f20\");\n    class $a extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.int16[1 * t + 0] = e, t;\n      }\n    }\n    $a.prototype.bytesPerElement = 2, Ws($a, \"StructArrayLayout1i2\");\n    class Ga extends oa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint8[1 * t + 0] = e, t;\n      }\n    }\n    Ga.prototype.bytesPerElement = 1, Ws(Ga, \"StructArrayLayout1ub1\");\n    class Ha extends sa {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n      get tileAnchorY() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get x1() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get y1() {\n        return this._structArray.float32[this._pos4 + 4];\n      }\n      get x2() {\n        return this._structArray.float32[this._pos4 + 5];\n      }\n      get y2() {\n        return this._structArray.float32[this._pos4 + 6];\n      }\n      get padding() {\n        return this._structArray.int16[this._pos2 + 14];\n      }\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 8];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n    }\n    Ha.prototype.size = 40;\n    class qa extends Sa {\n      get(t) {\n        return new Ha(this, t);\n      }\n    }\n    Ws(qa, \"CollisionBoxArray\");\n    class Xa extends sa {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get glyphStartIndex() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n      get numGlyphs() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n      get vertexStartIndex() {\n        return this._structArray.uint32[this._pos4 + 5];\n      }\n      get lineStartIndex() {\n        return this._structArray.uint32[this._pos4 + 6];\n      }\n      get lineLength() {\n        return this._structArray.uint32[this._pos4 + 7];\n      }\n      get segment() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get lowerSize() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get upperSize() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get lineOffsetX() {\n        return this._structArray.float32[this._pos4 + 10];\n      }\n      get lineOffsetY() {\n        return this._structArray.float32[this._pos4 + 11];\n      }\n      get writingMode() {\n        return this._structArray.uint8[this._pos1 + 48];\n      }\n      get placedOrientation() {\n        return this._structArray.uint8[this._pos1 + 49];\n      }\n      set placedOrientation(t) {\n        this._structArray.uint8[this._pos1 + 49] = t;\n      }\n      get hidden() {\n        return this._structArray.uint8[this._pos1 + 50];\n      }\n      set hidden(t) {\n        this._structArray.uint8[this._pos1 + 50] = t;\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 13];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 13] = t;\n      }\n      get associatedIconIndex() {\n        return this._structArray.int16[this._pos2 + 28];\n      }\n      get flipState() {\n        return this._structArray.uint8[this._pos1 + 58];\n      }\n      set flipState(t) {\n        this._structArray.uint8[this._pos1 + 58] = t;\n      }\n    }\n    Xa.prototype.size = 60;\n    class Za extends Ta {\n      get(t) {\n        return new Xa(this, t);\n      }\n    }\n    Ws(Za, \"PlacedSymbolArray\");\n    class Wa extends sa {\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 0];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 1];\n      }\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 6];\n      }\n      get rightJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 7];\n      }\n      get centerJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 8];\n      }\n      get leftJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 9];\n      }\n      get verticalPlacedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 10];\n      }\n      get placedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 11];\n      }\n      get verticalPlacedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 12];\n      }\n      get key() {\n        return this._structArray.uint16[this._pos2 + 13];\n      }\n      get textBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 14];\n      }\n      get textBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 15];\n      }\n      get verticalTextBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get verticalTextBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get iconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get iconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n      get verticalIconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 20];\n      }\n      get verticalIconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 21];\n      }\n      get featureIndex() {\n        return this._structArray.uint16[this._pos2 + 22];\n      }\n      get numHorizontalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 23];\n      }\n      get numVerticalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 24];\n      }\n      get numIconVertices() {\n        return this._structArray.uint16[this._pos2 + 25];\n      }\n      get numVerticalIconVertices() {\n        return this._structArray.uint16[this._pos2 + 26];\n      }\n      get useRuntimeCollisionCircles() {\n        return this._structArray.uint16[this._pos2 + 27];\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 14];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 14] = t;\n      }\n      get textOffset0() {\n        return this._structArray.float32[this._pos4 + 15];\n      }\n      get textOffset1() {\n        return this._structArray.float32[this._pos4 + 16];\n      }\n      get collisionCircleDiameter() {\n        return this._structArray.float32[this._pos4 + 17];\n      }\n      get zOffset() {\n        return this._structArray.float32[this._pos4 + 18];\n      }\n      set zOffset(t) {\n        this._structArray.float32[this._pos4 + 18] = t;\n      }\n      get hasIconTextFit() {\n        return this._structArray.uint8[this._pos1 + 76];\n      }\n      get elevationFeatureIndex() {\n        return this._structArray.uint16[this._pos2 + 39];\n      }\n    }\n    Wa.prototype.size = 80;\n    class Ya extends Ba {\n      get(t) {\n        return new Wa(this, t);\n      }\n    }\n    Ws(Ya, \"SymbolInstanceArray\");\n    class Ka extends pa {\n      getoffsetX(t) {\n        return this.float32[1 * t + 0];\n      }\n    }\n    Ws(Ka, \"GlyphOffsetArray\");\n    class Ja extends ua {\n      getx(t) {\n        return this.int16[2 * t + 0];\n      }\n      gety(t) {\n        return this.int16[2 * t + 1];\n      }\n    }\n    Ws(Ja, \"SymbolLineVertexArray\");\n    class Qa extends sa {\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 0];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n      get layoutVertexArrayOffset() {\n        return this._structArray.uint16[this._pos2 + 4];\n      }\n    }\n    Qa.prototype.size = 12;\n    class tl extends Oa {\n      get(t) {\n        return new Qa(this, t);\n      }\n    }\n    Ws(tl, \"FeatureIndexArray\");\n    class el extends Ia {\n      geta_centroid_pos0(t) {\n        return this.uint16[2 * t + 0];\n      }\n      geta_centroid_pos1(t) {\n        return this.uint16[2 * t + 1];\n      }\n    }\n    Ws(el, \"FillExtrusionCentroidArray\");\n    class rl extends sa {\n      get a_join_normal_inside0() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get a_join_normal_inside1() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get a_join_normal_inside2() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n    }\n    rl.prototype.size = 6;\n    class nl extends ca {\n      get(t) {\n        return new rl(this, t);\n      }\n    }\n    Ws(nl, \"FillExtrusionWallArray\");\n    const il = aa([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      sl = aa([{\n        name: \"a_circle_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      ol = aa([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    class al {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.segments = t;\n      }\n      _prepareSegment(t, e, r, n) {\n        let i = this.segments[this.segments.length - 1];\n        return t > al.MAX_VERTEX_ARRAY_LENGTH && Gt(\"Max vertices per segment is \".concat(al.MAX_VERTEX_ARRAY_LENGTH, \": bucket requested \").concat(t)), (!i || i.vertexLength + t > al.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n          vertexOffset: e,\n          primitiveOffset: r,\n          vertexLength: 0,\n          primitiveLength: 0\n        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n      }\n      prepareSegment(t, e, r, n) {\n        return this._prepareSegment(t, e.length, r.length, n);\n      }\n      get() {\n        return this.segments;\n      }\n      destroy() {\n        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n      }\n      static simpleSegment(t, e, r, n) {\n        return new al([{\n          vertexOffset: t,\n          primitiveOffset: e,\n          vertexLength: r,\n          primitiveLength: n,\n          vaos: {},\n          sortKey: 0\n        }]);\n      }\n    }\n    function ll(t, e) {\n      return 256 * (t = Tt(Math.floor(t), 0, 255)) + Tt(Math.floor(e), 0, 255);\n    }\n    al.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ws(al, \"SegmentVector\");\n    const ul = aa([{\n        name: \"a_pattern\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixel_ratio\",\n        components: 1,\n        type: \"Float32\"\n      }]),\n      cl = aa([{\n        name: \"a_pattern_b\",\n        components: 4,\n        type: \"Uint16\"\n      }]),\n      hl = aa([{\n        name: \"a_dash\",\n        components: 4,\n        type: \"Uint16\"\n      }]);\n    class pl {\n      constructor() {\n        this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;\n      }\n      add(t, e, r, n) {\n        this.ids.push(dl(t)), this.positions.push(e, r, n);\n      }\n      eachPosition(t, e) {\n        const r = dl(t);\n        let n = 0,\n          i = this.ids.length - 1;\n        for (; n < i;) {\n          const t = n + i >> 1;\n          this.ids[t] >= r ? i = t : n = t + 1;\n        }\n        for (; this.ids[n] === r;) e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;\n      }\n      static serialize(t, e) {\n        const r = new Float64Array(t.ids),\n          n = new Uint32Array(t.positions);\n        return fl(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {\n          ids: r,\n          positions: n\n        };\n      }\n      static deserialize(t) {\n        const e = new pl();\n        let r;\n        e.ids = t.ids, e.positions = t.positions;\n        for (const t of e.ids) t !== r && e.uniqueIds.push(t), r = t;\n        return e.indexed = !0, e;\n      }\n    }\n    function dl(t) {\n      const e = +t;\n      return Number.isSafeInteger(e) ? e : We(String(t));\n    }\n    function fl(t, e, r, n) {\n      for (; r < n;) {\n        const i = t[r + n >> 1];\n        let s = r - 1,\n          o = n + 1;\n        for (;;) {\n          do {\n            s++;\n          } while (t[s] < i);\n          do {\n            o--;\n          } while (t[o] > i);\n          if (s >= o) break;\n          ml(t, s, o), ml(e, 3 * s, 3 * o), ml(e, 3 * s + 1, 3 * o + 1), ml(e, 3 * s + 2, 3 * o + 2);\n        }\n        o - r < n - o ? (fl(t, e, r, o), r = o + 1) : (fl(t, e, o + 1, n), n = o);\n      }\n    }\n    function ml(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    Ws(pl, \"FeaturePositionMap\");\n    class yl {\n      constructor(t) {\n        this.gl = t.gl, this.initialized = !1;\n      }\n      fetchUniformLocation(t, e) {\n        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;\n      }\n      set(t, e, r) {\n        throw new Error(\"Uniform#set() must be implemented by each concrete Uniform\");\n      }\n    }\n    class gl extends yl {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));\n      }\n    }\n    class xl extends yl {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));\n      }\n    }\n    class vl extends yl {\n      constructor(t) {\n        super(t), this.current = [0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));\n      }\n    }\n    class bl extends yl {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));\n      }\n    }\n    class wl extends yl {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));\n      }\n    }\n    class _l extends yl {\n      constructor(t) {\n        super(t), this.current = sr.transparent.toPremultipliedRenderColor(null);\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));\n      }\n    }\n    const Al = new Float32Array(16);\n    class Ml extends yl {\n      constructor(t) {\n        super(t), this.current = Al;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) {\n          if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);\n          for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {\n            this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);\n            break;\n          }\n        }\n      }\n    }\n    const Il = new Float32Array(9),\n      Sl = new Float32Array(4);\n    class Pl extends yl {\n      constructor(t) {\n        super(t), this.current = Sl;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 4; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);\n          break;\n        }\n      }\n    }\n    function kl(t) {\n      return [ll(255 * t.r, 255 * t.g), ll(255 * t.b, 255 * t.a)];\n    }\n    class zl {\n      constructor(t, e, r, n) {\n        this.value = t, this.uniformNames = e.map(t => \"u_\".concat(t)), this.type = r, this.context = n;\n      }\n      setUniform(t, e, r, n, i) {\n        const s = n.constantOr(this.value);\n        e.set(t, i, s instanceof sr ? s.toPremultipliedRenderColor(this.lutExpression && \"constant\" === this.lutExpression.kind && \"none\" === this.lutExpression.value ? null : this.context.lut) : s);\n      }\n      getBinding(t, e) {\n        return \"color\" === this.type ? new _l(t) : new xl(t);\n      }\n    }\n    class El {\n      constructor(t, e) {\n        this.uniformNames = e.map(t => \"u_\".concat(t)), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;\n      }\n      setConstantPatternPositions(t, e) {\n        this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br), this.patternTransition = e ? e.tl.concat(e.br) : this.pattern;\n      }\n      setUniform(t, e, r, n, i) {\n        let s = null;\n        \"u_pattern\" !== i && \"u_dash\" !== i || (s = this.pattern), \"u_pattern_b\" === i && (s = this.patternTransition), \"u_pixel_ratio\" === i && (s = this.pixelRatio), s && e.set(t, i, s);\n      }\n      getBinding(t, e) {\n        return \"u_pattern\" === e || \"u_pattern_b\" === e || \"u_dash\" === e ? new wl(t) : new xl(t);\n      }\n    }\n    class Tl {\n      constructor(t, e, r, n) {\n        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: \"a_\".concat(t),\n          type: \"Float32\",\n          components: \"color\" === r ? 2 : 1,\n          offset: 0\n        })), this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r, n, i, s, o, a) {\n        const l = this.paintVertexArray.length,\n          u = \"composite\" === this.expression.kind || \"source\" === this.expression.kind ? this.expression.evaluate(new wo(0, {\n            brightness: s,\n            worldview: a\n          }), e, {}, i, n, o) : \"constant\" === this.expression.kind && this.expression.value,\n          c = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new wo(0, {\n            brightness: s,\n            worldview: a\n          }), e, {}, i, n, o) : this.lutExpression.value);\n        this.paintVertexArray.resize(t), this._setPaintValue(l, t, u, c ? null : this.context.lut);\n      }\n      updatePaintArray(t, e, r, n, i, s, o, a) {\n        const l = \"composite\" === this.expression.kind || \"source\" === this.expression.kind ? this.expression.evaluate({\n            zoom: 0,\n            brightness: o,\n            worldview: a\n          }, r, n, void 0, i) : \"constant\" === this.expression.kind && this.expression.value,\n          u = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new wo(0, {\n            brightness: o,\n            worldview: a\n          }), r, n, void 0, i) : this.lutExpression.value);\n        this._setPaintValue(t, e, l, u ? null : this.context.lut);\n      }\n      _setPaintValue(t, e, r, n) {\n        if (\"color\" === this.type) {\n          const i = kl(r.toPremultipliedRenderColor(n));\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1]);\n        } else {\n          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && \"constant\" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || \"constant\" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class Bl {\n      constructor(t, e, r, n, i, s) {\n        this.expression = t, this.uniformNames = e.map(t => \"u_\".concat(t, \"_t\")), this.type = r, this.useIntegerZoom = n, this.context = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: \"a_\".concat(t),\n          type: \"Float32\",\n          components: \"color\" === r ? 4 : 2,\n          offset: 0\n        })), this.paintVertexArray = new s();\n      }\n      populatePaintArray(t, e, r, n, i, s, o, a) {\n        const l = this.expression.evaluate(new wo(this.context.zoom, {\n            brightness: s,\n            worldview: a\n          }), e, {}, i, n, o),\n          u = this.expression.evaluate(new wo(this.context.zoom + 1, {\n            brightness: s,\n            worldview: a\n          }), e, {}, i, n, o),\n          c = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new wo(0, {\n            brightness: s,\n            worldview: a\n          }), e, {}, i, n, o) : this.lutExpression.value),\n          h = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValue(h, t, l, u, c ? null : this.context.lut);\n      }\n      updatePaintArray(t, e, r, n, i, s, o, a) {\n        const l = this.expression.evaluate({\n            zoom: this.context.zoom,\n            brightness: o,\n            worldview: a\n          }, r, n, void 0, i),\n          u = this.expression.evaluate({\n            zoom: this.context.zoom + 1,\n            brightness: o,\n            worldview: a\n          }, r, n, void 0, i),\n          c = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new wo(0, {\n            brightness: o,\n            worldview: a\n          }), r, n, void 0, i) : this.lutExpression.value);\n        this._setPaintValue(t, e, l, u, c ? null : this.context.lut);\n      }\n      _setPaintValue(t, e, r, n, i) {\n        if (\"color\" === this.type) {\n          const n = kl(r.toPremultipliedRenderColor(i)),\n            s = kl(r.toPremultipliedRenderColor(i));\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1], s[0], s[1]);\n        } else {\n          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n      setUniform(t, e, r, n, i) {\n        const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,\n          o = Tt(this.expression.interpolationFactor(s, this.context.zoom, this.context.zoom + 1), 0, 1);\n        e.set(t, i, o);\n      }\n      getBinding(t, e) {\n        return new xl(t);\n      }\n    }\n    class Vl {\n      constructor(t, e, r, n, i) {\n        this.expression = t, this.layerId = i, this.paintVertexAttributes = (\"array\" === r ? hl : ul).members;\n        for (let t = 0; t < e.length; ++t);\n        this.paintVertexArray = new n(), this.paintTransitionVertexArray = new va();\n      }\n      populatePaintArray(t, e, r, n) {\n        const i = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValues(i, t, e.patterns && e.patterns[this.layerId], r);\n      }\n      updatePaintArray(t, e, r, n, i, s, o) {\n        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);\n      }\n      _setPaintValues(t, e, r, n) {\n        if (!n || !r) return;\n        const i = n[r[0]],\n          s = n[r[1]];\n        if (i) {\n          if (i) {\n            const {\n              tl: r,\n              br: n,\n              pixelRatio: s\n            } = i;\n            for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r[0], r[1], n[0], n[1], s);\n          }\n          if (s) {\n            this.paintTransitionVertexArray.resize(this.paintVertexArray.length);\n            const {\n              tl: r,\n              br: n\n            } = s;\n            for (let i = t; i < e; i++) this.paintTransitionVertexArray.emplace(i, r[0], r[1], n[0], n[1]);\n          }\n        }\n      }\n      upload(t) {\n        const e = this.expression.isStateDependent || !this.expression.isLightConstant;\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t.createVertexBuffer(this.paintTransitionVertexArray, cl.members, e));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();\n      }\n    }\n    class Fl {\n      constructor(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => !0;\n        this.binders = {}, this._buffers = [], this.context = e;\n        const n = [];\n        for (const i in t.paint._values) {\n          const s = t.paint.get(i);\n          if (i.endsWith(\"-use-theme\")) continue;\n          if (!r(i)) continue;\n          if (!(s instanceof ko && Ms(s.property.specification))) continue;\n          const o = Rl(i, t.type),\n            a = s.value,\n            l = s.property.specification.type,\n            u = !!s.property.useIntegerZoom,\n            c = \"line-dasharray\" === i || i.endsWith(\"pattern\"),\n            h = t.paint.get(\"\".concat(i, \"-use-theme\")),\n            p = \"line-dasharray\" === i && \"constant\" !== t.layout.get(\"line-cap\").value.kind || h && \"constant\" !== h.value.kind;\n          if (\"constant\" !== a.kind || p) {\n            if (\"source\" === a.kind || p || c) {\n              const e = Ul(i, l, \"source\");\n              this.binders[i] = c ? new Vl(a, o, l, e, t.id) : new Tl(a, o, l, e), n.push(\"/a_\".concat(i));\n            } else {\n              const t = Ul(i, l, \"composite\");\n              this.binders[i] = new Bl(a, o, l, u, e, t), n.push(\"/z_\".concat(i));\n            }\n          } else this.binders[i] = c ? new El(a.value, o) : new zl(a.value, o, l, e), n.push(\"/u_\".concat(i));\n          h && (this.binders[i].lutExpression = h.value);\n        }\n        this.cacheKey = n.sort().join(\"\");\n      }\n      getMaxValue(t) {\n        const e = this.binders[t];\n        return e instanceof Tl || e instanceof Bl ? e.maxValue : 0;\n      }\n      populatePaintArrays(t, e, r, n, i, s, o, a) {\n        for (const l in this.binders) {\n          const u = this.binders[l];\n          u.context = this.context, (u instanceof Tl || u instanceof Bl || u instanceof Vl) && u.populatePaintArray(t, e, r, n, i, s, o, a);\n        }\n      }\n      setConstantPatternPositions(t, e) {\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          n instanceof El && n.setConstantPatternPositions(t, e);\n        }\n      }\n      getPatternTransitionVertexBuffer(t) {\n        const e = this.binders[t];\n        return e instanceof Vl ? e.paintTransitionVertexBuffer : null;\n      }\n      updatePaintArrays(t, e, r, n, i, s, o, a, l, u) {\n        let c = !1;\n        const h = Object.keys(t),\n          p = 0 !== h.length && !a,\n          d = p ? h : e.uniqueIds;\n        this.context.lut = i.lut;\n        for (const a in this.binders) {\n          const h = this.binders[a];\n          if (h.context = this.context, (h instanceof Tl || h instanceof Bl || h instanceof Vl) && h.expression && h.expression.kind && \"constant\" !== h.expression.kind && (!0 === h.expression.isStateDependent || !1 === h.expression.isLightConstant)) {\n            const f = i.paint.get(a);\n            h.expression = f.value;\n            for (const r of d) {\n              const i = t[r.toString()];\n              e.eachPosition(r, (t, e, r) => {\n                const a = n.feature(t);\n                h.updatePaintArray(e, r, a, i, s, o, l, u);\n              });\n            }\n            if (!p) for (const e of r.uniqueIds) {\n              const i = t[e.toString()];\n              r.eachPosition(e, (t, e, r) => {\n                const a = n.feature(t);\n                h.updatePaintArray(e, r, a, i, s, o, l, u);\n              });\n            }\n            c = !0;\n          }\n        }\n        return c;\n      }\n      defines() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof zl || r instanceof El) && t.push(...r.uniformNames.map(t => \"#define HAS_UNIFORM_\".concat(t)));\n        }\n        return t;\n      }\n      getPaintVertexBuffers() {\n        return this._buffers;\n      }\n      getUniforms(t) {\n        const e = [];\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          if (n instanceof zl || n instanceof El || n instanceof Bl) for (const i of n.uniformNames) e.push({\n            name: i,\n            property: r,\n            binding: n.getBinding(t, i)\n          });\n        }\n        return e;\n      }\n      setUniforms(t, e, r, n, i) {\n        for (const {\n          name: e,\n          property: s,\n          binding: o\n        } of r) this.binders[s].setUniform(t, o, i, n.get(s), e);\n      }\n      updatePaintBuffers() {\n        this._buffers = [];\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Tl || e instanceof Bl || e instanceof Vl) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer), e instanceof Vl && e.paintTransitionVertexBuffer && this._buffers.push(e.paintTransitionVertexBuffer);\n        }\n      }\n      upload(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Tl || r instanceof Bl || r instanceof Vl) && r.upload(t);\n        }\n        this.updatePaintBuffers();\n      }\n      destroy() {\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Tl || e instanceof Bl || e instanceof Vl) && e.destroy();\n        }\n      }\n    }\n    class Cl {\n      constructor(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => !0;\n        this.programConfigurations = {};\n        for (const n of t) this.programConfigurations[n.id] = new Fl(n, e, r);\n        this.needsUpload = !1, this._featureMap = new pl(), this._featureMapWithoutIds = new pl(), this._bufferOffset = 0, this._idlessCounter = 0;\n      }\n      populatePaintArrays(t, e, r, n, i, s, o, a, l) {\n        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, o, a, l);\n        void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t), this._idlessCounter += 1), this._bufferOffset = t, this.needsUpload = !0;\n      }\n      updatePaintArrays(t, e, r, n, i, s, o, a) {\n        for (const l of r) this.needsUpload = this.programConfigurations[l.id].updatePaintArrays(t, this._featureMap, this._featureMapWithoutIds, e, l, n, i, s, o || 0, a) || this.needsUpload;\n      }\n      get(t) {\n        return this.programConfigurations[t];\n      }\n      upload(t) {\n        if (this.needsUpload) {\n          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n          this.needsUpload = !1;\n        }\n      }\n      destroy() {\n        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n      }\n    }\n    const Dl = {\n      \"text-opacity\": [\"opacity\"],\n      \"icon-opacity\": [\"opacity\"],\n      \"text-occlusion-opacity\": [\"occlusion_opacity\"],\n      \"icon-occlusion-opacity\": [\"occlusion_opacity\"],\n      \"text-color\": [\"fill_color\"],\n      \"icon-color\": [\"fill_color\"],\n      \"text-emissive-strength\": [\"emissive_strength\"],\n      \"icon-emissive-strength\": [\"emissive_strength\"],\n      \"text-halo-color\": [\"halo_color\"],\n      \"icon-halo-color\": [\"halo_color\"],\n      \"text-halo-blur\": [\"halo_blur\"],\n      \"icon-halo-blur\": [\"halo_blur\"],\n      \"text-halo-width\": [\"halo_width\"],\n      \"icon-halo-width\": [\"halo_width\"],\n      \"symbol-z-offset\": [\"z_offset\"],\n      \"line-gap-width\": [\"gapwidth\"],\n      \"line-pattern\": [\"pattern\", \"pixel_ratio\", \"pattern_b\"],\n      \"fill-pattern\": [\"pattern\", \"pixel_ratio\", \"pattern_b\"],\n      \"fill-extrusion-pattern\": [\"pattern\", \"pixel_ratio\", \"pattern_b\"],\n      \"line-dasharray\": [\"dash\"],\n      \"fill-bridge-guard-rail-color\": [\"structure_color\"],\n      \"fill-tunnel-structure-color\": [\"structure_color\"]\n    };\n    function Rl(t, e) {\n      return Dl[t] || [t.replace(\"\".concat(e, \"-\"), \"\").replace(/-/g, \"_\")];\n    }\n    const Ll = {\n        \"line-pattern\": {\n          source: xa,\n          composite: xa\n        },\n        \"fill-pattern\": {\n          source: xa,\n          composite: xa\n        },\n        \"fill-extrusion-pattern\": {\n          source: xa,\n          composite: xa\n        },\n        \"line-dasharray\": {\n          source: va,\n          composite: va\n        }\n      },\n      Ol = {\n        color: {\n          source: La,\n          composite: Aa\n        },\n        number: {\n          source: pa,\n          composite: La\n        }\n      };\n    function Ul(t, e, r) {\n      const n = Ll[t];\n      return n && n[r] || Ol[e][r];\n    }\n    Ws(zl, \"ConstantBinder\"), Ws(El, \"PatternConstantBinder\"), Ws(Tl, \"SourceExpressionBinder\"), Ws(Vl, \"PatternCompositeBinder\"), Ws(Bl, \"CompositeExpressionBinder\"), Ws(Fl, \"ProgramConfiguration\", {\n      omit: [\"_buffers\"]\n    }), Ws(Cl, \"ProgramConfigurationSet\");\n    const Nl = Rn / Math.PI / 2,\n      jl = 5,\n      $l = 6,\n      Gl = 16383,\n      Hl = 64,\n      ql = [Hl, 32, 16],\n      Xl = -Nl,\n      Zl = Nl;\n    function Wl(t, e, r) {\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Nl;\n      return r = It(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];\n    }\n    function Yl(t, e, r) {\n      return Wl(Math.cos(It(t)), Math.sin(It(t)), e, r);\n    }\n    const Kl = 6371008.8,\n      Jl = 2 * Math.PI * Kl;\n    class Ql {\n      constructor(t, e) {\n        if (isNaN(t) || isNaN(e)) throw new Error(\"Invalid LngLat object: (\".concat(t, \", \").concat(e, \")\"));\n        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n      }\n      wrap() {\n        return new Ql(Vt(this.lng, -180, 180), this.lat);\n      }\n      toArray() {\n        return [this.lng, this.lat];\n      }\n      toString() {\n        return \"LngLat(\".concat(this.lng, \", \").concat(this.lat, \")\");\n      }\n      distanceTo(t) {\n        const e = Math.PI / 180,\n          r = this.lat * e,\n          n = t.lat * e,\n          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n        return Kl * Math.acos(Math.min(i, 1));\n      }\n      toBounds() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        const e = 360 * t / 40075017,\n          r = e / Math.cos(Math.PI / 180 * this.lat);\n        return new tu({\n          lng: this.lng - r,\n          lat: this.lat - e\n        }, {\n          lng: this.lng + r,\n          lat: this.lat + e\n        });\n      }\n      toEcef(t) {\n        return Yl(this.lat, this.lng, Nl + t * Nl / Kl);\n      }\n      static convert(t) {\n        if (t instanceof Ql) return t;\n        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ql(Number(t[0]), Number(t[1]));\n        if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new Ql(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n      }\n    }\n    class tu {\n      constructor(t, e) {\n        t && (e ? this.setSouthWest(t).setNorthEast(e) : Array.isArray(t) && 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n      }\n      setNorthEast(t) {\n        return this._ne = t instanceof Ql ? new Ql(t.lng, t.lat) : Ql.convert(t), this;\n      }\n      setSouthWest(t) {\n        return this._sw = t instanceof Ql ? new Ql(t.lng, t.lat) : Ql.convert(t), this;\n      }\n      extend(t) {\n        const e = this._sw,\n          r = this._ne;\n        let n, i;\n        if (t instanceof Ql) n = t, i = t;else {\n          if (!(t instanceof tu)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(tu.convert(t)) : this.extend(Ql.convert(t)) : \"object\" == typeof t && null !== t && t.hasOwnProperty(\"lat\") && (t.hasOwnProperty(\"lon\") || t.hasOwnProperty(\"lng\")) ? this.extend(Ql.convert(t)) : this;\n          if (n = t._sw, i = t._ne, !n || !i) return this;\n        }\n        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ql(n.lng, n.lat), this._ne = new Ql(i.lng, i.lat)), this;\n      }\n      getCenter() {\n        return new Ql((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n      }\n      getSouthWest() {\n        return this._sw;\n      }\n      getNorthEast() {\n        return this._ne;\n      }\n      getNorthWest() {\n        return new Ql(this.getWest(), this.getNorth());\n      }\n      getSouthEast() {\n        return new Ql(this.getEast(), this.getSouth());\n      }\n      getWest() {\n        return this._sw.lng;\n      }\n      getSouth() {\n        return this._sw.lat;\n      }\n      getEast() {\n        return this._ne.lng;\n      }\n      getNorth() {\n        return this._ne.lat;\n      }\n      toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n      }\n      toString() {\n        return \"LngLatBounds(\".concat(this._sw.toString(), \", \").concat(this._ne.toString(), \")\");\n      }\n      isEmpty() {\n        return !(this._sw && this._ne);\n      }\n      contains(t) {\n        const {\n          lng: e,\n          lat: r\n        } = Ql.convert(t);\n        let n = this._sw.lng <= e && e <= this._ne.lng;\n        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n      }\n      static convert(t) {\n        if (t) return t instanceof tu ? t : new tu(t);\n      }\n    }\n    const eu = 0,\n      ru = 25.5;\n    function nu(t) {\n      return Jl * Math.cos(t * Math.PI / 180);\n    }\n    function iu(t) {\n      return (180 + t) / 360;\n    }\n    function su(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n    function ou(t, e) {\n      return t / nu(e);\n    }\n    function au(t) {\n      return 360 * t - 180;\n    }\n    function lu(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function uu(t, e) {\n      return t * nu(lu(e));\n    }\n    const cu = 85.051129;\n    function hu(t) {\n      return Math.cos(It(Tt(t, -cu, cu)));\n    }\n    function pu(t, e) {\n      const r = Tt(e, eu, ru),\n        n = Math.pow(2, r);\n      return hu(t) * Jl / (512 * n);\n    }\n    function du(t) {\n      return 1 / Math.cos(t * Math.PI / 180);\n    }\n    function fu(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const r = Math.exp(Math.PI * (1 - (t.y + e / Rn) / (1 << t.z) * 2));\n      return 80150034 * r / (r * r + 1) / Rn / (1 << t.z);\n    }\n    class mu {\n      constructor(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        this.x = +t, this.y = +e, this.z = +r;\n      }\n      static fromLngLat(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        const r = Ql.convert(t);\n        return new mu(iu(r.lng), su(r.lat), ou(e, r.lat));\n      }\n      toLngLat() {\n        return new Ql(au(this.x), lu(this.y));\n      }\n      toAltitude() {\n        return uu(this.z, this.y);\n      }\n      meterInMercatorCoordinateUnits() {\n        return 1 / Jl * du(lu(this.y));\n      }\n    }\n    function yu(t, e, r, n, i, s, o, a, l) {\n      const u = (e + n) / 2,\n        c = (r + i) / 2,\n        h = new wt(u, c);\n      a(h), function (t, e, r, n, i, s) {\n        const o = r - i,\n          a = n - s;\n        return Math.abs((n - e) * o - (r - t) * a) / Math.hypot(o, a);\n      }(h.x, h.y, s.x, s.y, o.x, o.y) >= l ? (yu(t, e, r, u, c, s, h, a, l), yu(t, u, c, n, i, h, o, a, l)) : t.push(o);\n    }\n    function gu(t, e, r) {\n      let n = t[0],\n        i = n.x,\n        s = n.y;\n      e(n);\n      const o = [n];\n      for (let a = 1; a < t.length; a++) {\n        const l = t[a],\n          {\n            x: u,\n            y: c\n          } = l;\n        e(l), yu(o, i, s, u, c, n, l, e, r), i = u, s = c, n = l;\n      }\n      return o;\n    }\n    function xu(t, e, r, n) {\n      if (n(e, r)) {\n        const i = e.add(r)._mult(.5);\n        xu(t, e, i, n), xu(t, i, r, n);\n      } else t.push(r);\n    }\n    function vu(t, e) {\n      let r = t[0];\n      const n = [r];\n      for (let i = 1; i < t.length; i++) {\n        const s = t[i];\n        xu(n, r, s, e), r = s;\n      }\n      return n;\n    }\n    const bu = Math.pow(2, 14) - 1,\n      wu = -bu - 1;\n    function _u(t, e) {\n      const r = Math.round(t.x * e),\n        n = Math.round(t.y * e);\n      return t.x = Tt(r, wu, bu), t.y = Tt(n, wu, bu), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && Gt(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\"), t;\n    }\n    function Au(t, e, r) {\n      const n = t.loadGeometry(),\n        i = t.extent,\n        s = Rn / i;\n      if (e && r && r.projection.isReprojectedInTileSpace) {\n        const s = 1 << e.z,\n          {\n            scale: o,\n            x: a,\n            y: l,\n            projection: u\n          } = r,\n          c = t => {\n            const r = au((e.x + t.x / i) / s),\n              n = lu((e.y + t.y / i) / s),\n              c = u.project(r, n);\n            t.x = (c.x * o - a) * i, t.y = (c.y * o - l) * i;\n          };\n        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = gu(n[e], c, 1);else {\n          const t = [];\n          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));\n          n[e] = t;\n        }\n      }\n      for (const t of n) for (const e of t) _u(e, s);\n      return n;\n    }\n    function Mu(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? Au(t) : []\n      };\n    }\n    class Iu {\n      constructor(t, e, r, n, i) {\n        this.properties = {}, this.extent = r, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(Su, this, e);\n      }\n      loadGeometry() {\n        const t = this._pbf;\n        t.pos = this._geometry;\n        const e = t.readVarint() + t.pos,\n          r = [];\n        let n,\n          i = 1,\n          s = 0,\n          o = 0,\n          a = 0;\n        for (; t.pos < e;) {\n          if (s <= 0) {\n            const e = t.readVarint();\n            i = 7 & e, s = e >> 3;\n          }\n          if (s--, 1 === i || 2 === i) o += t.readSVarint(), a += t.readSVarint(), 1 === i && (n && r.push(n), n = []), n && n.push(new wt(o, a));else {\n            if (7 !== i) throw new Error(\"unknown command \".concat(i));\n            n && n.push(n[0].clone());\n          }\n        }\n        return n && r.push(n), r;\n      }\n      bbox() {\n        const t = this._pbf;\n        t.pos = this._geometry;\n        const e = t.readVarint() + t.pos;\n        let r = 1,\n          n = 0,\n          i = 0,\n          s = 0,\n          o = 1 / 0,\n          a = -1 / 0,\n          l = 1 / 0,\n          u = -1 / 0;\n        for (; t.pos < e;) {\n          if (n <= 0) {\n            const e = t.readVarint();\n            r = 7 & e, n = e >> 3;\n          }\n          if (n--, 1 === r || 2 === r) i += t.readSVarint(), s += t.readSVarint(), i < o && (o = i), i > a && (a = i), s < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error(\"unknown command \".concat(r));\n        }\n        return [o, l, a, u];\n      }\n      toGeoJSON(t, e, r) {\n        const n = this.extent * Math.pow(2, r),\n          i = this.extent * t,\n          s = this.extent * e,\n          o = this.loadGeometry();\n        function a(t) {\n          return [360 * (t.x + i) / n - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (t.y + s) / n) * Math.PI)) - 90];\n        }\n        function l(t) {\n          return t.map(a);\n        }\n        let u;\n        if (1 === this.type) {\n          const t = [];\n          for (const e of o) t.push(e[0]);\n          const e = l(t);\n          u = 1 === t.length ? {\n            type: \"Point\",\n            coordinates: e[0]\n          } : {\n            type: \"MultiPoint\",\n            coordinates: e\n          };\n        } else if (2 === this.type) {\n          const t = o.map(l);\n          u = 1 === t.length ? {\n            type: \"LineString\",\n            coordinates: t[0]\n          } : {\n            type: \"MultiLineString\",\n            coordinates: t\n          };\n        } else {\n          if (3 !== this.type) throw new Error(\"unknown feature type\");\n          {\n            const t = function (t) {\n                const e = t.length;\n                if (e <= 1) return [t];\n                const r = [];\n                let n, i;\n                for (let s = 0; s < e; s++) {\n                  const e = Pu(t[s]);\n                  0 !== e && (void 0 === i && (i = e < 0), i === e < 0 ? (n && r.push(n), n = [t[s]]) : n && n.push(t[s]));\n                }\n                return n && r.push(n), r;\n              }(o),\n              e = [];\n            for (const r of t) e.push(r.map(l));\n            u = 1 === e.length ? {\n              type: \"Polygon\",\n              coordinates: e[0]\n            } : {\n              type: \"MultiPolygon\",\n              coordinates: e\n            };\n          }\n        }\n        const c = {\n          type: \"Feature\",\n          geometry: u,\n          properties: this.properties\n        };\n        return null != this.id && (c.id = this.id), c;\n      }\n    }\n    function Su(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? function (t, e) {\n        const r = t.readVarint() + t.pos;\n        for (; t.pos < r;) {\n          const r = e._keys[t.readVarint()],\n            n = e._values[t.readVarint()];\n          e.properties[r] = n;\n        }\n      }(r, e) : 3 === t ? e.type = r.readVarint() : 4 === t && (e._geometry = r.pos);\n    }\n    function Pu(t) {\n      let e = 0;\n      for (let r, n, i = 0, s = t.length, o = s - 1; i < s; o = i++) r = t[i], n = t[o], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    Iu.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n    class ku {\n      constructor(t, e) {\n        this.version = 1, this.name = \"\", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(zu, this, e), this.length = this._features.length;\n      }\n      feature(t) {\n        if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n        this._pbf.pos = this._features[t];\n        const e = this._pbf.readVarint() + this._pbf.pos;\n        return new Iu(this._pbf, e, this.extent, this._keys, this._values);\n      }\n    }\n    function zu(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        let e = null;\n        const r = t.readVarint() + t.pos;\n        for (; t.pos < r;) {\n          const r = t.readVarint() >> 3;\n          e = 1 === r ? t.readString() : 2 === r ? t.readFloat() : 3 === r ? t.readDouble() : 4 === r ? t.readVarint64() : 5 === r ? t.readVarint() : 6 === r ? t.readSVarint() : 7 === r ? t.readBoolean() : null;\n        }\n        if (null == e) throw new Error(\"unknown feature value\");\n        return e;\n      }(r));\n    }\n    class Eu {\n      constructor(t, e) {\n        this.layers = t.readFields(Tu, {}, e);\n      }\n    }\n    function Tu(t, e, r) {\n      if (3 === t) {\n        const t = new ku(r, r.readVarint() + r.pos);\n        t.length && (e[t.name] = t);\n      }\n    }\n    const Bu = \"3d_elevation_id\",\n      Vu = \"level\";\n    class Fu {\n      constructor() {\n        this._valid = !1;\n      }\n      reset(t) {\n        return this.feature = t, this._valid = !0, this._geometry = t.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = !1), this;\n      }\n      geometry(t, e) {\n        return this._valid && t(e(this._geometry)), this;\n      }\n      require(t, e, r) {\n        return this.get(t, !0, e, r);\n      }\n      optional(t, e, r) {\n        return this.get(t, !1, e, r);\n      }\n      success() {\n        return this._valid;\n      }\n      get(t, e, r, n) {\n        const i = this.feature.properties.hasOwnProperty(t) ? +this.feature.properties[t] : void 0;\n        return this._valid && void 0 !== i && !Number.isNaN(i) ? r(n ? n(i) : i) : e && (this._valid = !1), this;\n      }\n    }\n    class Cu {\n      constructor(t, e) {\n        this.featureFunc = t, this.vertexFunc = e;\n      }\n      parseFeature(t, e, r) {\n        return this.featureFunc(t, e, r);\n      }\n      parseVertex(t, e, r) {\n        return this.vertexFunc(t, e, r);\n      }\n    }\n    const Du = new Cu((t, e, r) => t.reset(e).require(Bu, t => {\n        r.id = t;\n      }).optional(\"fixed_height_relative\", t => {\n        r.constantHeight = t;\n      }, Lu.decodeRelativeHeight).geometry(t => {\n        r.bounds = t;\n      }, mn).success(), (t, e, r) => t.reset(e).require(Bu, t => {\n        r.id = t;\n      }).require(\"elevation_idx\", t => {\n        r.idx = t;\n      }).require(\"extent\", t => {\n        r.extent = t;\n      }).require(\"height_relative\", t => {\n        r.height = t;\n      }, Lu.decodeRelativeHeight).geometry(t => {\n        r.position = t;\n      }, Lu.getPoint).success()),\n      Ru = new Cu((t, e, r) => t.reset(e).require(Bu, t => {\n        r.id = t;\n      }).optional(\"fixed_height\", t => {\n        r.constantHeight = t;\n      }, Lu.decodeMetricHeight).geometry(t => {\n        r.bounds = t;\n      }, mn).success(), (t, e, r) => t.reset(e).require(Bu, t => {\n        r.id = t;\n      }).require(\"elevation_idx\", t => {\n        r.idx = t;\n      }).require(\"extent\", t => {\n        r.extent = t;\n      }).require(\"height\", t => {\n        r.height = t;\n      }, Lu.decodeMetricHeight).geometry(t => {\n        r.position = t;\n      }, Lu.getPoint).success());\n    class Lu {\n      static getPoint(t) {\n        return at(t[0][0].x, t[0][0].y);\n      }\n      static decodeRelativeHeight(t) {\n        return 1e-4 * t * 5;\n      }\n      static decodeMetricHeight(t) {\n        return 1e-4 * t;\n      }\n      static getVersionSchema(t) {\n        return t ? \"1.0.1\" === t ? Ru : void 0 : Du;\n      }\n      static parse(t) {\n        const e = [],\n          r = [],\n          n = t.length,\n          i = new Fu();\n        for (let s = 0; s < n; s++) {\n          const n = t.feature(s),\n            o = n.properties.version,\n            a = Lu.getVersionSchema(o);\n          if (void 0 === a) {\n            Gt(\"Unknown elevation feature version number \".concat(o || \"(unknown)\"));\n            continue;\n          }\n          const l = n.properties.type;\n          if (!l) continue;\n          const u = Iu.types[n.type];\n          if (\"Point\" === u && \"curve_point\" === l) {\n            const t = {};\n            a.parseVertex(i, n, t) && e.push(t);\n          } else if (\"Polygon\" === u && \"curve_meta\" === l) {\n            const t = {};\n            a.parseFeature(i, n, t) && r.push(t);\n          }\n        }\n        return {\n          vertices: e,\n          features: r\n        };\n      }\n    }\n    class Ou {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n      intersectsPlane(t, e, r) {\n        const n = ft(e, this.dir);\n        if (Math.abs(n) < 1e-6) return !1;\n        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1]) / n;\n        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, !0;\n      }\n    }\n    class Uu {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n      intersectsPlane(t, e, r) {\n        const n = D(e, this.dir);\n        if (Math.abs(n) < 1e-6) return !1;\n        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;\n        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;\n      }\n      closestPointOnSphere(t, r, n) {\n        if (function (t, r) {\n          var n = t[0],\n            i = t[1],\n            s = t[2],\n            o = r[0],\n            a = r[1],\n            l = r[2];\n          return Math.abs(n - o) <= e * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - a) <= e * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(s - l) <= e * Math.max(1, Math.abs(s), Math.abs(l));\n        }(this.pos, t) || 0 === r) return n[0] = n[1] = n[2] = 0, !1;\n        const [i, s, o] = this.dir,\n          a = this.pos[0] - t[0],\n          l = this.pos[1] - t[1],\n          u = this.pos[2] - t[2],\n          c = i * i + s * s + o * o,\n          h = 2 * (a * i + l * s + u * o),\n          p = h * h - 4 * c * (a * a + l * l + u * u - r * r);\n        if (p < 0) {\n          const t = Math.max(-h / 2, 0),\n            e = a + i * t,\n            c = l + s * t,\n            p = u + o * t,\n            d = Math.hypot(e, c, p);\n          return n[0] = e * r / d, n[1] = c * r / d, n[2] = p * r / d, !1;\n        }\n        {\n          const t = (-h - Math.sqrt(p)) / (2 * c);\n          if (t < 0) {\n            const t = Math.hypot(a, l, u);\n            return n[0] = a * r / t, n[1] = l * r / t, n[2] = u * r / t, !1;\n          }\n          return n[0] = a + i * t, n[1] = l + s * t, n[2] = u + o * t, !0;\n        }\n      }\n    }\n    class Nu {\n      constructor(t, e, r, n, i) {\n        this.TL = t, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;\n      }\n      static fromInvProjectionMatrix(t, e, r) {\n        const n = [-1, 1, 1],\n          i = [1, 1, 1],\n          s = [1, -1, 1],\n          o = [-1, -1, 1],\n          a = O(n, n, t),\n          l = O(i, i, t),\n          u = O(s, s, t),\n          c = O(o, o, t);\n        return new Nu(a, l, u, c, e / r);\n      }\n    }\n    function ju(t, e, r) {\n      let n = 1 / 0,\n        i = -1 / 0;\n      const s = [];\n      for (const o of t) {\n        G(s, o, e);\n        const t = D(s, r);\n        n = Math.min(n, t), i = Math.max(i, t);\n      }\n      return [n, i];\n    }\n    function $u(t, e) {\n      let r = !0;\n      for (let n = 0; n < t.planes.length; n++) {\n        const i = t.planes[n];\n        let s = 0;\n        for (let t = 0; t < e.length; t++) s += +(D(i, e[t]) + i[3] >= 0);\n        if (0 === s) return 0;\n        s !== e.length && (r = !1);\n      }\n      return r ? 2 : 1;\n    }\n    function Gu(t, e) {\n      for (const r of t.projections) {\n        const n = ju(e, t.points[0], r.axis);\n        if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;\n      }\n      return 1;\n    }\n    function Hu(t, e) {\n      let r = 0;\n      const n = [0, 0, 0, 0];\n      for (let o = 0; o < t.length; o++) n[0] = t[o][0], n[1] = t[o][1], n[2] = t[o][2], n[3] = 1, (i = n)[0] * (s = e)[0] + i[1] * s[1] + i[2] * s[2] + i[3] * s[3] >= 0 && r++;\n      var i, s;\n      return r;\n    }\n    class qu {\n      constructor(t, e) {\n        this.points = t || new Array(8).fill([0, 0, 0]), this.planes = e || new Array(6).fill([0, 0, 0, 0]), this.bounds = Xu.fromPoints(this.points), this.projections = [], this.frustumEdges = [G([], this.points[2], this.points[3]), G([], this.points[0], this.points[3]), G([], this.points[4], this.points[0]), G([], this.points[5], this.points[1]), G([], this.points[6], this.points[2]), G([], this.points[7], this.points[3])];\n        for (const t of this.frustumEdges) {\n          const e = [0, -t[2], t[1]],\n            r = [t[2], 0, -t[0]];\n          this.projections.push({\n            axis: e,\n            projection: ju(this.points, this.points[0], e)\n          }), this.projections.push({\n            axis: r,\n            projection: ju(this.points, this.points[0], r)\n          });\n        }\n      }\n      static fromInvProjectionMatrix(t, e, r, n) {\n        const i = Math.pow(2, r),\n          s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {\n            const s = Y([], r, t),\n              o = 1 / s[3] / e * i;\n            return (a = s)[0] = (l = s)[0] * (u = [o, o, n ? 1 / s[3] : o, o])[0], a[1] = l[1] * u[1], a[2] = l[2] * u[2], a[3] = l[3] * u[3], a;\n            var a, l, u;\n          }),\n          o = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {\n            const e = C([], R([], G([], s[t[0]], s[t[1]]), G([], s[t[2]], s[t[1]]))),\n              r = -D(e, s[t[1]]);\n            return e.concat(r);\n          }),\n          a = [];\n        for (let t = 0; t < s.length; t++) a.push([s[t][0], s[t][1], s[t][2]]);\n        return new qu(a, o);\n      }\n      intersectsPrecise(t, e, r) {\n        for (let r = 0; r < e.length; r++) if (!Hu(t, e[r])) return 0;\n        for (let e = 0; e < this.planes.length; e++) if (!Hu(t, this.planes[e])) return 0;\n        for (const e of r) for (const r of this.frustumEdges) {\n          const n = R([], e, r),\n            i = _(n);\n          if (0 === i) continue;\n          E(n, n, 1 / i);\n          const s = ju(this.points, this.points[0], n),\n            o = ju(t, this.points[0], n);\n          if (s[0] > o[1] || o[0] > s[1]) return 0;\n        }\n        return 1;\n      }\n      containsPoint(t) {\n        for (const e of this.planes) {\n          const r = e[3];\n          if (D([e[0], e[1], e[2]], t) + r < 0) return !1;\n        }\n        return !0;\n      }\n    }\n    class Xu {\n      static fromPoints(t) {\n        const e = [1 / 0, 1 / 0, 1 / 0],\n          r = [-1 / 0, -1 / 0, -1 / 0];\n        for (const n of t) k(e, e, n), z(r, r, n);\n        return new Xu(e, r);\n      }\n      static fromTileIdAndHeight(t, e, r) {\n        const n = 1 << t.canonical.z,\n          i = t.canonical.x,\n          s = t.canonical.y;\n        return new Xu([i / n, s / n, e], [(i + 1) / n, (s + 1) / n, r]);\n      }\n      static applyTransform(t, e) {\n        const r = t.getCorners();\n        for (let t = 0; t < r.length; ++t) O(r[t], r[t], e);\n        return Xu.fromPoints(r);\n      }\n      static applyTransformFast(t, e) {\n        const r = [e[12], e[13], e[14]],\n          n = [...r];\n        for (let i = 0; i < 3; i++) for (let s = 0; s < 3; s++) {\n          const o = e[4 * s + i],\n            a = o * t.min[s],\n            l = o * t.max[s];\n          r[i] += Math.min(a, l), n[i] += Math.max(a, l);\n        }\n        return new Xu(r, n);\n      }\n      static projectAabbCorners(t, e) {\n        const r = t.getCorners();\n        for (let t = 0; t < r.length; ++t) O(r[t], r[t], e);\n        return r;\n      }\n      constructor(t, e) {\n        this.min = t, this.max = e, this.center = E([], I([], this.min, this.max), .5);\n      }\n      quadrant(t) {\n        const e = [t % 2 == 0, t < 2],\n          r = w(this.min),\n          n = w(this.max);\n        for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];\n        return n[2] = this.max[2], new Xu(r, n);\n      }\n      distanceX(t) {\n        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n      }\n      distanceY(t) {\n        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n      }\n      distanceZ(t) {\n        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];\n      }\n      getCorners() {\n        const t = this.min,\n          e = this.max;\n        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];\n      }\n      intersects(t) {\n        return this.intersectsAabb(t.bounds) ? $u(t, this.getCorners()) : 0;\n      }\n      intersectsFlat(t) {\n        return this.intersectsAabb(t.bounds) ? $u(t, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;\n      }\n      intersectsPrecise(t, e) {\n        return e || this.intersects(t) ? Gu(t, this.getCorners()) : 0;\n      }\n      intersectsPreciseFlat(t, e) {\n        return e || this.intersectsFlat(t) ? Gu(t, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;\n      }\n      intersectsAabb(t) {\n        for (let e = 0; e < 3; ++e) if (this.min[e] > t.max[e] || t.min[e] > this.max[e]) return !1;\n        return !0;\n      }\n      intersectsAabbXY(t) {\n        return !(this.min[0] > t.max[0] || t.min[0] > this.max[0] || this.min[1] > t.max[1] || t.min[1] > this.max[1]);\n      }\n      encapsulate(t) {\n        for (let e = 0; e < 3; e++) this.min[e] = Math.min(this.min[e], t.min[e]), this.max[e] = Math.max(this.max[e], t.max[e]);\n      }\n      encapsulatePoint(t) {\n        for (let e = 0; e < 3; e++) this.min[e] = Math.min(this.min[e], t[e]), this.max[e] = Math.max(this.max[e], t[e]);\n      }\n      closestPoint(t) {\n        return [Math.max(Math.min(this.max[0], t[0]), this.min[0]), Math.max(Math.min(this.max[1], t[1]), this.min[1]), Math.max(Math.min(this.max[2], t[2]), this.min[2])];\n      }\n    }\n    Ws(Xu, \"Aabb\");\n    class Zu {\n      constructor(t, e) {\n        this.feature = t, this.metersToTile = e, this.index = 0;\n      }\n      get() {\n        const t = this.feature.vertices[this.index],\n          e = this.feature.vertexProps[this.index].dir,\n          r = e[1],\n          n = -e[0],\n          i = (t.extent + 1) * this.metersToTile;\n        return [new wt(Math.trunc(t.position[0] + r * i), Math.trunc(t.position[1] + n * i)), new wt(Math.trunc(t.position[0] - r * i), Math.trunc(t.position[1] - n * i))];\n      }\n      next() {\n        this.index++;\n      }\n      valid() {\n        return this.index < this.feature.vertices.length;\n      }\n    }\n    class Wu {\n      constructor(t, e, r, n, i, s) {\n        if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this._tmpVec2 = [ot(), ot(), ot(), ot(), ot(), ot(), ot()], this.id = t, this.heightRange = {\n          min: r,\n          max: r\n        }, this.safeArea = e, this.constantHeight = r, null == this.constantHeight && (null != this.constantHeight || 0 !== n.length)) {\n          this.vertices = n, this.edges = i, this.edges = this.edges.filter(t => {\n            return t.a < this.vertices.length && t.b < this.vertices.length && !((e = this.vertices[t.a].position)[0] === (r = this.vertices[t.b].position)[0] && e[1] === r[1]);\n            var e, r;\n          }), this.heightRange = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n          };\n          for (const t of this.vertices) this.vertexProps.push({\n            dir: at(0, 0)\n          }), this.heightRange.min = Math.min(this.heightRange.min, t.height), this.heightRange.max = Math.max(this.heightRange.max, t.height);\n          for (const t of this.edges) {\n            const e = this.vertices[t.a].position,\n              r = this.vertices[t.b].position,\n              n = ct(ot(), r, e),\n              i = pt(n),\n              s = ht(ot(), n, 1 / i);\n            this.edgeProps.push({\n              vec: n,\n              dir: s,\n              len: i\n            });\n            const o = this.vertexProps[t.a].dir,\n              a = this.vertexProps[t.b].dir;\n            ut(o, o, s), ut(a, a, s);\n          }\n          for (const t of this.vertexProps) 0 === t.dir[0] && 0 === t.dir[1] || dt(t.dir, t.dir);\n          this.tessellate(s);\n        }\n      }\n      pointElevation(t) {\n        if (null != this.constantHeight) return this.constantHeight;\n        const e = this.getClosestEdge(t);\n        if (null == e) return 0;\n        const [r, n] = e;\n        return ur(this.vertices[this.edges[r].a].height, this.vertices[this.edges[r].b].height, n);\n      }\n      computeSlopeNormal(t, e) {\n        const r = this.getClosestEdge(t);\n        if (!r) return A(0, 0, 1);\n        const n = r[0],\n          i = this.edges[n],\n          s = this.edgeProps[n].vec,\n          o = A(s[0], s[1], (this.vertices[i.b].height - this.vertices[i.a].height) * e),\n          a = A(o[1], -o[0], 0);\n        R(a, a, o);\n        const l = _(a);\n        return l > 0 ? E(a, a, 1 / l) : M(a, 0, 0, 1);\n      }\n      getSafeArea() {\n        return this.safeArea;\n      }\n      isTunnel() {\n        return this.heightRange.max <= -5;\n      }\n      getClosestEdge(t) {\n        if (0 === this.edges.length) return;\n        let e = 0,\n          r = Number.POSITIVE_INFINITY,\n          n = 0;\n        const [i, s, o, a, l, u, c] = this._tmpVec2;\n        lt(c, t.x, t.y);\n        const h = new Ou(c, null);\n        for (let t = 0; t < this.edges.length; t++) {\n          const p = this.edges[t],\n            d = this.edgeProps[t].dir;\n          h.dir = d;\n          const f = this.vertices[p.a].position,\n            m = this.vertices[p.b].position,\n            y = h.intersectsPlane(f, this.vertexProps[p.a].dir, i),\n            g = h.intersectsPlane(m, this.vertexProps[p.b].dir, s);\n          if (!y || !g) continue;\n          ct(o, s, i), ct(a, c, i);\n          const x = ft(o, o),\n            v = x > 0 ? ft(a, o) / x : 0,\n            b = Tt(v, 0, 1),\n            w = Math.abs((v - b) * this.edgeProps[t].len);\n          ct(l, c, f), lt(u, d[1], -d[0]);\n          const _ = w + Math.abs(ft(l, u));\n          _ < r && (e = t, r = _, n = b);\n        }\n        return [e, n];\n      }\n      tessellate(t) {\n        const e = b(),\n          r = b(),\n          n = b(),\n          i = b();\n        for (let s = this.edges.length - 1; s >= 0; --s) {\n          const o = this.edges[s].a,\n            a = this.edges[s].b,\n            {\n              position: l,\n              height: u,\n              extent: c\n            } = this.vertices[o],\n            {\n              position: h,\n              height: p,\n              extent: d\n            } = this.vertices[a],\n            f = this.vertexProps[o].dir,\n            m = this.vertexProps[a].dir;\n          if (M(e, l[0] / t, l[1] / t, u), M(r, h[0] / t, h[1] / t, p), M(n, f[1], -f[0], 0), E(n, n, c), M(i, m[1], -m[0], 0), E(i, i, d), this.distSqLines(A(e[0] + .5 * n[0], e[1] + .5 * n[1], e[2] + .5 * n[2]), A(r[0] - .5 * i[0], r[1] - .5 * i[1], r[2] - .5 * i[2]), A(e[0] - .5 * n[0], e[1] - .5 * n[1], e[2] - .5 * n[2]), A(r[0] + .5 * i[0], r[1] + .5 * i[1], r[2] + .5 * i[2])) <= .0025000000000000005) continue;\n          const y = this.vertices.length,\n            g = ut(ot(), l, h);\n          this.vertices.push({\n            position: ht(g, g, .5),\n            height: .5 * (u + p),\n            extent: .5 * (c + d)\n          });\n          const x = ut(ot(), f, m);\n          this.vertexProps.push({\n            dir: dt(x, x)\n          }), this.edges.splice(s, 1), this.edgeProps.splice(s, 1), this.edges.push({\n            a: o,\n            b: y\n          }), this.edges.push({\n            a: y,\n            b: a\n          });\n          const v = ct(ot(), this.vertices[y].position, l),\n            b = pt(v),\n            w = {\n              vec: v,\n              dir: ht(ot(), v, 1 / b),\n              len: b\n            };\n          this.edgeProps.push(w), this.edgeProps.push(w);\n        }\n      }\n      distSqLines(t, e, r, n) {\n        const i = S(b(), e, t),\n          s = S(b(), n, r),\n          o = S(b(), t, r),\n          a = D(i, i),\n          l = D(i, s),\n          u = D(i, o),\n          c = D(s, s),\n          h = D(s, o),\n          p = a * c - l * l;\n        if (0 === p) return B(L(i, r, n, D(o, s) / D(s, s)), t);\n        const d = (a * h - l * u) / p;\n        return B(L(i, t, e, (l * h - u * c) / p), L(s, r, n, d));\n      }\n    }\n    class Yu {\n      static parseFrom(t, e) {\n        const r = Lu.parse(t);\n        if (!r) return [];\n        let {\n          vertices: n,\n          features: i\n        } = r;\n        const s = 1 / fu(e);\n        i.sort((t, e) => t.id - e.id), n.sort((t, e) => t.id - e.id || t.idx - e.idx), n = n.filter((t, e, r) => e === r.findIndex(e => e.id === t.id && e.idx === t.idx));\n        const o = new Array();\n        let a = 0;\n        const l = n.length;\n        for (const t of i) {\n          if (t.constantHeight) {\n            o.push(new Wu(t.id, t.bounds, t.constantHeight));\n            continue;\n          }\n          for (; a !== l && n[a].id < t.id;) a++;\n          if (a === l || n[a].id !== t.id) continue;\n          const e = new Array(),\n            r = new Array(),\n            i = a;\n          for (; a !== l && n[a].id === t.id;) {\n            const t = n[a];\n            if (e.push({\n              position: t.position,\n              height: t.height,\n              extent: t.extent\n            }), a !== i && n[a - 1].idx === t.idx - 1) {\n              const t = a - i;\n              r.push({\n                a: t - 1,\n                b: t\n              });\n            }\n            a++;\n          }\n          o.push(new Wu(t.id, t.bounds, void 0, e, r, s));\n        }\n        return o;\n      }\n      static getElevationFeature(t, e) {\n        if (!e) return;\n        const r = +t.properties[Bu];\n        return Number.isNaN(r) ? void 0 : e.find(t => t.id === r);\n      }\n    }\n    class Ku {\n      constructor(t, e) {\n        this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t.equals(e) || (this.zScale = Math.pow(2, e.z - t.z), this.xOffset = (t.x * this.zScale - e.x) * Rn, this.yOffset = (t.y * this.zScale - e.y) * Rn);\n      }\n      constantElevation(t, e) {\n        if (null != t.constantHeight) return this.computeBiasedHeight(t.constantHeight, e);\n      }\n      pointElevation(t, e, r) {\n        const n = this.constantElevation(e, r);\n        return null != n ? n : (t.x = t.x * this.zScale + this.xOffset, t.y = t.y * this.zScale + this.yOffset, this.computeBiasedHeight(e.pointElevation(t), r));\n      }\n      computeBiasedHeight(t, e) {\n        return e <= 0 ? t : t + e * Bt(0, e, t >= 0 ? t : Math.abs(.5 * t));\n      }\n    }\n    Ws(Wu, \"ElevationFeature\");\n    class Ju {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new ua(), this.indexArray = new Ea(), this.segments = new al(), this.programConfigurations = new Cl(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.elevationMode = this.layers[0].layout.get(\"circle-elevation-reference\"), this.hasElevation = !1, \"none\" !== this.elevationMode && (this.elevatedLayoutVertexArray = new pa()), this.worldview = t.worldview;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          s = [];\n        let o = null;\n        \"circle\" === i.type && (o = i.layout.get(\"circle-sort-key\"));\n        for (const {\n          feature: e,\n          id: i,\n          index: a,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = Mu(e, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom, {\n            worldview: this.worldview\n          }), u, r)) continue;\n          const c = o ? o.evaluate(u, {}, r) : void 0,\n            h = {\n              id: i,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: a,\n              geometry: t ? u.geometry : Au(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          s.push(h);\n        }\n        o && s.sort((t, e) => t.sortKey - e.sortKey);\n        let a = null;\n        \"globe\" === n.projection.name && (this.globeExtVertexArray = new ba(), a = n.projection);\n        for (const n of s) {\n          const {\n              geometry: i,\n              index: s,\n              sourceLayerIndex: o\n            } = n,\n            l = t[s].feature;\n          this.addFeature(n, i, s, e.availableImages, r, a, e.brightness, e.elevationFeatures), e.featureIndex.insert(l, i, s, o, this.index);\n        }\n        this.hasElevation || (this.elevatedLayoutVertexArray = void 0);\n      }\n      update(t, e, r, n, i, s, o) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o, this.worldview);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, il.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, ol.members)), this.elevatedLayoutVertexArray && (this.elevatedLayoutVertexBuffer = t.createVertexBuffer(this.elevatedLayoutVertexArray, sl.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy());\n      }\n      addFeature(t, e, r, n, i, s, o, a) {\n        let l;\n        \"none\" !== this.elevationMode && (l = Yu.getElevationFeature(t, a));\n        for (const r of e) for (const e of r) {\n          const r = e.x,\n            n = e.y;\n          if (r < 0 || r >= Rn || n < 0 || n >= Rn) continue;\n          if (s) {\n            const t = s.projectTilePoint(r, n, i),\n              e = s.upVector(i, r, n);\n            this.addGlobeExtVertex(t, e), this.addGlobeExtVertex(t, e), this.addGlobeExtVertex(t, e), this.addGlobeExtVertex(t, e);\n          }\n          const o = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n            a = o.vertexLength;\n          if (this.addCircleVertex(r, n, -1, -1), this.addCircleVertex(r, n, 1, -1), this.addCircleVertex(r, n, 1, 1), this.addCircleVertex(r, n, -1, 1), \"none\" !== this.elevationMode) {\n            const t = l ? l.pointElevation(new wt(r, n)) : 0;\n            this.hasElevation = this.hasElevation || 0 !== t;\n            for (let e = 0; e < 4; e++) this.elevatedLayoutVertexArray.emplaceBack(t);\n          }\n          this.indexArray.emplaceBack(a, a + 1, a + 2), this.indexArray.emplaceBack(a, a + 2, a + 3), o.vertexLength += 4, o.primitiveLength += 2;\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i, o, void 0, this.worldview);\n      }\n      addCircleVertex(t, e, r, n) {\n        this.layoutVertexArray.emplaceBack(2 * t + (r + 1) / 2, 2 * e + (n + 1) / 2);\n      }\n      addGlobeExtVertex(t, e) {\n        const r = 16384;\n        this.globeExtVertexArray.emplaceBack(t.x, t.y, t.z, e[0] * r, e[1] * r, e[2] * r);\n      }\n    }\n    function Qu(t, e) {\n      for (let r = 0; r < t.length; r++) if (cc(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (cc(t, e[r])) return !0;\n      return !!nc(t, e);\n    }\n    function tc(t, e, r) {\n      return !!cc(t, e) || !!ac(e, t, r);\n    }\n    function ec(t, e) {\n      if (1 === t.length) return uc(e, t[0]);\n      for (let r = 0; r < e.length; r++) {\n        const n = e[r];\n        for (let e = 0; e < n.length; e++) if (cc(t, n[e])) return !0;\n      }\n      for (let r = 0; r < t.length; r++) if (uc(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (nc(t, e[r])) return !0;\n      return !1;\n    }\n    function rc(t, e, r) {\n      if (t.length > 1) {\n        if (nc(t, e)) return !0;\n        for (let n = 0; n < e.length; n++) if (ac(e[n], t, r)) return !0;\n      }\n      for (let n = 0; n < t.length; n++) if (ac(t[n], e, r)) return !0;\n      return !1;\n    }\n    function nc(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1];\n        for (let t = 0; t < e.length - 1; t++) if (ic(n, i, e[t], e[t + 1])) return !0;\n      }\n      return !1;\n    }\n    function ic(t, e, r, n) {\n      return Ht(t, r, n) !== Ht(e, r, n) && Ht(t, e, r) !== Ht(t, e, n);\n    }\n    function sc(t, e, r) {\n      return (t.x - r.x) * (e.y - r.y) - (t.y - r.y) * (e.x - r.x);\n    }\n    function oc(t, e, r, n) {\n      const i = sc(t, e, n),\n        s = sc(t, e, r);\n      if (Math.sign(i) === Math.sign(s)) return;\n      const o = sc(r, n, t),\n        a = o + s - i;\n      return Math.sign(o) !== Math.sign(a) ? [o / (o - a), s / (s - i)] : void 0;\n    }\n    function ac(t, e, r) {\n      const n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n      for (let r = 1; r < e.length; r++) if (lc(t, e[r - 1], e[r]) < n) return !0;\n      return !1;\n    }\n    function lc(t, e, r) {\n      const n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n    function uc(t, e) {\n      let r,\n        n,\n        i,\n        s = !1;\n      for (let o = 0; o < t.length; o++) {\n        r = t[o];\n        for (let t = 0, o = r.length - 1; t < r.length; o = t++) n = r[t], i = r[o], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);\n      }\n      return s;\n    }\n    function cc(t, e) {\n      let r = !1;\n      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n        const s = t[n],\n          o = t[i];\n        s.y > e.y != o.y > e.y && e.x < (o.x - s.x) * (e.y - s.y) / (o.y - s.y) + s.x && (r = !r);\n      }\n      return r;\n    }\n    function hc(t, e, r, n, i) {\n      for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;\n      const s = [new wt(e, r), new wt(e, i), new wt(n, i), new wt(n, r)];\n      if (t.length > 2) for (const e of s) if (cc(t, e)) return !0;\n      for (let e = 0; e < t.length - 1; e++) if (pc(t[e], t[e + 1], s)) return !0;\n      return !1;\n    }\n    function pc(t, e, r) {\n      const n = r[0],\n        i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      const s = Ht(t, e, r[0]);\n      return s !== Ht(t, e, r[1]) || s !== Ht(t, e, r[2]) || s !== Ht(t, e, r[3]);\n    }\n    function dc(t, e, r, n, i, s) {\n      let o = e.y - t.y,\n        a = t.x - e.x;\n      if (s = s || 0) {\n        const t = o * o + a * a;\n        if (0 === t) return !0;\n        const e = Math.sqrt(t);\n        o /= e, a /= e;\n      }\n      return !((r.x - t.x) * o + (r.y - t.y) * a - s < 0 || (n.x - t.x) * o + (n.y - t.y) * a - s < 0 || (i.x - t.x) * o + (i.y - t.y) * a - s < 0);\n    }\n    function fc(t, e, r, n, i, s, o) {\n      return !(dc(t, e, n, i, s, o) || dc(e, r, n, i, s, o) || dc(r, t, n, i, s, o) || dc(n, i, t, e, r, o) || dc(i, s, t, e, r, o) || dc(s, n, t, e, r, o));\n    }\n    function mc(t, e, r) {\n      const n = e.paint.get(t).value;\n      return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n    function yc(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n    function gc(t, e, r, n, i) {\n      if (!e[0] && !e[1]) return t;\n      const s = wt.convert(e)._mult(i);\n      \"viewport\" === r && s._rotate(-n);\n      const o = [];\n      for (let e = 0; e < t.length; e++) o.push(t[e].sub(s));\n      return o;\n    }\n    function xc(t, e, r, n) {\n      const i = wt.convert(t)._mult(n);\n      return \"viewport\" === e && i._rotate(-r), i;\n    }\n    let vc, bc;\n    function wc(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n    Ws(Ju, \"CircleBucket\", {\n      omit: [\"layers\"]\n    });\n    class _c {\n      constructor(t, e, r) {\n        this.z = t, this.x = e, this.y = r, this.key = Ic(0, t, t, e, r);\n      }\n      equals(t) {\n        return this.z === t.z && this.x === t.x && this.y === t.y;\n      }\n      isChildOf(t) {\n        const e = this.z - t.z;\n        return 0 === t.z || t.z < this.z && t.x === this.x >> e && t.y === this.y >> e;\n      }\n      url(t, e) {\n        const r = function (t, e, r) {\n            var n = wc(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r),\n              i = wc(256 * (t + 1), 256 * (e + 1), r);\n            return n[0] + \",\" + n[1] + \",\" + i[0] + \",\" + i[1];\n          }(this.x, this.y, this.z),\n          n = function (t, e, r) {\n            let n,\n              i = \"\";\n            for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n            return i;\n          }(this.z, this.x, this.y);\n        return t[(this.x + this.y) % t.length].replace(\"{prefix}\", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(\"tms\" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(\"{quadkey}\", n).replace(\"{bbox-epsg-3857}\", r);\n      }\n      toString() {\n        return \"\".concat(this.z, \"/\").concat(this.x, \"/\").concat(this.y);\n      }\n    }\n    class Ac {\n      constructor(t, e) {\n        this.wrap = t, this.canonical = e, this.key = Ic(t, e.z, e.z, e.x, e.y);\n      }\n    }\n    class Mc {\n      constructor(t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new _c(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : Ic(e, t, r, n, i);\n      }\n      equals(t) {\n        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n      }\n      scaledTo(t) {\n        const e = this.canonical.z - t;\n        return t > this.canonical.z ? new Mc(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Mc(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n      }\n      calculateScaledKey(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n        if (this.overscaledZ === t && e) return this.key;\n        if (t > this.canonical.z) return Ic(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);\n        {\n          const r = this.canonical.z - t;\n          return Ic(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n        }\n      }\n      isChildOf(t) {\n        if (t.wrap !== this.wrap) return !1;\n        const e = this.canonical.z - t.canonical.z;\n        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.z < this.canonical.z && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n      }\n      children(t) {\n        if (this.overscaledZ >= t) return [new Mc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        const e = this.canonical.z + 1,\n          r = 2 * this.canonical.x,\n          n = 2 * this.canonical.y;\n        return [new Mc(e, this.wrap, e, r, n), new Mc(e, this.wrap, e, r + 1, n), new Mc(e, this.wrap, e, r, n + 1), new Mc(e, this.wrap, e, r + 1, n + 1)];\n      }\n      isLessThan(t) {\n        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n      }\n      wrapped() {\n        return new Mc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      unwrapTo(t) {\n        return new Mc(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n      }\n      toUnwrapped() {\n        return new Ac(this.wrap, this.canonical);\n      }\n      toString() {\n        return \"\".concat(this.overscaledZ, \"/\").concat(this.canonical.x, \"/\").concat(this.canonical.y);\n      }\n    }\n    function Ic(t, e, r, n, i) {\n      const s = 1 << Math.min(r, 22);\n      let o = s * (i % s) + n % s;\n      return t && r < 22 && (o += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * o + r) + (e - r);\n    }\n    const Sc = [t => {\n      let e = t.canonical.x - 1,\n        r = t.wrap;\n      return e < 0 && (e = (1 << t.canonical.z) - 1, r--), new Mc(t.overscaledZ, r, t.canonical.z, e, t.canonical.y);\n    }, t => {\n      let e = t.canonical.x + 1,\n        r = t.wrap;\n      return e === 1 << t.canonical.z && (e = 0, r++), new Mc(t.overscaledZ, r, t.canonical.z, e, t.canonical.y);\n    }, t => new Mc(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new Mc(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)];\n    Ws(_c, \"CanonicalTileID\"), Ws(Mc, \"OverscaledTileID\", {\n      omit: [\"projMatrix\", \"expandedProjMatrix\"]\n    });\n    const Pc = aa([{\n        type: \"Float32\",\n        name: \"a_globe_pos\",\n        components: 3\n      }, {\n        type: \"Float32\",\n        name: \"a_uv\",\n        components: 2\n      }]),\n      {\n        members: kc\n      } = Pc,\n      zc = aa([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    var Ec = aa([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    function Tc(t) {\n      return t * Nl / Kl;\n    }\n    const Bc = [new Xu([Xl, Xl, Xl], [Zl, Zl, Zl]), new Xu([Xl, Xl, Xl], [0, 0, Zl]), new Xu([0, Xl, Xl], [Zl, 0, Zl]), new Xu([Xl, 0, Xl], [0, Zl, Zl]), new Xu([0, 0, Xl], [Zl, Zl, Zl])];\n    function Vc(t, e, r) {\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n      const i = E([], t._camera.position, t.worldSize),\n        s = [e, r, 1, 1];\n      Y(s, s, t.pixelMatrixInverse), Z(s, s, 1 / s[3]);\n      const o = C([], G([], s, i)),\n        a = t.globeMatrix,\n        l = [a[12], a[13], a[14]],\n        u = G([], l, i),\n        c = _(u),\n        h = C([], u),\n        p = t.worldSize / (2 * Math.PI),\n        d = D(h, o),\n        f = Math.asin(p / c);\n      if (f < Math.acos(d)) {\n        if (!n) return null;\n        const t = [],\n          e = [];\n        E(t, o, c / d), C(e, G(e, t, u)), C(o, I(o, u, E(o, e, Math.tan(f) * c)));\n      }\n      const m = [];\n      new Uu(i, o).closestPointOnSphere(l, p, m);\n      const y = C([], Kt(a, 0)),\n        g = C([], Kt(a, 1)),\n        x = C([], Kt(a, 2)),\n        v = D(y, m),\n        b = D(g, m),\n        w = D(x, m),\n        A = St(Math.asin(-b / p));\n      let M = St(Math.atan2(v, w));\n      M = t.center.lng + function (t, e) {\n        const r = (e - t + 180) % 360 - 180;\n        return r < -180 ? r + 360 : r;\n      }(t.center.lng, M);\n      const S = iu(M),\n        P = Tt(su(A), 0, 1);\n      return new mu(S, P);\n    }\n    class Fc {\n      constructor(t, e, r) {\n        this.a = G([], t, r), this.b = G([], e, r), this.center = r;\n        const n = C([], this.a),\n          i = C([], this.b);\n        this.angle = Math.acos(D(n, i));\n      }\n    }\n    function Cc(t, e) {\n      if (0 === t.angle) return null;\n      let r;\n      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {\n        const i = Math.sin(r);\n        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);\n      }(t.a[e], t.b[e], t.angle, Tt(r, 0, 1)) + t.center[e];\n    }\n    function Dc(t) {\n      if (t.z <= 1) return Bc[t.z + 2 * t.y + t.x];\n      const e = Nc(Uc(t));\n      return Xu.fromPoints(e);\n    }\n    function Rc(t, e, r) {\n      return E(t, t, 1 - r), T(t, t, e, r);\n    }\n    function Lc(t, e, r) {\n      for (const n of t) O(n, n, e), E(n, n, r);\n    }\n    function Oc(t, e, r, n) {\n      const i = e / t.worldSize,\n        s = t.globeMatrix;\n      if (r.z <= 1) {\n        const t = Dc(r).getCorners();\n        return Lc(t, s, i), Xu.fromPoints(t);\n      }\n      const o = Uc(r, n),\n        a = Nc(o, Nl + Tc(t._tileCoverLift));\n      Lc(a, s, i);\n      const l = Number.MAX_VALUE,\n        u = [-l, -l, -l],\n        c = [l, l, l];\n      if (o.contains(t.center)) {\n        for (const t of a) k(c, c, t), z(u, u, t);\n        u[2] = 0;\n        const e = t.point,\n          r = [e.x * i, e.y * i, 0];\n        return k(c, c, r), z(u, u, r), new Xu(c, u);\n      }\n      if (t._tileCoverLift > 0) {\n        for (const t of a) k(c, c, t), z(u, u, t);\n        return new Xu(c, u);\n      }\n      const h = [s[12] * i, s[13] * i, s[14] * i],\n        p = o.getCenter(),\n        d = Tt(t.center.lat, -cu, cu),\n        f = Tt(p.lat, -cu, cu),\n        m = iu(t.center.lng),\n        y = su(d);\n      let g = m - iu(p.lng);\n      const x = y - su(f);\n      g > .5 ? g -= 1 : g < -.5 && (g += 1);\n      let v = 0;\n      Math.abs(g) > Math.abs(x) ? v = g >= 0 ? 1 : 3 : (v = x >= 0 ? 0 : 2, T(h, h, [s[4] * i, s[5] * i, s[6] * i], -Math.sin(It(x >= 0 ? o.getSouth() : o.getNorth())) * Nl));\n      const b = a[v],\n        w = a[(v + 1) % 4],\n        _ = new Fc(b, w, h),\n        A = [Cc(_, 0) || b[0], Cc(_, 1) || b[1], Cc(_, 2) || b[2]],\n        M = Yc(t.zoom);\n      if (M > 0) {\n        const n = function (_ref58, n, i, s, o) {\n          let {\n            x: t,\n            y: e,\n            z: r\n          } = _ref58;\n          const a = 1 / (1 << r);\n          let l = t * a,\n            u = l + a,\n            c = e * a,\n            h = c + a,\n            p = 0;\n          const d = (l + u) / 2 - s;\n          return d > .5 ? p = -1 : d < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (o *= n)) * i + o, h = (h * n - o) * i + o, [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]];\n        }(r, e, t._pixelsPerMercatorPixel, m, y);\n        for (let t = 0; t < a.length; t++) Rc(a[t], n[t], M);\n        const i = I([], n[v], n[(v + 1) % 4]);\n        E(i, i, .5), Rc(A, i, M);\n      }\n      for (const t of a) k(c, c, t), z(u, u, t);\n      return c[2] = Math.min(b[2], w[2]), k(c, c, A), z(u, u, A), new Xu(c, u);\n    }\n    function Uc(_ref59) {\n      let {\n        x: t,\n        y: e,\n        z: r\n      } = _ref59;\n      let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      const i = 1 / (1 << r),\n        s = new Ql(au(t * i), e === (1 << r) - 1 && n ? -90 : lu((e + 1) * i)),\n        o = new Ql(au((t + 1) * i), 0 === e && n ? 90 : lu(e * i));\n      return new tu(s, o);\n    }\n    function Nc(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Nl;\n      const r = It(t.getNorth()),\n        n = It(t.getSouth()),\n        i = Math.cos(r),\n        s = Math.cos(n),\n        o = Math.sin(r),\n        a = Math.sin(n),\n        l = t.getWest(),\n        u = t.getEast();\n      return [Wl(s, a, l, e), Wl(s, a, u, e), Wl(i, o, u, e), Wl(i, o, l, e)];\n    }\n    function jc(t, e, r, n) {\n      const i = 1 << r.z,\n        s = (t / Rn + r.x) / i;\n      return Yl(lu((e / Rn + r.y) / i), au(s), n);\n    }\n    function $c(_ref60) {\n      let {\n        min: t,\n        max: e\n      } = _ref60;\n      return Gl / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n    }\n    const Gc = new Float64Array(16);\n    function Hc(t) {\n      const e = $c(t),\n        r = y(Gc, [e, e, e]);\n      return h(r, r, F([], t.min));\n    }\n    function qc(t) {\n      const e = (n = t.min, (r = Gc)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);\n      var r, n;\n      const i = 1 / $c(t);\n      return p(e, e, [i, i, i]);\n    }\n    function Xc(t) {\n      const e = Rn / (2 * Math.PI);\n      return t / (2 * Math.PI) / e;\n    }\n    function Zc(t, e) {\n      return Rn / (512 * Math.pow(2, t)) * $c(Dc(e));\n    }\n    function Wc(t, e, r, n, i) {\n      const s = Xc(r),\n        o = [t, e, -r / (2 * Math.PI)],\n        a = l(new Float64Array(16));\n      return h(a, a, o), p(a, a, [s, s, s]), d(a, a, It(-i)), f(a, a, It(-n)), a;\n    }\n    function Yc(t) {\n      return Bt(jl, $l, t);\n    }\n    function Kc(t, e) {\n      const r = Yl(e.lat, e.lng),\n        n = function (t) {\n          const e = Yl(t._center.lat, t._center.lng);\n          let r = R([], A(0, 1, 0), e);\n          const n = g([], -t.angle, e);\n          r = O(r, r, n), g(n, -t._pitch, r);\n          const i = C([], e);\n          return E(i, i, Tc(t.cameraToCenterDistance / t.pixelsPerMeter)), O(i, i, n), I([], e, i);\n        }(t);\n      return o = (i = S([], n, r))[0], a = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], d = (p = Math.sqrt((o * o + a * a + l * l) * (u * u + c * c + h * h))) && D(i, s) / p, Math.acos(Math.min(Math.max(d, -1), 1));\n      var i, s, o, a, l, u, c, h, p, d;\n    }\n    function Jc(t, e) {\n      return Kc(t, e) > Math.PI / 2 * 1.01;\n    }\n    const Qc = It(85),\n      th = Math.cos(Qc),\n      eh = Math.sin(Qc),\n      rh = a(),\n      nh = t => {\n        const e = [];\n        return \"map\" === t.paint.get(\"circle-pitch-alignment\") && e.push(\"PITCH_WITH_MAP\"), \"map\" === t.paint.get(\"circle-pitch-scale\") && e.push(\"SCALE_WITH_MAP\"), e;\n      };\n    function ih(t, e, r, n, i, s, o, a, l) {\n      if (s && t.queryGeometry.isAboveHorizon) return !1;\n      s && (l *= t.pixelToTileUnitsFactor);\n      const u = t.tileID.canonical,\n        c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;\n      for (const h of e) for (const e of h) {\n        const h = e.add(a),\n          p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0,\n          d = r.projection.projectTilePoint(h.x, h.y, u);\n        if (p > 0) {\n          const t = r.projection.upVector(u, h.x, h.y);\n          d.x += t[0] * c * p, d.y += t[1] * c * p, d.z += t[2] * c * p;\n        }\n        const f = s ? h : sh(d.x, d.y, d.z, n),\n          m = s ? t.tilespaceRays.map(t => lh(t, p)) : t.queryGeometry.screenGeometry,\n          y = Y([], [d.x, d.y, d.z, 1], n);\n        if (!o && s ? l *= y[3] / r.cameraToCenterDistance : o && !s && (l *= r.cameraToCenterDistance / y[3]), s) {\n          const t = lu((e.y / Rn + u.y) / (1 << u.z));\n          l /= r.projection.pixelsPerMeter(t, 1) / ou(1, t);\n        }\n        if (tc(m, f, l)) return !0;\n      }\n      return !1;\n    }\n    function sh(t, e, r, n) {\n      const i = Y([], [t, e, r, 1], n);\n      return new wt(i[0] / i[3], i[1] / i[3]);\n    }\n    const oh = A(0, 0, 0),\n      ah = A(0, 0, 1);\n    function lh(t, e) {\n      const r = b();\n      return oh[2] = e, t.intersectsPlane(oh, ah, r), new wt(r[0], r[1]);\n    }\n    class uh extends Ju {}\n    let ch, hh, ph, dh;\n    function fh(t, _ref61, n, i) {\n      let {\n        width: e,\n        height: r\n      } = _ref61;\n      if (i) {\n        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(\"mismatched image size\");\n      } else i = new Uint8Array(e * r * n);\n      return t.width = e, t.height = r, t.data = i, t;\n    }\n    function mh(t, e, r) {\n      const {\n        width: n,\n        height: i\n      } = e;\n      n === t.width && i === t.height || (yh(t, e, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        width: Math.min(t.width, n),\n        height: Math.min(t.height, i)\n      }, r, null), t.width = n, t.height = i, t.data = e.data);\n    }\n    function yh(t, e, r, n, i, s, o, a) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n      const l = t.data,\n        u = e.data,\n        c = 4 === s && a;\n      for (let a = 0; a < i.height; a++) {\n        const h = ((r.y + a) * t.width + r.x) * s,\n          p = ((n.y + a) * e.width + n.x) * s;\n        if (c) for (let t = 0; t < i.width; t++) {\n          const e = h + t * s + 3,\n            r = p + t * s;\n          u[r + 0] = 255, u[r + 1] = 255, u[r + 2] = 255, u[r + 3] = l[e];\n        } else if (o) for (let t = 0; t < i.width; t++) {\n          const e = h + t * s,\n            r = p + t * s,\n            n = new sr(l[e + 0] / 255, l[e + 1] / 255, l[e + 2] / 255, l[e + 3]).toNonPremultipliedRenderColor(o).toArray();\n          u[r + 0] = n[0], u[r + 1] = n[1], u[r + 2] = n[2], u[r + 3] = n[3];\n        } else for (let t = 0; t < i.width * s; t++) u[p + t] = l[h + t];\n      }\n      return e;\n    }\n    Ws(uh, \"HeatmapBucket\", {\n      omit: [\"layers\"]\n    });\n    class gh {\n      constructor(t, e) {\n        fh(this, t, 1, e);\n      }\n      resize(t) {\n        mh(this, new gh(t), 1);\n      }\n      clone() {\n        return new gh({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i) {\n        yh(t, e, r, n, i, 1, null);\n      }\n    }\n    class xh {\n      constructor(t, e) {\n        fh(this, t, 4, e);\n      }\n      resize(t) {\n        mh(this, new xh(t), 4);\n      }\n      replace(t, e) {\n        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n      }\n      clone() {\n        return new xh({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i, s, o) {\n        yh(t, e, r, n, i, 4, s, o);\n      }\n    }\n    class vh {\n      constructor(t, e) {\n        this.width = t.width, this.height = t.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;\n      }\n    }\n    function bh(t) {\n      const e = {},\n        r = t.resolution || 256,\n        n = t.clips ? t.clips.length : 1,\n        i = t.image || new xh({\n          width: r,\n          height: n\n        }),\n        s = (r, n, s) => {\n          e[t.evaluationKey] = s;\n          const o = t.expression.evaluate(e),\n            a = o ? o.toNonPremultipliedRenderColor(null) : null;\n          a && (i.data[r + n + 0] = Math.floor(255 * a.r), i.data[r + n + 1] = Math.floor(255 * a.g), i.data[r + n + 2] = Math.floor(255 * a.b), i.data[r + n + 3] = Math.floor(255 * a.a));\n        };\n      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, o = 0; n < r; n++, o += 4) {\n        const a = n / (r - 1),\n          {\n            start: l,\n            end: u\n          } = t.clips[e];\n        s(i, o, l * (1 - a) + u * a);\n      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));\n      return i;\n    }\n    Ws(gh, \"AlphaImage\"), Ws(xh, \"RGBAImage\");\n    const wh = aa([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      _h = aa([{\n        name: \"a_road_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      Ah = aa([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_height\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      Mh = aa([{\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }], 4);\n    function Ih(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n      const n = e && e.length,\n        i = n ? e[0] * r : t.length;\n      let s = Sh(t, 0, i, r, !0);\n      const o = [];\n      if (!s || s.next === s.prev) return o;\n      let a, l, u;\n      if (n && (s = function (t, e, r, n) {\n        const i = [];\n        for (let r = 0, s = e.length; r < s; r++) {\n          const o = Sh(t, e[r] * n, r < s - 1 ? e[r + 1] * n : t.length, n, !1);\n          o === o.next && (o.steiner = !0), i.push(Rh(o));\n        }\n        i.sort(Vh);\n        for (let t = 0; t < i.length; t++) r = Fh(i[t], r);\n        return r;\n      }(t, e, s, r)), t.length > 80 * r) {\n        a = t[0], l = t[1];\n        let e = a,\n          n = l;\n        for (let s = r; s < i; s += r) {\n          const r = t[s],\n            i = t[s + 1];\n          r < a && (a = r), i < l && (l = i), r > e && (e = r), i > n && (n = i);\n        }\n        u = Math.max(e - a, n - l), u = 0 !== u ? 32767 / u : 0;\n      }\n      return kh(s, o, r, a, l, u, 0), o;\n    }\n    function Sh(t, e, r, n, i) {\n      let s;\n      if (i === function (t, e, r, n) {\n        let i = 0;\n        for (let s = e, o = r - n; s < r; s += n) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;\n        return i;\n      }(t, e, r, n) > 0) for (let i = e; i < r; i += n) s = Zh(i / n | 0, t[i], t[i + 1], s);else for (let i = r - n; i >= e; i -= n) s = Zh(i / n | 0, t[i], t[i + 1], s);\n      return s && jh(s, s.next) && (Wh(s), s = s.next), s;\n    }\n    function Ph(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      let r,\n        n = t;\n      do {\n        if (r = !1, n.steiner || !jh(n, n.next) && 0 !== Nh(n.prev, n, n.next)) n = n.next;else {\n          if (Wh(n), n = e = n.prev, n === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n      return e;\n    }\n    function kh(t, e, r, n, i, s, o) {\n      if (!t) return;\n      !o && s && function (t, e, r, n) {\n        let i = t;\n        do {\n          0 === i.z && (i.z = Dh(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n        } while (i !== t);\n        i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n          let e,\n            r = 1;\n          do {\n            let n,\n              i = t;\n            t = null;\n            let s = null;\n            for (e = 0; i;) {\n              e++;\n              let o = i,\n                a = 0;\n              for (let t = 0; t < r && (a++, o = o.nextZ, o); t++);\n              let l = r;\n              for (; a > 0 || l > 0 && o;) 0 !== a && (0 === l || !o || i.z <= o.z) ? (n = i, i = i.nextZ, a--) : (n = o, o = o.nextZ, l--), s ? s.nextZ = n : t = n, n.prevZ = s, s = n;\n              i = o;\n            }\n            s.nextZ = null, r *= 2;\n          } while (e > 1);\n        }(i);\n      }(t, n, i, s);\n      let a = t;\n      for (; t.prev !== t.next;) {\n        const l = t.prev,\n          u = t.next;\n        if (s ? Eh(t, n, i, s) : zh(t)) e.push(l.i, t.i, u.i), Wh(t), t = u.next, a = u.next;else if ((t = u) === a) {\n          o ? 1 === o ? kh(t = Th(Ph(t), e), e, r, n, i, s, 2) : 2 === o && Bh(t, e, r, n, i, s) : kh(Ph(t), e, r, n, i, s, 1);\n          break;\n        }\n      }\n    }\n    function zh(t) {\n      const e = t.prev,\n        r = t,\n        n = t.next;\n      if (Nh(e, r, n) >= 0) return !1;\n      const i = e.x,\n        s = r.x,\n        o = n.x,\n        a = e.y,\n        l = r.y,\n        u = n.y,\n        c = Math.min(i, s, o),\n        h = Math.min(a, l, u),\n        p = Math.max(i, s, o),\n        d = Math.max(a, l, u);\n      let f = n.next;\n      for (; f !== e;) {\n        if (f.x >= c && f.x <= p && f.y >= h && f.y <= d && Oh(i, a, s, l, o, u, f.x, f.y) && Nh(f.prev, f, f.next) >= 0) return !1;\n        f = f.next;\n      }\n      return !0;\n    }\n    function Eh(t, e, r, n) {\n      const i = t.prev,\n        s = t,\n        o = t.next;\n      if (Nh(i, s, o) >= 0) return !1;\n      const a = i.x,\n        l = s.x,\n        u = o.x,\n        c = i.y,\n        h = s.y,\n        p = o.y,\n        d = Math.min(a, l, u),\n        f = Math.min(c, h, p),\n        m = Math.max(a, l, u),\n        y = Math.max(c, h, p),\n        g = Dh(d, f, e, r, n),\n        x = Dh(m, y, e, r, n);\n      let v = t.prevZ,\n        b = t.nextZ;\n      for (; v && v.z >= g && b && b.z <= x;) {\n        if (v.x >= d && v.x <= m && v.y >= f && v.y <= y && v !== i && v !== o && Oh(a, c, l, h, u, p, v.x, v.y) && Nh(v.prev, v, v.next) >= 0) return !1;\n        if (v = v.prevZ, b.x >= d && b.x <= m && b.y >= f && b.y <= y && b !== i && b !== o && Oh(a, c, l, h, u, p, b.x, b.y) && Nh(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      for (; v && v.z >= g;) {\n        if (v.x >= d && v.x <= m && v.y >= f && v.y <= y && v !== i && v !== o && Oh(a, c, l, h, u, p, v.x, v.y) && Nh(v.prev, v, v.next) >= 0) return !1;\n        v = v.prevZ;\n      }\n      for (; b && b.z <= x;) {\n        if (b.x >= d && b.x <= m && b.y >= f && b.y <= y && b !== i && b !== o && Oh(a, c, l, h, u, p, b.x, b.y) && Nh(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      return !0;\n    }\n    function Th(t, e) {\n      let r = t;\n      do {\n        const n = r.prev,\n          i = r.next.next;\n        !jh(n, i) && $h(n, r, r.next, i) && qh(n, i) && qh(i, n) && (e.push(n.i, r.i, i.i), Wh(r), Wh(r.next), r = t = i), r = r.next;\n      } while (r !== t);\n      return Ph(r);\n    }\n    function Bh(t, e, r, n, i, s) {\n      let o = t;\n      do {\n        let t = o.next.next;\n        for (; t !== o.prev;) {\n          if (o.i !== t.i && Uh(o, t)) {\n            let a = Xh(o, t);\n            return o = Ph(o, o.next), a = Ph(a, a.next), kh(o, e, r, n, i, s, 0), void kh(a, e, r, n, i, s, 0);\n          }\n          t = t.next;\n        }\n        o = o.next;\n      } while (o !== t);\n    }\n    function Vh(t, e) {\n      let r = t.x - e.x;\n      return 0 === r && (r = t.y - e.y, 0 === r) && (r = (t.next.y - t.y) / (t.next.x - t.x) - (e.next.y - e.y) / (e.next.x - e.x)), r;\n    }\n    function Fh(t, e) {\n      const r = function (t, e) {\n        let r = e;\n        const n = t.x,\n          i = t.y;\n        let s,\n          o = -1 / 0;\n        if (jh(t, r)) return r;\n        do {\n          if (jh(t, r.next)) return r.next;\n          if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {\n            const t = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);\n            if (t <= n && t > o && (o = t, s = r.x < r.next.x ? r : r.next, t === n)) return s;\n          }\n          r = r.next;\n        } while (r !== e);\n        if (!s) return null;\n        const a = s,\n          l = s.x,\n          u = s.y;\n        let c = 1 / 0;\n        r = s;\n        do {\n          if (n >= r.x && r.x >= l && n !== r.x && Lh(i < u ? n : o, i, l, u, i < u ? o : n, i, r.x, r.y)) {\n            const e = Math.abs(i - r.y) / (n - r.x);\n            qh(r, t) && (e < c || e === c && (r.x > s.x || r.x === s.x && Ch(s, r))) && (s = r, c = e);\n          }\n          r = r.next;\n        } while (r !== a);\n        return s;\n      }(t, e);\n      if (!r) return e;\n      const n = Xh(r, t);\n      return Ph(n, n.next), Ph(r, r.next);\n    }\n    function Ch(t, e) {\n      return Nh(t.prev, t, e.prev) < 0 && Nh(e.next, t, t.next) < 0;\n    }\n    function Dh(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n    function Rh(t) {\n      let e = t,\n        r = t;\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n      return r;\n    }\n    function Lh(t, e, r, n, i, s, o, a) {\n      return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (n - a) >= (r - o) * (e - a) && (r - o) * (s - a) >= (i - o) * (n - a);\n    }\n    function Oh(t, e, r, n, i, s, o, a) {\n      return !(t === o && e === a) && Lh(t, e, r, n, i, s, o, a);\n    }\n    function Uh(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        let r = t;\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && $h(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n        return !1;\n      }(t, e) && (qh(t, e) && qh(e, t) && function (t, e) {\n        let r = t,\n          n = !1;\n        const i = (t.x + e.x) / 2,\n          s = (t.y + e.y) / 2;\n        do {\n          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n        return n;\n      }(t, e) && (Nh(t.prev, t, e.prev) || Nh(t, e.prev, e)) || jh(t, e) && Nh(t.prev, t, t.next) > 0 && Nh(e.prev, e, e.next) > 0);\n    }\n    function Nh(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n    function jh(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n    function $h(t, e, r, n) {\n      const i = Hh(Nh(t, e, r)),\n        s = Hh(Nh(t, e, n)),\n        o = Hh(Nh(r, n, t)),\n        a = Hh(Nh(r, n, e));\n      return i !== s && o !== a || !(0 !== i || !Gh(t, r, e)) || !(0 !== s || !Gh(t, n, e)) || !(0 !== o || !Gh(r, t, n)) || !(0 !== a || !Gh(r, e, n));\n    }\n    function Gh(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n    function Hh(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n    function qh(t, e) {\n      return Nh(t.prev, t, t.next) < 0 ? Nh(t, e, t.next) >= 0 && Nh(t, t.prev, e) >= 0 : Nh(t, e, t.prev) < 0 || Nh(t, t.next, e) < 0;\n    }\n    function Xh(t, e) {\n      const r = Yh(t.i, t.x, t.y),\n        n = Yh(e.i, e.x, e.y),\n        i = t.next,\n        s = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;\n    }\n    function Zh(t, e, r, n) {\n      const i = Yh(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n    function Wh(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n    function Yh(t, e, r) {\n      return {\n        i: t,\n        x: e,\n        y: r,\n        prev: null,\n        next: null,\n        z: 0,\n        prevZ: null,\n        nextZ: null,\n        steiner: !1\n      };\n    }\n    function Kh(t, e) {\n      const r = t.length;\n      if (r <= 1) return [t];\n      const n = [];\n      let i, s;\n      for (let e = 0; e < r; e++) {\n        const r = qt(t[e]);\n        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n      }\n      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (sn(n[t], e, 1, n[t].length - 1, Jh), n[t] = n[t].slice(0, e));\n      return n;\n    }\n    function Jh(t, e) {\n      return e.area - t.area;\n    }\n    function Qh(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      if (!t) return null;\n      const n = \"string\" == typeof t ? Cr.from(t).getPrimary() : t.getPrimary(),\n        i = \"string\" == typeof t ? null : t.getSecondary();\n      for (const t of [n, i]) {\n        if (!t) continue;\n        const n = t.id.toString();\n        e.has(n) || e.set(n, []), t.scaleSelf(r), e.get(n).push(t);\n      }\n      return {\n        primary: n.toString(),\n        secondary: i ? i.toString() : null\n      };\n    }\n    function tp(t, e, r, n) {\n      const i = n.patternDependencies;\n      let s = !1;\n      for (const n of e) {\n        const e = n.paint.get(\"\".concat(t, \"-pattern\"));\n        e.isConstant() || (s = !0), Qh(e.constantOr(null), i, r) && (s = !0);\n      }\n      return s;\n    }\n    function ep(t, e, r, n, i, s) {\n      const o = s.patternDependencies;\n      for (const a of e) {\n        const e = a.paint.get(\"\".concat(t, \"-pattern\")).value;\n        if (\"constant\" !== e.kind) {\n          let t = e.evaluate({\n            zoom: n\n          }, r, {}, s.availableImages);\n          t = t && t.name ? t.name : t;\n          const l = Qh(t, o, i);\n          if (!l) continue;\n          const {\n            primary: u,\n            secondary: c\n          } = l;\n          u && (r.patterns[a.id] = [u, c].filter(Boolean));\n        }\n      }\n      return r;\n    }\n    class rp {\n      constructor() {\n        this.polygons = new Map();\n      }\n      add(t) {\n        const r = this.polygons.get(t);\n        for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          e[_key3 - 1] = arguments[_key3];\n        }\n        r ? r.push(...e) : this.polygons.set(t, e);\n      }\n      merge(t) {\n        for (const [e, r] of t.polygons) this.add(e, ...r);\n      }\n    }\n    class np {\n      constructor() {\n        this.portals = [];\n      }\n      static isOnBorder(t, e) {\n        return t <= 0 && e <= 0 || t >= Rn && e >= Rn;\n      }\n      static evaluate(t) {\n        if (0 === t.length) return new np();\n        let e = [];\n        for (const r of t) e.push(...r.portals);\n        if (0 === e.length) return new np();\n        for (const t of e) {\n          const e = t.va,\n            r = t.vb;\n          (np.isOnBorder(e.x, r.x) || np.isOnBorder(e.y, r.y)) && (t.type = \"border\");\n        }\n        const r = e.filter(t => \"unevaluated\" !== t.type),\n          n = e.filter(t => \"unevaluated\" === t.type);\n        if (0 === n.length) return new np();\n        n.sort((t, e) => t.hash === e.hash ? t.isTunnel === e.isTunnel ? 0 : t.isTunnel ? -1 : 1 : t.hash < e.hash ? 1 : -1), e = r.concat(n);\n        let i = r.length,\n          s = i,\n          o = i;\n        do {\n          if (s++, s === e.length || e[i].hash !== e[s].hash) {\n            if (s - i == 2) {\n              o < i && (e[o] = e[i], e[i] = null);\n              const t = e[o],\n                r = e[s - 1];\n              t.type = t.isTunnel !== r.isTunnel ? \"tunnel\" : \"polygon\", t.connection = {\n                a: t.connection.a,\n                b: r.connection.a\n              }, o++;\n            }\n            i = s;\n          }\n        } while (i !== e.length);\n        return e.splice(o), e.sort((t, e) => t.hash < e.hash ? 1 : -1), {\n          portals: e\n        };\n      }\n    }\n    Ws(np, \"ElevationPortalGraph\"), Ws(rp, \"ElevationPolygons\");\n    class ip {\n      constructor(t, e, r) {\n        this.outPositions = t, this.outNormals = e, this.outIndices = r, this.vertexLookup = new Map();\n      }\n      addVertex(t, e, r) {\n        let n = t[2];\n        null != r && (n *= r);\n        const i = \"\".concat(t[0], \",\").concat(t[1], \",\").concat(t[2], \",\").concat(e[0], \",\").concat(e[1], \",\").concat(e[2]),\n          s = this.vertexLookup.get(i);\n        if (null != s) return s;\n        const o = this.outPositions.length;\n        this.vertexLookup.set(i, o);\n        const a = Math.trunc(16384 * e[0]),\n          l = Math.trunc(16384 * e[1]),\n          u = Math.trunc(16384 * e[2]);\n        return this.outPositions.emplaceBack(t[0], t[1], n), this.outNormals.emplaceBack(a, l, u), o;\n      }\n      addTriangle(t, e, r) {\n        this.outIndices.emplaceBack(t, e, r);\n      }\n      addTriangles(t, e, r) {\n        if (0 === t.length) return;\n        const n = 1 === r.length,\n          i = b(),\n          s = b();\n        for (let o = 0; o < t.length; o += 3) {\n          const a = e[t[o + 0]],\n            l = e[t[o + 1]],\n            u = e[t[o + 2]],\n            c = n ? r[0] : r[t[o + 1]],\n            h = n ? r[0] : r[t[o + 2]];\n          M(i, a.x, a.y, n ? r[0] : r[t[o + 0]]);\n          const p = this.addVertex(i, s);\n          M(i, l.x, l.y, c);\n          const d = this.addVertex(i, s);\n          M(i, u.x, u.y, h);\n          const f = this.addVertex(i, s);\n          this.outIndices.emplaceBack(p, d, f);\n        }\n      }\n      addQuad(t, e, r, n, i, s) {\n        const o = this.addVertex(t, i, s),\n          a = this.addVertex(e, i, s),\n          l = this.addVertex(r, i, s),\n          u = this.addVertex(n, i, s);\n        this.addTriangle(o, a, l), this.addTriangle(l, u, o);\n      }\n      getVertexCount() {\n        return this.outPositions.length;\n      }\n      clearVertexLookup() {\n        this.vertexLookup.clear();\n      }\n    }\n    class sp {\n      constructor(t, e, r, n) {\n        this.unevaluatedPortals = new np(), this.portalPolygons = new rp(), this.bridgeFeatureSections = [], this.tunnelFeatureSections = [], this.vertexHashLookup = new Map(), this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new da(), this.vertexNormals = new fa(), this.indexArray = new Ea(), this.tileToMeters = fu(t), this.bridgeProgramConfigurations = new Cl(e, {\n          zoom: r,\n          lut: n\n        }, t => \"fill-tunnel-structure-color\" !== t), this.tunnelProgramConfigurations = new Cl(e, {\n          zoom: r,\n          lut: n\n        }, t => \"fill-bridge-guard-rail-color\" !== t);\n      }\n      addVertices(t, e) {\n        const r = this.unevalVertices.length;\n        for (let r = 0; r < t.length; r++) this.unevalVertices.push(t[r]), this.unevalHeights.push(e[r]);\n        return r;\n      }\n      addTriangles(t, e, r) {\n        const n = r ? this.unevalTunnelTriangles : this.unevalTriangles;\n        for (const r of t) n.push(r + e);\n      }\n      addRenderableRing(t, e, r, n, i, s) {\n        const o = [new wt(i.min.x, i.min.y), new wt(i.max.x, i.min.y), new wt(i.max.x, i.max.y), new wt(i.min.x, i.max.y)];\n        for (let a = 0; a < r - 1; a++) {\n          const r = e + a,\n            l = r + 1,\n            u = this.unevalVertices[r],\n            c = this.unevalVertices[l];\n          if (!(u.x >= i.min.x && u.x <= i.max.x && u.y >= i.min.y && u.y <= i.max.y || c.x >= i.min.x && c.x <= i.max.x && c.y >= i.min.y && c.y <= i.max.y || pc(u, c, o))) continue;\n          if (this.isOnBorder(u.x, c.x) || this.isOnBorder(u.y, c.y)) continue;\n          const h = sp.computeEdgeHash(this.unevalVertices[r], this.unevalVertices[l]);\n          let p,\n            d = this.vertexHashLookup.get(sp.computePosHash(u));\n          null != d ? p = d.next : (d = this.vertexHashLookup.get(sp.computePosHash(c)), p = null != d ? d.prev : h), this.unevalEdges.push({\n            polygonIdx: t,\n            a: r,\n            b: l,\n            hash: h,\n            portalHash: p,\n            isTunnel: n,\n            type: \"unevaluated\",\n            featureInfo: s\n          });\n        }\n      }\n      addPortalCandidates(t, e, r, n, i) {\n        if (0 === e.length) return;\n        this.portalPolygons.add(t, {\n          geometry: e,\n          zLevel: i\n        });\n        const s = e[0];\n        this.vertexHashLookup.clear();\n        let o = sp.computeEdgeHash(s[s.length - 2], s[s.length - 1]);\n        for (let e = 0; e < s.length - 1; e++) {\n          const i = s[e + 0],\n            a = s[e + 1],\n            l = at(a.x - i.x, a.y - i.y),\n            u = pt(l);\n          if (0 === u) continue;\n          let c = \"unevaluated\";\n          const h = n.pointElevation(i),\n            p = n.pointElevation(a);\n          Math.abs(h) < .01 && Math.abs(p) < .01 ? c = \"entrance\" : (this.isOnBorder(i.x, a.x) || this.isOnBorder(i.y, a.y)) && (c = \"border\");\n          const d = sp.computeEdgeHash(i, a);\n          this.unevaluatedPortals.portals.push({\n            connection: {\n              a: t,\n              b: void 0\n            },\n            va: i,\n            vb: a,\n            vab: l,\n            length: u,\n            hash: d,\n            isTunnel: r,\n            type: c\n          });\n          const f = sp.computePosHash(i);\n          this.vertexHashLookup.set(f, {\n            prev: o,\n            next: d\n          }), o = d;\n        }\n      }\n      construct(t) {\n        if (0 === this.unevalVertices.length) return;\n        const e = () => ({\n            vertexOffset: 0,\n            primitiveOffset: this.indexArray.length\n          }),\n          r = t => {\n            t.primitiveLength = this.indexArray.length - t.primitiveOffset;\n          },\n          n = new ip(this.vertexPositions, this.vertexNormals, this.indexArray);\n        this.prepareEdges(t.portals, this.unevalEdges);\n        const i = e(),\n          s = e(),\n          o = e(),\n          a = (t, e) => {\n            t.sort((t, r) => t.type === e && r.type !== e ? -1 : t.type !== e && r.type === e ? 1 : 0);\n            const r = t.findIndex(t => t.type !== e);\n            return r >= 0 ? r : t.length;\n          };\n        let l = 0;\n        this.unevalEdges.length > 0 && (l = a(this.unevalEdges, \"none\"), this.constructBridgeStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {\n          min: 0,\n          max: l\n        }, this.tileToMeters)), r(o);\n        const u = e(),\n          c = e();\n        if (this.unevalEdges.length > 0) {\n          const t = this.unevalEdges.splice(l),\n            e = a(t, \"tunnel\") + l;\n          this.unevalEdges.push(...t), this.constructTunnelStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {\n            min: 0,\n            max: l\n          }, {\n            min: l,\n            max: e\n          });\n        }\n        r(u), n.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r(c), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r(s), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-.1]), r(i), this.maskSegments = al.simpleSegment(0, c.primitiveOffset, 0, c.primitiveLength), this.depthSegments = al.simpleSegment(0, s.primitiveOffset, 0, s.primitiveLength), this.renderableBridgeSegments = al.simpleSegment(0, o.primitiveOffset, 0, o.primitiveLength), this.renderableTunnelSegments = al.simpleSegment(0, u.primitiveOffset, 0, u.primitiveLength), this.shadowCasterSegments = al.simpleSegment(0, i.primitiveOffset, 0, i.primitiveLength);\n      }\n      update(t, e, r, n, i, s, o, a) {\n        this.bridgeProgramConfigurations.updatePaintArrays(t, e, i, r, n, s, o, a), this.tunnelProgramConfigurations.updatePaintArrays(t, e, i, r, n, s, o, a);\n      }\n      upload(t) {\n        this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t.createVertexBuffer(this.vertexPositions, Ah.members), this.vertexBufferNormal = t.createVertexBuffer(this.vertexNormals, Mh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.bridgeProgramConfigurations.upload(t), this.tunnelProgramConfigurations.upload(t));\n      }\n      destroy() {\n        this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableBridgeSegments.destroy(), this.renderableTunnelSegments.destroy(), this.shadowCasterSegments.destroy()), this.bridgeProgramConfigurations.destroy(), this.tunnelProgramConfigurations.destroy();\n      }\n      populatePaintArrays(t, e, r, n, i) {\n        const s = (s, o) => {\n          for (let a = 0; a < o.length - 1; a++) {\n            const l = o[a].featureIndex,\n              u = o[a + 1].vertexStart,\n              c = t.feature(l);\n            s.populatePaintArrays(u, c, l, {}, r, e, n, void 0, i);\n          }\n        };\n        s(this.bridgeProgramConfigurations, this.bridgeFeatureSections), s(this.tunnelProgramConfigurations, this.tunnelFeatureSections);\n      }\n      computeVertexConnections(t, e, r, n, i) {\n        const s = new Map();\n        for (let o = n; o < i; o++) {\n          const n = r[o],\n            i = n.a,\n            a = n.b,\n            l = sp.computePosHash(t[i]),\n            u = sp.computePosHash(t[a]);\n          let c = s.get(l);\n          c || (c = {}, s.set(l, c));\n          let h = s.get(u);\n          h || (h = {}, s.set(u, h)), e[i] <= 0 && e[a] <= 0 || (c.to = a, h.from = i);\n        }\n        return s;\n      }\n      isTerminalVertex(t, e) {\n        const r = sp.computePosHash(this.unevalVertices[t]),\n          n = e.get(r);\n        return !n || !n.from || !n.to;\n      }\n      constructBridgeStructures(t, e, r, n, i, s) {\n        t.clearVertexLookup();\n        const o = this.computeVertexConnections(e, r, n, i.min, i.max),\n          a = 1 / s,\n          l = .5 * a,\n          u = (t, n) => M(t, e[n].x, e[n].y, r[n] * a),\n          c = b(),\n          h = b(),\n          p = b(),\n          d = b(),\n          f = b(),\n          m = (t, r) => {\n            const n = o.get(sp.computePosHash(e[r])),\n              i = n.from,\n              s = n.to;\n            if (!i || !s) return;\n            u(c, i), u(h, r), u(p, s), j(d), $(c, h) || (G(f, h, c), C(d, f)), $(p, h) || (G(f, p, h), I(d, d, C(f, f)));\n            const a = q(d);\n            return a > 0 ? E(t, d, 1 / a) : void 0;\n          };\n        let y = Number.POSITIVE_INFINITY;\n        this.sortSubarray(n, i.min, i.max, (t, e) => t.featureInfo.featureIndex - e.featureInfo.featureIndex);\n        const g = b(),\n          x = b(),\n          v = b(),\n          w = b(),\n          _ = b(),\n          A = b(),\n          S = b(),\n          P = b(),\n          k = b(),\n          z = [b(), b(), b(), b()],\n          T = [b(), b(), b(), b()],\n          B = [{\n            coord: new wt(0, 0),\n            height: 0\n          }, {\n            coord: new wt(0, 0),\n            height: 0\n          }],\n          V = (t, e) => t > e;\n        for (let u = i.min; u < i.max; u++) {\n          const i = n[u];\n          if (!i.featureInfo.guardRailEnabled) continue;\n          if (!this.prepareEdgePoints(B, e, r, i, V)) continue;\n          const [c, h] = B;\n          if (M(g, c.coord.x, c.coord.y, a * c.height), M(x, h.coord.x, h.coord.y, a * h.height), $(g, x)) continue;\n          G(v, x, g), C(v, v);\n          const p = m(P, i.a) || v,\n            d = m(k, i.b) || v;\n          M(w, p[1], -p[0], 0), C(w, w), M(_, d[1], -d[0], 0), C(_, _), R(P, w, p), C(A, P), R(P, _, d), C(S, P), I(z[0], g, E(P, G(P, w, A), l)), I(z[1], g, E(P, I(P, w, A), l)), I(z[2], g, E(P, A, l)), z[3] = g, I(T[0], x, E(P, G(P, _, S), l)), I(T[1], x, E(P, I(P, _, S), l)), I(T[2], x, E(P, S, l)), T[3] = x, y = this.addFeatureSection(i.featureInfo.featureIndex, y, this.bridgeFeatureSections, t);\n          const f = t.addVertex(z[0], w, s),\n            b = t.addVertex(z[1], w, s),\n            D = t.addVertex(T[0], _, s),\n            L = t.addVertex(T[1], _, s);\n          t.addTriangle(f, b, D), t.addTriangle(b, L, D);\n          const O = t.addVertex(z[1], A, s),\n            U = t.addVertex(z[2], A, s),\n            N = t.addVertex(T[1], S, s),\n            j = t.addVertex(T[2], S, s);\n          t.addTriangle(O, U, N), t.addTriangle(U, j, N), F(w, w), F(_, _);\n          const H = t.addVertex(z[2], w, s),\n            q = t.addVertex(z[3], w, s),\n            X = t.addVertex(T[2], _, s),\n            Z = t.addVertex(T[3], _, s);\n          t.addTriangle(H, q, X), t.addTriangle(q, Z, X);\n          const W = this.isTerminalVertex(i.a, o),\n            Y = this.isTerminalVertex(i.b, o);\n          c.height < .01 && W && t.addQuad(z[3], z[2], z[1], z[0], F(p, p), s), h.height < .01 && Y && t.addQuad(T[0], T[1], T[2], T[3], d, s);\n        }\n        this.bridgeFeatureSections.push({\n          featureIndex: Number.POSITIVE_INFINITY,\n          vertexStart: t.getVertexCount()\n        });\n      }\n      constructTunnelStructures(t, e, r, n, i, s) {\n        t.clearVertexLookup();\n        let o = Number.POSITIVE_INFINITY;\n        const a = (t, e) => t.featureInfo.featureIndex - e.featureInfo.featureIndex;\n        this.sortSubarray(n, i.min, i.max, a), this.sortSubarray(n, s.min, s.max, a);\n        const l = t => C(t, t),\n          u = [{\n            coord: new wt(0, 0),\n            height: 0\n          }, {\n            coord: new wt(0, 0),\n            height: 0\n          }],\n          c = (t, e) => t < e,\n          h = b(),\n          p = b(),\n          d = b(),\n          f = b(),\n          m = b();\n        for (let s = i.min; s < i.max; s++) {\n          if (!this.prepareEdgePoints(u, e, r, n[s], c)) continue;\n          const [i, a] = u,\n            y = l(M(m, -(a.coord.y - i.coord.y), a.coord.x - i.coord.x, 0));\n          o = this.addFeatureSection(n[s].featureInfo.featureIndex, o, this.tunnelFeatureSections, t), t.addQuad(M(h, i.coord.x, i.coord.y, i.height), M(p, a.coord.x, a.coord.y, a.height), M(d, a.coord.x, a.coord.y, n[s].isTunnel ? -.1 : 0), M(f, i.coord.x, i.coord.y, n[s].isTunnel ? -.1 : 0), y);\n        }\n        for (let i = s.min; i < s.max; i++) {\n          const s = n[i];\n          s.isTunnel && ([s.a, s.b] = [s.b, s.a]);\n          const a = e[s.a],\n            u = e[s.b],\n            c = l(M(m, -(u.y - a.y), u.x - a.x, 0));\n          o = this.addFeatureSection(s.featureInfo.featureIndex, o, this.tunnelFeatureSections, t), t.addQuad(M(h, u.x, u.y, 0), M(p, a.x, a.y, 0), M(d, a.x, a.y, r[s.a] + 4), M(f, u.x, u.y, r[s.b] + 4), c), t.addQuad(M(h, a.x, a.y, 0), M(p, u.x, u.y, 0), M(d, u.x, u.y, r[s.b] + 4), M(f, a.x, a.y, r[s.a] + 4), c);\n        }\n        this.tunnelFeatureSections.push({\n          featureIndex: Number.POSITIVE_INFINITY,\n          vertexStart: t.getVertexCount()\n        });\n      }\n      setElevatedPoint(t, e, r, n) {\n        t.coord.x = e, t.coord.y = r, t.height = n;\n      }\n      prepareEdgePoints(t, e, r, n, i) {\n        let s = e[n.a].x,\n          o = e[n.a].y,\n          a = e[n.b].x,\n          l = e[n.b].y,\n          u = r[n.a],\n          c = r[n.b];\n        const h = i(u, 0),\n          p = i(c, 0);\n        if (h && p) return this.setElevatedPoint(t[0], s, o, u), this.setElevatedPoint(t[1], a, l, c), !0;\n        if (!h && !p) return !1;\n        if (h) {\n          if (!p) {\n            const t = c / (c - u);\n            a = ur(a, s, t), l = ur(l, o, t), c = ur(c, u, t);\n          }\n        } else {\n          const t = u / (u - c);\n          s = ur(s, a, t), o = ur(o, l, t), u = ur(u, c, t);\n        }\n        return this.setElevatedPoint(t[0], s, o, u), this.setElevatedPoint(t[1], a, l, c), !0;\n      }\n      prepareEdges(t, e) {\n        if (0 === e.length) return;\n        e.sort((t, e) => t.hash === e.hash ? e.polygonIdx - t.polygonIdx : e.hash > t.hash ? 1 : -1);\n        let r = 0,\n          n = 0,\n          i = 0,\n          s = e[r].polygonIdx;\n        do {\n          n++, (n === e.length || e[r].hash !== e[n].hash) && ((1 == n - r || e[n - 1].polygonIdx !== s) && (i < r && (e[i] = e[r], e[r] = null), e[i].type = \"none\", i++), r = n, r !== e.length && (s = e[r].polygonIdx));\n        } while (r !== e.length);\n        if (e.splice(i), 0 !== e.length && 0 !== t.length) {\n          e.sort((t, e) => t.portalHash < e.portalHash ? 1 : -1);\n          let r = 0,\n            n = 0;\n          for (; r !== e.length && n !== t.length;) {\n            const i = e[r],\n              s = t[n];\n            i.portalHash > s.hash ? r++ : s.hash > i.portalHash ? n++ : (i.type = s.type, r++);\n          }\n        }\n      }\n      isOnBorder(t, e) {\n        return t <= 0 && e <= 0 || t >= Rn && e >= Rn;\n      }\n      addFeatureSection(t, e, r, n) {\n        return t !== e && (e = t, r.push({\n          featureIndex: t,\n          vertexStart: n.getVertexCount()\n        }), n.clearVertexLookup()), e;\n      }\n      sortSubarray(t, e, r, n) {\n        const i = t.slice(e, r);\n        i.sort(n), t.splice(e, i.length, ...i);\n      }\n      static computeEdgeHash(t, e) {\n        return (t.y === e.y && t.x > e.x || t.y > e.y) && ([t, e] = [e, t]), BigInt(sp.computePosHash(t)) << 32n | BigInt(sp.computePosHash(e));\n      }\n      static computePosHash(t) {\n        return ((65535 & t.x) << 16 | 65535 & t.y) >>> 0;\n      }\n    }\n    var op,\n      ap = {\n        exports: {}\n      },\n      lp = (op || (op = 1, function (t, e) {\n        !function (t) {\n          function e(t, e) {\n            return t > e ? 1 : t < e ? -1 : 0;\n          }\n          var r = function (t, r) {\n              void 0 === t && (t = e), void 0 === r && (r = !1), this._compare = t, this._root = null, this._size = 0, this._noDuplicates = !!r;\n            },\n            n = {\n              size: {\n                configurable: !0\n              }\n            };\n          function i(t, e, r, n, s) {\n            var o = s - n;\n            if (o > 0) {\n              var a = n + Math.floor(o / 2),\n                l = {\n                  key: e[a],\n                  data: r[a],\n                  parent: t\n                };\n              return l.left = i(l, e, r, n, a), l.right = i(l, e, r, a + 1, s), l;\n            }\n            return null;\n          }\n          function s(t, e, r, n, i) {\n            if (!(r >= n)) {\n              for (var o = t[r + n >> 1], a = r - 1, l = n + 1;;) {\n                do {\n                  a++;\n                } while (i(t[a], o) < 0);\n                do {\n                  l--;\n                } while (i(t[l], o) > 0);\n                if (a >= l) break;\n                var u = t[a];\n                t[a] = t[l], t[l] = u, u = e[a], e[a] = e[l], e[l] = u;\n              }\n              s(t, e, r, l, i), s(t, e, l + 1, n, i);\n            }\n          }\n          r.prototype.rotateLeft = function (t) {\n            var e = t.right;\n            e && (t.right = e.left, e.left && (e.left.parent = t), e.parent = t.parent), t.parent ? t === t.parent.left ? t.parent.left = e : t.parent.right = e : this._root = e, e && (e.left = t), t.parent = e;\n          }, r.prototype.rotateRight = function (t) {\n            var e = t.left;\n            e && (t.left = e.right, e.right && (e.right.parent = t), e.parent = t.parent), t.parent ? t === t.parent.left ? t.parent.left = e : t.parent.right = e : this._root = e, e && (e.right = t), t.parent = e;\n          }, r.prototype._splay = function (t) {\n            for (; t.parent;) {\n              var e = t.parent;\n              e.parent ? e.left === t && e.parent.left === e ? (this.rotateRight(e.parent), this.rotateRight(e)) : e.right === t && e.parent.right === e ? (this.rotateLeft(e.parent), this.rotateLeft(e)) : e.left === t && e.parent.right === e ? (this.rotateRight(e), this.rotateLeft(e)) : (this.rotateLeft(e), this.rotateRight(e)) : e.left === t ? this.rotateRight(e) : this.rotateLeft(e);\n            }\n          }, r.prototype.splay = function (t) {\n            for (var e, r, n, i, s; t.parent;) (r = (e = t.parent).parent) && r.parent ? ((n = r.parent).left === r ? n.left = t : n.right = t, t.parent = n) : (t.parent = null, this._root = t), i = t.left, s = t.right, t === e.left ? (r && (r.left === e ? (e.right ? (r.left = e.right, r.left.parent = r) : r.left = null, e.right = r, r.parent = e) : (i ? (r.right = i, i.parent = r) : r.right = null, t.left = r, r.parent = t)), s ? (e.left = s, s.parent = e) : e.left = null, t.right = e, e.parent = t) : (r && (r.right === e ? (e.left ? (r.right = e.left, r.right.parent = r) : r.right = null, e.left = r, r.parent = e) : (s ? (r.left = s, s.parent = r) : r.left = null, t.right = r, r.parent = t)), i ? (e.right = i, i.parent = e) : e.right = null, t.left = e, e.parent = t);\n          }, r.prototype.replace = function (t, e) {\n            t.parent ? t === t.parent.left ? t.parent.left = e : t.parent.right = e : this._root = e, e && (e.parent = t.parent);\n          }, r.prototype.minNode = function (t) {\n            if (void 0 === t && (t = this._root), t) for (; t.left;) t = t.left;\n            return t;\n          }, r.prototype.maxNode = function (t) {\n            if (void 0 === t && (t = this._root), t) for (; t.right;) t = t.right;\n            return t;\n          }, r.prototype.insert = function (t, e) {\n            var r = this._root,\n              n = null,\n              i = this._compare;\n            if (this._noDuplicates) for (; r;) {\n              if (n = r, 0 === i(r.key, t)) return;\n              r = i(r.key, t) < 0 ? r.right : r.left;\n            } else for (; r;) n = r, r = i(r.key, t) < 0 ? r.right : r.left;\n            return r = {\n              key: t,\n              data: e,\n              left: null,\n              right: null,\n              parent: n\n            }, n ? i(n.key, r.key) < 0 ? n.right = r : n.left = r : this._root = r, this.splay(r), this._size++, r;\n          }, r.prototype.find = function (t) {\n            for (var e = this._root, r = this._compare; e;) {\n              var n = r(e.key, t);\n              if (n < 0) e = e.right;else {\n                if (!(n > 0)) return e;\n                e = e.left;\n              }\n            }\n            return null;\n          }, r.prototype.contains = function (t) {\n            for (var e = this._root, r = this._compare; e;) {\n              var n = r(t, e.key);\n              if (0 === n) return !0;\n              e = n < 0 ? e.left : e.right;\n            }\n            return !1;\n          }, r.prototype.remove = function (t) {\n            var e = this.find(t);\n            if (!e) return !1;\n            if (this.splay(e), e.left) {\n              if (e.right) {\n                var r = this.minNode(e.right);\n                r.parent !== e && (this.replace(r, r.right), r.right = e.right, r.right.parent = r), this.replace(e, r), r.left = e.left, r.left.parent = r;\n              } else this.replace(e, e.left);\n            } else this.replace(e, e.right);\n            return this._size--, !0;\n          }, r.prototype.removeNode = function (t) {\n            if (!t) return !1;\n            if (this.splay(t), t.left) {\n              if (t.right) {\n                var e = this.minNode(t.right);\n                e.parent !== t && (this.replace(e, e.right), e.right = t.right, e.right.parent = e), this.replace(t, e), e.left = t.left, e.left.parent = e;\n              } else this.replace(t, t.left);\n            } else this.replace(t, t.right);\n            return this._size--, !0;\n          }, r.prototype.erase = function (t) {\n            var e = this.find(t);\n            if (e) {\n              this.splay(e);\n              var r = e.left,\n                n = e.right,\n                i = null;\n              r && (r.parent = null, i = this.maxNode(r), this.splay(i), this._root = i), n && (r ? i.right = n : this._root = n, n.parent = i), this._size--;\n            }\n          }, r.prototype.pop = function () {\n            var t = this._root,\n              e = null;\n            if (t) {\n              for (; t.left;) t = t.left;\n              e = {\n                key: t.key,\n                data: t.data\n              }, this.remove(t.key);\n            }\n            return e;\n          }, r.prototype.next = function (t) {\n            var e = t;\n            if (e) if (e.right) for (e = e.right; e && e.left;) e = e.left;else for (e = t.parent; e && e.right === t;) t = e, e = e.parent;\n            return e;\n          }, r.prototype.prev = function (t) {\n            var e = t;\n            if (e) if (e.left) for (e = e.left; e && e.right;) e = e.right;else for (e = t.parent; e && e.left === t;) t = e, e = e.parent;\n            return e;\n          }, r.prototype.forEach = function (t) {\n            for (var e = this._root, r = [], n = !1, i = 0; !n;) e ? (r.push(e), e = e.left) : r.length > 0 ? (t(e = r.pop(), i++), e = e.right) : n = !0;\n            return this;\n          }, r.prototype.range = function (t, e, r, n) {\n            for (var i = [], s = this._compare, o = this._root; 0 !== i.length || o;) if (o) i.push(o), o = o.left;else {\n              if (s((o = i.pop()).key, e) > 0) break;\n              if (s(o.key, t) >= 0 && r.call(n, o)) return this;\n              o = o.right;\n            }\n            return this;\n          }, r.prototype.keys = function () {\n            for (var t = this._root, e = [], r = [], n = !1; !n;) t ? (e.push(t), t = t.left) : e.length > 0 ? (t = e.pop(), r.push(t.key), t = t.right) : n = !0;\n            return r;\n          }, r.prototype.values = function () {\n            for (var t = this._root, e = [], r = [], n = !1; !n;) t ? (e.push(t), t = t.left) : e.length > 0 ? (t = e.pop(), r.push(t.data), t = t.right) : n = !0;\n            return r;\n          }, r.prototype.at = function (t) {\n            for (var e = this._root, r = [], n = !1, i = 0; !n;) if (e) r.push(e), e = e.left;else if (r.length > 0) {\n              if (e = r.pop(), i === t) return e;\n              i++, e = e.right;\n            } else n = !0;\n            return null;\n          }, r.prototype.load = function (t, e, r) {\n            if (void 0 === t && (t = []), void 0 === e && (e = []), void 0 === r && (r = !1), 0 !== this._size) throw new Error(\"bulk-load: tree is not empty\");\n            var n = t.length;\n            return r && s(t, e, 0, n - 1, this._compare), this._root = i(null, t, e, 0, n), this._size = n, this;\n          }, r.prototype.min = function () {\n            var t = this.minNode(this._root);\n            return t ? t.key : null;\n          }, r.prototype.max = function () {\n            var t = this.maxNode(this._root);\n            return t ? t.key : null;\n          }, r.prototype.isEmpty = function () {\n            return null === this._root;\n          }, n.size.get = function () {\n            return this._size;\n          }, r.createTree = function (t, e, n, i, s) {\n            return new r(n, s).load(t, e, i);\n          }, Object.defineProperties(r.prototype, n);\n          var o = 0,\n            a = 1,\n            l = 2,\n            u = 3,\n            c = 0,\n            h = 1,\n            p = 2,\n            d = 3;\n          function f(t, e, r) {\n            null === e ? (t.inOut = !1, t.otherInOut = !0) : (t.isSubject === e.isSubject ? (t.inOut = !e.inOut, t.otherInOut = e.otherInOut) : (t.inOut = !e.otherInOut, t.otherInOut = e.isVertical() ? !e.inOut : e.inOut), e && (t.prevInResult = !m(e, r) || e.isVertical() ? e.prevInResult : e));\n            var n = m(t, r);\n            t.resultTransition = n ? function (t, e) {\n              var r,\n                n = !t.inOut,\n                i = !t.otherInOut;\n              switch (e) {\n                case c:\n                  r = n && i;\n                  break;\n                case h:\n                  r = n || i;\n                  break;\n                case d:\n                  r = n ^ i;\n                  break;\n                case p:\n                  r = t.isSubject ? n && !i : i && !n;\n              }\n              return r ? 1 : -1;\n            }(t, r) : 0;\n          }\n          function m(t, e) {\n            switch (t.type) {\n              case o:\n                switch (e) {\n                  case c:\n                    return !t.otherInOut;\n                  case h:\n                    return t.otherInOut;\n                  case p:\n                    return t.isSubject && t.otherInOut || !t.isSubject && !t.otherInOut;\n                  case d:\n                    return !0;\n                }\n                break;\n              case l:\n                return e === c || e === h;\n              case u:\n                return e === p;\n              case a:\n                return !1;\n            }\n            return !1;\n          }\n          var y = function (t, e, r, n, i) {\n              this.left = e, this.point = t, this.otherEvent = r, this.isSubject = n, this.type = i || o, this.inOut = !1, this.otherInOut = !1, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = !0;\n            },\n            g = {\n              inResult: {\n                configurable: !0\n              }\n            };\n          function x(t, e) {\n            return t[0] === e[0] && t[1] === e[1];\n          }\n          y.prototype.isBelow = function (t) {\n            var e = this.point,\n              r = this.otherEvent.point;\n            return this.left ? (e[0] - t[0]) * (r[1] - t[1]) - (r[0] - t[0]) * (e[1] - t[1]) > 0 : (r[0] - t[0]) * (e[1] - t[1]) - (e[0] - t[0]) * (r[1] - t[1]) > 0;\n          }, y.prototype.isAbove = function (t) {\n            return !this.isBelow(t);\n          }, y.prototype.isVertical = function () {\n            return this.point[0] === this.otherEvent.point[0];\n          }, g.inResult.get = function () {\n            return 0 !== this.resultTransition;\n          }, y.prototype.clone = function () {\n            var t = new y(this.point, this.left, this.otherEvent, this.isSubject, this.type);\n            return t.contourId = this.contourId, t.resultTransition = this.resultTransition, t.prevInResult = this.prevInResult, t.isExteriorRing = this.isExteriorRing, t.inOut = this.inOut, t.otherInOut = this.otherInOut, t;\n          }, Object.defineProperties(y.prototype, g);\n          var v = 11102230246251565e-32,\n            b = 134217729,\n            w = (3 + 8 * v) * v;\n          function _(t, e, r, n, i) {\n            var s,\n              o,\n              a,\n              l,\n              u = e[0],\n              c = n[0],\n              h = 0,\n              p = 0;\n            c > u == c > -u ? (s = u, u = e[++h]) : (s = c, c = n[++p]);\n            var d = 0;\n            if (h < t && p < r) for (c > u == c > -u ? (a = s - ((o = u + s) - u), u = e[++h]) : (a = s - ((o = c + s) - c), c = n[++p]), s = o, 0 !== a && (i[d++] = a); h < t && p < r;) c > u == c > -u ? (a = s - ((o = s + u) - (l = o - s)) + (u - l), u = e[++h]) : (a = s - ((o = s + c) - (l = o - s)) + (c - l), c = n[++p]), s = o, 0 !== a && (i[d++] = a);\n            for (; h < t;) a = s - ((o = s + u) - (l = o - s)) + (u - l), u = e[++h], s = o, 0 !== a && (i[d++] = a);\n            for (; p < r;) a = s - ((o = s + c) - (l = o - s)) + (c - l), c = n[++p], s = o, 0 !== a && (i[d++] = a);\n            return 0 === s && 0 !== d || (i[d++] = s), d;\n          }\n          function A(t) {\n            return new Float64Array(t);\n          }\n          var M = 33306690738754716e-32,\n            I = 22204460492503146e-32,\n            S = 11093356479670487e-47,\n            P = A(4),\n            k = A(8),\n            z = A(12),\n            E = A(16),\n            T = A(4);\n          function B(t, e, r) {\n            var n = function (t, e, r, n, i, s) {\n              var o = (e - s) * (r - i),\n                a = (t - i) * (n - s),\n                l = o - a;\n              if (0 === o || 0 === a || o > 0 != a > 0) return l;\n              var u = Math.abs(o + a);\n              return Math.abs(l) >= M * u ? l : -function (t, e, r, n, i, s, o) {\n                var a,\n                  l,\n                  u,\n                  c,\n                  h,\n                  p,\n                  d,\n                  f,\n                  m,\n                  y,\n                  g,\n                  x,\n                  v,\n                  A,\n                  M,\n                  B,\n                  V,\n                  F,\n                  C = t - i,\n                  D = r - i,\n                  R = e - s,\n                  L = n - s;\n                P[0] = (M = (f = C - (d = (p = b * C) - (p - C))) * (y = L - (m = (p = b * L) - (p - L))) - ((A = C * L) - d * m - f * m - d * y)) - ((g = M - (V = (f = R - (d = (p = b * R) - (p - R))) * (y = D - (m = (p = b * D) - (p - D))) - ((B = R * D) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), P[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), P[2] = x - ((F = x + g) - (h = F - x)) + (g - h), P[3] = F;\n                var O = function (t, e) {\n                    for (var r = e[0], n = 1; n < 4; n++) r += e[n];\n                    return r;\n                  }(0, P),\n                  U = I * o;\n                if (O >= U || -O >= U) return O;\n                if (a = t - (C + (h = t - C)) + (h - i), u = r - (D + (h = r - D)) + (h - i), l = e - (R + (h = e - R)) + (h - s), c = n - (L + (h = n - L)) + (h - s), 0 === a && 0 === l && 0 === u && 0 === c) return O;\n                if (U = S * o + w * Math.abs(O), (O += C * c + L * a - (R * u + D * l)) >= U || -O >= U) return O;\n                T[0] = (M = (f = a - (d = (p = b * a) - (p - a))) * (y = L - (m = (p = b * L) - (p - L))) - ((A = a * L) - d * m - f * m - d * y)) - ((g = M - (V = (f = l - (d = (p = b * l) - (p - l))) * (y = D - (m = (p = b * D) - (p - D))) - ((B = l * D) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), T[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), T[2] = x - ((F = x + g) - (h = F - x)) + (g - h), T[3] = F;\n                var N = _(4, P, 4, T, k);\n                T[0] = (M = (f = C - (d = (p = b * C) - (p - C))) * (y = c - (m = (p = b * c) - (p - c))) - ((A = C * c) - d * m - f * m - d * y)) - ((g = M - (V = (f = R - (d = (p = b * R) - (p - R))) * (y = u - (m = (p = b * u) - (p - u))) - ((B = R * u) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), T[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), T[2] = x - ((F = x + g) - (h = F - x)) + (g - h), T[3] = F;\n                var j = _(N, k, 4, T, z);\n                T[0] = (M = (f = a - (d = (p = b * a) - (p - a))) * (y = c - (m = (p = b * c) - (p - c))) - ((A = a * c) - d * m - f * m - d * y)) - ((g = M - (V = (f = l - (d = (p = b * l) - (p - l))) * (y = u - (m = (p = b * u) - (p - u))) - ((B = l * u) - d * m - f * m - d * y))) + (h = M - g)) + (h - V), T[1] = (v = A - ((x = A + g) - (h = x - A)) + (g - h)) - ((g = v - B) + (h = v - g)) + (h - B), T[2] = x - ((F = x + g) - (h = F - x)) + (g - h), T[3] = F;\n                var $ = _(j, z, 4, T, E);\n                return E[$ - 1];\n              }(t, e, r, n, i, s, u);\n            }(t[0], t[1], e[0], e[1], r[0], r[1]);\n            return n > 0 ? -1 : n < 0 ? 1 : 0;\n          }\n          function V(t, e) {\n            var r = t.point,\n              n = e.point;\n            return r[0] > n[0] ? 1 : r[0] < n[0] ? -1 : r[1] !== n[1] ? r[1] > n[1] ? 1 : -1 : function (t, e, r, n) {\n              return t.left !== e.left ? t.left ? 1 : -1 : 0 !== B(r, t.otherEvent.point, e.otherEvent.point) ? t.isBelow(e.otherEvent.point) ? -1 : 1 : !t.isSubject && e.isSubject ? 1 : -1;\n            }(t, e, r);\n          }\n          function F(t, e, r) {\n            var n = new y(e, !1, t, t.isSubject),\n              i = new y(e, !0, t.otherEvent, t.isSubject);\n            return x(t.point, t.otherEvent.point) && console.warn(\"what is that, a collapsed segment?\", t), n.contourId = i.contourId = t.contourId, V(i, t.otherEvent) > 0 && (t.otherEvent.left = !0, i.left = !1), t.otherEvent.otherEvent = i, t.otherEvent = n, r.push(i), r.push(n), r;\n          }\n          function C(t, e) {\n            return t[0] * e[1] - t[1] * e[0];\n          }\n          function D(t, e) {\n            return t[0] * e[0] + t[1] * e[1];\n          }\n          function R(t, e, r) {\n            var n = function (t, e, r, n, i) {\n                var s = [e[0] - t[0], e[1] - t[1]],\n                  o = [n[0] - r[0], n[1] - r[1]];\n                function a(t, e, r) {\n                  return [t[0] + e * r[0], t[1] + e * r[1]];\n                }\n                var l = [r[0] - t[0], r[1] - t[1]],\n                  u = C(s, o),\n                  c = u * u,\n                  h = D(s, s);\n                if (c > 0) {\n                  var p = C(l, o) / u;\n                  if (p < 0 || p > 1) return null;\n                  var d = C(l, s) / u;\n                  return d < 0 || d > 1 ? null : 0 === p || 1 === p ? [a(t, p, s)] : 0 === d || 1 === d ? [a(r, d, o)] : [a(t, p, s)];\n                }\n                if ((c = (u = C(l, s)) * u) > 0) return null;\n                var f = D(s, l) / h,\n                  m = f + D(s, o) / h,\n                  y = Math.min(f, m),\n                  g = Math.max(f, m);\n                return y <= 1 && g >= 0 ? 1 === y ? [a(t, y > 0 ? y : 0, s)] : 0 === g ? [a(t, g < 1 ? g : 1, s)] : [a(t, y > 0 ? y : 0, s), a(t, g < 1 ? g : 1, s)] : null;\n              }(t.point, t.otherEvent.point, e.point, e.otherEvent.point),\n              i = n ? n.length : 0;\n            if (0 === i) return 0;\n            if (1 === i && (x(t.point, e.point) || x(t.otherEvent.point, e.otherEvent.point))) return 0;\n            if (2 === i && t.isSubject === e.isSubject) return 0;\n            if (1 === i) return x(t.point, n[0]) || x(t.otherEvent.point, n[0]) || F(t, n[0], r), x(e.point, n[0]) || x(e.otherEvent.point, n[0]) || F(e, n[0], r), 1;\n            var s = [],\n              o = !1,\n              c = !1;\n            return x(t.point, e.point) ? o = !0 : 1 === V(t, e) ? s.push(e, t) : s.push(t, e), x(t.otherEvent.point, e.otherEvent.point) ? c = !0 : 1 === V(t.otherEvent, e.otherEvent) ? s.push(e.otherEvent, t.otherEvent) : s.push(t.otherEvent, e.otherEvent), o && c || o ? (e.type = a, t.type = e.inOut === t.inOut ? l : u, o && !c && F(s[1].otherEvent, s[0].point, r), 2) : c ? (F(s[0], s[1].point, r), 3) : s[0] !== s[3].otherEvent ? (F(s[0], s[1].point, r), F(s[1], s[2].point, r), 3) : (F(s[0], s[1].point, r), F(s[3].otherEvent, s[2].point, r), 3);\n          }\n          function L(t, e) {\n            if (t === e) return 0;\n            if (0 !== B(t.point, t.otherEvent.point, e.point) || 0 !== B(t.point, t.otherEvent.point, e.otherEvent.point)) return x(t.point, e.point) ? t.isBelow(e.otherEvent.point) ? -1 : 1 : t.point[0] === e.point[0] ? t.point[1] < e.point[1] ? -1 : 1 : 1 === V(t, e) ? e.isAbove(t.point) ? -1 : 1 : t.isBelow(e.point) ? -1 : 1;\n            if (t.isSubject !== e.isSubject) return t.isSubject ? -1 : 1;\n            var r = t.point,\n              n = e.point;\n            return r[0] === n[0] && r[1] === n[1] ? (r = t.otherEvent.point)[0] === (n = e.otherEvent.point)[0] && r[1] === n[1] ? 0 : t.contourId > e.contourId ? 1 : -1 : 1 === V(t, e) ? 1 : -1;\n          }\n          var O = function () {\n            this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;\n          };\n          function U(t, e, r, n) {\n            var i,\n              s = t + 1,\n              o = e[t].point,\n              a = e.length;\n            for (s < a && (i = e[s].point); s < a && i[0] === o[0] && i[1] === o[1];) {\n              if (!r[s]) return s;\n              ++s < a && (i = e[s].point);\n            }\n            for (s = t - 1; r[s] && s > n;) s--;\n            return s;\n          }\n          O.prototype.isExterior = function () {\n            return null == this.holeOf;\n          };\n          var N = $,\n            j = $;\n          function $(t, e) {\n            if (!(this instanceof $)) return new $(t, e);\n            if (this.data = t || [], this.length = this.data.length, this.compare = e || G, this.length > 0) for (var r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);\n          }\n          function G(t, e) {\n            return t < e ? -1 : t > e ? 1 : 0;\n          }\n          $.prototype = {\n            push: function (t) {\n              this.data.push(t), this.length++, this._up(this.length - 1);\n            },\n            pop: function () {\n              if (0 !== this.length) {\n                var t = this.data[0];\n                return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t;\n              }\n            },\n            peek: function () {\n              return this.data[0];\n            },\n            _up: function (t) {\n              for (var e = this.data, r = this.compare, n = e[t]; t > 0;) {\n                var i = t - 1 >> 1,\n                  s = e[i];\n                if (r(n, s) >= 0) break;\n                e[t] = s, t = i;\n              }\n              e[t] = n;\n            },\n            _down: function (t) {\n              for (var e = this.data, r = this.compare, n = this.length >> 1, i = e[t]; t < n;) {\n                var s = 1 + (t << 1),\n                  o = s + 1,\n                  a = e[s];\n                if (o < this.length && r(e[o], a) < 0 && (s = o, a = e[o]), r(a, i) >= 0) break;\n                e[t] = a, t = s;\n              }\n              e[t] = i;\n            }\n          }, N.default = j;\n          var H = Math.max,\n            q = Math.min,\n            X = 0;\n          function Z(t, e, r, n, i, s) {\n            var o, a, l, u, c, h;\n            for (o = 0, a = t.length - 1; o < a; o++) if (u = t[o + 1], c = new y(l = t[o], !1, void 0, e), h = new y(u, !1, c, e), c.otherEvent = h, l[0] !== u[0] || l[1] !== u[1]) {\n              c.contourId = h.contourId = r, s || (c.isExteriorRing = !1, h.isExteriorRing = !1), V(c, h) > 0 ? h.left = !0 : c.left = !0;\n              var p = l[0],\n                d = l[1];\n              i[0] = q(i[0], p), i[1] = q(i[1], d), i[2] = H(i[2], p), i[3] = H(i[3], d), n.push(c), n.push(h);\n            }\n          }\n          var W = [];\n          function Y(t, e, n) {\n            \"number\" == typeof t[0][0][0] && (t = [t]), \"number\" == typeof e[0][0][0] && (e = [e]);\n            var i = function (t, e, r) {\n              var n = null;\n              return t.length * e.length == 0 && (r === c ? n = W : r === p ? n = t : r !== h && r !== d || (n = 0 === t.length ? e : t)), n;\n            }(t, e, n);\n            if (i) return i === W ? null : i;\n            var s = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              o = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              a = function (t, e, r, n, i) {\n                var s,\n                  o,\n                  a,\n                  l,\n                  u,\n                  c,\n                  h = new N(null, V);\n                for (a = 0, l = t.length; a < l; a++) for (u = 0, c = (s = t[a]).length; u < c; u++) (o = 0 === u) && X++, Z(s[u], !0, X, h, r, o);\n                for (a = 0, l = e.length; a < l; a++) for (u = 0, c = (s = e[a]).length; u < c; u++) o = 0 === u, i === p && (o = !1), o && X++, Z(s[u], !1, X, h, n, o);\n                return h;\n              }(t, e, s, o, n);\n            if (i = function (t, e, r, n, i) {\n              var s = null;\n              return (r[0] > n[2] || n[0] > r[2] || r[1] > n[3] || n[1] > r[3]) && (i === c ? s = W : i === p ? s = t : i !== h && i !== d || (s = t.concat(e))), s;\n            }(t, e, s, o, n)) return i === W ? null : i;\n            for (var l = function (t) {\n                var e,\n                  r,\n                  n = function (t) {\n                    var e,\n                      r,\n                      n,\n                      i,\n                      s = [];\n                    for (r = 0, n = t.length; r < n; r++) ((e = t[r]).left && e.inResult || !e.left && e.otherEvent.inResult) && s.push(e);\n                    for (var o = !1; !o;) for (o = !0, r = 0, n = s.length; r < n; r++) r + 1 < n && 1 === V(s[r], s[r + 1]) && (i = s[r], s[r] = s[r + 1], s[r + 1] = i, o = !1);\n                    for (r = 0, n = s.length; r < n; r++) (e = s[r]).otherPos = r;\n                    for (r = 0, n = s.length; r < n; r++) (e = s[r]).left || (i = e.otherPos, e.otherPos = e.otherEvent.otherPos, e.otherEvent.otherPos = i);\n                    return s;\n                  }(t),\n                  i = {},\n                  s = [],\n                  o = function () {\n                    if (!i[e]) {\n                      var t = s.length,\n                        r = function (t, e, r) {\n                          var n = new O();\n                          if (null != t.prevInResult) {\n                            var i = t.prevInResult,\n                              s = i.outputContourId;\n                            if (i.resultTransition > 0) {\n                              var o = e[s];\n                              if (null != o.holeOf) {\n                                var a = o.holeOf;\n                                e[a].holeIds.push(r), n.holeOf = a, n.depth = e[s].depth;\n                              } else e[s].holeIds.push(r), n.holeOf = s, n.depth = e[s].depth + 1;\n                            } else n.holeOf = null, n.depth = e[s].depth;\n                          } else n.holeOf = null, n.depth = 0;\n                          return n;\n                        }(n[e], s, t),\n                        o = function (e) {\n                          i[e] = !0, e < n.length && n[e] && (n[e].outputContourId = t);\n                        },\n                        a = e,\n                        l = e;\n                      for (r.points.push(n[e].point); o(a), o(a = n[a].otherPos), r.points.push(n[a].point), !((a = U(a, n, i, l)) == l || a >= n.length) && n[a];);\n                      s.push(r);\n                    }\n                  };\n                for (e = 0, r = n.length; e < r; e++) o();\n                return s;\n              }(function (t, e, n, i, s, o) {\n                for (var a, l, u, h = new r(L), d = [], m = Math.min(i[2], s[2]); 0 !== t.length;) {\n                  var y = t.pop();\n                  if (d.push(y), o === c && y.point[0] > m || o === p && y.point[0] > i[2]) break;\n                  if (y.left) {\n                    l = a = h.insert(y), a = a !== (u = h.minNode()) ? h.prev(a) : null, l = h.next(l);\n                    var g = a ? a.key : null;\n                    if (f(y, g, o), l && 2 === R(y, l.key, t) && (f(y, g, o), f(l.key, y, o)), a && 2 === R(a.key, y, t)) {\n                      var x = a;\n                      f(g, (x = x !== u ? h.prev(x) : null) ? x.key : null, o), f(y, g, o);\n                    }\n                  } else l = a = h.find(y = y.otherEvent), a && l && (a = a !== u ? h.prev(a) : null, l = h.next(l), h.remove(y), l && a && R(a.key, l.key, t));\n                }\n                return d;\n              }(a, 0, 0, s, o, n)), u = [], m = 0; m < l.length; m++) {\n              var y = l[m];\n              if (y.isExterior()) {\n                for (var g = [y.points], x = 0; x < y.holeIds.length; x++) g.push(l[y.holeIds[x]].points);\n                u.push(g);\n              }\n            }\n            return u;\n          }\n          var K = {\n            UNION: h,\n            DIFFERENCE: p,\n            INTERSECTION: c,\n            XOR: d\n          };\n          t.diff = function (t, e) {\n            return Y(t, e, p);\n          }, t.intersection = function (t, e) {\n            return Y(t, e, c);\n          }, t.operations = K, t.union = function (t, e) {\n            return Y(t, e, h);\n          }, t.xor = function (t, e) {\n            return Y(t, e, d);\n          }, Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          });\n        }(e);\n      }(0, ap.exports)), ap.exports);\n    /**\n     * martinez v0.7.4\n     * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n     *\n     * @author Alex Milevski <info@w8r.name>\n     * @license MIT\n     * @preserve\n     */\n    function up(t, e, r, n) {\n      const i = [],\n        s = 0 === n ? (t, e, r, n, i, s) => {\n          t.push(new wt(s, r + (s - e) / (n - e) * (i - r)));\n        } : (t, e, r, n, i, s) => {\n          t.push(new wt(e + (s - r) / (i - r) * (n - e), s));\n        };\n      for (const o of t) {\n        const t = [];\n        for (const i of o) {\n          if (i.length <= 2) continue;\n          const o = [];\n          for (let t = 0; t < i.length - 1; t++) {\n            const a = i[t].x,\n              l = i[t].y,\n              u = i[t + 1].x,\n              c = i[t + 1].y,\n              h = 0 === n ? a : l,\n              p = 0 === n ? u : c;\n            h < e ? p > e && s(o, a, l, u, c, e) : h > r ? p < r && s(o, a, l, u, c, r) : o.push(i[t]), p < e && h >= e && s(o, a, l, u, c, e), p > r && h <= r && s(o, a, l, u, c, r);\n          }\n          let a = i[i.length - 1];\n          const l = 0 === n ? a.x : a.y;\n          l >= e && l <= r && o.push(a), o.length && (a = o[o.length - 1], o[0].x === a.x && o[0].y === a.y || o.push(o[0]), t.push(o));\n        }\n        t.length && i.push(t);\n      }\n      return i;\n    }\n    function cp(t, e) {\n      const r = pp(t),\n        n = pp([e]),\n        i = lp.intersection(r, n);\n      return null == i ? [] : dp(i);\n    }\n    function hp(t, e) {\n      const r = 65536;\n      let n = pp(t, r);\n      const i = [];\n      for (; e.valid(); e.next()) {\n        const [t, n] = e.get(),\n          s = t.x * r,\n          o = t.y * r,\n          a = n.x * r,\n          l = n.y * r,\n          u = a - s,\n          c = l - o,\n          h = Math.hypot(u, c);\n        if (0 === h) continue;\n        const p = Math.trunc(c / h * 3),\n          d = -Math.trunc(u / h * 3);\n        i.push([[[s, o], [a, l], [a + p, l + d], [s + p, o + d], [s, o]]]);\n      }\n      return i.length > 0 && (n = lp.diff(n, i)), dp(n, 1 / r);\n    }\n    function pp(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return [t.map(t => t.map(t => [t.x * e, t.y * e]))];\n    }\n    function dp(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return t.map(t => t.map((t, r) => {\n        const n = t.map(t => new wt(t[0] * e, t[1] * e).round());\n        return r > 0 && n.reverse(), n;\n      }));\n    }\n    class fp {\n      constructor(t, e) {\n        this.layoutVertexArray = new ua(), this.indexArray = new Ea(), this.lineIndexArray = new Ia(), this.triangleSegments = new al(), this.lineSegments = new al(), this.programConfigurations = new Cl(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.uploaded = !1, e && (this.elevatedLayoutVertexArray = new pa());\n      }\n      update(t, e, r, n, i, s, o, a) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o, a);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      needsUpload() {\n        return this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t.createVertexBuffer(this.elevatedLayoutVertexArray, _h.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());\n      }\n      populatePaintArrays(t, e, r, n, i, s, o) {\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, e, r, n, i, s, void 0, o);\n      }\n    }\n    class mp {\n      constructor(t) {\n        this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lut = t.lut, this.bufferData = new fp(t, !1), this.elevationBufferData = new fp(t, !0), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection, this.elevationMode = this.layers[0].layout.get(\"fill-elevation-reference\"), this.sourceLayerIndex = t.sourceLayerIndex, this.worldview = t.worldview;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.hasPattern = tp(\"fill\", this.layers, this.pixelRatio, e);\n        const i = this.layers[0].layout.get(\"fill-sort-key\"),\n          s = [];\n        for (const {\n          feature: o,\n          id: a,\n          index: l,\n          sourceLayerIndex: u\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            c = Mu(o, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom, {\n            worldview: this.worldview\n          }), c, r)) continue;\n          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,\n            p = {\n              id: a,\n              properties: o.properties,\n              type: o.type,\n              sourceLayerIndex: u,\n              index: l,\n              geometry: t ? c.geometry : Au(o, r, n),\n              patterns: {},\n              sortKey: h\n            };\n          s.push(p);\n        }\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: o\n          } = n;\n          if (this.hasPattern) {\n            const t = ep(\"fill\", this.layers, n, this.zoom, this.pixelRatio, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness, e.elevationFeatures);\n          e.featureIndex.insert(t[s].feature, i, s, o, this.index);\n        }\n      }\n      update(t, e, r, n, i, s, o) {\n        this.bufferData.update(t, e, r, n, i, s, o, this.worldview), this.elevationBufferData.update(t, e, r, n, i, s, o, this.worldview), this.elevatedStructures && this.elevatedStructures.update(t, e, r, n, i, s, o, this.worldview);\n      }\n      addFeatures(t, e, r, n, i, s) {\n        for (const i of this.patternFeatures) this.addFeature(i, i.geometry, i.index, e, r, n, s, t.elevationFeatures);\n      }\n      isEmpty() {\n        return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();\n      }\n      uploadPending() {\n        return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();\n      }\n      upload(t) {\n        this.bufferData.upload(t), this.elevationBufferData.upload(t), this.elevatedStructures && this.elevatedStructures.upload(t);\n      }\n      destroy() {\n        this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();\n      }\n      addFeature(t, e, r, n, i) {\n        let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n        let o = arguments.length > 6 ? arguments[6] : undefined;\n        let a = arguments.length > 7 ? arguments[7] : undefined;\n        const l = Kh(e, 500);\n        \"none\" !== this.elevationMode ? this.addElevatedRoadFeature(t, l, n, r, a) : this.addGeometry(l, this.bufferData), this.bufferData.populatePaintArrays(t, r, i, s, n, o, this.worldview), this.elevationBufferData.populatePaintArrays(t, r, i, s, n, o, this.worldview);\n      }\n      getUnevaluatedPortalGraph() {\n        return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;\n      }\n      getElevationPolygons() {\n        return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0;\n      }\n      setEvaluatedPortalGraph(t, e, r, n, i) {\n        this.elevatedStructures && (this.elevatedStructures.construct(t), this.elevatedStructures.populatePaintArrays(e, r, n, i, this.worldview));\n      }\n      addElevatedRoadFeature(t, e, r, n, i) {\n        const s = new Array(),\n          o = Yu.getElevationFeature(t, i);\n        if (!o) return void this.addGeometry(e, this.bufferData);\n        {\n          const t = this.clipPolygonsToTile(e, 1);\n          t.length > 0 && s.push({\n            polygons: t,\n            elevationFeature: o,\n            elevationTileID: r\n          });\n        }\n        const a = {\n          guardRailEnabled: this.layers[0].layout.get(\"fill-construct-bridge-guard-rail\").evaluate(t, {}, r),\n          featureIndex: n\n        };\n        for (const e of s) if (e.elevationFeature) {\n          if (\"hd-road-base\" === this.elevationMode) {\n            this.elevatedStructures || (this.elevatedStructures = new sp(e.elevationTileID, this.layers, this.zoom, this.lut));\n            const r = e.elevationFeature.isTunnel();\n            let n = 0;\n            t.properties.hasOwnProperty(Vu) && (n = +t.properties[Vu]);\n            for (const t of e.polygons) this.elevatedStructures.addPortalCandidates(e.elevationFeature.id, t, r, e.elevationFeature, n);\n          }\n          null == e.elevationFeature.constantHeight && (e.polygons = this.prepareElevatedPolygons(e.polygons, e.elevationFeature, e.elevationTileID));\n          const i = new Ku(r, e.elevationTileID);\n          this.addElevatedGeometry(e.polygons, i, e.elevationFeature, \"hd-road-base\" === this.elevationMode ? 0 : .05, n, a);\n        }\n      }\n      addElevatedGeometry(t, e, r, n, i, s) {\n        const o = {\n            elevation: r,\n            elevationSampler: e,\n            bias: n,\n            index: i,\n            featureInfo: s\n          },\n          [a, l] = this.addGeometry(t, this.elevationBufferData, o);\n        null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = {\n          min: a,\n          max: l\n        } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, a), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, l));\n      }\n      addGeometry(t, e, r) {\n        let n = Number.POSITIVE_INFINITY,\n          i = Number.NEGATIVE_INFINITY,\n          s = null;\n        r && (s = r.elevationSampler.constantElevation(r.elevation, r.bias), null != s && (n = s, i = s));\n        const o = (t, o, a) => {\n          if (null != r) if (o.push(t), null != s) e.elevatedLayoutVertexArray.emplaceBack(s), a.push(s);else {\n            const s = r.elevationSampler.pointElevation(t, r.elevation, r.bias);\n            e.elevatedLayoutVertexArray.emplaceBack(s), a.push(s), n = Math.min(n, s), i = Math.max(i, s);\n          }\n        };\n        for (const n of t) {\n          let t = 0;\n          for (const e of n) t += e.length;\n          const i = e.triangleSegments.prepareSegment(t, e.layoutVertexArray, e.indexArray),\n            s = i.vertexLength,\n            a = [],\n            l = [],\n            u = [],\n            c = [],\n            h = [],\n            p = e.layoutVertexArray.length;\n          for (const t of n) {\n            if (0 === t.length) continue;\n            t !== n[0] && l.push(a.length / 2);\n            const i = e.lineSegments.prepareSegment(t.length, e.layoutVertexArray, e.lineIndexArray),\n              s = i.vertexLength;\n            r && h.push(e.layoutVertexArray.length - p), o(t[0], u, c), e.layoutVertexArray.emplaceBack(t[0].x, t[0].y), e.lineIndexArray.emplaceBack(s + t.length - 1, s), a.push(t[0].x), a.push(t[0].y);\n            for (let r = 1; r < t.length; r++) o(t[r], u, c), e.layoutVertexArray.emplaceBack(t[r].x, t[r].y), e.lineIndexArray.emplaceBack(s + r - 1, s + r), a.push(t[r].x), a.push(t[r].y);\n            i.vertexLength += t.length, i.primitiveLength += t.length;\n          }\n          const d = Ih(a, l);\n          for (let t = 0; t < d.length; t += 3) e.indexArray.emplaceBack(s + d[t], s + d[t + 1], s + d[t + 2]);\n          if (d.length > 0 && r && \"hd-road-base\" === this.elevationMode) {\n            const t = r.elevation.isTunnel(),\n              e = r.elevation.safeArea,\n              n = this.elevatedStructures.addVertices(u, c);\n            this.elevatedStructures.addTriangles(d, n, t);\n            const i = h.length;\n            if (i > 0) {\n              for (let s = 0; s < i - 1; s++) this.elevatedStructures.addRenderableRing(r.index, h[s] + n, h[s + 1] - h[s], t, e, r.featureInfo);\n              this.elevatedStructures.addRenderableRing(r.index, h[i - 1] + n, u.length - h[i - 1], t, e, r.featureInfo);\n            }\n          }\n          i.vertexLength += t, i.primitiveLength += d.length / 3;\n        }\n        return [n, i];\n      }\n      prepareElevatedPolygons(t, e, r) {\n        const n = 1 / fu(r),\n          i = [];\n        for (const r of t) {\n          const t = hp(r, new Zu(e, n));\n          i.push(...t);\n        }\n        return i;\n      }\n      clipPolygonsToTile(t, e) {\n        const r = -e,\n          n = -e,\n          i = Rn + e,\n          s = Rn + e;\n        let o = 0;\n        const a = [],\n          l = [];\n        for (; o < t.length; o++) {\n          const e = t[o],\n            u = mn(e);\n          (u.min.x >= r && u.max.x <= i && u.min.y >= n && u.max.y <= s ? a : l).push(e);\n        }\n        if (a.length === t.length) return t;\n        const u = [new wt(r, n), new wt(i, n), new wt(i, s), new wt(r, s), new wt(r, n)],\n          c = a;\n        for (const t of l) c.push(...cp(t, u));\n        return c;\n      }\n    }\n    let yp, gp, xp, vp;\n    Ws(mp, \"FillBucket\", {\n      omit: [\"layers\", \"patternFeatures\"]\n    }), Ws(fp, \"FillBufferData\"), Ws(sp, \"ElevatedStructures\");\n    class bp {\n      constructor(t, e, r, n) {\n        if (this.triangleCount = e.length / 3, this.min = new wt(0, 0), this.max = new wt(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t.length) return;\n        const [i, s] = [t[0].clone(), t[0].clone()];\n        for (let e = 1; e < t.length; ++e) {\n          const r = t[e];\n          i.x = Math.min(i.x, r.x), i.y = Math.min(i.y, r.y), s.x = Math.max(s.x, r.x), s.y = Math.max(s.y, r.y);\n        }\n        if (n) {\n          const t = Math.ceil(Math.max(s.x - i.x, s.y - i.y) / n);\n          r = Math.max(r, t);\n        }\n        if (0 === r) return;\n        this.min = i, this.max = s;\n        const o = this.max.sub(this.min);\n        o.x = Math.max(o.x, 1), o.y = Math.max(o.y, 1);\n        const a = Math.max(o.x, o.y) / r;\n        this.cellsX = Math.max(1, Math.ceil(o.x / a)), this.cellsY = Math.max(1, Math.ceil(o.y / a)), this.xScale = 1 / a, this.yScale = 1 / a;\n        const l = [];\n        for (let r = 0; r < this.triangleCount; r++) {\n          const n = t[e[3 * r + 0]].sub(this.min),\n            i = t[e[3 * r + 1]].sub(this.min),\n            s = t[e[3 * r + 2]].sub(this.min),\n            o = wp(Math.floor(Math.min(n.x, i.x, s.x)), this.xScale, this.cellsX),\n            u = wp(Math.floor(Math.max(n.x, i.x, s.x)), this.xScale, this.cellsX),\n            c = wp(Math.floor(Math.min(n.y, i.y, s.y)), this.yScale, this.cellsY),\n            h = wp(Math.floor(Math.max(n.y, i.y, s.y)), this.yScale, this.cellsY),\n            p = new wt(0, 0),\n            d = new wt(0, 0),\n            f = new wt(0, 0),\n            m = new wt(0, 0);\n          for (let t = c; t <= h; ++t) {\n            p.y = d.y = t * a, f.y = m.y = (t + 1) * a;\n            for (let e = o; e <= u; ++e) p.x = f.x = e * a, d.x = m.x = (e + 1) * a, (fc(n, i, s, p, d, m) || fc(n, i, s, p, m, f)) && l.push({\n              cellIdx: t * this.cellsX + e,\n              triIdx: r\n            });\n          }\n        }\n        if (0 === l.length) return;\n        l.sort((t, e) => t.cellIdx - e.cellIdx || t.triIdx - e.triIdx);\n        let u = 0;\n        for (; u < l.length;) {\n          const t = l[u].cellIdx,\n            e = {\n              start: this.payload.length,\n              len: 0\n            };\n          for (; u < l.length && l[u].cellIdx === t;) ++e.len, this.payload.push(l[u++].triIdx);\n          this.cells[t] = e;\n        }\n      }\n      _lazyInitLookup() {\n        this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);\n      }\n      queryPoint(t, e) {\n        if (0 === this.triangleCount || 0 === this.cells.length) return;\n        if (t.x > this.max.x || this.min.x > t.x || t.y > this.max.y || this.min.y > t.y) return;\n        const r = wp(t.x - this.min.x, this.xScale, this.cellsX),\n          n = wp(t.y - this.min.y, this.yScale, this.cellsY),\n          i = this.cells[n * this.cellsX + r];\n        if (i) {\n          this._lazyInitLookup();\n          for (let t = 0; t < i.len; t++) {\n            const r = this.payload[i.start + t],\n              n = Math.floor(r / 8),\n              s = 1 << r % 8;\n            if (!(this.lookup[n] & s) && (this.lookup[n] |= s, e.push(r), e.length === this.triangleCount)) return;\n          }\n        }\n      }\n      query(t, e, r) {\n        if (0 === this.triangleCount || 0 === this.cells.length) return;\n        if (t.x > this.max.x || this.min.x > e.x) return;\n        if (t.y > this.max.y || this.min.y > e.y) return;\n        this._lazyInitLookup();\n        const n = wp(t.x - this.min.x, this.xScale, this.cellsX),\n          i = wp(e.x - this.min.x, this.xScale, this.cellsX),\n          s = wp(t.y - this.min.y, this.yScale, this.cellsY),\n          o = wp(e.y - this.min.y, this.yScale, this.cellsY);\n        for (let t = s; t <= o; t++) for (let e = n; e <= i; e++) {\n          const n = this.cells[t * this.cellsX + e];\n          if (n) for (let t = 0; t < n.len; t++) {\n            const e = this.payload[n.start + t],\n              i = Math.floor(e / 8),\n              s = 1 << e % 8;\n            if (!(this.lookup[i] & s) && (this.lookup[i] |= s, r.push(e), r.length === this.triangleCount)) return;\n          }\n        }\n      }\n    }\n    function wp(t, e, r) {\n      return Math.max(0, Math.min(r - 1, Math.floor(t * e)));\n    }\n    Ws(bp, \"TriangleGridIndex\");\n    class _p {\n      constructor(t) {\n        this.zoom = t.zoom, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.footprints = [], this.worldview = t.worldview;\n      }\n      updateFootprints(t, e) {\n        for (const r of this.footprints) e.push({\n          footprint: r,\n          id: t\n        });\n      }\n      populate(t, e, r, n) {\n        const i = [];\n        for (const {\n          feature: e,\n          id: s,\n          index: o,\n          sourceLayerIndex: a\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = Mu(e, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom, {\n            worldview: this.worldview\n          }), l, r)) continue;\n          const u = {\n            id: s,\n            properties: e.properties,\n            type: e.type,\n            sourceLayerIndex: a,\n            index: o,\n            geometry: t ? l.geometry : Au(e, r, n),\n            patterns: {}\n          };\n          i.push(u);\n        }\n        for (const n of i) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: o\n          } = n;\n          this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness), e.featureIndex.insert(t[s].feature, i, s, o, this.index);\n        }\n      }\n      isEmpty() {\n        return 0 === this.footprints.length;\n      }\n      uploadPending() {\n        return !1;\n      }\n      upload(t) {}\n      update(t, e, r, n, i, s, o) {}\n      destroy() {}\n      addFeature(t, e, r, n, i) {\n        let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n        let o = arguments.length > 6 ? arguments[6] : undefined;\n        for (const t of Kh(e, 2)) {\n          const e = [],\n            r = [],\n            n = [],\n            i = new wt(1 / 0, 1 / 0),\n            s = new wt(-1 / 0, -1 / 0);\n          for (const o of t) if (0 !== o.length) {\n            o !== t[0] && n.push(r.length / 2);\n            for (let t = 0; t < o.length; t++) r.push(o[t].x), r.push(o[t].y), e.push(o[t]), i.x = Math.min(i.x, o[t].x), i.y = Math.min(i.y, o[t].y), s.x = Math.max(s.x, o[t].x), s.y = Math.max(s.y, o[t].y);\n          }\n          const o = Ih(r, n),\n            a = new bp(e, o, 8, 256);\n          this.footprints.push({\n            vertices: e,\n            indices: o,\n            grid: a,\n            min: i,\n            max: s\n          });\n        }\n      }\n    }\n    Ws(_p, \"ClipBucket\", {\n      omit: [\"layers\"]\n    });\n    const Ap = aa([{\n        name: \"a_pos_normal_ed\",\n        components: 4,\n        type: \"Int16\"\n      }]),\n      Mp = aa([{\n        name: \"a_pos_end\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_angular_offset_factor\",\n        components: 1,\n        type: \"Int16\"\n      }]),\n      Ip = aa([{\n        name: \"a_centroid_pos\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      Sp = aa([{\n        name: \"a_join_normal_inside\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      Pp = aa([{\n        name: \"a_hidden_by_landmark\",\n        components: 1,\n        type: \"Uint8\"\n      }]),\n      kp = aa([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      {\n        members: zp\n      } = Ap,\n      Ep = Number.MAX_SAFE_INTEGER,\n      Tp = Ep - 1;\n    function Bp(t, e, r, n) {\n      return t.order < e || t.order === Ep || !(t.clipMask & r) || function (t, e) {\n        return 0 !== e.length && void 0 === e.find(e => e === t);\n      }(n, t.clipScope);\n    }\n    function Vp(t, e) {\n      return t.x - e.x || t.y - e.y;\n    }\n    function Fp(t, e) {\n      return 0 === Vp(t.min, e.min) && 0 === Vp(t.max, e.max);\n    }\n    function Cp(t, e) {\n      return !(t.min.x > e.max.x || t.max.x < e.min.x || t.min.y > e.max.y || t.max.y < e.min.y);\n    }\n    function Dp(t, e) {\n      if (t.length !== e.length) return !1;\n      for (let r = 0; r < t.length; r++) if (t[r].sourceId !== e[r].sourceId || !Fp(t[r], e[r]) || t[r].order !== e[r].order || t[r].clipMask !== e[r].clipMask || !_t(t[r].clipScope, e[r].clipScope)) return !1;\n      return !0;\n    }\n    function Rp(t, e, r) {\n      const n = 1 / Rn,\n        i = 1 / (1 << r.canonical.z),\n        s = (e.x * n + r.canonical.x) * i + r.wrap,\n        o = (e.y * n + r.canonical.y) * i;\n      return {\n        min: new wt((t.x * n + r.canonical.x) * i + r.wrap, (t.y * n + r.canonical.y) * i),\n        max: new wt(s, o)\n      };\n    }\n    function Lp(t, e, r) {\n      const n = 1 << r.canonical.z,\n        i = ((e.x - r.wrap) * n - r.canonical.x) * Rn,\n        s = (e.y * n - r.canonical.y) * Rn;\n      return {\n        min: new wt(((t.x - r.wrap) * n - r.canonical.x) * Rn, (t.y * n - r.canonical.y) * Rn),\n        max: new wt(i, s)\n      };\n    }\n    function Op(t, e, r, n, i, s, o) {\n      const a = t.indices,\n        l = t.vertices,\n        u = [];\n      for (let c = n; c < n + i; c += 3) {\n        const n = e[r[c + 0] + s],\n          i = e[r[c + 1] + s],\n          h = e[r[c + 2] + s],\n          p = Math.min(n.x, i.x, h.x),\n          d = Math.max(n.x, i.x, h.x),\n          f = Math.min(n.y, i.y, h.y),\n          m = Math.max(n.y, i.y, h.y);\n        u.length = 0, t.grid.query(new wt(p, f), new wt(d, m), u);\n        for (let t = 0; t < u.length; t++) {\n          const e = u[t];\n          if (fc(l[a[3 * e + 0]], l[a[3 * e + 1]], l[a[3 * e + 2]], n, i, h, o)) return !0;\n        }\n      }\n      return !1;\n    }\n    function Up(t, e, r, n) {\n      if (!t || !r) return !1;\n      let i = t.vertices;\n      if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {\n        if (r.vertices.length < t.vertices.length) return Up(r, n, t, e);\n        const s = e.canonical,\n          o = n.canonical,\n          a = Math.pow(2, o.z - s.z);\n        i = t.vertices.map(t => new wt((t.x + s.x * Rn) * a - o.x * Rn, (t.y + s.y * Rn) * a - o.y * Rn));\n      }\n      return Op(r, i, t.indices, 0, t.indices.length, 0, 0);\n    }\n    function Np(t, e, r, n) {\n      const i = Math.pow(2, n.z - r.z);\n      return new wt((t + r.x * Rn) * i - n.x * Rn, (e + r.y * Rn) * i - n.y * Rn);\n    }\n    function jp(t, e) {\n      const r = [];\n      e.grid.queryPoint(t, r);\n      const n = e.indices,\n        i = e.vertices;\n      for (let e = 0; e < r.length; e++) {\n        const s = r[e];\n        if (cc([i[n[3 * s + 0]], i[n[3 * s + 1]], i[n[3 * s + 2]]], t)) return !0;\n      }\n      return !1;\n    }\n    const $p = [new wt(0, 0), new wt(Rn, 0), new wt(Rn, Rn), new wt(0, Rn)];\n    function Gp(t, e) {\n      const r = [];\n      let n = [];\n      if (!e || t.length < 2) return [t];\n      if (2 === t.length) return pc(t[0], t[1], $p) ? [t] : [];\n      for (let e = 0; e < t.length + 2; e++) {\n        const i = t[e % t.length],\n          s = t[(e + 1) % t.length],\n          o = pc(0 === e ? t[t.length - 1] : t[(e - 1) % t.length], i, $p),\n          a = pc(i, s, $p),\n          l = o || a;\n        l && n.push(i), l && a || n.length > 0 && (n.length > 1 && r.push(n), n = []);\n      }\n      return n.length > 1 && r.push(n), r;\n    }\n    const Hp = Iu.types,\n      qp = [\"fill-extrusion-base\", \"fill-extrusion-height\", \"fill-extrusion-color\", \"fill-extrusion-pattern\", \"fill-extrusion-flood-light-wall-radius\", \"fill-extrusion-line-width\", \"fill-extrusion-emissive-strength\"],\n      Xp = [\"fill-extrusion-flood-light-ground-radius\"],\n      Zp = Math.pow(2, 13),\n      Wp = Math.pow(2, 15) - 1,\n      Yp = new wt(0, 1),\n      Kp = 2147483648;\n    function Jp(t, e, r, n, i, s, o, a) {\n      t.emplaceBack((e << 1) + o, (r << 1) + s, (Math.floor(n * Zp) << 1) + i, Math.round(a));\n    }\n    function Qp(t, e, r) {\n      t.emplaceBack(e.x * Rn, e.y * Rn, r ? 1 : 0);\n    }\n    function td(t, e, r, n, i, s) {\n      t.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, s);\n    }\n    function ed(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class rd {\n      constructor() {\n        this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;\n      }\n    }\n    class nd {\n      constructor() {\n        this.centroidXY = new wt(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new wt(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new wt(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0, this.buildingId = 0;\n      }\n      span() {\n        return new wt(this.max.x - this.min.x, this.max.y - this.min.y);\n      }\n    }\n    class id {\n      constructor() {\n        this.acc = new wt(0, 0), this.accCount = 0, this.centroidDataIndex = 0;\n      }\n      startRing(t, e) {\n        t.min.x === Number.MAX_VALUE && (t.min.x = t.max.x = e.x, t.min.y = t.max.y = e.y);\n      }\n      appendEdge(t, e, r) {\n        this.accCount++, this.acc._add(e);\n        let n = !!this.borders;\n        e.x < t.min.x ? (t.min.x = e.x, n = !0) : e.x > t.max.x && (t.max.x = e.x, n = !0), e.y < t.min.y ? (t.min.y = e.y, n = !0) : e.y > t.max.y && (t.max.y = e.y, n = !0), ((0 === e.x || e.x === Rn) && e.x === r.x) != ((0 === e.y || e.y === Rn) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);\n      }\n      checkBorderIntersection(t, e) {\n        e.x < 0 != t.x < 0 && this.addBorderIntersection(0, ur(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > Rn != t.x > Rn && this.addBorderIntersection(1, ur(e.y, t.y, (Rn - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, ur(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > Rn != t.y > Rn && this.addBorderIntersection(3, ur(e.x, t.x, (Rn - e.y) / (t.y - e.y)));\n      }\n      addBorderIntersection(t, e) {\n        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);\n        const r = this.borders[t];\n        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);\n      }\n      processBorderOverlap(t, e) {\n        if (t.x === e.x) {\n          if (t.y === e.y) return;\n          const r = 0 === t.x ? 0 : 1;\n          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);\n        } else {\n          const r = 0 === t.y ? 2 : 3;\n          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);\n        }\n      }\n      centroid() {\n        return 0 === this.accCount ? new wt(0, 0) : new wt(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));\n      }\n      intersectsCount() {\n        return this.borders ? this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0) : 0;\n      }\n    }\n    function sd(t, e) {\n      const r = t.add(e)._unit(),\n        n = Tt(t.x * r.x + t.y * r.y, -1, 1);\n      var i, s, o;\n      return i = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(i))) / 4 * Wp * ((s = t).x * (o = e).y - s.y * o.x < 0 ? -1 : 1);\n    }\n    const od = [t => t.x < 0, t => t.x > Rn, t => t.y < 0, t => t.y > Rn];\n    function ad(t, e, r, n) {\n      const i = [4];\n      if (0 === n) return i;\n      r._mult(n);\n      const s = t.sub(r),\n        o = e.sub(r),\n        a = [t, e, s, o];\n      for (let t = 0; t < 4; t++) for (const e of a) if (od[t](e)) {\n        i.push(t);\n        break;\n      }\n      return i;\n    }\n    class ld {\n      constructor(t) {\n        this.vertexArray = new ma(), this.indexArray = new Ea(), this.programConfigurations = new Cl(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }, t => Xp.includes(t)), this._segments = new al(), this.hiddenByLandmarkVertexArray = new Ga(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new al();\n      }\n      getDefaultSegment() {\n        return this.regionSegments[4];\n      }\n      hasData() {\n        return 0 !== this.vertexArray.length;\n      }\n      addData(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n        const i = t.length;\n        if (i > 2) {\n          let s = Math.max(0, this._segments.get().length - 1);\n          const o = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[s].length);\n          let a;\n          s !== this._segments.get().length - 1 && (s++, this._segmentToGroundQuads[s] = [], this._segmentToRegionTriCounts[s] = [0, 0, 0, 0, 0]);\n          {\n            const e = t[0],\n              r = t[1];\n            a = sd(e.sub(t[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());\n          }\n          for (let l = 0; l < i; l++) {\n            const u = l === i - 1 ? 0 : l + 1,\n              c = t[l],\n              h = t[u],\n              p = t[u === i - 1 ? 0 : u + 1],\n              d = h.sub(c)._perp()._unit(),\n              f = sd(d, p.sub(h)._perp()._unit()),\n              m = a,\n              y = f;\n            if (dd(c, h, e) || n && fd(c, e) && fd(h, e)) {\n              a = f;\n              continue;\n            }\n            const g = o.vertexLength;\n            td(this.vertexArray, c, h, 1, 1, m), td(this.vertexArray, c, h, 1, 0, m), td(this.vertexArray, c, h, 0, 1, y), td(this.vertexArray, c, h, 0, 0, y), o.vertexLength += 4;\n            const x = ad(c, h, d, r);\n            for (const t of x) this._segmentToGroundQuads[s].push({\n              id: g,\n              region: t\n            }), this._segmentToRegionTriCounts[s][t] += 2, o.primitiveLength += 2;\n            a = f;\n          }\n        }\n      }\n      prepareBorderSegments() {\n        if (!this.hasData()) return;\n        const t = this._segments.get(),\n          e = t.length;\n        for (let t = 0; t < e; t++) this._segmentToGroundQuads[t].sort((t, e) => t.region - e.region);\n        for (let r = 0; r < e; r++) {\n          const e = this._segmentToGroundQuads[r],\n            n = t[r],\n            i = this._segmentToRegionTriCounts[r];\n          i.reduce((t, e) => t + e, 0);\n          let s = 0;\n          for (let t = 0; t <= 4; t++) {\n            const e = i[t];\n            if (0 !== e) {\n              let r = this.regionSegments[t];\n              r || (r = this.regionSegments[t] = new al());\n              const i = {\n                vertexOffset: n.vertexOffset,\n                primitiveOffset: n.primitiveOffset + s,\n                vertexLength: n.vertexLength,\n                primitiveLength: e\n              };\n              r.get().push(i);\n            }\n            s += e;\n          }\n          for (let t = 0; t < e.length; t++) {\n            const r = e[t].id;\n            this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);\n          }\n        }\n        this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;\n      }\n      addPaintPropertiesData(t, e, r, n, i, s, o) {\n        this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t, e, r, n, i, s, void 0, o);\n      }\n      upload(t) {\n        this.hasData() && (this.vertexBuffer = t.createVertexBuffer(this.vertexArray, Mp.members), this.indexBuffer = t.createIndexBuffer(this.indexArray));\n      }\n      uploadPaintProperties(t) {\n        this.hasData() && this.programConfigurations.upload(t);\n      }\n      update(t, e, r, n, i, s, o, a) {\n        this.hasData() && this.programConfigurations.updatePaintArrays(t, e, r, n, i, s, o, a);\n      }\n      updateHiddenByLandmark(t) {\n        this.updateHiddenByLandmarkRange(t.groundVertexArrayOffset, t.groundVertexCount, !!(t.flags & Kp));\n      }\n      updateHiddenByLandmarkRange(t, e, r) {\n        if (!this.hasData()) return;\n        const n = e + t;\n        if (0 !== e) {\n          for (let e = t; e < n; ++e) this.hiddenByLandmarkVertexArray.emplace(e, r ? 1 : 0);\n          this._needsHiddenByLandmarkUpdate = !0;\n        }\n      }\n      uploadHiddenByLandmark(t) {\n        this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t.createVertexBuffer(this.hiddenByLandmarkVertexArray, Pp.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);\n      }\n      destroy() {\n        if (this.vertexBuffer) {\n          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();\n          for (let t = 0; t <= 4; t++) {\n            const e = this.regionSegments[t];\n            e && e.destroy();\n          }\n        }\n      }\n    }\n    class ud {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.pixelRatio = t.pixelRatio, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Ea(), this.footprintVertices = new ua(), this.footprintSegments = [], this.layoutVertexArray = new ha(), this.centroidVertexArray = new el(), this.wallVertexArray = new nl(), this.indexArray = new Ea(), this.programConfigurations = new Cl(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }, t => qp.includes(t)), this.segments = new al(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.groundEffect = new ld(t), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [], this.worldview = t.worldview;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.features = [], this.hasPattern = tp(\"fill-extrusion\", this.layers, this.pixelRatio, e), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = fu(r), this.edgeRadius = this.layers[0].layout.get(\"fill-extrusion-edge-radius\") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get(\"fill-extrusion-line-width\").constantOr(1);\n        for (const {\n          feature: i,\n          id: s,\n          index: o,\n          sourceLayerIndex: a\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = Mu(i, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom, {\n            worldview: this.worldview\n          }), l, r)) continue;\n          const u = {\n              id: s,\n              sourceLayerIndex: a,\n              index: o,\n              geometry: t ? l.geometry : Au(i, r, n),\n              properties: i.properties,\n              type: i.type,\n              patterns: {}\n            },\n            c = this.layoutVertexArray.length,\n            h = \"Polygon\" === Hp[u.type];\n          if (this.hasPattern) this.features.push({\n            featureId: i.id,\n            feature: ep(\"fill-extrusion\", this.layers, u, this.zoom, this.pixelRatio, e)\n          });else if (this.wallMode) for (const t of u.geometry) for (const s of Gp(t, h)) this.addFeature(i.id, u, [s], o, r, {}, e.availableImages, n, e.brightness);else this.addFeature(i.id, u, u.geometry, o, r, {}, e.availableImages, n, e.brightness);\n          e.featureIndex.insert(i, u.geometry, o, a, this.index, c);\n        }\n        this.sortBorders(), \"mercator\" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;\n      }\n      addFeatures(t, e, r, n, i, s) {\n        for (const {\n          featureId: t,\n          feature: o\n        } of this.features) {\n          const a = \"Polygon\" === Hp[o.type],\n            {\n              geometry: l\n            } = o;\n          if (this.wallMode) for (const u of l) for (const l of Gp(u, a)) this.addFeature(t, o, [l], o.index, e, r, n, i, s);else this.addFeature(t, o, l, o.index, e, r, n, i, s);\n        }\n        this.sortBorders(), \"mercator\" === this.projection.name && this.splitToSubtiles();\n      }\n      update(t, e, r, n, i, s, o) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o, this.worldview), this.groundEffect.update(t, e, i, r, n, s, o, this.worldview);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, zp), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t.createVertexBuffer(this.wallVertexArray, Sp.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, kp.members, !0)), this.groundEffect.upload(t)), this.groundEffect.uploadPaintProperties(t), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      uploadCentroid(t) {\n        this.groundEffect.uploadHiddenByLandmark(t), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Ip.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      addFeature(t, e, r, n, i, s, o, a, l) {\n        const u = this.layers[0].paint.get(\"fill-extrusion-flood-light-ground-radius\").evaluate(e, {}) / this.tileToMeter,\n          c = [new wt(0, 0), new wt(Rn, Rn)],\n          h = a.projection,\n          p = \"globe\" === h.name,\n          d = this.wallMode || \"Polygon\" === Hp[e.type],\n          f = new id();\n        f.centroidDataIndex = this.centroidData.length;\n        const m = new nd();\n        m.buildingId = t, e.properties && e.properties.hasOwnProperty(\"building_id\") && (m.buildingId = e.properties.building_id);\n        const y = this.layers[0].paint.get(\"fill-extrusion-base\").evaluate(e, {}, i) <= 0,\n          g = this.layers[0].paint.get(\"fill-extrusion-height\").evaluate(e, {}, i);\n        let x;\n        if (m.height = g, m.vertexArrayOffset = this.layoutVertexArray.length, m.groundVertexArrayOffset = this.groundEffect.vertexArray.length, p && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new ba()), this.wallMode) {\n          if (p) return void Gt(\"Non zero fill-extrusion-line-width is not yet supported on globe.\");\n          if (1 !== r.length) return;\n          x = function (t) {\n            const e = t[0].x === t[t.length - 1].x && t[0].y === t[t.length - 1].y,\n              r = function (t) {\n                let e = 0;\n                const r = t.length;\n                for (let n = 0; n < r; n++) e += (t[(n + 1) % r].x - t[n].x) * (t[(n + 1) % r].y + t[n].y);\n                return e >= 0;\n              }(t);\n            r || (t = t.reverse());\n            const n = {\n                geometry: [],\n                joinNormals: [],\n                indices: []\n              },\n              i = [],\n              s = [],\n              o = [];\n            let a = t.length;\n            for (; a >= 2 && t[a - 1].equals(t[a - 2]);) a--;\n            if (a < (e ? 3 : 2)) return n;\n            let l,\n              u,\n              c,\n              h,\n              p,\n              d = 0;\n            for (; d < a - 1 && t[d].equals(t[d + 1]);) d++;\n            e && (l = t[a - 2], p = t[d].sub(l)._unit()._perp());\n            for (let r = d; r < a; r++) {\n              if (c = r === a - 1 ? e ? t[d + 1] : void 0 : t[r + 1], c && t[r].equals(c)) continue;\n              p && (h = p), l && (u = l), l = t[r], p = c ? c.sub(l)._unit()._perp() : h, h = h || p;\n              let n = h.add(p);\n              0 === n.x && 0 === n.y || n._unit();\n              const f = n.x * p.x + n.y * p.y,\n                m = 0 !== f ? 1 / f : 1 / 0,\n                y = h.x * p.y - h.y * p.x > 0;\n              let g = \"miter\";\n              const x = 2;\n              \"miter\" === g && m > x && (g = \"bevel\"), \"bevel\" === g && (m > 100 && (g = \"flipbevel\"), m < x && (g = \"miter\"));\n              const v = (t, e, r, n) => {\n                const a = new wt(t.x, t.y),\n                  l = new wt(t.x, t.y);\n                a.x += e.x * n, a.y += e.y * n, l.x -= e.x * Math.max(r, 1), l.y -= e.y * Math.max(r, 1), o.push(e), i.push(a), s.push(l);\n              };\n              if (\"miter\" === g) n._mult(m), v(l, n, 0, 0);else if (\"flipbevel\" === g) n = p.mult(-1), v(l, n, 0, 0), v(l, n.mult(-1), 0, 0);else {\n                const t = -Math.sqrt(m * m - 1),\n                  e = y ? t : 0,\n                  r = y ? 0 : t;\n                u && v(l, h, e, r), c && v(l, p, e, r);\n              }\n            }\n            n.geometry = [...i, ...s.reverse(), i[0]], n.joinNormals = [...o, ...o.reverse(), o[o.length - 1]];\n            const f = n.geometry.length - 1;\n            for (let t = 0; t < f / 2; t++) if (t + 1 < f / 2) {\n              let e = t,\n                r = t + 1,\n                i = f - 1 - t,\n                s = f - 2 - t;\n              e = 0 === e ? f - 1 : e - 1, r = 0 === r ? f - 1 : r - 1, i = 0 === i ? f - 1 : i - 1, s = 0 === s ? f - 1 : s - 1, n.indices.push(i), n.indices.push(r), n.indices.push(e), n.indices.push(i), n.indices.push(s), n.indices.push(r);\n            }\n            return n;\n          }(r[0]), r = [x.geometry];\n        }\n        const v = (t, e) => t < (e.length - 1) / 2 || t === e.length - 1,\n          b = this.wallMode ? [r] : Kh(r, 500);\n        for (let t = b.length - 1; t >= 0; t--) {\n          const e = b[t];\n          (0 === e.length || (w = e[0]).every(t => t.x <= 0) || w.every(t => t.x >= Rn) || w.every(t => t.y <= 0) || w.every(t => t.y >= Rn)) && b.splice(t, 1);\n        }\n        var w;\n        let _;\n        if (p) _ = xd(b, c, i);else {\n          _ = [];\n          for (const t of b) _.push({\n            polygon: t,\n            bounds: c\n          });\n        }\n        const A = d ? this.edgeRadius : 0,\n          M = A > 0 && this.zoom < 17,\n          I = (t, e) => {\n            if (0 === t.length) return !1;\n            const r = t[t.length - 1];\n            return e.x === r.x && e.y === r.y;\n          };\n        for (const {\n          polygon: t,\n          bounds: e\n        } of _) {\n          let r = 0,\n            n = 0;\n          for (const e of t) d && !e[0].equals(e[e.length - 1]) && e.push(e[0]), n += d ? e.length - 1 : e.length;\n          const s = this.segments.prepareSegment((d ? 5 : 4) * n, this.layoutVertexArray, this.indexArray);\n          m.footprintSegIdx < 0 && (m.footprintSegIdx = this.footprintSegments.length), m.polygonSegIdx < 0 && (m.polygonSegIdx = this.polygonSegments.length);\n          const o = {\n              triangleArrayOffset: this.indexArray.length,\n              triangleCount: 0,\n              triangleSegIdx: this.segments.segments.length - 1\n            },\n            a = new rd();\n          if (a.vertexOffset = this.footprintVertices.length, a.indexOffset = 3 * this.footprintIndices.length, a.ringIndices = [], d) {\n            const n = [],\n              o = [];\n            r = s.vertexLength;\n            for (let r = 0; r < t.length; r++) {\n              const l = t[r];\n              l.length && 0 !== r && o.push(n.length / 2);\n              const c = [];\n              let d, f;\n              d = l[1].sub(l[0])._perp()._unit(), a.ringIndices.push(l.length - 1);\n              for (let t = 1; t < l.length; t++) {\n                const e = l[t],\n                  r = l[t === l.length - 1 ? 1 : t + 1],\n                  o = e.clone();\n                if (A) {\n                  f = r.sub(e)._perp()._unit();\n                  const t = d.add(f)._unit(),\n                    n = A * Math.min(4, 1 / (d.x * t.x + d.y * t.y));\n                  o.x += n * t.x, o.y += n * t.y, o.x = Math.round(o.x), o.y = Math.round(o.y), d = f;\n                }\n                if (!y || 0 !== A && !M || I(c, o) || c.push(o), Jp(this.layoutVertexArray, o.x, o.y, 0, 0, 1, 1, 0), this.wallMode) {\n                  const e = v(t, l);\n                  Qp(this.wallVertexArray, x.joinNormals[t], !e);\n                }\n                s.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), n.push(e.x, e.y), p && ed(this.layoutVertexExtArray, h.projectTilePoint(o.x, o.y, i), h.upVector(i, o.x, o.y));\n              }\n              y && (0 === A || M) && (0 !== c.length && I(c, c[0]) && c.pop(), this.groundEffect.addData(c, e, u));\n            }\n            const l = this.wallMode ? x.indices : Ih(n, o);\n            for (let t = 0; t < l.length; t += 3) this.footprintIndices.emplaceBack(a.vertexOffset + l[t + 0], a.vertexOffset + l[t + 1], a.vertexOffset + l[t + 2]), this.indexArray.emplaceBack(r + l[t], r + l[t + 2], r + l[t + 1]), s.primitiveLength++;\n            a.indexCount += l.length, a.vertexCount += this.footprintVertices.length - a.vertexOffset;\n          }\n          for (let n = 0; n < t.length; n++) {\n            const o = t[n];\n            f.startRing(m, o[0]);\n            let a = o.length > 4 && md(o[o.length - 2], o[0], o[1]),\n              l = A ? hd(o[o.length - 2], o[0], o[1], A) : 0;\n            const c = [];\n            let g, b, w;\n            b = o[1].sub(o[0])._perp()._unit();\n            let _ = !0;\n            for (let t = 1, n = 0; t < o.length; t++) {\n              let u = o[t - 1],\n                d = o[t];\n              const M = o[t === o.length - 1 ? 1 : t + 1];\n              if (f.appendEdge(m, d, u), dd(d, u, e)) {\n                A && (b = M.sub(d)._perp()._unit(), _ = !_);\n                continue;\n              }\n              const S = d.sub(u)._perp(),\n                P = S.x / (Math.abs(S.x) + Math.abs(S.y)),\n                k = S.y > 0 ? 1 : 0,\n                z = u.dist(d);\n              if (n + z > 32768 && (n = 0), A) {\n                w = M.sub(d)._perp()._unit();\n                let t = pd(u, d, M, cd(b, w), A);\n                isNaN(t) && (t = 0);\n                const e = d.sub(u)._unit();\n                u = u.add(e.mult(l))._round(), d = d.add(e.mult(-t))._round(), l = t, b = w, y && this.zoom >= 17 && (I(c, u) || c.push(u), I(c, d) || c.push(d));\n              }\n              const E = s.vertexLength,\n                T = o.length > 4 && md(u, d, M);\n              let B = yd(n, a, _);\n              if (Jp(this.layoutVertexArray, u.x, u.y, P, k, 0, 0, B), Jp(this.layoutVertexArray, u.x, u.y, P, k, 0, 1, B), this.wallMode) {\n                const e = v(t - 1, o),\n                  r = x.joinNormals[t - 1];\n                Qp(this.wallVertexArray, r, e), Qp(this.wallVertexArray, r, e);\n              }\n              if (n += z, B = yd(n, T, !_), a = T, Jp(this.layoutVertexArray, d.x, d.y, P, k, 0, 0, B), Jp(this.layoutVertexArray, d.x, d.y, P, k, 0, 1, B), this.wallMode) {\n                const e = v(t, o),\n                  r = x.joinNormals[t];\n                Qp(this.wallVertexArray, r, e), Qp(this.wallVertexArray, r, e);\n              }\n              if (s.vertexLength += 4, this.indexArray.emplaceBack(E + 0, E + 1, E + 2), this.indexArray.emplaceBack(E + 1, E + 3, E + 2), s.primitiveLength += 2, A) {\n                const n = r + (1 === t ? o.length - 2 : t - 2),\n                  i = 1 === t ? r : n + 1;\n                if (this.indexArray.emplaceBack(E + 1, n, E + 3), this.indexArray.emplaceBack(n, i, E + 3), s.primitiveLength += 2, void 0 === g && (g = E), !dd(M, o[t], e)) {\n                  const e = t === o.length - 1 ? g : s.vertexLength;\n                  this.indexArray.emplaceBack(E + 2, E + 3, e), this.indexArray.emplaceBack(E + 3, e + 1, e), this.indexArray.emplaceBack(E + 3, i, e + 1), s.primitiveLength += 3;\n                }\n                _ = !_;\n              }\n              if (p) {\n                const t = this.layoutVertexExtArray,\n                  e = h.projectTilePoint(u.x, u.y, i),\n                  r = h.projectTilePoint(d.x, d.y, i),\n                  n = h.upVector(i, u.x, u.y),\n                  s = h.upVector(i, d.x, d.y);\n                ed(t, e, n), ed(t, e, n), ed(t, r, s), ed(t, r, s);\n              }\n            }\n            d && (r += o.length - 1), y && A && this.zoom >= 17 && (0 !== c.length && I(c, c[0]) && c.pop(), this.groundEffect.addData(c, e, u, A > 0));\n          }\n          this.footprintSegments.push(a), o.triangleCount = this.indexArray.length - o.triangleArrayOffset, this.polygonSegments.push(o), ++m.footprintSegLen, ++m.polygonSegLen;\n        }\n        if (m.vertexCount = this.layoutVertexArray.length - m.vertexArrayOffset, m.groundVertexCount = this.groundEffect.vertexArray.length - m.groundVertexArrayOffset, 0 !== m.vertexCount) {\n          if (m.centroidXY = f.borders ? Yp : this.encodeCentroid(f, m), this.centroidData.push(m), f.borders) {\n            this.featuresOnBorder.push(f);\n            const t = this.featuresOnBorder.length - 1;\n            for (let e = 0; e < f.borders.length; e++) f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t);\n          }\n          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, s, o, i, l, void 0, this.worldview), this.groundEffect.addPaintPropertiesData(e, n, s, o, i, l, this.worldview), this.maxHeight = Math.max(this.maxHeight, g);\n        }\n      }\n      sortBorders() {\n        for (let t = 0; t < this.borderFeatureIndices.length; t++) this.borderFeatureIndices[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);\n      }\n      splitToSubtiles() {\n        const t = [];\n        for (let e = 0; e < this.centroidData.length; e++) {\n          const r = this.centroidData[e],\n            n = +(r.min.y + r.max.y > Rn),\n            i = 2 * n + (+(r.min.x + r.max.x > Rn) ^ n);\n          for (let n = 0; n < r.polygonSegLen; n++) {\n            const s = r.polygonSegIdx + n;\n            t.push({\n              centroidIdx: e,\n              subtile: i,\n              polygonSegmentIdx: s,\n              triangleSegmentIdx: this.polygonSegments[s].triangleSegIdx\n            });\n          }\n        }\n        const e = new Ea();\n        t.sort((t, e) => t.triangleSegmentIdx === e.triangleSegmentIdx ? t.subtile - e.subtile : t.triangleSegmentIdx - e.triangleSegmentIdx);\n        let r = 0,\n          n = 0,\n          i = 0;\n        for (const e of t) {\n          if (e.triangleSegmentIdx !== r) break;\n          i++;\n        }\n        const s = t.length;\n        for (; n !== t.length;) {\n          r = t[n].triangleSegmentIdx;\n          let o = 0,\n            a = n,\n            l = n;\n          for (let e = a; e < i && t[e].subtile === o; e++) l++;\n          for (; a !== i;) {\n            const n = t[a];\n            o = n.subtile;\n            const s = this.centroidData[n.centroidIdx].min.clone(),\n              u = this.centroidData[n.centroidIdx].max.clone(),\n              c = {\n                vertexOffset: this.segments.segments[r].vertexOffset,\n                primitiveOffset: e.length,\n                vertexLength: this.segments.segments[r].vertexLength,\n                primitiveLength: 0,\n                sortKey: void 0,\n                vaos: {}\n              };\n            for (let r = a; r < l; r++) {\n              const n = t[r],\n                i = this.polygonSegments[n.polygonSegmentIdx],\n                o = this.centroidData[n.centroidIdx].min,\n                a = this.centroidData[n.centroidIdx].max,\n                l = this.indexArray.uint16;\n              for (let t = i.triangleArrayOffset; t < i.triangleArrayOffset + i.triangleCount; t++) e.emplaceBack(l[3 * t], l[3 * t + 1], l[3 * t + 2]);\n              c.primitiveLength += i.triangleCount, s.x = Math.min(s.x, o.x), s.y = Math.min(s.y, o.y), u.x = Math.max(u.x, a.x), u.y = Math.max(u.y, a.y);\n            }\n            c.primitiveLength > 0 && this.triangleSubSegments.push({\n              segment: c,\n              min: s,\n              max: u\n            }), a = l;\n            for (let e = a; e < i && t[e].subtile === t[a].subtile; e++) l++;\n          }\n          n = i;\n          for (let e = n; e < s && t[e].triangleSegmentIdx === t[n].triangleSegmentIdx; e++) i++;\n        }\n        e._trim(), this.indexArray = e;\n      }\n      getVisibleSegments(t, e, r) {\n        const n = new al();\n        if (this.wallMode) {\n          for (const t of this.triangleSubSegments) n.segments.push(t.segment);\n          return n;\n        }\n        let i = 0,\n          s = 0;\n        const o = 1 << t.canonical.z;\n        if (e) {\n          const r = e.getMinMaxForTile(t);\n          r && (i = r.min, s = r.max);\n        }\n        s += this.maxHeight;\n        const a = t.toUnwrapped();\n        let l;\n        const u = [a.canonical.x / o + a.wrap, a.canonical.y / o],\n          c = [(a.canonical.x + 1) / o + a.wrap, (a.canonical.y + 1) / o],\n          h = (t, e, r) => [t[0] * (1 - r[0]) + e[0] * r[0], t[1] * (1 - r[1]) + e[1] * r[1]],\n          p = [],\n          d = [];\n        for (const t of this.triangleSubSegments) {\n          p[0] = t.min.x / Rn, p[1] = t.min.y / Rn, d[0] = t.max.x / Rn, d[1] = t.max.y / Rn;\n          const e = h(u, c, p),\n            o = h(u, c, d);\n          if (0 === new Xu([e[0], e[1], i], [o[0], o[1], s]).intersectsPrecise(r)) {\n            l && (n.segments.push(l), l = void 0);\n            continue;\n          }\n          const a = t.segment;\n          l && l.vertexOffset !== a.vertexOffset && (n.segments.push(l), l = void 0), l ? (l.vertexLength += a.vertexLength, l.primitiveLength += a.primitiveLength) : l = {\n            vertexOffset: a.vertexOffset,\n            primitiveLength: a.primitiveLength,\n            vertexLength: a.vertexLength,\n            primitiveOffset: a.primitiveOffset,\n            sortKey: void 0,\n            vaos: {}\n          };\n        }\n        return l && n.segments.push(l), n;\n      }\n      encodeCentroid(t, e) {\n        const r = t.centroid(),\n          n = e.span(),\n          i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)),\n          s = Math.min(7, Math.round(n.y * this.tileToMeter / 10));\n        return new wt(Tt(r.x, 1, Rn - 1) << 3 | i, Tt(r.y, 1, Rn - 1) << 3 | s);\n      }\n      encodeBorderCentroid(t) {\n        if (!t.borders) return new wt(0, 0);\n        const e = t.borders,\n          r = Number.MAX_VALUE;\n        if (e[0][0] !== r || e[1][0] !== r) {\n          const t = e[0][0] !== r ? 0 : 1;\n          return new wt(6 | (e[0][0] !== r ? 0 : 65528), (e[t][0] + e[t][1]) / 2 << 3 | 6);\n        }\n        {\n          const t = e[2][0] !== r ? 2 : 3;\n          return new wt((e[t][0] + e[t][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));\n        }\n      }\n      showCentroid(t) {\n        const e = this.centroidData[t.centroidDataIndex];\n        e.flags &= 2147483647, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);\n      }\n      writeCentroidToBuffer(t) {\n        this.groundEffect.updateHiddenByLandmark(t);\n        const e = t.vertexArrayOffset,\n          r = t.vertexCount + t.vertexArrayOffset,\n          n = t.flags & Kp ? Yp : t.centroidXY,\n          i = this.centroidVertexArray.geta_centroid_pos0(e);\n        if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {\n          for (let t = e; t < r; ++t) this.centroidVertexArray.emplace(t, n.x, n.y);\n          this.needsCentroidUpdate = !0;\n        }\n      }\n      createCentroidsBuffer() {\n        this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);\n        for (const t of this.centroidData) this.writeCentroidToBuffer(t);\n      }\n      updateReplacement(t, e, r) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const n = e.getReplacementRegionsForTile(t.toUnwrapped());\n        if (Dp(this.activeReplacements, n)) return;\n        if (this.activeReplacements = n, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();else for (const t of this.centroidData) t.flags &= 2147483647;\n        const i = [];\n        for (const e of this.activeReplacements) {\n          if (e.order < r) continue;\n          const n = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t.canonical.z));\n          if (e.footprint.buildingId) {\n            const t = e.footprint.buildingId;\n            for (const e of this.centroidData) e.buildingId === t && (e.flags |= Kp);\n          } else for (const r of this.centroidData) if (!(r.flags & Kp || e.min.x > r.max.x || r.min.x > e.max.x || e.min.y > r.max.y || r.min.y > e.max.y)) for (let s = 0; s < r.footprintSegLen; s++) {\n            const o = this.footprintSegments[r.footprintSegIdx + s];\n            if (i.length = 0, vd(this.footprintVertices, o.vertexOffset, o.vertexCount, e.footprintTileId.canonical, t.canonical, i), Op(e.footprint, i, this.footprintIndices.uint16, o.indexOffset, o.indexCount, -o.vertexOffset, -n)) {\n              r.flags |= Kp;\n              break;\n            }\n          }\n        }\n        for (const t of this.centroidData) this.writeCentroidToBuffer(t);\n        this.borderDoneWithNeighborZ = [-1, -1, -1, -1];\n      }\n      footprintContainsPoint(t, e, r) {\n        let n = !1;\n        for (let i = 0; i < r.footprintSegLen; i++) {\n          const s = this.footprintSegments[r.footprintSegIdx + i];\n          let o = 0;\n          for (const r of s.ringIndices) {\n            for (let i = o, a = r + o - 1; i < r + o; a = i++) {\n              const r = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 0],\n                o = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 1],\n                l = this.footprintVertices.int16[2 * (a + s.vertexOffset) + 1];\n              o > e != l > e && t < (this.footprintVertices.int16[2 * (a + s.vertexOffset) + 0] - r) * (e - o) / (l - o) + r && (n = !n);\n            }\n            o = r;\n          }\n        }\n        return n;\n      }\n      getHeightAtTileCoord(t, e) {\n        let r = Number.NEGATIVE_INFINITY,\n          n = !0;\n        const i = 4 * (t + Rn) * Rn + (e + Rn);\n        if (this.partLookup.hasOwnProperty(i)) {\n          const t = this.partLookup[i];\n          return t ? {\n            height: t.height,\n            hidden: !!(t.flags & Kp)\n          } : void 0;\n        }\n        for (const s of this.centroidData) t > s.max.x || s.min.x > t || e > s.max.y || s.min.y > e || s.height <= r || this.footprintContainsPoint(t, e, s) && (r = s.height, this.partLookup[i] = s, n = !!(s.flags & Kp));\n        if (r !== Number.NEGATIVE_INFINITY) return {\n          height: r,\n          hidden: n\n        };\n        this.partLookup[i] = void 0;\n      }\n    }\n    function cd(t, e) {\n      const r = t.add(e)._unit();\n      return t.x * r.x + t.y * r.y;\n    }\n    function hd(t, e, r, n) {\n      const i = e.sub(t)._perp()._unit(),\n        s = r.sub(e)._perp()._unit();\n      return pd(t, e, r, cd(i, s), n);\n    }\n    function pd(t, e, r, n, i) {\n      const s = Math.sqrt(1 - n * n);\n      return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * s / n);\n    }\n    function dd(t, e, r) {\n      return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y;\n    }\n    function fd(t, e) {\n      return t.x < e[0].x || t.x > e[1].x || t.y < e[0].y || t.y > e[1].y;\n    }\n    function md(t, e, r) {\n      if (t.x < 0 || t.x >= Rn || e.x < 0 || e.x >= Rn || r.x < 0 || r.x >= Rn) return !1;\n      const n = r.sub(e),\n        i = n.perp(),\n        s = t.sub(e);\n      return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;\n    }\n    function yd(t, e, r) {\n      const n = e ? 2 | t : -3 & t;\n      return r ? 1 | n : -2 & n;\n    }\n    function gd() {\n      const t = Math.PI / 32,\n        e = Math.tan(t),\n        r = Kl;\n      return r * Math.sqrt(1 + 2 * e * e) - r;\n    }\n    function xd(t, e, r) {\n      const n = 1 << r.z,\n        i = au(r.x / n),\n        s = au((r.x + 1) / n),\n        o = lu(r.y / n),\n        a = lu((r.y + 1) / n);\n      return function (t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        let s = arguments.length > 5 ? arguments[5] : undefined;\n        const o = [];\n        if (!t.length || !r || !n) return o;\n        const a = (t, e) => {\n            for (const r of t) o.push({\n              polygon: r,\n              bounds: e\n            });\n          },\n          l = Math.ceil(Math.log2(r)),\n          u = Math.ceil(Math.log2(n)),\n          c = l - u,\n          h = [];\n        for (let t = 0; t < Math.abs(c); t++) h.push(c > 0 ? 0 : 1);\n        for (let t = 0; t < Math.min(l, u); t++) h.push(0), h.push(1);\n        let p = t;\n        if (p = up(p, e[0].y - i, e[1].y + i, 1), p = up(p, e[0].x - i, e[1].x + i, 0), !p.length) return o;\n        const d = [];\n        for (h.length ? d.push({\n          polygons: p,\n          bounds: e,\n          depth: 0\n        }) : a(p, e); d.length;) {\n          const t = d.pop(),\n            e = t.depth,\n            r = h[e],\n            n = t.bounds[0],\n            o = t.bounds[1],\n            l = 0 === r ? n.x : n.y,\n            u = 0 === r ? o.x : o.y,\n            c = s ? s(r, l, u) : .5 * (l + u),\n            p = up(t.polygons, l - i, c + i, r),\n            f = up(t.polygons, c - i, u + i, r);\n          if (p.length) {\n            const t = [n, new wt(0 === r ? c : o.x, 1 === r ? c : o.y)];\n            h.length > e + 1 ? d.push({\n              polygons: p,\n              bounds: t,\n              depth: e + 1\n            }) : a(p, t);\n          }\n          if (f.length) {\n            const t = [new wt(0 === r ? c : n.x, 1 === r ? c : n.y), o];\n            h.length > e + 1 ? d.push({\n              polygons: f,\n              bounds: t,\n              depth: e + 1\n            }) : a(f, t);\n          }\n        }\n        return o;\n      }(t, e, Math.ceil((s - i) / 11.25), Math.ceil((o - a) / 11.25), 1, (t, e, i) => {\n        if (0 === t) return .5 * (e + i);\n        {\n          const t = lu((r.y + e / Rn) / n);\n          return (su(.5 * (lu((r.y + i / Rn) / n) + t)) * n - r.y) * Rn;\n        }\n      });\n    }\n    function vd(t, e, r, n, i, s) {\n      const o = Math.pow(2, n.z - i.z);\n      for (let a = 0; a < r; a++) {\n        let r = t.int16[2 * (a + e) + 0],\n          l = t.int16[2 * (a + e) + 1];\n        r = (r + i.x * Rn) * o - n.x * Rn, l = (l + i.y * Rn) * o - n.y * Rn, s.push(new wt(r, l));\n      }\n    }\n    let bd, wd;\n    Ws(ud, \"FillExtrusionBucket\", {\n      omit: [\"layers\", \"features\"]\n    }), Ws(nd, \"PartData\"), Ws(rd, \"FootprintSegment\"), Ws(id, \"BorderCentroidData\"), Ws(ld, \"GroundEffect\");\n    class _d extends wt {\n      constructor(t, e, r) {\n        super(t, e), this.z = r;\n      }\n    }\n    class Ad extends _d {\n      constructor(t, e, r, n) {\n        super(t, e, r), this.w = n;\n      }\n    }\n    function Md(t, e, r, n) {\n      const i = \"x\" === r ? \"y\" : \"x\",\n        s = (n - t[r]) / (e[r] - t[r]);\n      t[i] = Math.round(t[i] + (e[i] - t[i]) * s), t[r] = n, t.hasOwnProperty(\"z\") && (t.z = ur(t.z, e.z, s)), t.hasOwnProperty(\"w\") && (t.w = ur(t.w, e.w, s));\n    }\n    function Id(t, e, r, n) {\n      const i = r,\n        s = n;\n      for (const r of [\"x\", \"y\"]) {\n        let n = t,\n          o = e;\n        n[r] >= o[r] && (n = e, o = t), n[r] < i && o[r] > i && Md(n, o, r, i), n[r] < s && o[r] > s && Md(o, n, r, s);\n      }\n    }\n    function Sd(t, e, r, n, i, s) {\n      const o = [];\n      for (let a = 0; a < t.length; a++) {\n        const l = t[a];\n        let u;\n        const c = o.length;\n        let h = 0;\n        for (let t = 0; t < l.length - 1; t++) {\n          let c = l[t],\n            p = l[t + 1],\n            d = 0;\n          const f = h;\n          let m, y;\n          s && (d = Math.hypot(p.x - c.x, p.y - c.y), h += d, m = c, y = p), c.x < e && p.x < e || (c.x < e ? c = new wt(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x < e && (p = new wt(e, c.y + (e - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y < r && p.y < r || (c.y < r ? c = new wt(c.x + (r - c.y) / (p.y - c.y) * (p.x - c.x), r)._round() : p.y < r && (p = new wt(c.x + (r - c.y) / (p.y - c.y) * (p.x - c.x), r)._round()), c.x >= n && p.x >= n || (c.x >= n ? c = new wt(n, c.y + (n - c.x) / (p.x - c.x) * (p.y - c.y))._round() : p.x >= n && (p = new wt(n, c.y + (n - c.x) / (p.x - c.x) * (p.y - c.y))._round()), c.y >= i && p.y >= i || (c.y >= i ? c = new wt(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round() : p.y >= i && (p = new wt(c.x + (i - c.y) / (p.y - c.y) * (p.x - c.x), i)._round()), u && c.equals(u[u.length - 1]) || (u = [c], o.push(u), s && s.push({\n            progress: {\n              min: f + kd(m, y, c) * d,\n              max: 1\n            },\n            parentIndex: a,\n            prevPoint: m,\n            nextPoint: y\n          })), u.push(p), s && (s[s.length - 1].progress.max = f + kd(m, y, p) * d, s[s.length - 1].nextPoint = y)))));\n        }\n        if (s && h > 0) for (let t = c; t < o.length; t++) s[t].progress.min /= h, s[t].progress.max /= h;\n      }\n      return o;\n    }\n    function Pd(t, e, r, n, i) {\n      if (t.length < 2) return void n.push(t);\n      const s = [];\n      for (; e.valid();) {\n        const [r, n] = e.get();\n        for (let e = 0; e < t.length - 1; e++) {\n          const i = t[e],\n            o = t[e + 1],\n            a = oc(i, o, r, n);\n          if (a) {\n            const [t] = a,\n              r = new wt(ur(i.x, o.x, t), ur(i.y, o.y, t));\n            s.push({\n              t: e + t,\n              distance: 0,\n              point: r\n            });\n          }\n        }\n        e.next();\n      }\n      if (0 === s.length) return void n.push(t);\n      s.sort((t, e) => t.t - e.t);\n      let o = 0,\n        a = 0,\n        l = [];\n      for (n.push(l); o !== t.length;) {\n        if (a === s.length) {\n          for (; o !== t.length;) 0 !== l.length && l[l.length - 1].equals(t[o]) || l.push(t[o]), o++;\n          break;\n        }\n        s[a].t <= o ? (0 !== l.length && l[l.length - 1].equals(s[a].point) || l.push(s[a].point), Math.trunc(s[a].t), a++) : (0 !== l.length && l[l.length - 1].equals(t[o]) || l.push(t[o]), o++);\n      }\n    }\n    function kd(t, e, r) {\n      return t.x !== e.x ? (r.x - t.x) / (e.x - t.x) : t.y !== e.y ? (r.y - t.y) / (e.y - t.y) : 0;\n    }\n    function zd(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n    function Ed(t, e) {\n      if (1 === t.length) {\n        let r = 0;\n        const n = e[r++];\n        let i;\n        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n        for (; r < e.length; r++) {\n          const s = e[r],\n            o = t[0],\n            a = i.sub(n),\n            l = s.sub(n),\n            u = o.sub(n),\n            c = zd(a, a),\n            h = zd(a, l),\n            p = zd(l, l),\n            d = zd(u, a),\n            f = zd(u, l),\n            m = c * p - h * h,\n            y = (p * d - h * f) / m,\n            g = (c * f - h * d) / m,\n            x = n.z * (1 - y - g) + i.z * y + s.z * g;\n          if (isFinite(x)) return x;\n        }\n        return 1 / 0;\n      }\n      {\n        let t = 1 / 0;\n        for (const r of e) t = Math.min(t, r.z);\n        return t;\n      }\n    }\n    function Td(t, e, r, n, i, s, o, a) {\n      const l = o * i.getElevationAt(t, e, !0, !0),\n        u = 0 !== s[0],\n        c = u ? 0 === s[1] ? o * (s[0] / 7 - 450) : o * function (t, e, r) {\n          const n = Math.floor(e[0] / 8),\n            i = Math.floor(e[1] / 8),\n            s = 10 * (e[0] - 8 * n),\n            o = 10 * (e[1] - 8 * i),\n            a = t.getElevationAt(n, i, !0, !0),\n            l = t.getMeterToDEM(r),\n            u = Math.floor(.5 * (s * l - 1)),\n            c = Math.floor(.5 * (o * l - 1)),\n            h = t.tileCoordToPixel(n, i),\n            p = 2 * u + 1,\n            d = 2 * c + 1,\n            f = function (t, e, r, n, i) {\n              return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];\n            }(t, h.x - u, h.y - c, p, d),\n            m = Math.abs(f[0] - f[1]),\n            y = Math.abs(f[2] - f[3]),\n            g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]),\n            x = Math.min(.25, .5 * l * (m + y) / p),\n            v = Math.min(.25, .5 * l * g / d);\n          return a + Math.max(x * s, v * o);\n        }(i, s, a) : l;\n      return {\n        base: l + (0 === r ? -1 : r),\n        top: u ? Math.max(c + n, l + r + 2) : l + n\n      };\n    }\n    class Bd {\n      constructor(t) {\n        this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n          this._triggered = !1, this._callback();\n        });\n      }\n      trigger() {\n        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n          this._triggered = !1, this._callback();\n        }, 0));\n      }\n      remove() {\n        this._channel = void 0, this._callback = () => {};\n      }\n    }\n    class Vd {\n      constructor() {\n        this.tasks = {}, this.taskQueue = [], Lt([\"process\"], this), this.invoker = new Bd(this.process), this.nextId = 0;\n      }\n      add(t, e) {\n        const r = this.nextId++,\n          n = function (_ref62) {\n            let {\n              type: t,\n              isSymbolTile: e,\n              zoom: r\n            } = _ref62;\n            return r = r || 0, \"message\" === t ? 0 : \"maybePrepare\" !== t || e ? \"parseTile\" !== t || e ? \"parseTile\" === t && e ? 300 - r : \"maybePrepare\" === t && e ? 400 - r : 500 : 200 - r : 100 - r;\n          }(e);\n        if (0 === n) {\n          try {\n            t();\n          } finally {}\n          return null;\n        }\n        return this.tasks[r] = {\n          fn: t,\n          metadata: e,\n          priority: n,\n          id: r\n        }, this.taskQueue.push(r), this.invoker.trigger(), {\n          cancel: () => {\n            delete this.tasks[r];\n          }\n        };\n      }\n      process() {\n        try {\n          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;\n          const t = this.pick();\n          if (null === t) return;\n          const e = this.tasks[t];\n          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;\n          e.fn();\n        } finally {}\n      }\n      pick() {\n        let t = null,\n          e = 1 / 0;\n        for (let r = 0; r < this.taskQueue.length; r++) {\n          const n = this.tasks[this.taskQueue[r]];\n          n.priority < e && (e = n.priority, t = r);\n        }\n        if (null === t) return null;\n        const r = this.taskQueue[t];\n        return this.taskQueue.splice(t, 1), r;\n      }\n      remove() {\n        this.invoker.remove();\n      }\n    }\n    class Fd {\n      constructor(t, e, r) {\n        this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, Lt([\"receive\"], this), this.target.addEventListener(\"message\", this.receive, !1), this.scheduler = new Vd();\n      }\n      send(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n        let s = arguments.length > 5 ? arguments[5] : undefined;\n        const o = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n        r && (r.metadata = s, this.callbacks[o] = r);\n        const a = new Set();\n        return this.target.postMessage({\n          id: o,\n          type: t,\n          hasCallback: !!r,\n          targetMapId: n,\n          mustQueue: i,\n          sourceMapId: this.mapId,\n          data: Js(e, a)\n        }, a), {\n          cancel: () => {\n            r && delete this.callbacks[o], this.target.postMessage({\n              id: o,\n              type: \"<cancel>\",\n              targetMapId: n,\n              sourceMapId: this.mapId\n            });\n          }\n        };\n      }\n      receive(t) {\n        const e = t.data;\n        if (!e) return;\n        const r = e.id;\n        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n          const t = this.cancelCallbacks[r];\n          delete this.cancelCallbacks[r], t && t.cancel();\n        } else if (e.mustQueue || Zt(self)) {\n          const t = this.callbacks[r],\n            n = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {\n              type: \"message\"\n            });\n          n && (this.cancelCallbacks[r] = n);\n        } else this.processTask(r, e);\n      }\n      processTask(t, e) {\n        if (delete this.cancelCallbacks[t], \"<response>\" === e.type) {\n          const r = this.callbacks[t];\n          delete this.callbacks[t], r && (e.error ? r(Qs(e.error)) : r(null, Qs(e.data)));\n        } else {\n          const r = new Set(),\n            n = e.hasCallback ? (e, n) => {\n              this.target.postMessage({\n                id: t,\n                type: \"<response>\",\n                sourceMapId: this.mapId,\n                error: e ? Js(e) : null,\n                data: Js(n, r)\n              }, r);\n            } : () => {},\n            i = Qs(e.data);\n          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {\n            const t = e.type.split(\".\"),\n              {\n                source: r,\n                scope: s\n              } = i;\n            this.parent.getWorkerSource(e.sourceMapId, t[0], r, s)[t[1]](i, n);\n          } else n(new Error(\"Could not find function \".concat(e.type)));\n        }\n      }\n      remove() {\n        this.scheduler.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n      }\n    }\n    var Cd = {\n      workerUrl: \"\",\n      workerClass: null,\n      workerParams: void 0\n    };\n    const Dd = \"mapboxgl_preloaded_worker_pool\";\n    class Rd {\n      constructor() {\n        this.active = {};\n      }\n      acquire(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Rd.workerCount;\n        if (!this.workers) for (this.workers = []; this.workers.length < e;) this.workers.push(null != Cd.workerClass ? new Cd.workerClass() : new self.Worker(Cd.workerUrl, Cd.workerParams));\n        return this.active[t] = !0, this.workers.slice();\n      }\n      release(t) {\n        delete this.active[t], this.workers && 0 === this.numActive() && (this.workers.forEach(t => {\n          t.terminate();\n        }), this.workers = null);\n      }\n      isPreloaded() {\n        return !!this.active[Dd];\n      }\n      numActive() {\n        return Object.keys(this.active).length;\n      }\n    }\n    Rd.workerCount = 2;\n    class Ld {\n      constructor(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Worker\";\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Rd.workerCount;\n        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = Dt();\n        const i = this.workerPool.acquire(this.id, n);\n        for (let t = 0; t < i.length; t++) {\n          const n = new Ld.Actor(i[t], e, this.id);\n          n.name = \"\".concat(r, \" \").concat(t), this.actors.push(n);\n        }\n        this.ready = !1, this.broadcast(\"checkIfReady\", null, () => {\n          this.ready = !0;\n        });\n      }\n      broadcast(t, e, r) {\n        Ft(this.actors, (r, n) => {\n          r.send(t, e, n);\n        }, r = r || function () {});\n      }\n      getActor() {\n        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n      }\n      remove() {\n        this.actors.forEach(t => {\n          t.remove();\n        }), this.actors = [], this.workerPool.release(this.id);\n      }\n    }\n    let Od, Ud;\n    function Nd() {\n      return Od || (Od = new Rd()), Od;\n    }\n    Ld.Actor = Fd;\n    class jd {\n      constructor(t) {\n        this.module = t;\n      }\n      createIntArray(t) {\n        const e = new Int32Array(t),\n          r = this.module.malloc(e.length * e.BYTES_PER_ELEMENT);\n        return this.module.heap32.set(e, r / e.BYTES_PER_ELEMENT), r;\n      }\n      createFloatArray(t) {\n        const e = new Float32Array(t),\n          r = this.module.malloc(e.length * e.BYTES_PER_ELEMENT);\n        return this.module.heapF32.set(e, r / e.BYTES_PER_ELEMENT), r;\n      }\n      createStringBuffer(t) {\n        const e = this.module.malloc(t.length + 1);\n        for (let r = 0; r < t.length; ++r) this.module.heapU8[e + r] = t.charCodeAt(r);\n        return this.module.heapU8[e + t.length] = 0, e;\n      }\n      readStringBuffer(t) {\n        let e = \"\";\n        for (; 0 !== this.module.heapU8[t];) e += String.fromCharCode(this.module.heapU8[t]), ++t;\n        return e;\n      }\n      setStyle(t) {\n        const e = t.entranceColorRgb,\n          r = t.facadeGlazingColorRgb,\n          n = t.roofColorRgb,\n          i = t.wallColorRgb,\n          s = t.normalScale;\n        this.module.setStyle(e[0], e[1], e[2], r[0], r[1], r[2], n[0], n[1], n[2], i[0], i[1], i[2], s[0], s[1], s[2], t.tileToMeters);\n      }\n      setAOOptions(t, e) {\n        this.module.setAOOptions(t ? 1 : 0, e);\n      }\n      setMetricOptions(t, e) {\n        this.module.setMetricOptions(t ? 1 : 0, e);\n      }\n      setStructuralOptions(t) {\n        this.module.setStructuralOptions(t ? 1 : 0);\n      }\n      setFacadeOptions(t, e) {\n        this.module.setFacadeOptions(t, e ? 1 : 0);\n      }\n      setFauxFacadeOptions(t, e, r) {\n        this.module.setFauxFacadeOptions(t ? 1 : 0, e ? 1 : 0, r);\n      }\n      setFacadeClassifierOptions(t) {\n        this.module.setFacadeClassifierOptions(t);\n      }\n      generateMesh(t, e) {\n        for (const e of t) {\n          const t = this.createStringBuffer(e.roofType),\n            r = [0],\n            n = [];\n          for (const t of e.coordinates) if (Array.isArray(t)) {\n            for (const e of t) n.push(e.x), n.push(e.y);\n            r.push(n.length);\n          }\n          const i = this.createIntArray(r),\n            s = this.createFloatArray(n);\n          this.module.addFeature(e.id, e.sourceId, e.minHeight, e.height, t, e.roofType.length, s, i, r.length - 1), this.module.free(t), this.module.free(i), this.module.free(s);\n        }\n        for (const t of e) {\n          let e;\n          e = t.entrances ? JSON.parse(t.entrances) : [];\n          const r = this.createFloatArray(e),\n            n = [];\n          for (const e of t.coordinates) n.push(e.x), n.push(e.y);\n          const i = this.createFloatArray(n);\n          this.module.addFacade(t.sourceId, t.crossPerc, t.distanceToRoad, r, e.length, i, n.length), this.module.free(r), this.module.free(i);\n        }\n        if (!this.module.generateMesh()) {\n          const t = this.module.getLastError();\n          return this.readStringBuffer(t);\n        }\n        const r = this.module.getMeshCount(),\n          n = new Array(r);\n        for (let t = 0; t < r; t++) {\n          const e = this.module.getPositionsPtr(t),\n            r = this.module.getPositionsLength(t),\n            i = new Float32Array(this.module.heapF32.buffer, e, r),\n            s = this.module.getNormalsPtr(t),\n            o = this.module.getNormalsLength(t),\n            a = new Float32Array(this.module.heapF32.buffer, s, o),\n            l = this.module.getColorsPtr(t),\n            u = this.module.getColorsLength(t),\n            c = new Uint8Array(this.module.heapU8.buffer, l, u),\n            h = this.module.getAOPtr(t),\n            p = this.module.getAOLength(t),\n            d = new Float32Array(this.module.heapF32.buffer, h, p),\n            f = this.module.getUVPtr(t),\n            m = this.module.getUVLength(t),\n            y = new Float32Array(this.module.heapF32.buffer, f, m),\n            g = this.module.getFauxFacadePtr(t),\n            x = this.module.getFauxFacadeLength(t),\n            v = new Uint8Array(this.module.heapU8.buffer, g, x),\n            b = this.module.getIndicesPtr(t),\n            w = this.module.getIndicesLength(t),\n            _ = new Int32Array(this.module.heap32.buffer, b, w),\n            A = this.module.getBuildingPart(t),\n            M = this.readStringBuffer(A);\n          n[t] = {\n            positions: i,\n            normals: a,\n            colors: c,\n            ao: d,\n            uv: y,\n            isFauxFacade: v,\n            indices: _,\n            buildingPart: M\n          };\n        }\n        const i = this.module.getRingCount(),\n          s = [];\n        for (let t = 0; t < i; t++) {\n          const e = this.module.getRingPtr(t),\n            r = this.module.getRingLength(t),\n            n = new Float32Array(this.module.heapF32.buffer, e, r);\n          s.push(n);\n        }\n        return {\n          meshes: n,\n          outerRingLength: this.module.getOuterRingLength(),\n          modifiedPolygonRings: s\n        };\n      }\n    }\n    let $d,\n      Gd,\n      Hd,\n      qd,\n      Xd,\n      Zd = null,\n      Wd = null,\n      Yd = null,\n      Kd = null;\n    function Jd() {\n      return Zt(self) && self.worker.dracoUrl ? self.worker.dracoUrl : Gd || ne.DRACO_URL;\n    }\n    function Qd() {\n      if (Zt(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;\n      if (qd) return qd;\n      const t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);\n      if (\"object\" != typeof WebAssembly) throw new Error(\"WebAssembly not supported, cannot instantiate meshoptimizer\");\n      return qd = WebAssembly.validate(t) ? ne.MESHOPT_SIMD_URL : ne.MESHOPT_URL, qd;\n    }\n    function tf() {\n      return Kd;\n    }\n    const ef = {\n        5120: Int8Array,\n        5121: Uint8Array,\n        5122: Int16Array,\n        5123: Uint16Array,\n        5125: Uint32Array,\n        5126: Float32Array\n      },\n      rf = {\n        5120: \"DT_INT8\",\n        5121: \"DT_UINT8\",\n        5122: \"DT_INT16\",\n        5123: \"DT_UINT16\",\n        5125: \"DT_UINT32\",\n        5126: \"DT_FLOAT32\"\n      },\n      nf = {\n        SCALAR: 1,\n        VEC2: 2,\n        VEC3: 3,\n        VEC4: 4,\n        MAT2: 4,\n        MAT3: 9,\n        MAT4: 16\n      };\n    function sf(t, e, r) {\n      const n = r.json.bufferViews.length,\n        i = r.buffers.length;\n      e.bufferView = n, r.json.bufferViews[n] = {\n        buffer: i,\n        byteLength: t.byteLength\n      }, r.buffers[i] = t;\n    }\n    const of = \"KHR_draco_mesh_compression\";\n    function af(t, e) {\n      const r = t.extensions && t.extensions[of];\n      if (!r) return;\n      const n = new Hd.Decoder(),\n        i = ff(e, r.bufferView),\n        s = new Hd.Mesh();\n      if (!n.DecodeArrayToMesh(i, i.byteLength, s)) throw new Error(\"Failed to decode Draco mesh\");\n      const o = e.json.accessors[t.indices],\n        a = ef[o.componentType],\n        l = o.count * a.BYTES_PER_ELEMENT,\n        u = Hd._malloc(l);\n      a === Uint16Array ? n.GetTrianglesUInt16Array(s, l, u) : n.GetTrianglesUInt32Array(s, l, u), sf(Hd.memory.buffer.slice(u, u + l), o, e), Hd._free(u);\n      for (const i of Object.keys(r.attributes)) {\n        const o = n.GetAttributeByUniqueId(s, r.attributes[i]),\n          a = e.json.accessors[t.attributes[i]],\n          l = rf[a.componentType],\n          u = a.count * nf[a.type] * ef[a.componentType].BYTES_PER_ELEMENT,\n          c = Hd._malloc(u);\n        n.GetAttributeDataArrayForAllPoints(s, o, Hd[l], u, c), sf(Hd.memory.buffer.slice(c, c + u), a, e), Hd._free(c);\n      }\n      n.destroy(), s.destroy(), delete t.extensions[of];\n    }\n    const lf = \"EXT_meshopt_compression\";\n    function uf(t, e) {\n      if (!t.extensions || !t.extensions[lf]) return;\n      const r = t.extensions[lf],\n        n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0),\n        i = new Uint8Array(r.count * r.byteStride);\n      Xd.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t.buffer = e.buffers.length, t.byteOffset = 0, e.buffers[t.buffer] = i.buffer, delete t.extensions[lf];\n    }\n    const cf = 1179937895,\n      hf = new TextDecoder(\"utf8\");\n    function pf(t, e) {\n      return new URL(t, e).href;\n    }\n    function df(t, e, r, n) {\n      return fetch(pf(t.uri, n)).then(t => t.arrayBuffer()).then(t => {\n        e.buffers[r] = t;\n      });\n    }\n    function ff(t, e) {\n      const r = t.json.bufferViews[e];\n      return new Uint8Array(t.buffers[r.buffer], r.byteOffset || 0, r.byteLength);\n    }\n    function mf(t, e, r, n) {\n      if (t.uri) {\n        const i = pf(t.uri, n);\n        return fetch(i).then(t => t.blob()).then(t => createImageBitmap(t)).then(t => {\n          e.images[r] = t;\n        });\n      }\n      if (void 0 !== t.bufferView) {\n        const n = ff(e, t.bufferView),\n          i = new Blob([n], {\n            type: t.mimeType\n          });\n        return createImageBitmap(i).then(t => {\n          e.images[r] = t;\n        });\n      }\n    }\n    function yf(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let r = arguments.length > 2 ? arguments[2] : undefined;\n      const n = {\n        json: null,\n        images: [],\n        buffers: []\n      };\n      if (new Uint32Array(t, e, 1)[0] === cf) {\n        const r = new Uint32Array(t, e);\n        let i = 2;\n        const s = (r[i++] >> 2) - 3,\n          o = r[i++] >> 2;\n        if (i++, n.json = JSON.parse(hf.decode(r.subarray(i, i + o))), i += o, i < s) {\n          const s = r[i++];\n          i++;\n          const o = e + (i << 2);\n          n.buffers[0] = t.slice(o, o + s);\n        }\n      } else n.json = JSON.parse(hf.decode(new Uint8Array(t, e)));\n      const {\n        buffers: i,\n        images: s,\n        meshes: o,\n        extensionsUsed: a,\n        bufferViews: l\n      } = n.json;\n      let u = Promise.resolve();\n      if (i) {\n        const t = [];\n        for (let e = 0; e < i.length; e++) {\n          const s = i[e];\n          s.uri ? t.push(df(s, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);\n        }\n        u = Promise.all(t);\n      }\n      return u.then(() => {\n        const t = [],\n          e = a && a.includes(of),\n          i = a && a.includes(lf);\n        if (e && t.push(function () {\n          if (!Hd) return null != $d ? $d : ($d = function (t) {\n            let e,\n              r = null;\n            function n() {\n              e = new Uint8Array(r.buffer);\n            }\n            function i() {\n              throw new Error(\"Unexpected Draco error.\");\n            }\n            const s = {\n              a: {\n                a: i,\n                d: function (t, r, n) {\n                  return e.copyWithin(t, r, r + n);\n                },\n                c: function (t) {\n                  const i = e.length,\n                    s = Math.max(t >>> 0, Math.ceil(1.2 * i)),\n                    o = Math.ceil((s - i) / 65536);\n                  try {\n                    return r.grow(o), n(), !0;\n                  } catch (t) {\n                    return !1;\n                  }\n                },\n                b: i\n              }\n            };\n            return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t, s) : t.then(t => t.arrayBuffer()).then(t => WebAssembly.instantiate(t, s))).then(t => {\n              const {\n                Rb: i,\n                Qb: s,\n                P: o,\n                T: a,\n                X: l,\n                Ja: u,\n                La: c,\n                Qa: h,\n                Va: p,\n                Wa: d,\n                eb: f,\n                jb: m,\n                f: y,\n                e: g,\n                yb: x,\n                zb: v,\n                Ab: b,\n                Bb: w,\n                Db: _,\n                Gb: A\n              } = t.instance.exports;\n              r = g;\n              const M = (() => {\n                let t = 0,\n                  r = 0,\n                  n = 0,\n                  o = 0;\n                return a => {\n                  n && (i(o), i(t), r += n, n = t = 0), t || (r += 128, t = s(r));\n                  const l = a.length + 7 & -8;\n                  let u = t;\n                  l >= r && (n = l, u = o = s(l));\n                  for (let t = 0; t < a.length; t++) e[u + t] = a[t];\n                  return u;\n                };\n              })();\n              return n(), y(), {\n                memory: g,\n                _free: i,\n                _malloc: s,\n                Mesh: class {\n                  constructor() {\n                    this.ptr = o();\n                  }\n                  destroy() {\n                    a(this.ptr);\n                  }\n                },\n                Decoder: class {\n                  constructor() {\n                    this.ptr = u();\n                  }\n                  destroy() {\n                    m(this.ptr);\n                  }\n                  DecodeArrayToMesh(t, e, r) {\n                    const n = M(t),\n                      i = c(this.ptr, n, e, r.ptr);\n                    return !!l(i);\n                  }\n                  GetAttributeByUniqueId(t, e) {\n                    return {\n                      ptr: h(this.ptr, t.ptr, e)\n                    };\n                  }\n                  GetTrianglesUInt16Array(t, e, r) {\n                    p(this.ptr, t.ptr, e, r);\n                  }\n                  GetTrianglesUInt32Array(t, e, r) {\n                    d(this.ptr, t.ptr, e, r);\n                  }\n                  GetAttributeDataArrayForAllPoints(t, e, r, n, i) {\n                    f(this.ptr, t.ptr, e.ptr, r, n, i);\n                  }\n                },\n                DT_INT8: x(),\n                DT_UINT8: v(),\n                DT_INT16: b(),\n                DT_UINT16: w(),\n                DT_UINT32: _(),\n                DT_FLOAT32: A()\n              };\n            });\n          }(fetch(Jd())), $d.then(t => {\n            Hd = t, $d = void 0;\n          }));\n        }()), i && t.push(function () {\n          if (Xd) return;\n          const t = function (t) {\n            let e;\n            const r = WebAssembly.instantiateStreaming(t, {}).then(t => {\n                e = t.instance, e.exports.__wasm_call_ctors();\n              }),\n              n = {\n                NONE: \"\",\n                OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n                QUATERNION: \"meshopt_decodeFilterQuat\",\n                EXPONENTIAL: \"meshopt_decodeFilterExp\"\n              },\n              i = {\n                ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n                TRIANGLES: \"meshopt_decodeIndexBuffer\",\n                INDICES: \"meshopt_decodeIndexSequence\"\n              };\n            return {\n              ready: r,\n              supported: !0,\n              decodeGltfBuffer(t, r, s, o, a, l) {\n                !function (t, e, r, n, i, s, o) {\n                  const a = t.exports.sbrk,\n                    l = n + 3 & -4,\n                    u = a(l * i),\n                    c = a(s.length),\n                    h = new Uint8Array(t.exports.memory.buffer);\n                  h.set(s, c);\n                  const p = e(u, n, i, c, s.length);\n                  if (0 === p && o && o(u, l, i), r.set(h.subarray(u, u + n * i)), a(u - a(0)), 0 !== p) throw new Error(\"Malformed buffer data: \".concat(p));\n                }(e, e.exports[i[a]], t, r, s, o, e.exports[n[l]]);\n              }\n            };\n          }(fetch(Qd()));\n          return t.ready.then(() => {\n            Xd = t;\n          });\n        }()), s) for (let e = 0; e < s.length; e++) t.push(mf(s[e], n, e, r));\n        return (t.length ? Promise.all(t) : Promise.resolve()).then(() => {\n          if (e && o) for (const {\n            primitives: t\n          } of o) for (const e of t) af(e, n);\n          if (i && o && l) for (const t of l) uf(t, n);\n          return n;\n        });\n      });\n    }\n    function gf(t) {\n      switch (t) {\n        case WebGL2RenderingContext.RGBA8:\n          return WebGL2RenderingContext.RGBA;\n        case WebGL2RenderingContext.DEPTH_COMPONENT16:\n          return WebGL2RenderingContext.DEPTH_COMPONENT;\n        case WebGL2RenderingContext.DEPTH24_STENCIL8:\n          return WebGL2RenderingContext.DEPTH_STENCIL;\n        case WebGL2RenderingContext.R8:\n        case WebGL2RenderingContext.R32F:\n          return WebGL2RenderingContext.RED;\n      }\n    }\n    function xf(t) {\n      switch (t) {\n        case WebGL2RenderingContext.RGBA8:\n          return WebGL2RenderingContext.UNSIGNED_BYTE;\n        case WebGL2RenderingContext.DEPTH_COMPONENT16:\n          return WebGL2RenderingContext.UNSIGNED_SHORT;\n        case WebGL2RenderingContext.DEPTH24_STENCIL8:\n          return WebGL2RenderingContext.UNSIGNED_INT_24_8;\n        case WebGL2RenderingContext.R8:\n          return WebGL2RenderingContext.UNSIGNED_BYTE;\n        case WebGL2RenderingContext.R32F:\n          return WebGL2RenderingContext.FLOAT;\n      }\n    }\n    class vf {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = r, this.useMipmap = n && n.useMipmap, this.texture = t.gl.createTexture(), this.update(e, {\n          premultiply: n && n.premultiply\n        });\n      }\n      update(t, e) {\n        const r = t && t instanceof HTMLVideoElement && 0 === t.width ? t.videoWidth : t.width,\n          n = t && t instanceof HTMLVideoElement && 0 === t.height ? t.videoHeight : t.height,\n          {\n            context: i\n          } = this,\n          {\n            gl: s\n          } = i,\n          {\n            x: o,\n            y: a\n          } = e && e.position ? e.position : {\n            x: 0,\n            y: 0\n          },\n          l = o + r,\n          u = a + n;\n        !this.size || this.size[0] === l && this.size[1] === u || (s.bindTexture(s.TEXTURE_2D, null), s.deleteTexture(this.texture), this.texture = s.createTexture(), this.size = null), s.bindTexture(s.TEXTURE_2D, this.texture), i.pixelStoreUnpackFlipY.set(!1), i.pixelStoreUnpack.set(1), i.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA8 && (!e || !1 !== e.premultiply));\n        const c = t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ImageBitmap && t instanceof ImageBitmap;\n        if (!this.size && l > 0 && u > 0) {\n          const t = this.useMipmap ? Math.floor(Math.log2(Math.max(l, u))) + 1 : 1;\n          s.texStorage2D(s.TEXTURE_2D, t, this.format, l, u), this.size = [l, u];\n        }\n        this.size && (c ? s.texSubImage2D(s.TEXTURE_2D, 0, o, a, gf(this.format), xf(this.format), t) : \"data\" in t && t.data && s.texSubImage2D(s.TEXTURE_2D, 0, o, a, r, n, gf(this.format), xf(this.format), t.data)), this.useMipmap && s.generateMipmap(s.TEXTURE_2D);\n      }\n      bind(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        const {\n            context: n\n          } = this,\n          {\n            gl: i\n          } = n;\n        i.bindTexture(i.TEXTURE_2D, this.texture), t !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t), this.minFilter = t), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n      bindExtraParam(t, e, r, n, i) {\n        const {\n            context: s\n          } = this,\n          {\n            gl: o\n          } = s;\n        o.bindTexture(o.TEXTURE_2D, this.texture), e !== this.magFilter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), this.magFilter = e), t !== this.minFilter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, this.useMipmap ? t === o.NEAREST ? o.NEAREST_MIPMAP_NEAREST : o.LINEAR_MIPMAP_LINEAR : t), this.minFilter = t), r !== this.wrapS && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, n), this.wrapT = n), i !== this.compareMode && (i ? (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_COMPARE_MODE, o.COMPARE_REF_TO_TEXTURE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_COMPARE_FUNC, i)) : o.texParameteri(o.TEXTURE_2D, o.TEXTURE_COMPARE_MODE, o.NONE), this.compareMode = i);\n      }\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n    }\n    class bf {\n      constructor(t, e) {\n        this.context = t, this.texture = e;\n      }\n      bind(t, e) {\n        const {\n            context: r\n          } = this,\n          {\n            gl: n\n          } = r;\n        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t), this.minFilter = t), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n    }\n    const wf = aa([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      _f = aa([{\n        name: \"a_color_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      Af = aa([{\n        name: \"a_color_4f\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      Mf = aa([{\n        name: \"a_uv_2f\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      If = aa([{\n        name: \"a_normal_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      Sf = aa([{\n        name: \"a_normal_matrix0\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix1\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix2\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix3\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      Pf = aa([{\n        name: \"a_pbr\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_heightBasedEmissiveStrength\",\n        components: 3,\n        type: \"Float32\"\n      }]);\n    function kf(t, e) {\n      const r = Ef(t.projection, t.zoom, t.width, t.height),\n        n = function (t, e, r, n, i) {\n          const s = new Ql(r.lng - 180 * Tf, r.lat),\n            o = new Ql(r.lng + 180 * Tf, r.lat),\n            a = t.project(s.lng, s.lat),\n            u = t.project(o.lng, o.lat),\n            h = -Math.atan2(u.y - a.y, u.x - a.x),\n            d = mu.fromLngLat(r);\n          d.y = Tt(d.y, -1 + Tf, 1 - Tf);\n          const f = d.toLngLat(),\n            y = t.project(f.lng, f.lat),\n            g = mu.fromLngLat(f);\n          g.x += Tf;\n          const x = g.toLngLat(),\n            v = t.project(x.lng, x.lat),\n            b = Vf(v.x - y.x, v.y - y.y, h),\n            w = mu.fromLngLat(f);\n          w.y += Tf;\n          const _ = w.toLngLat(),\n            A = t.project(_.lng, _.lat),\n            M = Vf(A.x - y.x, A.y - y.y, h),\n            I = Math.abs(b.x) / Math.abs(M.y),\n            S = l([]);\n          m(S, S, -h * (1 - (i ? 0 : n)));\n          const P = l([]);\n          return p(P, P, [1, 1 - (1 - I) * n, 1]), P[4] = -M.x / M.y * n, m(P, P, h), c(P, S, P), P;\n        }(t.projection, 0, t.center, r, e),\n        i = zf(t);\n      return p(n, n, [i, i, 1]), n;\n    }\n    function zf(t) {\n      const e = t.projection,\n        r = Ef(t.projection, t.zoom, t.width, t.height),\n        n = Bf(e, t.center),\n        i = Bf(e, Ql.convert(e.center));\n      return Math.pow(2, n * r + (1 - r) * i);\n    }\n    function Ef(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1 / 0;\n      const s = t.range;\n      if (!s) return 0;\n      const o = Math.min(i, Math.max(r, n)),\n        a = Math.log2(o / 1024);\n      return Bt(s[0] + a, s[1] + a, e);\n    }\n    const Tf = 1 / 4e4;\n    function Bf(t, e) {\n      const r = Tt(e.lat, -cu, cu),\n        n = new Ql(e.lng - 180 * Tf, r),\n        i = new Ql(e.lng + 180 * Tf, r),\n        s = t.project(n.lng, r),\n        o = t.project(i.lng, r),\n        a = mu.fromLngLat(n),\n        l = mu.fromLngLat(i),\n        u = o.x - s.x,\n        c = o.y - s.y,\n        h = l.x - a.x,\n        p = l.y - a.y,\n        d = Math.sqrt((h * h + p * p) / (u * u + c * c));\n      return Math.log2(d);\n    }\n    function Vf(t, e, r) {\n      const n = Math.cos(r),\n        i = Math.sin(r);\n      return {\n        x: t * n - e * i,\n        y: t * i + e * n\n      };\n    }\n    function Ff(t, e, r) {\n      l(t), m(t, t, It(e[2])), d(t, t, It(e[0])), f(t, t, It(e[1])), p(t, t, r), c(t, t, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\n    }\n    function Cf(t, e, r, n, i, s, o, a) {\n      const l = [r[0] - e[0], r[1] - e[1], 0],\n        u = [n[0] - e[0], n[1] - e[1], 0];\n      if (_(l) < 1e-12 || _(u) < 1e-12) return J(t);\n      const c = R([], l, u);\n      C(c, c), S(u, n, e), l[2] = (s - i) * a, u[2] = (o - i) * a;\n      const h = l;\n      return R(h, l, u), C(h, h), st(t, c, h);\n    }\n    function Df(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      const n = Yc(e.zoom),\n        i = function (t, e, r) {\n          const n = e.worldSize,\n            i = [t[12], t[13], t[14]],\n            s = lu(i[1] / n),\n            o = au(i[0] / n),\n            a = l([]),\n            u = ou(1, s) * n,\n            d = ou(1, 0) * n * pu(s, e.zoom),\n            f = 1 / Xc(n);\n          let m = d * f;\n          if (r) {\n            const t = Ef(e.projection, e.zoom, e.width, e.height, 1024);\n            m = f * e.projection.pixelSpaceConversion(e.center.lat, n, t);\n          }\n          const y = Yl(s, o);\n          I(y, y, E([], C([], y), u * m * i[2]));\n          const g = function (t) {\n            const e = [t[0], t[1], t[2]];\n            let r = [0, 1, 0];\n            const n = R([], r, e);\n            return R(r, e, n), 0 === V(r) && (r = [0, 1, 0], R(n, e, r)), C(n, n), C(r, r), C(e, e), [n[0], n[1], n[2], 0, r[0], r[1], r[2], 0, e[0], e[1], e[2], 0, t[0], t[1], t[2], 1];\n          }(y);\n          p(a, a, [m, m, m * u]), h(a, a, [-i[0], -i[1], -i[2]]);\n          const x = c([], e.globeMatrix, g);\n          return c(x, x, a), c(x, x, t), x;\n        }(t, e, r);\n      if (n > 0) {\n        const r = function (t, e) {\n          const r = e.worldSize,\n            n = ou(1, 0) * r * pu(e.center.lat, e.zoom) / Xc(r),\n            i = ou(1, e.center.lat) * r,\n            s = l([]);\n          f(s, s, It(e.center.lng)), d(s, s, It(e.center.lat)), h(s, s, [0, 0, Nl]), p(s, s, [n, n, n * i]);\n          const o = e.point;\n          return h(s, s, [-o.x, -o.y, 0]), c(s, s, t), c(s, e.globeMatrix, s);\n        }(t, e);\n        return function (t, e, r) {\n          const n = (t, e, r) => {\n              const n = _(t),\n                i = _(e),\n                s = Rc(t, e, r);\n              return E(s, s, 1 / _(s) * ur(n, i, r));\n            },\n            i = n([t[0], t[1], t[2]], [e[0], e[1], e[2]], r),\n            s = n([t[4], t[5], t[6]], [e[4], e[5], e[6]], r),\n            o = n([t[8], t[9], t[10]], [e[8], e[9], e[10]], r),\n            a = Rc([t[12], t[13], t[14]], [e[12], e[13], e[14]], r);\n          return [i[0], i[1], i[2], 0, s[0], s[1], s[2], 0, o[0], o[1], o[2], 0, a[0], a[1], a[2], 1];\n        }(i, r, n);\n      }\n      return i;\n    }\n    function Rf(t, e, r, n) {\n      const i = Xu.projectAabbCorners(n, r);\n      let s = Number.MAX_VALUE,\n        o = -1;\n      for (let t = 0; t < i.length; ++t) {\n        const r = i[t];\n        r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < s && (o = t, s = r[2]);\n      }\n      const a = t => new wt(i[t][0], i[t][1]);\n      let l;\n      switch (o) {\n        case 0:\n        case 6:\n          l = [a(1), a(5), a(4), a(7), a(3), a(2), a(1)];\n          break;\n        case 1:\n        case 7:\n          l = [a(0), a(4), a(5), a(6), a(2), a(3), a(0)];\n          break;\n        case 3:\n        case 5:\n          l = [a(1), a(0), a(4), a(7), a(6), a(2), a(1)];\n          break;\n        default:\n          l = [a(1), a(5), a(6), a(7), a(3), a(0), a(1)];\n      }\n      if (Qu(t, l)) return s;\n    }\n    const Lf = 64,\n      Of = {\n        CoordinateSpaceTile: 1,\n        HasMapboxMeshFeatures: 4,\n        HasMeshoptCompression: 8\n      };\n    function Uf(t, e, r, n, i, s, o, a, u) {\n      let d = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : !1;\n      const f = r.zoom,\n        m = r.project(n),\n        y = pu(n.lat, f),\n        g = 1 / y;\n      l(t), h(t, t, [m.x + o[0] * g, m.y + o[1] * g, o[2]]);\n      let v = 1,\n        b = 1;\n      const w = r.worldSize;\n      if (d) {\n        if (\"mercator\" === r.projection.name) {\n          let t = 0;\n          r.elevation && (t = r.elevation.getAtPointOrZero(new mu(m.x / w, m.y / w), 0));\n          const e = Y([], [m.x, m.y, t, 1], r.projMatrix)[3] / r.cameraToCenterDistance;\n          v = e, b = e * pu(r.center.lat, f);\n        } else if (\"globe\" === r.projection.name) {\n          const e = Df(t, r),\n            i = [0, 0, 0, 1];\n          Y(i, i, c([], r.projMatrix, e));\n          const s = i[3] / r.cameraToCenterDistance,\n            o = Yc(f),\n            a = r.projection.pixelsPerMeter(n.lat, w) * pu(n.lat, f),\n            l = r.projection.pixelsPerMeter(r.center.lat, w) * pu(r.center.lat, f);\n          v = s / ur(a, hu(r.center.lat), o), b = s * y / a, v *= l, b *= l;\n        }\n      } else v = g;\n      p(t, t, [v, v, b]);\n      const _ = [...t],\n        A = e.orientation,\n        M = [];\n      if (Ff(M, [A[0] + i[0], A[1] + i[1], A[2] + i[2]], s), c(t, _, M), a && r.elevation) {\n        let i = 0;\n        const s = [];\n        if (u && r.elevation) {\n          i = function (t, e, r, n, i) {\n            const s = e.elevation;\n            if (!s) return 0;\n            const o = Xu.projectAabbCorners(r, n),\n              a = ou(1, i.lat) * e.worldSize,\n              l = function (t, e) {\n                const r = [0, 0, 1],\n                  n = [{\n                    corners: [0, 1, 3, 2],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [1, 5, 2, 6],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [0, 4, 1, 5],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [2, 6, 3, 7],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [4, 7, 5, 6],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [0, 3, 4, 7],\n                    dotProductWithUp: 0\n                  }];\n                for (const i of n) {\n                  const n = t[i.corners[0]],\n                    s = t[i.corners[1]],\n                    o = t[i.corners[2]],\n                    a = [s[0] - n[0], s[1] - n[1], e * (s[2] - n[2])],\n                    l = R(a, a, [o[0] - n[0], o[1] - n[1], e * (o[2] - n[2])]);\n                  C(l, l), i.dotProductWithUp = D(l, r);\n                }\n                return n.sort((t, e) => t.dotProductWithUp - e.dotProductWithUp), n[0].corners;\n              }(o, a),\n              u = o[l[0]],\n              c = o[l[1]],\n              h = o[l[2]],\n              p = o[l[3]],\n              d = s.getAtPointOrZero(new mu(u[0] / e.worldSize, u[1] / e.worldSize), 0),\n              f = s.getAtPointOrZero(new mu(c[0] / e.worldSize, c[1] / e.worldSize), 0),\n              m = s.getAtPointOrZero(new mu(h[0] / e.worldSize, h[1] / e.worldSize), 0),\n              y = s.getAtPointOrZero(new mu(p[0] / e.worldSize, p[1] / e.worldSize), 0),\n              g = (d + y) / 2,\n              x = (f + m) / 2;\n            return g > x ? f < m ? Cf(t, c, p, u, f, y, d, a) : Cf(t, h, u, p, m, d, y, a) : d < y ? Cf(t, u, c, h, d, f, m, a) : Cf(t, p, h, c, y, m, f, a), Math.max(g, x);\n          }(s, r, e.aabb, t, n);\n          const o = c([], x([], s), M);\n          c(t, _, o);\n        } else i = r.elevation.getAtPointOrZero(new mu(m.x / w, m.y / w), 0);\n        0 !== i && (t[14] += i);\n      }\n    }\n    function Nf(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      t.uploaded || (t.gfxTexture = new vf(e, t.image, r ? e.gl.R8 : e.gl.RGBA8, {\n        useMipmap: t.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST\n      }), t.uploaded = !0, t.image = null);\n    }\n    function jf(t, e, r) {\n      t.indexBuffer = e.createIndexBuffer(t.indexArray, !1, !0), t.vertexBuffer = e.createVertexBuffer(t.vertexArray, wf.members, !1, !0), t.normalArray && (t.normalBuffer = e.createVertexBuffer(t.normalArray, If.members, !1, !0)), t.texcoordArray && (t.texcoordBuffer = e.createVertexBuffer(t.texcoordArray, Mf.members, !1, !0)), t.colorArray && (t.colorBuffer = e.createVertexBuffer(t.colorArray, (12 === t.colorArray.bytesPerElement ? _f : Af).members, !1, !0)), t.featureArray && (t.pbrBuffer = e.createVertexBuffer(t.featureArray, Pf.members, !0)), t.segments = al.simpleSegment(0, 0, t.vertexArray.length, t.indexArray.length);\n      const n = t.material;\n      n.pbrMetallicRoughness.baseColorTexture && Nf(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && Nf(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && Nf(n.normalTexture, e), n.occlusionTexture && Nf(n.occlusionTexture, e, r), n.emissionTexture && Nf(n.emissionTexture, e);\n    }\n    function $f(t, e, r) {\n      if (t.meshes) for (const n of t.meshes) jf(n, e, r);\n      if (t.children) for (const n of t.children) $f(n, e, r);\n    }\n    function Gf(t) {\n      if (t.meshes) for (const e of t.meshes) e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();\n      if (t.children) for (const e of t.children) Gf(e);\n    }\n    function Hf(t) {\n      if (t.meshes) for (const r of t.meshes) r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));\n      var e;\n      if (t.children) for (const e of t.children) Hf(e);\n    }\n    function qf(t, e) {\n      const r = t.json.bufferViews[e.bufferView],\n        n = ef[e.componentType];\n      return new n(t.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== nf[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : nf[e.type]));\n    }\n    function Xf(t, e, r, n) {\n      const i = ef[e.componentType],\n        s = function (t) {\n          switch (t) {\n            case Int8Array:\n              return 1 / 127;\n            case Uint8Array:\n              return 1 / 255;\n            case Int16Array:\n              return 1 / 32767;\n            case Uint16Array:\n              return 1 / 65535;\n            default:\n              return 1;\n          }\n        }(i),\n        o = t.json.bufferViews[e.bufferView],\n        a = o.byteStride ? o.byteStride / i.BYTES_PER_ELEMENT : nf[e.type],\n        l = r.float32,\n        u = l.length / r.capacity;\n      for (let t = 0, r = 0; t < e.count * a; t += a, r += u) for (let e = 0; e < u; e++) l[r + e] = n[t + e] * s;\n      r._trim();\n    }\n    function Zf(t, e, r) {\n      const n = t.indices,\n        i = t.attributes,\n        s = {};\n      s.indexArray = new Ea();\n      const o = e.json.accessors[n],\n        a = o.count / 3;\n      s.indexArray.reserve(a);\n      const l = qf(e, o);\n      for (let t = 0; t < a; t++) s.indexArray.emplaceBack(l[3 * t], l[3 * t + 1], l[3 * t + 2]);\n      s.indexArray._trim(), s.vertexArray = new ga();\n      const u = e.json.accessors[i.POSITION];\n      s.vertexArray.reserve(u.count);\n      const c = qf(e, u);\n      for (let t = 0; t < u.count; t++) s.vertexArray.emplaceBack(c[3 * t], c[3 * t + 1], c[3 * t + 2]);\n      if (s.vertexArray._trim(), s.aabb = new Xu(u.min, u.max), s.centroid = function (t, e) {\n        const r = [0, 0, 0],\n          n = t.length;\n        if (n > 0) {\n          for (let i = 0; i < n; i++) {\n            const n = 3 * t[i];\n            r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];\n          }\n          r[0] /= n, r[1] /= n, r[2] /= n;\n        }\n        return r;\n      }(l, c), void 0 !== i.COLOR_0) {\n        const t = e.json.accessors[i.COLOR_0],\n          r = nf[t.type],\n          n = qf(e, t);\n        s.colorArray = 3 === r ? new ga() : new Aa(), s.colorArray.resize(t.count), Xf(e, t, s.colorArray, n);\n      }\n      if (void 0 !== i.NORMAL) {\n        s.normalArray = new ga();\n        const t = e.json.accessors[i.NORMAL];\n        s.normalArray.resize(t.count);\n        const r = qf(e, t);\n        Xf(e, t, s.normalArray, r);\n      }\n      if (void 0 !== i.TEXCOORD_0 && r.length > 0) {\n        s.texcoordArray = new La();\n        const t = e.json.accessors[i.TEXCOORD_0];\n        s.texcoordArray.resize(t.count);\n        const r = qf(e, t);\n        Xf(e, t, s.texcoordArray, r);\n      }\n      if (void 0 !== i._FEATURE_ID_RGBA4444) {\n        const t = e.json.accessors[i._FEATURE_ID_RGBA4444];\n        e.json.extensionsUsed && e.json.extensionsUsed.includes(\"EXT_meshopt_compression\") && (s.featureData = qf(e, t));\n      }\n      void 0 !== i._FEATURE_RGBA4444 && (s.featureData = new Uint32Array(qf(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));\n      const h = t.material;\n      return s.material = function (t, e) {\n        const {\n            emissiveFactor: r = [0, 0, 0],\n            alphaMode: n = \"OPAQUE\",\n            alphaCutoff: i = .5,\n            normalTexture: s,\n            occlusionTexture: o,\n            emissiveTexture: a,\n            doubleSided: l\n          } = t,\n          {\n            baseColorFactor: u = [1, 1, 1, 1],\n            metallicFactor: c = 1,\n            roughnessFactor: h = 1,\n            baseColorTexture: p,\n            metallicRoughnessTexture: d\n          } = t.pbrMetallicRoughness || {},\n          f = o ? e[o.index] : void 0;\n        if (o && o.extensions && o.extensions.KHR_texture_transform && f) {\n          const t = o.extensions.KHR_texture_transform;\n          f.offsetScale = [t.offset[0], t.offset[1], t.scale[0], t.scale[1]];\n        }\n        return {\n          pbrMetallicRoughness: {\n            baseColorFactor: new sr(...u),\n            metallicFactor: c,\n            roughnessFactor: h,\n            baseColorTexture: p ? e[p.index] : void 0,\n            metallicRoughnessTexture: d ? e[d.index] : void 0\n          },\n          doubleSided: l,\n          emissiveFactor: new sr(...r),\n          alphaMode: n,\n          alphaCutoff: i,\n          normalTexture: s ? e[s.index] : void 0,\n          occlusionTexture: f,\n          emissionTexture: a ? e[a.index] : void 0,\n          defined: void 0 === t.defined\n        };\n      }(void 0 !== h ? e.json.materials[h] : {\n        defined: !1\n      }, r), s;\n    }\n    function Wf(t, e, r) {\n      const {\n          matrix: n,\n          rotation: i,\n          translation: s,\n          scale: o,\n          mesh: a,\n          extras: l,\n          children: u\n        } = t,\n        c = {};\n      if (c.matrix = n || function (t, e, r, n) {\n        var i = e[0],\n          s = e[1],\n          o = e[2],\n          a = e[3],\n          l = i + i,\n          u = s + s,\n          c = o + o,\n          h = i * l,\n          p = i * u,\n          d = i * c,\n          f = s * u,\n          m = s * c,\n          y = o * c,\n          g = a * l,\n          x = a * u,\n          v = a * c,\n          b = n[0],\n          w = n[1],\n          _ = n[2];\n        return t[0] = (1 - (f + y)) * b, t[1] = (p + v) * b, t[2] = (d - x) * b, t[3] = 0, t[4] = (p - v) * w, t[5] = (1 - (h + y)) * w, t[6] = (m + g) * w, t[7] = 0, t[8] = (d + x) * _, t[9] = (m - g) * _, t[10] = (1 - (h + f)) * _, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n      }([], i || [0, 0, 0, 1], s || [0, 0, 0], o || [1, 1, 1]), void 0 !== a) {\n        c.meshes = r[a];\n        const t = c.anchor = [0, 0];\n        for (const e of c.meshes) {\n          const {\n            min: r,\n            max: n\n          } = e.aabb;\n          t[0] += r[0] + n[0], t[1] += r[1] + n[1];\n        }\n        t[0] = Math.floor(t[0] / c.meshes.length / 2), t[1] = Math.floor(t[1] / c.meshes.length / 2);\n      }\n      if (l && (l.id && (c.id = l.id), l.lights && (c.lights = function (t) {\n        if (!t.length) return [];\n        const e = function (t) {\n            const e = atob(t),\n              r = new Uint8Array(e.length);\n            for (let t = 0; t < e.length; t++) r[t] = e.codePointAt(t);\n            return r;\n          }(t),\n          r = [],\n          n = e.length / 24,\n          i = new Uint16Array(e.buffer),\n          s = new Float32Array(e.buffer);\n        for (let t = 0; t < n; t++) {\n          const e = i[2 * t * 6] / 30,\n            n = i[2 * t * 6 + 1] / 30,\n            o = i[2 * t * 6 + 10] / 100,\n            a = s[6 * t + 1],\n            l = s[6 * t + 2],\n            u = s[6 * t + 3],\n            c = s[6 * t + 4],\n            h = u - a,\n            p = c - l,\n            d = Math.hypot(h, p);\n          r.push({\n            pos: [a + .5 * h, l + .5 * p, n],\n            normal: [p / d, -h / d, 0],\n            width: d,\n            height: e,\n            depth: o,\n            points: [a, l, u, c]\n          });\n        }\n        return r;\n      }(l.lights))), u) {\n        const t = [];\n        for (const n of u) t.push(Wf(e.json.nodes[n], e, r));\n        c.children = t;\n      }\n      return c;\n    }\n    function Yf(t) {\n      if (0 === t.vertices.length || 0 === t.indices.length) return null;\n      const e = new bp(t.vertices, t.indices, 8, 256),\n        [r, n] = [e.min.clone(), e.max.clone()];\n      return {\n        vertices: t.vertices,\n        indices: t.indices,\n        grid: e,\n        min: r,\n        max: n\n      };\n    }\n    function Kf(t) {\n      if (!t.extras || !t.extras.ground) return null;\n      const e = t.extras.ground;\n      if (!e || !Array.isArray(e) || 0 === e.length) return null;\n      const r = e[0];\n      if (!r || !Array.isArray(r) || 0 === r.length) return null;\n      const n = [];\n      for (const t of r) {\n        if (!Array.isArray(t) || 2 !== t.length) continue;\n        const e = t[0],\n          r = t[1];\n        \"number\" == typeof e && \"number\" == typeof r && n.push(new wt(e, r));\n      }\n      if (n.length < 3) return null;\n      n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();\n      let i = 0;\n      for (let t = 0; t < n.length; t++) {\n        const e = n[t],\n          r = n[(t + 1) % n.length],\n          s = n[(t + 2) % n.length];\n        i += (e.x - r.x) * (s.y - r.y) - (s.x - r.x) * (e.y - r.y);\n      }\n      i > 0 && n.reverse();\n      const s = Ih(n.flatMap(t => [t.x, t.y]), []);\n      return 0 === s.length ? null : {\n        vertices: n,\n        indices: s\n      };\n    }\n    function Jf(t, e) {\n      const r = [],\n        n = [];\n      let i = 0;\n      const s = [];\n      for (const o of t) {\n        i = r.length;\n        const t = o.vertexArray.float32,\n          a = o.indexArray.uint16;\n        for (let n = 0; n < o.vertexArray.length; n++) s[0] = t[3 * n + 0], s[1] = t[3 * n + 1], s[2] = t[3 * n + 2], O(s, s, e), r.push(new wt(s[0], s[1]));\n        for (let t = 0; t < 3 * o.indexArray.length; t++) n.push(a[t] + i);\n      }\n      if (n.length % 3 != 0) return null;\n      for (let t = 0; t < n.length; t += 3) {\n        const e = r[n[t + 0]],\n          i = r[n[t + 1]],\n          s = r[n[t + 2]];\n        (e.x - i.x) * (s.y - i.y) - (s.x - i.x) * (e.y - i.y) > 0 && ([n[t + 1], n[t + 2]] = [n[t + 2], n[t + 1]]);\n      }\n      return {\n        vertices: r,\n        indices: n\n      };\n    }\n    function Qf(t) {\n      const e = function (t, e) {\n          const r = [],\n            n = WebGL2RenderingContext;\n          if (t.json.textures) for (const i of t.json.textures) {\n            const s = {\n              magFilter: n.LINEAR,\n              minFilter: n.NEAREST,\n              wrapS: n.REPEAT,\n              wrapT: n.REPEAT\n            };\n            void 0 !== i.sampler && Object.assign(s, t.json.samplers[i.sampler]), r.push({\n              image: e[i.source],\n              sampler: s,\n              uploaded: !1\n            });\n          }\n          return r;\n        }(t, t.images),\n        r = function (t, e) {\n          const r = [];\n          for (const n of t.json.meshes) {\n            const i = [];\n            for (const r of n.primitives) i.push(Zf(r, t, e));\n            r.push(i);\n          }\n          return r;\n        }(t, e),\n        {\n          scenes: n,\n          scene: i,\n          nodes: s\n        } = t.json,\n        o = n ? n[i || 0].nodes : [...s.keys()],\n        a = [];\n      for (const e of o) a.push(Wf(s[e], t, r));\n      return function (t, e, r) {\n        const n = {},\n          i = new Set();\n        for (let s = 0; s < t.length; s++) {\n          const t = r[e[s]];\n          if (!t.extras) continue;\n          const o = t.extras[\"mapbox:footprint:version\"],\n            a = t.extras[\"mapbox:footprint:id\"];\n          (o || a) && i.add(s), \"1.0.0\" === o && a && (n[a] = s);\n        }\n        for (let s = 0; s < t.length; s++) {\n          if (i.has(s)) continue;\n          const o = t[s],\n            a = r[e[s]];\n          if (!a.extras) continue;\n          let l = null;\n          o.id in n && (l = Jf(t[n[o.id]].meshes, o.matrix)), l || (l = Kf(a)), l && (o.footprint = Yf(l));\n        }\n        if (i.size > 0) {\n          const e = Array.from(i.values()).sort((t, e) => t - e);\n          for (let r = e.length - 1; r >= 0; r--) t.splice(e[r], 1);\n        }\n      }(a, o, t.json.nodes), a;\n    }\n    function tm(t) {\n      t.heightmap = new Float32Array(4096), t.heightmap.fill(-1);\n      const e = t.vertexArray.float32,\n        r = t.aabb.min[0] - 1,\n        n = t.aabb.min[1] - 1,\n        i = Lf / (t.aabb.max[0] - r + 2),\n        s = Lf / (t.aabb.max[1] - n + 2);\n      for (let o = 0; o < e.length; o += 3) {\n        const a = e[o + 2],\n          l = (e[o + 0] - r) * i | 0,\n          u = (e[o + 1] - n) * s | 0;\n        a > t.heightmap[u * Lf + l] && (t.heightmap[u * Lf + l] = a);\n      }\n    }\n    function em(t, e, r, n, i) {\n      r.reserve(r.length + 4 * t.length), n.reserve(n.length + 10 * t.length), i.reserve(i.length + 10 * t.length);\n      let s = n.length;\n      for (const o of t) {\n        const t = Math.min(10, Math.max(4, 1.3 * o.height)) * e,\n          a = [-o.normal[1], o.normal[0], 0],\n          l = Math.min(.29, .1 * o.width / o.depth),\n          u = o.width - 2 * o.depth * e * (l + .01),\n          c = T([], o.pos, a, u / 2),\n          h = T([], o.pos, a, -u / 2),\n          p = [c[0], c[1], c[2] + o.height],\n          d = [h[0], h[1], h[2] + o.height],\n          f = T([], o.normal, a, l);\n        E(f, f, t);\n        const m = T([], o.normal, a, -l);\n        E(m, m, t), I(f, c, f), I(m, h, m), c[2] += .1, h[2] += .1, n.emplaceBack(f[0], f[1], f[2]), n.emplaceBack(m[0], m[1], m[2]), n.emplaceBack(c[0], c[1], c[2]), n.emplaceBack(h[0], h[1], h[2]), n.emplaceBack(p[0], p[1], p[2]), n.emplaceBack(d[0], d[1], d[2]), n.emplaceBack(c[0], c[1], c[2]), n.emplaceBack(h[0], h[1], h[2]), n.emplaceBack(f[0], f[1], f[2]), n.emplaceBack(m[0], m[1], m[2]);\n        const y = u / t / 2;\n        i.emplaceBack(-y - l, -1, y, .8), i.emplaceBack(y + l, -1, y, .8), i.emplaceBack(-y, 0, y, 1.3), i.emplaceBack(y, 0, y, 1.3), i.emplaceBack(y + l, -.8, y, .7), i.emplaceBack(y + l, -.8, y, .7), i.emplaceBack(0, 0, y, 1.3), i.emplaceBack(0, 0, y, 1.3), i.emplaceBack(y + l, -1.2, y, .8), i.emplaceBack(y + l, -1.2, y, .8), r.emplaceBack(6 + s, 4 + s, 8 + s), r.emplaceBack(7 + s, 9 + s, 5 + s), r.emplaceBack(0 + s, 1 + s, 2 + s), r.emplaceBack(1 + s, 3 + s, 2 + s), s += 10;\n      }\n    }\n    function rm(t, e) {\n      const r = {};\n      r.indexArray = new Ea(), r.vertexArray = new ga(), r.colorArray = new Aa(), em(t, e, r.indexArray, r.vertexArray, r.colorArray);\n      const n = {\n        defined: !0\n      };\n      n.emissiveFactor = sr.black;\n      const i = {};\n      return i.baseColorFactor = sr.white, n.pbrMetallicRoughness = i, r.material = n, r.aabb = new Xu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r;\n    }\n    const nm = aa([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      im = aa([{\n        name: \"a_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      sm = aa([{\n        name: \"a_centroid_3\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      om = aa([{\n        name: \"a_part_color_emissive\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      am = aa([{\n        name: \"a_faux_facade_color_emissive\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      lm = aa([{\n        name: \"a_faux_facade_data\",\n        components: 4,\n        type: \"Uint16\"\n      }]),\n      um = aa([{\n        name: \"a_faux_facade_vertical_range\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      cm = aa([{\n        name: \"a_bloom_attenuation\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      hm = Iu.types,\n      pm = 32767;\n    function dm(t, e) {\n      const r = Rn + e;\n      for (const n of t) for (const t of n) if (t.x < -e || t.x > r || t.y < -e || t.y > r) return !1;\n      return !0;\n    }\n    class fm {\n      constructor() {\n        this.layoutVertexArray = new ga(), this.layoutAttenuationArray = new Aa(), this.layoutColorArray = new Ia(), this.indexArray = new Ea(), this.indexArrayForConflation = new Ea(), this.segmentsBucket = new al();\n      }\n    }\n    class mm {\n      constructor() {\n        this.layoutVertexArray = new ga(), this.layoutNormalArray = new ca(), this.layoutCentroidArray = new ca(), this.layoutColorArray = new Ia(), this.layoutFacadePaintArray = null, this.layoutFacadeDataArray = null, this.layoutFacadeVerticalRangeArray = null, this.layoutAOArray = [], this.indexArray = new Ea(), this.indexArrayForConflation = new Ea(), this.segmentsBucket = new al(), this.entranceBloom = new fm();\n      }\n    }\n    class ym {\n      constructor(t) {\n        this.colorBufferUploaded = !1, this.maxHeight = 0, this.replacementUpdateTime = 0, this.activeReplacements = [], this.footprints = [], this.featuresOnBorder = [], this.buildingFeatures = [], this.buildingWithoutFacade = new mm(), this.buildingWithFacade = new mm(), this.indexArrayForConflationUploaded = !1, this.footprintLookup = {}, this.zoom = t.zoom, this.canonical = t.canonical, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.worldview = t.worldview, this.lut = t.lut, this.buildingWithFacade.layoutFacadePaintArray = new Ia(), this.buildingWithFacade.layoutFacadeDataArray = new va(), this.buildingWithFacade.layoutFacadeVerticalRangeArray = new Ia(), this.programConfigurations = new Cl(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection, this.groundEffect = new ld(t);\n      }\n      updateFootprints(t, e) {\n        for (const r of this.footprints) e.push({\n          footprint: r,\n          id: t\n        });\n      }\n      prepare() {\n        return function () {\n          if (null != Kd || null != Yd) return null;\n          if (null != Wd) return Wd;\n          const t = fetch(ne.BUILDING_GEN_URL);\n          return Wd = function (t) {\n            let e, r, n, i;\n            function s() {\n              e = new Uint8Array(i.buffer), r = new Int32Array(i.buffer), n = new Float32Array(i.buffer);\n            }\n            function o() {\n              throw new Error(\"Unexpected BuildingGen error.\");\n            }\n            const a = () => {},\n              l = {\n                a: {\n                  a: o,\n                  f: function (t) {\n                    const r = e.length,\n                      n = Math.max(t >>> 0, Math.ceil(1.2 * r)),\n                      o = Math.ceil((n - r) / 65536);\n                    try {\n                      return i.grow(o), s(), !0;\n                    } catch (t) {\n                      return !1;\n                    }\n                  },\n                  g: o,\n                  b: a,\n                  c: a,\n                  d: a,\n                  e: a\n                }\n              };\n            return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t, l) : t.then(t => t.arrayBuffer()).then(t => WebAssembly.instantiate(t, l))).then(t => {\n              const o = t.instance.exports;\n              return (0, o.g)(), i = o.f, s(), new jd({\n                setStyle: o.h,\n                setAOOptions: o.i,\n                setMetricOptions: o.j,\n                setStructuralOptions: o.k,\n                setFacadeOptions: o.l,\n                setFauxFacadeOptions: o.m,\n                setFacadeClassifierOptions: o.n,\n                addFeature: o.o,\n                addFacade: o.p,\n                generateMesh: o.q,\n                getLastError: o.r,\n                getOuterRingLength: o.s,\n                getMeshCount: o.t,\n                getPositionsPtr: o.u,\n                getPositionsLength: o.v,\n                getNormalsPtr: o.w,\n                getNormalsLength: o.x,\n                getColorsPtr: o.y,\n                getColorsLength: o.z,\n                getAOPtr: o.A,\n                getAOLength: o.B,\n                getUVPtr: o.C,\n                getUVLength: o.D,\n                getFauxFacadePtr: o.E,\n                getFauxFacadeLength: o.F,\n                getIndicesPtr: o.G,\n                getIndicesLength: o.H,\n                getBuildingPart: o.I,\n                getRingCount: o.J,\n                getRingPtr: o.K,\n                getRingLength: o.L,\n                free: o.M,\n                malloc: o.N,\n                heapU8: e,\n                heap32: r,\n                heapF32: n\n              });\n            });\n          }(t).then(t => (Wd = null, Kd = t, Kd)).catch(t => {\n            Gt(\"Could not load building-gen\"), Wd = null, Yd = t;\n          }), Wd;\n        }();\n      }\n      populate(t, e, r, n) {\n        const i = tf();\n        if (!i) return;\n        const s = fu(r);\n        this.tileToMeter = s, this.brightness = e.brightness, i.setStyle({\n          convertToMeters: !1,\n          entranceColorRgb: [1, 1, 1],\n          facadeGlazingColorRgb: [.5607843137254902, .6745098039215687, .7215686274509804],\n          normalScale: [1, -1, s],\n          ridgeHeight: 3,\n          roofColorRgb: [.886274516, .784313738, .713725507],\n          tileToMeters: s,\n          tileZoom: 16,\n          wallColorRgb: [.988235294, .933333337, .811764717]\n        }), i.setAOOptions(!1, .3), i.setMetricOptions(!1, 16), i.setStructuralOptions(!0), i.setFacadeClassifierOptions(3);\n        const o = new Map();\n        for (const {\n          feature: e\n        } of t) {\n          if (\"LineString\" !== hm[e.type]) continue;\n          const t = this.layers[0]._featureFilter.needGeometry,\n            i = Mu(e, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom), i, r)) continue;\n          const s = t ? i.geometry : Au(e, r, n),\n            a = [];\n          for (const t of s) for (const e of t) a.push({\n            x: e.x,\n            y: e.y\n          });\n          const l = {\n              coordinates: a,\n              crossPerc: e.properties.cross_perc,\n              distanceToRoad: e.properties.distance_to_road,\n              entrances: e.properties.entrances,\n              sourceId: 0\n            },\n            u = e.properties.source_id;\n          let c = o.get(u);\n          c || (c = [], o.set(u, c)), c.push(l);\n        }\n        this.maxHeight = 0;\n        for (const {\n          feature: a,\n          index: l\n        } of t) {\n          if (\"LineString\" === hm[a.type]) continue;\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = Mu(a, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom), u, r)) continue;\n          const c = t ? u.geometry : Au(a, r, n),\n            h = Kh(c, 500);\n          if (!dm(c, 163)) continue;\n          const p = this.layers[0],\n            d = p.layout.get(\"building-base\").evaluate(a, {}, r),\n            f = p.layout.get(\"building-height\").evaluate(a, {}, r),\n            m = p.layout.get(\"building-roof-shape\").evaluate(a, {}, r),\n            y = p.paint.get(\"building-ambient-occlusion-intensity\"),\n            g = p.paint.get(\"building-ambient-occlusion-ground-radius\") / this.tileToMeter;\n          if (\"flat\" === m) continue;\n          const x = p.layout.get(\"building-facade\").evaluate(a, {}, r);\n          i.setFacadeOptions(4, !0), i.setFauxFacadeOptions(x, !1, 1);\n          const v = a.properties.source_id;\n          let b;\n          b = o.has(v) ? o.get(v) : [];\n          let w = 0,\n            _ = 0,\n            A = 0,\n            M = 0,\n            I = 0,\n            S = 0;\n          if (x) {\n            let t = Math.round(p.layout.get(\"building-facade-floors\").evaluate(a, {}, r));\n            if (0 === d) {\n              t = Math.max(1, t - (b.length > 0 ? 1 : 0));\n              let e = 4;\n              if (f > 100) {\n                const t = [10, 13, 15];\n                e = t[a.id ? a.id % t.length : 0], i.setFacadeOptions(e, !0);\n              }\n              I = 1.6803 * e / s;\n            } else I = d / s;\n            S = f / s, I = Math.min(I, S), A = p.layout.get(\"building-facade-unit-width\").evaluate(a, {}, r) / s, M = (S - I) / t, i.setFauxFacadeOptions(!0, !0, A);\n            const e = p.layout.get(\"building-facade-window\").evaluate(a, {}, r);\n            w = e[0], _ = e[1];\n          }\n          const P = [],\n            k = new wt(1 / 0, 1 / 0),\n            z = new wt(-1 / 0, -1 / 0),\n            E = new wt(0, 0);\n          let T = 0;\n          for (const t of h) if (t.length > 0) {\n            const e = [];\n            for (const r of t) {\n              const t = [];\n              for (let e = r.length - 1; e >= 0; e--) {\n                const n = r[e];\n                t.push({\n                  x: n.x,\n                  y: n.y\n                }), k.x = Math.min(k.x, n.x), k.y = Math.min(k.y, n.y), z.x = Math.max(z.x, n.x), z.y = Math.max(z.y, n.y), E.x += n.x, E.y += n.y, T++;\n              }\n              e.push(t);\n            }\n            P.push({\n              id: a.id ? a.id : 0,\n              height: f,\n              minHeight: d,\n              sourceId: 0,\n              roofType: m,\n              coordinates: e\n            });\n          }\n          E.x /= T || 1, E.y /= T || 1;\n          const B = i.generateMesh(P, b);\n          if (\"string\" == typeof B) {\n            Gt(\"Unable to generate building \".concat(a.id, \": \").concat(B));\n            continue;\n          }\n          if (0 === B.meshes.length || 0 === B.modifiedPolygonRings.length) continue;\n          let V = 0;\n          for (const t of B.meshes) V += t.positions.length / 3;\n          const F = x ? this.buildingWithFacade : this.buildingWithoutFacade,\n            C = F.segmentsBucket.prepareSegment(V, F.layoutVertexArray, F.indexArray),\n            D = [];\n          let R = null,\n            L = 0,\n            O = -1;\n          const U = F.indexArray.length;\n          let N = 0;\n          for (const t of B.meshes) {\n            const e = F.layoutVertexArray.length;\n            if (\"entrance\" === t.buildingPart) {\n              const e = new Array();\n              for (let r = 0; r < t.indices.length; r += 12) {\n                const n = t.positions[r + 0],\n                  i = t.positions[r + 1],\n                  s = t.positions[r + 3],\n                  o = t.positions[r + 4],\n                  a = t.positions[r + 2],\n                  l = t.positions[r + 8] - a,\n                  u = 1,\n                  c = s - n,\n                  h = o - i,\n                  p = Math.hypot(c, h);\n                e.push({\n                  pos: [n + .5 * c, i + .5 * h, a],\n                  normal: [h / p, -c / p, 0],\n                  width: p,\n                  height: l,\n                  depth: u,\n                  points: [n, i, s, o]\n                });\n              }\n              const r = F.entranceBloom.segmentsBucket.prepareSegment(10 * e.length, F.entranceBloom.layoutVertexArray, F.entranceBloom.indexArray),\n                n = F.entranceBloom.layoutVertexArray.length;\n              L = F.entranceBloom.indexArray.length, em(e, .5 / this.tileToMeter, F.entranceBloom.indexArray, F.entranceBloom.layoutVertexArray, F.entranceBloom.layoutAttenuationArray);\n              const i = F.entranceBloom.layoutVertexArray.length - n;\n              O = F.entranceBloom.indexArray.length - L;\n              for (let t = 0; t < i; t++) {\n                const t = 65535;\n                F.entranceBloom.layoutColorArray.emplaceBack(t, t);\n              }\n              r.vertexLength += i, r.primitiveLength += O, R = {\n                part: t.buildingPart,\n                vertexOffset: n,\n                vertexLength: i\n              };\n            }\n            for (let e = 0; e < t.positions.length; e += 3) N = Math.max(N, t.positions[e + 2]), F.layoutVertexArray.emplaceBack(t.positions[e], t.positions[e + 1], t.positions[e + 2]);\n            const r = Math.floor(E.x),\n              n = Math.floor(E.y),\n              i = Math.floor(N);\n            for (let e = 0; e < t.positions.length; e += 3) F.layoutCentroidArray.emplaceBack(r, n, i);\n            for (let e = 0; e < t.normals.length; e += 3) F.layoutNormalArray.emplaceBack(t.normals[e + 0] * pm, t.normals[e + 1] * pm, t.normals[e + 2] * pm);\n            for (let e = 0; e < t.ao.length; e++) F.layoutAOArray.push(t.ao[e]);\n            for (let e = 0; e < t.colors.length; e += 3) {\n              const r = 1 + (t.ao[e / 3] - 1) * y;\n              F.layoutColorArray.emplaceBack(t.colors[e] * r << 8 | t.colors[e + 1] * r, t.colors[e + 2] * r << 8);\n            }\n            if (x) {\n              for (let e = 0; e < t.positions.length; e += 3) F.layoutFacadePaintArray.emplaceBack(65535, 255);\n              for (let e = 0; e < t.isFauxFacade.length; e++) if (t.isFauxFacade[e]) {\n                const r = 1 | Math.min(65535, Math.floor(t.uv[2 * e] * B.outerRingLength)),\n                  n = Math.floor(255 * w) << 8 | Math.floor(255 * _),\n                  i = Math.floor(65535 * Math.min(1, A / Rn)),\n                  s = Math.floor(65535 * Math.min(1, M / Rn));\n                F.layoutFacadeDataArray.emplaceBack(r, n, i, s);\n                const o = Math.floor(65535 * Math.min(1, I / Rn)),\n                  a = Math.floor(65535 * Math.min(1, S / Rn));\n                F.layoutFacadeVerticalRangeArray.emplaceBack(o, a);\n              } else F.layoutFacadeDataArray.emplaceBack(0, 0, 0, 0), F.layoutFacadeVerticalRangeArray.emplaceBack(0, 0);\n            }\n            const s = C.vertexLength;\n            for (let e = 0; e < t.indices.length; e += 3) F.indexArray.emplaceBack(s + t.indices[e], s + t.indices[e + 1], s + t.indices[e + 2]);\n            C.vertexLength += t.positions.length / 3, C.primitiveLength += t.indices.length / 3, (\"roof\" === t.buildingPart || \"wall\" === t.buildingPart || \"facade_glazing\" === t.buildingPart || \"entrance\" === t.buildingPart) && D.push({\n              part: t.buildingPart,\n              vertexOffset: e,\n              vertexLength: t.positions.length / 3\n            });\n          }\n          this.maxHeight = Math.max(this.maxHeight, N), this.buildingFeatures.push({\n            feature: u,\n            hasFauxFacade: x,\n            segment: C,\n            parts: D,\n            buildingBloom: R\n          });\n          const j = F.indexArray.length - U,\n            $ = [],\n            G = [],\n            H = new wt(1 / 0, 1 / 0),\n            q = new wt(-1 / 0, -1 / 0),\n            X = this.groundEffect.vertexArray.length;\n          for (const t of B.modifiedPolygonRings) {\n            const e = [],\n              r = new wt(1 / 0, 1 / 0),\n              n = new wt(-1 / 0, -1 / 0);\n            for (let i = 0; i < t.length; i += 2) {\n              const s = t.length - i - 2;\n              r.x = Math.min(r.x, t[s]), r.y = Math.min(r.y, t[s + 1]), n.x = Math.max(n.x, t[s]), n.y = Math.max(n.y, t[s + 1]);\n              const o = new wt(t[s], t[s + 1]);\n              e.push(o), $.push(o.x, o.y), G.push(o.clone());\n            }\n            H.x = Math.min(H.x, r.x), H.y = Math.min(H.y, r.y), q.x = Math.max(q.x, n.x), q.y = Math.max(q.y, n.y), this.groundEffect.addData(e, [r, n], g);\n          }\n          const Z = this.groundEffect.vertexArray.length - X;\n          (k.x < 0 || z.x > Rn || k.y < 0 || z.y > Rn) && this.featuresOnBorder.push({\n            featureId: a.id,\n            footprintIndex: this.footprints.length\n          });\n          {\n            const t = Ih($, null, 2),\n              e = new bp(G, t, 8, 256);\n            let r = a.id;\n            a.properties && a.properties.hasOwnProperty(\"building_id\") && (r = a.properties.building_id), this.footprints.push({\n              vertices: G,\n              indices: t,\n              grid: e,\n              min: H,\n              max: q,\n              buildingId: r,\n              hiddenFlags: 0,\n              indicesOffset: U,\n              indicesLength: j,\n              bloomIndicesOffset: L,\n              bloomIndicesLength: O,\n              groundEffectVertexOffset: X,\n              groundEffectVertexLength: Z,\n              hasFauxFacade: x,\n              segment: C,\n              height: N\n            });\n          }\n          this.programConfigurations.populatePaintArrays(F.layoutVertexArray.length, a, l, {}, e.availableImages, r, e.brightness), this.groundEffect.addPaintPropertiesData(a, l, {}, e.availableImages, r, e.brightness);\n        }\n        this.groundEffect.prepareBorderSegments(), this.evaluate(this.layers[0], {});\n      }\n      update(t, e, r, n, i, s, o) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o), this.groundEffect.update(t, e, i, r, n, s, o), this.evaluate(this.layers[0], t), this.colorBufferUploaded = !1;\n      }\n      isEmpty() {\n        return 0 === this.buildingWithoutFacade.layoutVertexArray.length && 0 === this.buildingWithFacade.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        const e = e => {\n          e.layoutVertexBuffer = t.createVertexBuffer(e.layoutVertexArray, nm.members), e.layoutNormalBuffer = t.createVertexBuffer(e.layoutNormalArray, im.members), e.layoutCentroidBuffer = t.createVertexBuffer(e.layoutCentroidArray, sm.members), e.layoutFacadeDataArray && e.layoutFacadeDataArray.length && (e.layoutFacadeDataBuffer = t.createVertexBuffer(e.layoutFacadeDataArray, lm.members)), e.layoutFacadeVerticalRangeArray && e.layoutFacadeVerticalRangeArray.length && (e.layoutFacadeVerticalRangeBuffer = t.createVertexBuffer(e.layoutFacadeVerticalRangeArray, um.members)), e.entranceBloom.layoutVertexArray.length && (e.entranceBloom.layoutVertexBuffer = t.createVertexBuffer(e.entranceBloom.layoutVertexArray, nm.members), e.entranceBloom.layoutAttenuationBuffer = t.createVertexBuffer(e.entranceBloom.layoutAttenuationArray, cm.members)), this.uploadUpdatedColorBuffer(t), this.uploadUpdatedIndexBuffer(t);\n        };\n        this.uploaded || (e(this.buildingWithoutFacade), e(this.buildingWithFacade), this.groundEffect.upload(t)), this.groundEffect.uploadPaintProperties(t), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        const t = t => {\n          t.layoutVertexBuffer && (t.layoutVertexBuffer.destroy(), t.layoutNormalBuffer.destroy(), t.layoutColorBuffer.destroy(), t.segmentsBucket.destroy(), t.indexBuffer && t.indexBuffer.destroy(), t.entranceBloom.layoutVertexBuffer && (t.entranceBloom.layoutVertexBuffer.destroy(), t.entranceBloom.layoutColorBuffer.destroy(), t.entranceBloom.layoutAttenuationBuffer.destroy(), t.entranceBloom.indexBuffer.destroy(), t.entranceBloom.segmentsBucket.destroy()));\n        };\n        t(this.buildingWithoutFacade), t(this.buildingWithFacade), this.groundEffect.destroy(), this.programConfigurations.destroy();\n      }\n      updateFootprintHiddenFlags(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n        let n = !1;\n        const i = r ? e : 0,\n          s = 0 | (r ? -1 : ~e);\n        0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);\n        for (const e of t) {\n          const t = this.footprints[e],\n            r = t.hiddenFlags & s | i;\n          t.hiddenFlags !== r && (t.hiddenFlags = r, n = !0, this.groundEffect.updateHiddenByLandmarkRange(t.groundEffectVertexOffset, t.groundEffectVertexLength, 0 !== t.hiddenFlags));\n        }\n        return n && (this.indexArrayForConflationUploaded = !1), n;\n      }\n      uploadUpdatedIndexBuffer(t) {\n        if (this.groundEffect.uploadHiddenByLandmark(t), this.indexArrayForConflationUploaded) return;\n        const e = t => {\n          0 !== t.indexArray.length && (t.indexArrayForConflation.resize(t.indexArray.length), t.indexArrayForConflation.uint16.set(t.indexArray.uint16), t.entranceBloom.indexArrayForConflation.resize(t.entranceBloom.indexArray.length), t.entranceBloom.indexArrayForConflation.uint16.set(t.entranceBloom.indexArray.uint16));\n        };\n        e(this.buildingWithoutFacade), e(this.buildingWithFacade);\n        for (const t of this.footprints) {\n          const e = t.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade,\n            r = t.indicesOffset + t.indicesLength;\n          if (0 !== t.hiddenFlags) {\n            for (let n = t.indicesOffset; n < r; n++) e.indexArrayForConflation.uint16[3 * n + 0] = 0, e.indexArrayForConflation.uint16[3 * n + 1] = 0, e.indexArrayForConflation.uint16[3 * n + 2] = 0;\n            const n = t.bloomIndicesOffset + t.bloomIndicesLength;\n            for (let r = t.bloomIndicesOffset; r < n; r++) e.entranceBloom.indexArrayForConflation.uint16[3 * r + 0] = 0, e.entranceBloom.indexArrayForConflation.uint16[3 * r + 1] = 0, e.entranceBloom.indexArrayForConflation.uint16[3 * r + 2] = 0;\n          }\n        }\n        const r = e => {\n          0 !== e.indexArray.length && (e.indexBuffer ? e.indexBuffer.updateData(e.indexArrayForConflation) : e.indexBuffer = t.createIndexBuffer(e.indexArrayForConflation, !0), e.entranceBloom.indexBuffer ? e.entranceBloom.indexBuffer.updateData(e.entranceBloom.indexArrayForConflation) : e.entranceBloom.indexBuffer = t.createIndexBuffer(e.entranceBloom.indexArrayForConflation, !0));\n        };\n        r(this.buildingWithoutFacade), r(this.buildingWithFacade), this.indexArrayForConflationUploaded = !0;\n      }\n      uploadUpdatedColorBuffer(t) {\n        const e = e => {\n          e.layoutColorBuffer ? e.layoutColorBuffer.updateData(e.layoutColorArray) : e.layoutColorBuffer = t.createVertexBuffer(e.layoutColorArray, om.members, !0), e.layoutFacadePaintArray && (e.layoutFacadePaintBuffer ? e.layoutFacadePaintBuffer.updateData(e.layoutFacadePaintArray) : e.layoutFacadePaintBuffer = t.createVertexBuffer(e.layoutFacadePaintArray, am.members, !0)), e.entranceBloom.layoutColorBuffer ? e.entranceBloom.layoutColorBuffer.updateData(e.entranceBloom.layoutColorArray) : e.entranceBloom.layoutColorBuffer = t.createVertexBuffer(e.entranceBloom.layoutColorArray, om.members, !0);\n        };\n        e(this.buildingWithoutFacade), e(this.buildingWithFacade), this.colorBufferUploaded = !0;\n      }\n      evaluate(t, e) {\n        const r = t.paint.get(\"building-ambient-occlusion-intensity\");\n        for (const n of this.buildingFeatures) {\n          const i = e[n.feature.id],\n            s = n.feature;\n          s.properties[\"building-part\"] = \"roof\";\n          const o = t.paint.get(\"building-color\").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut),\n            a = t.paint.get(\"building-emissive-strength\").evaluate(s, i, this.canonical);\n          s.properties[\"building-part\"] = \"wall\";\n          const l = t.paint.get(\"building-color\").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut),\n            u = t.paint.get(\"building-emissive-strength\").evaluate(s, i, this.canonical);\n          s.properties[\"building-part\"] = \"window\";\n          const c = t.paint.get(\"building-color\").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut),\n            h = t.paint.get(\"building-emissive-strength\").evaluate(s, i, this.canonical);\n          s.properties[\"building-part\"] = \"door\";\n          const p = t.paint.get(\"building-color\").evaluate(s, i, this.canonical).toPremultipliedRenderColor(this.lut),\n            d = t.paint.get(\"building-emissive-strength\").evaluate(s, i, this.canonical),\n            f = n.hasFauxFacade ? this.buildingWithFacade : this.buildingWithoutFacade;\n          for (const t of n.parts) {\n            let e,\n              i = o;\n            \"roof\" === t.part ? (i = o, e = a) : \"wall\" === t.part ? (i = l, e = u) : \"facade_glazing\" === t.part ? (i = c, e = h) : \"entrance\" === t.part && (i = p, e = d), e = Tt(e, 0, 1);\n            for (let s = 0; s < t.vertexLength; s++) {\n              const o = t.vertexOffset + s,\n                a = 1 + (f.layoutAOArray[o] - 1) * r;\n              f.layoutColorArray.emplace(o, i.r * a * 255 << 8 | i.g * a * 255, i.b * a * 255 << 8 | 255 * e), n.hasFauxFacade && f.layoutFacadePaintArray.emplace(o, 255 * c.r << 8 | 255 * c.g, 255 * c.b << 8 | 255 * h);\n            }\n          }\n          const m = n.buildingBloom;\n          if (m) for (let t = 0; t < m.vertexLength; t++) f.entranceBloom.layoutColorArray.emplace(m.vertexOffset + t, 255 * p.r << 8 | 255 * p.g, 255 * p.b << 8 | 51 * d);\n        }\n      }\n      needsEvaluation() {\n        return !this.colorBufferUploaded;\n      }\n      updateReplacement(t, e, r) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const n = e.getReplacementRegionsForTile(t.toUnwrapped());\n        if (Dp(this.activeReplacements, n)) return;\n        this.activeReplacements = n;\n        for (const t of this.footprints) t.hiddenFlags &= -2;\n        const i = [];\n        for (const e of this.activeReplacements) {\n          if (e.order <= Tp) continue;\n          const r = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t.canonical.z));\n          for (const n of this.footprints) n.min.x > e.max.x || n.max.x < e.min.x || n.min.y > e.max.y || n.max.y < e.min.y || (i.length = 0, gm(n.vertices, 0, n.vertices.length, e.footprintTileId.canonical, t.canonical, i), Op(e.footprint, i, n.indices, 0, n.indices.length, 0, -r) && (n.hiddenFlags |= 1));\n        }\n        0 === this.groundEffect.hiddenByLandmarkVertexArray.length && this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);\n        for (const t of this.footprints) this.groundEffect.updateHiddenByLandmarkRange(t.groundEffectVertexOffset, t.groundEffectVertexLength, 0 !== t.hiddenFlags);\n        this.indexArrayForConflationUploaded = !1;\n      }\n      getHeightAtTileCoord(t, e) {\n        let r = Number.NEGATIVE_INFINITY,\n          n = !0;\n        const i = 4 * (t + Rn) * Rn + (e + Rn);\n        if (this.footprintLookup.hasOwnProperty(i)) {\n          const t = this.footprintLookup[i];\n          return t ? {\n            height: t.height,\n            hidden: 0 !== t.hiddenFlags\n          } : void 0;\n        }\n        const s = new wt(t, e);\n        for (const o of this.footprints) t > o.max.x || o.min.x > t || e > o.max.y || o.min.y > e || o.height <= r || jp(s, o) && (r = o.height, this.footprintLookup[i] = o, n = 0 !== o.hiddenFlags);\n        if (r !== Number.NEGATIVE_INFINITY) return {\n          height: r,\n          hidden: n\n        };\n        this.footprintLookup[i] = void 0;\n      }\n    }\n    function gm(t, e, r, n, i, s) {\n      const o = Math.pow(2, n.z - i.z);\n      for (let a = 0; a < r; a++) {\n        let r = t[a + e].x,\n          l = t[a + e].y;\n        r = (r + i.x * Rn) * o - n.x * Rn, l = (l + i.y * Rn) * o - n.y * Rn, s.push(new wt(r, l));\n      }\n    }\n    let xm, vm;\n    Ws(ym, \"BuildingBucket\", {\n      omit: [\"layers\"]\n    }), Ws(mm, \"BuildingGeometry\"), Ws(fm, \"BuildingBloomGeometry\");\n    const bm = aa([{\n        name: \"a_pos_normal\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_data\",\n        components: 4,\n        type: \"Uint8\"\n      }, {\n        name: \"a_linesofar\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      wm = aa([{\n        name: \"a_z_offset_width\",\n        components: 3,\n        type: \"Float32\"\n      }], 4),\n      {\n        members: _m\n      } = bm,\n      Am = aa([{\n        name: \"a_packed\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: Mm\n      } = Am,\n      Im = aa([{\n        name: \"a_pattern_data\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: Sm\n      } = Im;\n    class Pm {\n      constructor(t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.image = new gh({\n          width: t,\n          height: e\n        }), this.positions = {}, this.uploaded = !1;\n      }\n      getDash(t, e) {\n        const r = this.getKey(t, e);\n        return this.positions[r];\n      }\n      trim() {\n        const t = this.width,\n          e = this.height = Rt(this.nextRow);\n        this.image.resize({\n          width: t,\n          height: e\n        });\n      }\n      getKey(t, e) {\n        return t.join(\",\") + e;\n      }\n      getDashRanges(t, e, r) {\n        const n = [];\n        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,\n          s = t[0] * r,\n          o = !0;\n        n.push({\n          left: i,\n          right: s,\n          isDash: o,\n          zeroLength: 0 === t[0]\n        });\n        let a = t[0];\n        for (let e = 1; e < t.length; e++) {\n          o = !o;\n          const l = t[e];\n          i = a * r, a += l, s = a * r, n.push({\n            left: i,\n            right: s,\n            isDash: o,\n            zeroLength: 0 === l\n          });\n        }\n        return n;\n      }\n      addRoundDash(t, e, r) {\n        const n = e / 2;\n        for (let e = -r; e <= r; e++) {\n          const i = this.width * (this.nextRow + r + e);\n          let s = 0,\n            o = t[s];\n          for (let a = 0; a < this.width; a++) {\n            a / o.right > 1 && (o = t[++s]);\n            const l = Math.abs(a - o.left),\n              u = Math.abs(a - o.right),\n              c = Math.min(l, u);\n            let h;\n            const p = e / r * (n + 1);\n            if (o.isDash) {\n              const t = n - Math.abs(p);\n              h = Math.sqrt(c * c + t * t);\n            } else h = n - Math.sqrt(c * c + p * p);\n            this.image.data[i + a] = Math.max(0, Math.min(255, h + 128));\n          }\n        }\n      }\n      addRegularDash(t, e) {\n        for (let e = t.length - 1; e >= 0; --e) {\n          const r = t[e],\n            n = t[e + 1];\n          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));\n        }\n        const r = t[0],\n          n = t[t.length - 1];\n        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);\n        const i = this.width * this.nextRow;\n        let s = 0,\n          o = t[s];\n        for (let r = 0; r < this.width; r++) {\n          r / o.right > 1 && (o = t[++s]);\n          const n = Math.abs(r - o.left),\n            a = Math.abs(r - o.right),\n            l = Math.min(n, a);\n          this.image.data[i + r] = Math.max(0, Math.min(255, (o.isDash ? l : -l) + e + 128));\n        }\n      }\n      addDash(t, e) {\n        const r = this.getKey(t, e);\n        if (this.positions[r]) return this.positions[r];\n        const n = \"round\" === e,\n          i = n ? 7 : 0,\n          s = 2 * i + 1;\n        if (this.nextRow + s > this.height) return Gt(\"LineAtlas out of space\"), null;\n        0 === t.length && t.push(1);\n        let o = 0;\n        for (let e = 0; e < t.length; e++) t[e] < 0 && (Gt(\"Negative value is found in line dasharray, replacing values with 0\"), t[e] = 0), o += t[e];\n        if (0 !== o) {\n          const r = this.width / o,\n            s = this.getDashRanges(t, this.width, r);\n          n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, \"square\" === e ? .5 * r : 0);\n        }\n        const a = this.nextRow + i;\n        this.nextRow += s;\n        const l = {\n          tl: [a, i],\n          br: [o, 0]\n        };\n        return this.positions[r] = l, l;\n      }\n    }\n    Ws(Pm, \"LineAtlas\");\n    const km = Iu.types,\n      zm = Math.cos(Math.PI / 180 * 37.5),\n      Em = Math.cos(Math.PI / 180 * 5);\n    class Tm {\n      constructor(t) {\n        this.evaluationGlobals = {\n          zoom: 0,\n          lineProgress: void 0\n        }, this.elevationType = \"none\", this.zoom = t.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t.overscaling, this.pixelRatio = t.pixelRatio, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n          this.gradients[t.id] = {};\n        }), this.layoutVertexArray = new ya(), this.layoutVertexArray2 = new ga(), this.patternVertexArray = new ga(), this.indexArray = new Ea(), this.programConfigurations = new Cl(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.segments = new al(), this.maxLineLength = 0, this.zOffsetVertexArray = new ga(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.tessellationStep = t.tessellationStep ? t.tessellationStep : Rn / 64, this.worldview = t.worldview;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.hasPattern = tp(\"line\", this.layers, this.pixelRatio, e);\n        const i = this.layers[0].layout.get(\"line-sort-key\");\n        this.tileToMeter = fu(r);\n        const s = this.layers[0].layout.get(\"line-elevation-reference\");\n        if (\"hd-road-markup\" === s) this.elevationType = \"road\";else {\n          const t = this.layers[0].layout.get(\"line-z-offset\"),\n            e = t.isConstant() && !t.constantOr(0);\n          this.elevationType = \"sea\" !== s && \"ground\" !== s && e ? \"none\" : \"offset\", \"offset\" === this.elevationType && \"none\" === s && Gt(\"line-elevation-reference: ground is used for the layer \".concat(this.layerIds[0], \" because non-zero line-z-offset value was found.\"));\n        }\n        const o = this.layers[0].layout.get(\"line-cross-slope\");\n        this.hasCrossSlope = \"offset\" === this.elevationType && void 0 !== o;\n        const a = [];\n        for (const {\n          feature: e,\n          id: s,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = Mu(e, t);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom, {\n            worldview: this.worldview\n          }), u, r)) continue;\n          const c = i ? i.evaluate(u, {}, r) : void 0,\n            h = {\n              id: s,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: t ? u.geometry : Au(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          a.push(h);\n        }\n        i && a.sort((t, e) => t.sortKey - e.sortKey);\n        const {\n            lineAtlas: l,\n            featureIndex: u\n          } = e,\n          c = this.addConstantDashes(l);\n        for (const n of a) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: o\n          } = n;\n          if (c && this.addFeatureDashes(n, l), this.hasPattern) {\n            const t = ep(\"line\", this.layers, n, this.zoom, this.pixelRatio, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, l.positions, e.availableImages, e.brightness, e.elevationFeatures);\n          u.insert(t[s].feature, i, s, o, this.index);\n        }\n      }\n      addConstantDashes(t) {\n        let e = !1;\n        for (const r of this.layers) {\n          const n = r.paint.get(\"line-dasharray\").value,\n            i = r.layout.get(\"line-cap\").value;\n          if (\"constant\" !== n.kind || \"constant\" !== i.kind) e = !0;else {\n            const e = i.value,\n              r = n.value;\n            if (!r) continue;\n            t.addDash(r, e);\n          }\n        }\n        return e;\n      }\n      addFeatureDashes(t, e) {\n        const r = this.zoom;\n        for (const n of this.layers) {\n          const i = n.paint.get(\"line-dasharray\").value,\n            s = n.layout.get(\"line-cap\").value;\n          if (\"constant\" === i.kind && \"constant\" === s.kind) continue;\n          let o, a;\n          if (\"constant\" === i.kind) {\n            if (o = i.value, !o) continue;\n          } else o = i.evaluate({\n            zoom: r\n          }, t);\n          a = \"constant\" === s.kind ? s.value : s.evaluate({\n            zoom: r\n          }, t), e.addDash(o, a), t.patterns[n.id] = [e.getKey(o, a)];\n        }\n      }\n      update(t, e, r, n, i, s, o, a) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o, a);\n      }\n      addFeatures(t, e, r, n, i, s) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n, s);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Mm)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t.createVertexBuffer(this.patternVertexArray, Sm)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t.createVertexBuffer(this.zOffsetVertexArray, wm.members, !0)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, _m), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      lineFeatureClips(t, e) {\n        let r, n;\n        if (e && e > 0 ? (r = \"mapbox_clip_start_\".concat(e), n = \"mapbox_clip_end_\".concat(e)) : (r = \"mapbox_clip_start\", n = \"mapbox_clip_end\"), t.properties && t.properties.hasOwnProperty(r) && t.properties.hasOwnProperty(n)) return {\n          start: +t.properties[r],\n          end: +t.properties[n]\n        };\n      }\n      addFeature(t, e, r, n, i, s, o, a) {\n        const l = this.layers[0].layout,\n          u = l.get(\"line-join\").evaluate(t, {}),\n          c = l.get(\"line-cap\").evaluate(t, {}),\n          h = l.get(\"line-miter-limit\"),\n          p = l.get(\"line-round-limit\");\n        this.lineClips = this.lineFeatureClips(t), this.lineFeature = t;\n        const d = !(!t.properties || !t.properties.hasOwnProperty(\"mapbox_line_metrics\")) && t.properties.mapbox_line_metrics;\n        this.zOffsetValue = l.get(\"line-z-offset\").value;\n        const f = this.layers[0].paint.get(\"line-width\").value;\n        if (\"constant\" !== f.kind && !1 === f.isLineProgressConstant && (this.variableWidthValue = f), \"road\" === this.elevationType) {\n          const r = this.layoutVertexArray.length;\n          if (!this.addElevatedRoadFeature(t, e, n, a, u, c, h, p)) {\n            const [i, s] = this.clipRuntimeLinesToTile(e, 1);\n            for (let e = 0; e < i.length; e++) {\n              const r = i[e],\n                o = s[e],\n                a = {\n                  progress: {\n                    min: o.progress.min,\n                    max: o.progress.max\n                  },\n                  nextDir: this.computeSegNextDir(o, r),\n                  prevDir: this.computeSegPrevDir(o, r)\n                };\n              this.addLine(r, t, n, u, c, h, p, a, d && o.parentIndex > 0 ? o.parentIndex : null);\n            }\n            this.fillNonElevatedRoadSegment(r);\n          }\n        } else for (let r = 0; r < e.length; r++) this.addLine(e[r], t, n, u, c, h, p, void 0, d && r > 0 ? r : null);\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n, o, void 0, this.worldview);\n      }\n      computeSegNextDir(t, e) {\n        return t.nextPoint.sub(e.at(-2)).unit();\n      }\n      computeSegPrevDir(t, e) {\n        return e[1].sub(t.prevPoint).unit();\n      }\n      clipLinesToTile(t, e) {\n        return Sd(t, -e, -e, Rn + e, Rn + e);\n      }\n      clipRuntimeLinesToTile(t, e) {\n        const r = [];\n        return [Sd(t, -e, -e, Rn + e, Rn + e, r), r];\n      }\n      addElevatedRoadFeature(t, e, r, n, i, s, o, a) {\n        const l = [],\n          u = Yu.getElevationFeature(t, n);\n        if (u) {\n          const t = this.clipLinesToTile(e, 1),\n            n = this.prepareElevatedLines(t, u, r);\n          for (const t of n) l.push({\n            geometry: t,\n            elevation: u,\n            elevationTileID: r,\n            segment: {\n              progress: {\n                min: 0,\n                max: 1\n              },\n              nextDir: void 0,\n              prevDir: void 0\n            }\n          });\n        }\n        if (0 === l.length) return !1;\n        for (const e of l) {\n          const n = this.layoutVertexArray.length;\n          this.addLine(e.geometry, t, r, i, s, o, a);\n          const l = new Ku(r, e.elevationTileID);\n          if (e.elevation) for (let t = n; t < this.layoutVertexArray.length; t++) {\n            const r = new wt(this.layoutVertexArray.int16[6 * t] >> 1, this.layoutVertexArray.int16[6 * t + 1] >> 1),\n              n = l.pointElevation(r, e.elevation, .05);\n            this.updateHeightRange(n), this.zOffsetVertexArray.emplaceBack(n, 0, 0);\n          } else this.fillNonElevatedRoadSegment(n);\n        }\n        return !0;\n      }\n      prepareElevatedLines(t, e, r) {\n        if (null != e.constantHeight) return t;\n        const n = [],\n          i = 1 / fu(r);\n        for (const r of t) Pd(r, new Zu(e, i), 0, n);\n        return n;\n      }\n      fillNonElevatedRoadSegment(t) {\n        for (let e = t; e < this.layoutVertexArray.length; e++) this.zOffsetVertexArray.emplaceBack(0, 0, 0);\n      }\n      updateHeightRange(t) {\n        this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t), this.heightRange.max = Math.max(this.heightRange.max, t)) : this.heightRange = {\n          min: t,\n          max: t\n        };\n      }\n      addLine(t, e, r, n, i, s, o, a, l) {\n        this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0, this.lineClips = l ? this.lineFeatureClips(e, l) : this.lineClips;\n        const u = \"none\" === n;\n        this.patternJoinNone = this.hasPattern && u, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];\n        const c = a && a.progress.min > 0,\n          h = a && a.progress.max < 1;\n        if (this.lineClips) {\n          let r = {\n              min: this.lineClips.start,\n              max: this.lineClips.end\n            },\n            n = 1;\n          if (a) {\n            const t = this.lineClips.end - this.lineClips.start;\n            r = function (t, e, r) {\n              return {\n                min: re(t.min, e, r),\n                max: re(t.max, e, r)\n              };\n            }(a.progress, {\n              min: 0,\n              max: 1\n            }, r), t > 0 && (n = (r.max - r.min) / t);\n          }\n          const i = +e.properties.mapbox_clip_feature_len,\n            s = +e.properties.mapbox_clip_seg_len;\n          if (Number.isNaN(i) || Number.isNaN(s)) {\n            for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n            const e = this.totalDistance / (r.max - r.min);\n            this.totalFeatureLength = Number.isFinite(e) ? e : 0, this.lineClips.start = r.min, this.lineClips.end = r.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n          } else this.totalFeatureLength = i, this.distance = s * n, this.lineClips.start = r.min, this.lineClips.end = r.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);\n          this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();\n        }\n        const p = \"Polygon\" === km[e.type];\n        let d = t.length;\n        for (; d >= 2 && t[d - 1].equals(t[d - 2]);) d--;\n        let f = 0;\n        for (; f < d - 1 && t[f].equals(t[f + 1]);) f++;\n        if (d < (p ? 3 : 2)) return;\n        \"bevel\" === n && (s = 1.05);\n        const m = this.segments.prepareSegment(10 * d, this.layoutVertexArray, this.indexArray);\n        let y, g, x, v, b, w, _, A;\n        a && a.prevDir && (w = a.prevDir.perp()), a && a.nextDir && (_ = a.nextDir.perp()), this.e1 = this.e2 = -1, p && (y = t[d - 2], b = t[f].sub(y)._unit()._perp());\n        for (let e = f; e < d; e++) {\n          if (x = e === d - 1 ? p ? t[f + 1] : void 0 : t[e + 1], x && t[e].equals(x)) continue;\n          b && (v = b), y && (g = y), y = t[e], A = this.evaluateLineProgressFeatures(g ? g.dist(y) : 0), b = x ? x.sub(y)._unit()._perp() : v, v = v || b;\n          const r = g && x;\n          let a = r ? n : p || u ? \"butt\" : i;\n          const l = v.x * b.x + v.y * b.y;\n          if (u) {\n            const t = function (t) {\n              if (t.patternJoinNone) {\n                const e = t.segmentPoints.length / 2,\n                  r = t.lineSoFar - t.segmentStart;\n                for (let n = 0; n < e; ++n) {\n                  const e = t.segmentPoints[2 * n + 1],\n                    i = Math.round(t.segmentPoints[2 * n]) + .5 + .25 * e;\n                  t.patternVertexArray.emplaceBack(i, r, t.segmentStart), t.patternVertexArray.emplaceBack(i, r, t.segmentStart);\n                }\n                t.segmentPoints.length = 0;\n              }\n              t.e1 = t.e2 = -1;\n            };\n            if (r && l < Em) {\n              this.updateDistance(g, y), this.addCurrentVertex(y, v, 1, 1, m, A), t(this), this.addCurrentVertex(y, b, -1, -1, m, A);\n              continue;\n            }\n            if (g) {\n              if (!x) {\n                this.updateDistance(g, y), this.addCurrentVertex(y, v, 1, 1, m, A), t(this);\n                continue;\n              }\n              a = \"miter\";\n            }\n          }\n          let M = v.add(b);\n          0 === M.x && 0 === M.y || M._unit();\n          const I = M.x * b.x + M.y * b.y,\n            S = 0 !== I ? 1 / I : 1 / 0,\n            P = 2 * Math.sqrt(2 - 2 * I),\n            k = I < zm && g && x,\n            z = v.x * b.y - v.y * b.x > 0,\n            E = this.overscaling <= 16 ? 15 * Rn / (512 * this.overscaling) : 0;\n          if (r && \"round\" === a) if (S < o) a = \"miter\";else if (S <= 2) {\n            const t = Bm(y, -10, Rn + 10);\n            a = \"offset\" === this.elevationType && (t || this.hasCrossSlope) ? \"miter\" : \"fakeround\";\n          }\n          if (\"miter\" === a && S > s && (a = \"bevel\"), \"bevel\" === a && (S > 2 && (a = \"flipbevel\"), S < s && (a = \"miter\")), g && !(\"miter\" === a && k) && this.updateDistance(g, y), \"miter\" === a) {\n            if (k) {\n              const t = y.dist(g);\n              if (t > 2 * E) {\n                const e = y.sub(y.sub(g)._mult(E / t)._round());\n                this.updateDistance(g, e), this.addCurrentVertex(e, v, 0, 0, m, A), g = e;\n              }\n              this.updateDistance(g, y), M._mult(S), this.addCurrentVertex(y, M, 0, 0, m, A);\n              const e = y.dist(x);\n              if (e > 2 * E) {\n                const t = y.add(x.sub(y)._mult(E / e)._round());\n                this.updateDistance(y, t), this.addCurrentVertex(t, b, 0, 0, m, A), y = t;\n              }\n            } else M._mult(S), this.addCurrentVertex(y, M, 0, 0, m, A);\n          } else if (\"flipbevel\" === a) {\n            if (S > 100) M = b.mult(-1);else {\n              const t = S * v.add(b).mag() / v.sub(b).mag();\n              M._perp()._mult(t * (z ? -1 : 1));\n            }\n            this.addCurrentVertex(y, M, 0, 0, m, A), this.addCurrentVertex(y, M.mult(-1), 0, 0, m, A);\n          } else if (\"bevel\" === a || \"fakeround\" === a) {\n            null != A && g && this.addCurrentVertex(y, _ || v, -1, -1, m, A);\n            const t = y.dist(g) <= 2 * E && \"bevel\" !== a,\n              e = M.mult(z ? 1 : -1);\n            e._mult(S);\n            const r = b.mult(z ? -1 : 1),\n              n = v.mult(z ? -1 : 1),\n              i = this.evaluateLineProgressFeatures(this.distance);\n            if (null == A && (this.addHalfVertex(y, e.x, e.y, !1, !z, 0, m, i), t || this.addHalfVertex(y, e.x + 2 * n.x, e.y + 2 * n.y, !1, z, 0, m, i)), \"fakeround\" === a) {\n              const t = Math.round(180 * P / Math.PI / 20);\n              this.addHalfVertex(y, n.x, n.y, !1, z, 0, m, i);\n              for (let e = 0; e < t; e++) {\n                let s = e / t;\n                if (.5 !== s) {\n                  const t = s - .5;\n                  s += s * t * (s - 1) * ((1.0904 + l * (l * (3.55645 - 1.43519 * l) - 3.2452)) * t * t + (.848013 + l * (.215638 * l - 1.06021)));\n                }\n                const o = r.sub(n)._mult(s)._add(n)._unit();\n                this.addHalfVertex(y, o.x, o.y, !1, z, 0, m, i);\n              }\n              this.addHalfVertex(y, r.x, r.y, !1, z, 0, m, i);\n            }\n            t || null != A || this.addHalfVertex(y, e.x + 2 * r.x, e.y + 2 * r.y, !1, z, 0, m, i), null != A && x && this.addCurrentVertex(y, w || b, 1, 1, m, A);\n          } else if (\"butt\" === a) this.addCurrentVertex(y, M, 0, 0, m, A);else if (\"square\" === a) {\n            if (!g) {\n              const t = c ? 0 : -1;\n              this.addCurrentVertex(y, M, t, t, m, A);\n            }\n            if (this.addCurrentVertex(y, M, 0, 0, m, A), g) {\n              const t = h ? 0 : 1;\n              this.addCurrentVertex(y, M, t, t, m, A);\n            }\n          } else if (\"round\" === a) {\n            if (g) {\n              const t = !r && _ ? _ : v;\n              this.addCurrentVertex(y, t, 0, 0, m, A), !r && h || this.addCurrentVertex(y, t, 1, 1, m, A, !0);\n            }\n            if (x) {\n              const t = !r && w ? w : b;\n              !r && c || this.addCurrentVertex(y, t, -1, -1, m, A, !0), this.addCurrentVertex(y, t, 0, 0, m, A);\n            }\n          }\n        }\n      }\n      addVerticesTo(t, e, r, n, i, s, o, a, l, u) {\n        const c = (e.w - t.w) / this.tessellationStep | 0;\n        let h = 0;\n        const p = this.scaledDistance;\n        if (c > 1) {\n          this.lineSoFar = t.w;\n          const p = (e.x - t.x) / c,\n            d = (e.y - t.y) / c,\n            f = (e.z - t.z) / c,\n            m = (e.w - t.w) / c;\n          for (let e = 1; e < c; ++e) {\n            t.x += p, t.y += d, t.z += f, this.lineSoFar += m, h += m;\n            const e = this.evaluateLineProgressFeatures(this.prevDistance + h);\n            this.scaledDistance = (this.prevDistance + h) / this.totalDistance, this.addHalfVertex(t, r, n, u, !1, o, l, e), this.addHalfVertex(t, i, s, u, !0, -a, l, e);\n          }\n        }\n        this.lineSoFar = e.w, this.scaledDistance = p;\n        const d = this.evaluateLineProgressFeatures(this.distance);\n        this.addHalfVertex(e, r, n, u, !1, o, l, d), this.addHalfVertex(e, i, s, u, !0, -a, l, d);\n      }\n      evaluateLineProgressFeatures(t) {\n        if (!this.variableWidthValue && \"offset\" !== this.elevationType) return null;\n        this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t) / this.totalFeatureLength) : Gt(\"line-progress evaluation for \".concat(this.layerIds[0], \" requires enabling 'lineMetrics' for the source.\"));\n        let e = 0;\n        return this.variableWidthValue && \"constant\" !== this.variableWidthValue.kind && (e = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), \"offset\" !== this.elevationType ? {\n          zOffset: 0,\n          variableWidth: e\n        } : \"constant\" === this.zOffsetValue.kind ? {\n          zOffset: this.zOffsetValue.value,\n          variableWidth: e\n        } : {\n          zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,\n          variableWidth: e\n        };\n      }\n      addCurrentVertex(t, e, r, n, i, s) {\n        let o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;\n        const a = e.x + e.y * r,\n          l = e.y - e.x * r,\n          u = e.y * n - e.x,\n          c = -e.y - e.x * n;\n        if (null != s) {\n          const e = \"offset\" === this.elevationType,\n            h = -10,\n            p = Rn + 10,\n            d = s.zOffset,\n            f = new Ad(t.x, t.y, d, this.lineSoFar),\n            m = !!e && Bm(t, h, p),\n            y = this.lineSoFar,\n            g = this.distance;\n          if (this.currentVertex) {\n            if (m) {\n              const e = this.currentVertexIsOutside,\n                s = this.currentVertex,\n                m = new Ad(t.x, t.y, d, this.lineSoFar);\n              if (Id(s, m, h, p), !Bm(m, h, p)) {\n                if (e) {\n                  this.e1 = this.e2 = -1, this.distance -= s.dist(f), this.lineSoFar = s.w;\n                  const t = this.evaluateLineProgressFeatures(s.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));\n                  this.addHalfVertex(s, a, l, o, !1, r, i, t), this.addHalfVertex(s, u, c, o, !0, -n, i, t), this.prevDistance = this.distance;\n                }\n                this.distance = this.prevDistance + s.dist(m), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s, m, a, l, u, c, r, n, i, o), this.distance = g, this.scaledDistance = this.distance / this.totalDistance;\n              }\n            } else {\n              const t = this.currentVertex;\n              if (this.currentVertexIsOutside) {\n                Id(t, f, h, p), this.e1 = this.e2 = -1, this.distance -= t.dist(f), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t.w;\n                const e = this.evaluateLineProgressFeatures(t.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));\n                this.addHalfVertex(t, a, l, o, !1, r, i, e), this.addHalfVertex(t, u, c, o, !0, -n, i, e), this.prevDistance = this.distance, this.distance = g, this.scaledDistance = this.distance / this.totalDistance;\n              }\n              this.addVerticesTo(t, f, a, l, u, c, r, n, i, o);\n            }\n          } else m || (this.addHalfVertex(t, a, l, o, !1, r, i, s), this.addHalfVertex(t, u, c, o, !0, -n, i, s));\n          this.currentVertex = f, this.currentVertexIsOutside = m, this.lineSoFar = y;\n        } else this.addHalfVertex(t, a, l, o, !1, r, i, s), this.addHalfVertex(t, u, c, o, !0, -n, i, s);\n      }\n      addHalfVertex(_ref63, r, n, i, s, o, a, l) {\n        let {\n          x: t,\n          y: e\n        } = _ref63;\n        if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s || this.segmentPoints.push(this.lineSoFar - this.segmentStart, o)), this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === o ? 0 : o < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {\n          const t = ur(this.lineClips.start, this.lineClips.end, this.scaledDistance);\n          this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t);\n        }\n        const u = a.vertexLength++;\n        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), a.primitiveLength++), s ? this.e2 = u : this.e1 = u, null != l && this.zOffsetVertexArray.emplaceBack(l.zOffset, l.variableWidth, l.variableWidth);\n      }\n      updateScaledDistance() {\n        this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;\n      }\n      updateDistance(t, e) {\n        this.prevDistance = this.distance, this.distance += t.dist(e), this.updateScaledDistance();\n      }\n    }\n    function Bm(t, e, r) {\n      return t.x < e || t.x > r || t.y < e || t.y > r;\n    }\n    let Vm, Fm;\n    function Cm(t, e, r) {\n      return e * (Rn / (t.tileSize * Math.pow(2, r - t.tileID.overscaledZ)));\n    }\n    Ws(Tm, \"LineBucket\", {\n      omit: [\"layers\", \"patternFeatures\", \"currentVertex\", \"currentVertexIsOutside\"]\n    });\n    const Dm = (t, e, r) => (1 - r) * t + r * e;\n    function Rm(t, e) {\n      return 1 / Cm(t, 1, e.tileZoom);\n    }\n    function Lm(t, e, r, n) {\n      return t.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get(\"line-translate\"), r.paint.get(\"line-translate-anchor\"));\n    }\n    const Om = t => {\n      const e = [];\n      Um(t) && e.push(\"RENDER_LINE_DASH\"), t.paint.get(\"line-gradient\") && e.push(\"RENDER_LINE_GRADIENT\");\n      const r = t.paint.get(\"line-trim-offset\");\n      0 === r[0] && 0 === r[1] || e.push(\"RENDER_LINE_TRIM_OFFSET\"), 0 !== t.paint.get(\"line-border-width\").constantOr(1) && e.push(\"RENDER_LINE_BORDER\");\n      const n = \"none\" === t.layout.get(\"line-join\").constantOr(\"miter\"),\n        i = !!t.paint.get(\"line-pattern\").constantOr(1);\n      return n && i && e.push(\"LINE_JOIN_NONE\"), e;\n    };\n    function Um(t) {\n      const e = t.paint.get(\"line-dasharray\").value;\n      return \"constant\" !== e.kind || e.value;\n    }\n    let Nm;\n    const jm = () => Nm || (Nm = {\n      layout: Vm || (Vm = new Vo({\n        \"line-cap\": new To(Fo.layout_line[\"line-cap\"]),\n        \"line-join\": new To(Fo.layout_line[\"line-join\"]),\n        \"line-miter-limit\": new Eo(Fo.layout_line[\"line-miter-limit\"]),\n        \"line-round-limit\": new Eo(Fo.layout_line[\"line-round-limit\"]),\n        \"line-sort-key\": new To(Fo.layout_line[\"line-sort-key\"]),\n        \"line-z-offset\": new To(Fo.layout_line[\"line-z-offset\"]),\n        \"line-elevation-reference\": new Eo(Fo.layout_line[\"line-elevation-reference\"]),\n        \"line-cross-slope\": new Eo(Fo.layout_line[\"line-cross-slope\"]),\n        visibility: new Eo(Fo.layout_line.visibility),\n        \"line-width-unit\": new Eo(Fo.layout_line[\"line-width-unit\"])\n      })),\n      paint: Fm || (Fm = new Vo({\n        \"line-opacity\": new To(Fo.paint_line[\"line-opacity\"]),\n        \"line-color\": new To(Fo.paint_line[\"line-color\"]),\n        \"line-translate\": new Eo(Fo.paint_line[\"line-translate\"]),\n        \"line-translate-anchor\": new Eo(Fo.paint_line[\"line-translate-anchor\"]),\n        \"line-width\": new To(Fo.paint_line[\"line-width\"]),\n        \"line-gap-width\": new To(Fo.paint_line[\"line-gap-width\"]),\n        \"line-offset\": new To(Fo.paint_line[\"line-offset\"]),\n        \"line-blur\": new To(Fo.paint_line[\"line-blur\"]),\n        \"line-dasharray\": new To(Fo.paint_line[\"line-dasharray\"]),\n        \"line-pattern\": new To(Fo.paint_line[\"line-pattern\"]),\n        \"line-pattern-cross-fade\": new Eo(Fo.paint_line[\"line-pattern-cross-fade\"]),\n        \"line-gradient\": new Bo(Fo.paint_line[\"line-gradient\"]),\n        \"line-trim-offset\": new Eo(Fo.paint_line[\"line-trim-offset\"]),\n        \"line-trim-fade-range\": new Eo(Fo.paint_line[\"line-trim-fade-range\"]),\n        \"line-trim-color\": new Eo(Fo.paint_line[\"line-trim-color\"]),\n        \"line-emissive-strength\": new Eo(Fo.paint_line[\"line-emissive-strength\"]),\n        \"line-border-width\": new To(Fo.paint_line[\"line-border-width\"]),\n        \"line-border-color\": new To(Fo.paint_line[\"line-border-color\"]),\n        \"line-occlusion-opacity\": new Eo(Fo.paint_line[\"line-occlusion-opacity\"]),\n        \"line-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"line-gradient-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"line-trim-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"line-border-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        })\n      }))\n    }, Nm);\n    class $m extends To {\n      possiblyEvaluate(t, e) {\n        return e = new wo(Math.floor(e.zoom), {\n          now: e.now,\n          fadeDuration: e.fadeDuration,\n          transition: e.transition,\n          worldview: e.worldview\n        }), super.possiblyEvaluate(t, e);\n      }\n      evaluate(t, e, r, n) {\n        return e = Object.assign({}, e, {\n          zoom: Math.floor(e.zoom)\n        }), super.evaluate(t, e, r, n);\n      }\n    }\n    let Gm;\n    function Hm(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n    const qm = aa([{\n        name: \"a_pos_offset\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_tex_size\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixeloffset\",\n        components: 4,\n        type: \"Int16\"\n      }], 4),\n      Xm = aa([{\n        name: \"a_globe_anchor\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_globe_normal\",\n        components: 3,\n        type: \"Float32\"\n      }], 4),\n      Zm = aa([{\n        name: \"a_projected_pos\",\n        components: 4,\n        type: \"Float32\"\n      }], 4);\n    aa([{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint32\"\n    }], 4);\n    const Wm = aa([{\n        name: \"a_auto_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      Ym = aa([{\n        name: \"a_x_axis\",\n        components: 3,\n        type: \"Float32\"\n      }, {\n        name: \"a_y_axis\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      Km = aa([{\n        name: \"a_texb\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      Jm = aa([{\n        name: \"a_placed\",\n        components: 2,\n        type: \"Uint8\"\n      }, {\n        name: \"a_shift\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_elevation_from_sea\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      Qm = aa([{\n        name: \"a_size_scale\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_padding\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_auto_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }]);\n    aa([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Float32\",\n      name: \"x1\"\n    }, {\n      type: \"Float32\",\n      name: \"y1\"\n    }, {\n      type: \"Float32\",\n      name: \"x2\"\n    }, {\n      type: \"Float32\",\n      name: \"y2\"\n    }, {\n      type: \"Int16\",\n      name: \"padding\"\n    }, {\n      type: \"Uint32\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"sourceLayerIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"bucketIndex\"\n    }]);\n    const ty = aa([{\n        name: \"a_pos\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_anchor_pos\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_extrude\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      ey = aa([{\n        name: \"a_pos_2f\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_radius\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_flags\",\n        components: 2,\n        type: \"Int16\"\n      }], 4);\n    aa([{\n      name: \"triangle\",\n      components: 3,\n      type: \"Uint16\"\n    }]), aa([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Uint16\",\n      name: \"glyphStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numGlyphs\"\n    }, {\n      type: \"Uint32\",\n      name: \"vertexStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineLength\"\n    }, {\n      type: \"Uint16\",\n      name: \"segment\"\n    }, {\n      type: \"Uint16\",\n      name: \"lowerSize\"\n    }, {\n      type: \"Uint16\",\n      name: \"upperSize\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetX\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetY\"\n    }, {\n      type: \"Uint8\",\n      name: \"writingMode\"\n    }, {\n      type: \"Uint8\",\n      name: \"placedOrientation\"\n    }, {\n      type: \"Uint8\",\n      name: \"hidden\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Int16\",\n      name: \"associatedIconIndex\"\n    }, {\n      type: \"Uint8\",\n      name: \"flipState\"\n    }]), aa([{\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"rightJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"centerJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"leftJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"placedIconSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedIconSymbolIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"key\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numHorizontalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"useRuntimeCollisionCircles\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Float32\",\n      components: 2,\n      name: \"textOffset\"\n    }, {\n      type: \"Float32\",\n      name: \"collisionCircleDiameter\"\n    }, {\n      type: \"Float32\",\n      name: \"zOffset\"\n    }, {\n      type: \"Uint8\",\n      name: \"hasIconTextFit\"\n    }, {\n      type: \"Uint16\",\n      name: \"elevationFeatureIndex\"\n    }]), aa([{\n      type: \"Float32\",\n      name: \"offsetX\"\n    }]), aa([{\n      type: \"Int16\",\n      name: \"x\"\n    }, {\n      type: \"Int16\",\n      name: \"y\"\n    }]);\n    var ry = 24;\n    function ny(t, e, r) {\n      return t.sections.forEach(t => {\n        t.text = function (t, e, r) {\n          const n = e.layout.get(\"text-transform\").evaluate(r, {});\n          return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), bo.applyArabicShaping && (t = bo.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n    const iy = {\n      \"!\": \"ï¸\",\n      \"#\": \"ï¼\",\n      $: \"ï¼\",\n      \"%\": \"ï¼\",\n      \"&\": \"ï¼\",\n      \"(\": \"ï¸µ\",\n      \")\": \"ï¸¶\",\n      \"*\": \"ï¼\",\n      \"+\": \"ï¼\",\n      \",\": \"ï¸\",\n      \"-\": \"ï¸²\",\n      \".\": \"ã»\",\n      \"/\": \"ï¼\",\n      \":\": \"ï¸\",\n      \";\": \"ï¸\",\n      \"<\": \"ï¸¿\",\n      \"=\": \"ï¼\",\n      \">\": \"ï¹\",\n      \"?\": \"ï¸\",\n      \"@\": \"ï¼ \",\n      \"[\": \"ï¹\",\n      \"\\\\\": \"ï¼¼\",\n      \"]\": \"ï¹\",\n      \"^\": \"ï¼¾\",\n      _: \"ï¸³\",\n      \"`\": \"ï½\",\n      \"{\": \"ï¸·\",\n      \"|\": \"â\",\n      \"}\": \"ï¸¸\",\n      \"~\": \"ï½\",\n      \"Â¢\": \"ï¿ \",\n      \"Â£\": \"ï¿¡\",\n      \"Â¥\": \"ï¿¥\",\n      \"Â¦\": \"ï¿¤\",\n      \"Â¬\": \"ï¿¢\",\n      \"Â¯\": \"ï¿£\",\n      \"â\": \"ï¸²\",\n      \"â\": \"ï¸±\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â¦\": \"ï¸\",\n      \"â§\": \"ã»\",\n      \"â©\": \"ï¿¦\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸¿\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸½\",\n      \"ã\": \"ï¸¾\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸»\",\n      \"ã\": \"ï¸¼\",\n      \"ã\": \"ï¸¹\",\n      \"ã\": \"ï¸º\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸µ\",\n      \"ï¼\": \"ï¸¶\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸²\",\n      \"ï¼\": \"ã»\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸¿\",\n      \"ï¼\": \"ï¹\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼»\": \"ï¹\",\n      \"ï¼½\": \"ï¹\",\n      \"ï¼¿\": \"ï¸³\",\n      \"ï½\": \"ï¸·\",\n      \"ï½\": \"â\",\n      \"ï½\": \"ï¸¸\",\n      \"ï½\": \"ï¸µ\",\n      \"ï½ \": \"ï¸¶\",\n      \"ï½¡\": \"ï¸\",\n      \"ï½¢\": \"ï¹\",\n      \"ï½£\": \"ï¹\",\n      \"â\": \"â\",\n      \"â\": \"â\"\n    };\n    function sy(t) {\n      return \"ï¸¶\" === t || \"ï¹\" === t || \"ï¸¸\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸¾\" === t || \"ï¸¼\" === t || \"ï¸º\" === t || \"ï¸\" === t || \"ï¹\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï½\" === t || \"ï¿£\" === t || \"ï¸\" === t || \"ï¸\" === t;\n    }\n    function oy(t) {\n      return \"ï¸µ\" === t || \"ï¹\" === t || \"ï¸·\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸½\" === t || \"ï¸»\" === t || \"ï¸¹\" === t || \"ï¸\" === t || \"ï¸¿\" === t;\n    }\n    const ay = 4294967296,\n      ly = 1 / ay,\n      uy = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf-8\");\n    let cy = class {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array(16);\n        this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;\n      }\n      readFields(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.length;\n        for (; this.pos < r;) {\n          const r = this.readVarint(),\n            n = r >> 3,\n            i = this.pos;\n          this.type = 7 & r, t(n, e, this), this.pos === i && this.skip(r);\n        }\n        return e;\n      }\n      readMessage(t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      }\n      readFixed32() {\n        const t = this.dataView.getUint32(this.pos, !0);\n        return this.pos += 4, t;\n      }\n      readSFixed32() {\n        const t = this.dataView.getInt32(this.pos, !0);\n        return this.pos += 4, t;\n      }\n      readFixed64() {\n        const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * ay;\n        return this.pos += 8, t;\n      }\n      readSFixed64() {\n        const t = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * ay;\n        return this.pos += 8, t;\n      }\n      readFloat() {\n        const t = this.dataView.getFloat32(this.pos, !0);\n        return this.pos += 4, t;\n      }\n      readDouble() {\n        const t = this.dataView.getFloat64(this.pos, !0);\n        return this.pos += 8, t;\n      }\n      readVarint(t) {\n        const e = this.buf;\n        let r, n;\n        return n = e[this.pos++], r = 127 & n, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 7, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 14, n < 128 ? r : (n = e[this.pos++], r |= (127 & n) << 21, n < 128 ? r : (n = e[this.pos], r |= (15 & n) << 28, function (t, e, r) {\n          const n = r.buf;\n          let i, s;\n          if (s = n[r.pos++], i = (112 & s) >> 4, s < 128) return hy(t, i, e);\n          if (s = n[r.pos++], i |= (127 & s) << 3, s < 128) return hy(t, i, e);\n          if (s = n[r.pos++], i |= (127 & s) << 10, s < 128) return hy(t, i, e);\n          if (s = n[r.pos++], i |= (127 & s) << 17, s < 128) return hy(t, i, e);\n          if (s = n[r.pos++], i |= (127 & s) << 24, s < 128) return hy(t, i, e);\n          if (s = n[r.pos++], i |= (1 & s) << 31, s < 128) return hy(t, i, e);\n          throw new Error(\"Expected varint not more than 10 bytes\");\n        }(r, t, this)))));\n      }\n      readVarint64() {\n        return this.readVarint(!0);\n      }\n      readSVarint() {\n        const t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      }\n      readBoolean() {\n        return Boolean(this.readVarint());\n      }\n      readString() {\n        const t = this.readVarint() + this.pos,\n          e = this.pos;\n        return this.pos = t, t - e >= 12 && uy ? uy.decode(this.buf.subarray(e, t)) : function (t, e, r) {\n          let n = \"\",\n            i = e;\n          for (; i < r;) {\n            const e = t[i];\n            let s,\n              o,\n              a,\n              l = null,\n              u = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;\n            if (i + u > r) break;\n            1 === u ? e < 128 && (l = e) : 2 === u ? (s = t[i + 1], 128 == (192 & s) && (l = (31 & e) << 6 | 63 & s, l <= 127 && (l = null))) : 3 === u ? (s = t[i + 1], o = t[i + 2], 128 == (192 & s) && 128 == (192 & o) && (l = (15 & e) << 12 | (63 & s) << 6 | 63 & o, (l <= 2047 || l >= 55296 && l <= 57343) && (l = null))) : 4 === u && (s = t[i + 1], o = t[i + 2], a = t[i + 3], 128 == (192 & s) && 128 == (192 & o) && 128 == (192 & a) && (l = (15 & e) << 18 | (63 & s) << 12 | (63 & o) << 6 | 63 & a, (l <= 65535 || l >= 1114112) && (l = null))), null === l ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += u;\n          }\n          return n;\n        }(this.buf, e, t);\n      }\n      readBytes() {\n        const t = this.readVarint() + this.pos,\n          e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      }\n      readPackedVarint() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let e = arguments.length > 1 ? arguments[1] : undefined;\n        const r = this.readPackedEnd();\n        for (; this.pos < r;) t.push(this.readVarint(e));\n        return t;\n      }\n      readPackedSVarint() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readSVarint());\n        return t;\n      }\n      readPackedBoolean() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readBoolean());\n        return t;\n      }\n      readPackedFloat() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readFloat());\n        return t;\n      }\n      readPackedDouble() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readDouble());\n        return t;\n      }\n      readPackedFixed32() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readFixed32());\n        return t;\n      }\n      readPackedSFixed32() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readSFixed32());\n        return t;\n      }\n      readPackedFixed64() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readFixed64());\n        return t;\n      }\n      readPackedSFixed64() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        const e = this.readPackedEnd();\n        for (; this.pos < e;) t.push(this.readSFixed64());\n        return t;\n      }\n      readPackedEnd() {\n        return 2 === this.type ? this.readVarint() + this.pos : this.pos + 1;\n      }\n      skip(t) {\n        const e = 7 & t;\n        if (0 === e) for (; this.buf[this.pos++] > 127;);else if (2 === e) this.pos = this.readVarint() + this.pos;else if (5 === e) this.pos += 4;else {\n          if (1 !== e) throw new Error(\"Unimplemented type: \".concat(e));\n          this.pos += 8;\n        }\n      }\n      writeTag(t, e) {\n        this.writeVarint(t << 3 | e);\n      }\n      realloc(t) {\n        let e = this.length || 16;\n        for (; e < this.pos + t;) e *= 2;\n        if (e !== this.length) {\n          const t = new Uint8Array(e);\n          t.set(this.buf), this.buf = t, this.dataView = new DataView(t.buffer), this.length = e;\n        }\n      }\n      finish() {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      }\n      writeFixed32(t) {\n        this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;\n      }\n      writeSFixed32(t) {\n        this.realloc(4), this.dataView.setInt32(this.pos, t, !0), this.pos += 4;\n      }\n      writeFixed64(t) {\n        this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * ly), !0), this.pos += 8;\n      }\n      writeSFixed64(t) {\n        this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, !0), this.dataView.setInt32(this.pos + 4, Math.floor(t * ly), !0), this.pos += 8;\n      }\n      writeVarint(t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          let r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (r = ~(-t % 4294967296), n = ~(-t / 4294967296), 4294967295 ^ r ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            const r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      }\n      writeSVarint(t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      }\n      writeBoolean(t) {\n        this.writeVarint(+t);\n      }\n      writeString(t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        const e = this.pos;\n        this.pos = function (t, e, r) {\n          for (let n, i, s = 0; s < e.length; s++) {\n            if (n = e.charCodeAt(s), n > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n          return r;\n        }(this.buf, t, this.pos);\n        const r = this.pos - e;\n        r >= 128 && py(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      }\n      writeFloat(t) {\n        this.realloc(4), this.dataView.setFloat32(this.pos, t, !0), this.pos += 4;\n      }\n      writeDouble(t) {\n        this.realloc(8), this.dataView.setFloat64(this.pos, t, !0), this.pos += 8;\n      }\n      writeBytes(t) {\n        const e = t.length;\n        this.writeVarint(e), this.realloc(e);\n        for (let r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n      }\n      writeRawMessage(t, e) {\n        this.pos++;\n        const r = this.pos;\n        t(e, this);\n        const n = this.pos - r;\n        n >= 128 && py(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      }\n      writeMessage(t, e, r) {\n        this.writeTag(t, 2), this.writeRawMessage(e, r);\n      }\n      writePackedVarint(t, e) {\n        e.length && this.writeMessage(t, dy, e);\n      }\n      writePackedSVarint(t, e) {\n        e.length && this.writeMessage(t, fy, e);\n      }\n      writePackedBoolean(t, e) {\n        e.length && this.writeMessage(t, gy, e);\n      }\n      writePackedFloat(t, e) {\n        e.length && this.writeMessage(t, my, e);\n      }\n      writePackedDouble(t, e) {\n        e.length && this.writeMessage(t, yy, e);\n      }\n      writePackedFixed32(t, e) {\n        e.length && this.writeMessage(t, xy, e);\n      }\n      writePackedSFixed32(t, e) {\n        e.length && this.writeMessage(t, vy, e);\n      }\n      writePackedFixed64(t, e) {\n        e.length && this.writeMessage(t, by, e);\n      }\n      writePackedSFixed64(t, e) {\n        e.length && this.writeMessage(t, wy, e);\n      }\n      writeBytesField(t, e) {\n        this.writeTag(t, 2), this.writeBytes(e);\n      }\n      writeFixed32Field(t, e) {\n        this.writeTag(t, 5), this.writeFixed32(e);\n      }\n      writeSFixed32Field(t, e) {\n        this.writeTag(t, 5), this.writeSFixed32(e);\n      }\n      writeFixed64Field(t, e) {\n        this.writeTag(t, 1), this.writeFixed64(e);\n      }\n      writeSFixed64Field(t, e) {\n        this.writeTag(t, 1), this.writeSFixed64(e);\n      }\n      writeVarintField(t, e) {\n        this.writeTag(t, 0), this.writeVarint(e);\n      }\n      writeSVarintField(t, e) {\n        this.writeTag(t, 0), this.writeSVarint(e);\n      }\n      writeStringField(t, e) {\n        this.writeTag(t, 2), this.writeString(e);\n      }\n      writeFloatField(t, e) {\n        this.writeTag(t, 5), this.writeFloat(e);\n      }\n      writeDoubleField(t, e) {\n        this.writeTag(t, 1), this.writeDouble(e);\n      }\n      writeBooleanField(t, e) {\n        this.writeVarintField(t, +e);\n      }\n    };\n    function hy(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n    function py(t, e, r) {\n      const n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n      for (let e = r.pos - 1; e >= t; e--) r.buf[e + n] = r.buf[e];\n    }\n    function dy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeVarint(t[r]);\n    }\n    function fy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n    }\n    function my(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeFloat(t[r]);\n    }\n    function yy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeDouble(t[r]);\n    }\n    function gy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n    }\n    function xy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n    }\n    function vy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n    }\n    function by(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n    }\n    function wy(t, e) {\n      for (let r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n    }\n    const _y = 3;\n    function Ay(t, e, r) {\n      e.glyphs = [], 1 === t && r.readMessage(My, e);\n    }\n    function My(t, e, r) {\n      if (3 === t) {\n        const {\n          id: t,\n          bitmap: n,\n          width: i,\n          height: s,\n          left: o,\n          top: a,\n          advance: l\n        } = r.readMessage(Iy, {});\n        e.glyphs.push({\n          id: t,\n          bitmap: new gh({\n            width: i + 2 * _y,\n            height: s + 2 * _y\n          }, n),\n          metrics: {\n            width: i,\n            height: s,\n            left: o,\n            top: a,\n            advance: l\n          }\n        });\n      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());\n    }\n    function Iy(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n    const Sy = _y,\n      Py = {\n        horizontal: 1,\n        vertical: 2,\n        horizontalOnly: 3\n      };\n    class ky {\n      constructor() {\n        this.scale = 1, this.fontStack = \"\", this.image = null;\n      }\n      static forText(t, e) {\n        const r = new ky();\n        return r.scale = t || 1, r.fontStack = e, r;\n      }\n      static forImage(t) {\n        const e = new ky();\n        return e.image = t, e;\n      }\n    }\n    class zy {\n      constructor() {\n        this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n      }\n      static fromFeature(t, e, r) {\n        const n = new zy();\n        for (let i = 0; i < t.sections.length; i++) {\n          const s = t.sections[i];\n          s.image ? n.addImageSection(s, r) : n.addTextSection(s, e);\n        }\n        return n;\n      }\n      length() {\n        return this.text.length;\n      }\n      getSection(t) {\n        return this.sections[this.sectionIndex[t]];\n      }\n      getSections() {\n        return this.sections;\n      }\n      getSectionIndex(t) {\n        return this.sectionIndex[t];\n      }\n      getCodePoint(t) {\n        return this.text.codePointAt(t);\n      }\n      verticalizePunctuation(t) {\n        this.text = function (t, e) {\n          let r = \"\";\n          for (let n = 0; n < t.length; n++) {\n            const i = t.charCodeAt(n + 1) || null,\n              s = t.charCodeAt(n - 1) || null;\n            r += !e && (i && so(i) && !iy[t[n + 1]] || s && so(s) && !iy[t[n - 1]]) || !iy[t[n]] ? t[n] : iy[t[n]];\n          }\n          return r;\n        }(this.text, t);\n      }\n      trim() {\n        let t = 0;\n        for (let e = 0; e < this.text.length && Ty[this.text.charCodeAt(e)]; e++) t++;\n        let e = this.text.length;\n        for (let r = this.text.length - 1; r >= 0 && r >= t && Ty[this.text.charCodeAt(r)]; r--) e--;\n        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n      }\n      substring(t, e) {\n        const r = new zy();\n        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n      }\n      toString() {\n        return this.text;\n      }\n      getMaxScale() {\n        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n      }\n      addTextSection(t, e) {\n        this.text += t.text, this.sections.push(ky.forText(t.scale, t.fontStack || e));\n        const r = this.sections.length - 1;\n        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n      }\n      addImageSection(t, e) {\n        const r = t.image ? t.image.getPrimary() : null;\n        if (!r) return void Gt(\"Can't add FormattedSection with an empty image.\");\n        r.scaleSelf(e);\n        const n = this.getNextImageSectionCharCode();\n        n ? (this.text += String.fromCodePoint(n), this.sections.push(ky.forImage(r)), this.sectionIndex.push(this.sections.length - 1)) : Gt(\"Reached maximum number of images 6401\");\n      }\n      getNextImageSectionCharCode() {\n        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n      }\n    }\n    function Ey(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f) {\n      let m = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;\n      const y = zy.fromFeature(t, i, m);\n      h === Py.vertical && y.verticalizePunctuation(p);\n      let g = [];\n      const x = function (t, e, r, n, i, s) {\n          if (!t) return [];\n          const o = [],\n            a = function (t, e, r, n, i, s) {\n              let o = 0;\n              for (let r = 0; r < t.length(); r++) {\n                const a = t.getSection(r);\n                o += Vy(t.getCodePoint(r), a, n, i, e, s);\n              }\n              return o / Math.max(1, Math.ceil(o / r));\n            }(t, e, r, n, i, s),\n            l = t.text.indexOf(\"â\") >= 0;\n          let u = 0;\n          for (let r = 0; r < t.length(); r++) {\n            const h = t.getSection(r),\n              p = t.getCodePoint(r);\n            if (Ty[p] || (u += Vy(p, h, n, i, e, s)), r < t.length() - 1) {\n              const e = !((c = p) < 11904 || !(to[\"Bopomofo Extended\"](c) || to.Bopomofo(c) || to[\"CJK Compatibility Forms\"](c) || to[\"CJK Compatibility Ideographs\"](c) || to[\"CJK Compatibility\"](c) || to[\"CJK Radicals Supplement\"](c) || to[\"CJK Strokes\"](c) || to[\"CJK Symbols and Punctuation\"](c) || to[\"CJK Unified Ideographs Extension A\"](c) || to[\"CJK Unified Ideographs\"](c) || to[\"Enclosed CJK Letters and Months\"](c) || to[\"Halfwidth and Fullwidth Forms\"](c) || to.Hiragana(c) || to[\"Ideographic Description Characters\"](c) || to[\"Kangxi Radicals\"](c) || to[\"Katakana Phonetic Extensions\"](c) || to.Katakana(c) || to[\"Vertical Forms\"](c) || to[\"Yi Radicals\"](c) || to[\"Yi Syllables\"](c)));\n              (By[p] || e || h.image) && o.push(Dy(r + 1, u, a, o, Cy(p, t.getCodePoint(r + 1), e && l), !1));\n            }\n          }\n          var c;\n          return Ry(Dy(t.length(), u, a, o, 0, !0));\n        }(y, u, s, e, n, d),\n        {\n          processBidirectionalText: v,\n          processStyledBidirectionalText: b\n        } = bo;\n      if (v && 1 === y.sections.length) {\n        const t = v(y.toString(), x);\n        for (const e of t) {\n          const t = new zy();\n          t.text = e, t.sections = y.sections;\n          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n          g.push(t);\n        }\n      } else if (b) {\n        const t = b(y.text, y.sectionIndex, x);\n        for (const e of t) {\n          const t = new zy();\n          t.text = e[0], t.sectionIndex = e[1], t.sections = y.sections, g.push(t);\n        }\n      } else g = function (t, e) {\n        const r = [],\n          n = t.text;\n        let i = 0;\n        for (const n of e) r.push(t.substring(i, n)), i = n;\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(y, x);\n      const w = [],\n        _ = {\n          positionedLines: w,\n          text: y.toString(),\n          top: c[1],\n          bottom: c[1],\n          left: c[0],\n          right: c[0],\n          writingMode: h,\n          iconsInText: !1,\n          verticalizable: !1,\n          hasBaseline: !1\n        };\n      if (function (t, e, r, n, i, s, o, a, l, u, c, h) {\n        let p = 0,\n          d = 0,\n          f = 0;\n        const m = \"right\" === a ? 1 : \"left\" === a ? 0 : .5;\n        let y = !1;\n        for (const t of i) {\n          const r = t.getSections();\n          for (const t of r) {\n            if (t.image) continue;\n            const r = e[t.fontStack];\n            if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;\n          }\n          if (!y) break;\n        }\n        let g = 0;\n        for (const o of i) {\n          o.trim();\n          const i = o.getMaxScale(),\n            a = (i - 1) * ry,\n            v = {\n              positionedGlyphs: [],\n              lineOffset: 0\n            };\n          t.positionedLines[g] = v;\n          const b = v.positionedGlyphs;\n          let w = 0;\n          if (!o.length()) {\n            d += s, ++g;\n            continue;\n          }\n          let _ = 0,\n            A = 0;\n          for (let s = 0; s < o.length(); s++) {\n            const a = o.getSection(s),\n              f = o.getSectionIndex(s),\n              m = o.getCodePoint(s);\n            let g = a.scale,\n              v = null,\n              M = null,\n              I = null,\n              S = ry,\n              P = 0,\n              k = l;\n            k === Py.vertical && (12312 === (x = m) || 12313 === x || 12316 === x || 12540 === x || 12448 === x) && (k = Py.horizontal);\n            const z = !(k === Py.horizontal || !c && !io(m) || c && (Ty[m] || oo(m)));\n            if (a.image) {\n              const e = n.get(a.image.toString());\n              if (!e) continue;\n              I = a.image, t.iconsInText = t.iconsInText || !0, M = e.paddedRect;\n              const r = e.displaySize;\n              g = g * ry / h, v = {\n                width: r[0],\n                height: r[1],\n                left: 0,\n                top: -Sy,\n                advance: z ? r[1] : r[0],\n                localGlyph: !1\n              }, P = y ? -v.height * g : i * ry - 17 - r[1] * g, S = v.advance;\n              const s = (z ? r[0] : r[1]) * g - ry * i;\n              s > 0 && s > w && (w = s);\n            } else {\n              const t = r[a.fontStack];\n              if (!t) continue;\n              t[m] && (M = t[m]);\n              const n = e[a.fontStack];\n              if (!n) continue;\n              const s = n.glyphs[m];\n              if (!s) continue;\n              if (v = s.metrics, S = 8203 !== m ? ry : 0, y) {\n                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,\n                  e = void 0 !== n.descender ? Math.abs(n.descender) : 0,\n                  r = (t + e) * g;\n                _ < r && (_ = r, A = (t - e) / 2 * g), P = -t * g;\n              } else P = (i - g) * ry - 17;\n            }\n            z ? (t.verticalizable = !0, b.push({\n              glyph: m,\n              image: I,\n              x: p,\n              y: d + P,\n              vertical: z,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: a.fontStack,\n              sectionIndex: f,\n              metrics: v,\n              rect: M\n            }), p += S * g + u) : (b.push({\n              glyph: m,\n              image: I,\n              x: p,\n              y: d + P,\n              vertical: z,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: a.fontStack,\n              sectionIndex: f,\n              metrics: v,\n              rect: M\n            }), p += v.advance * g + u);\n          }\n          0 !== b.length && (f = Math.max(p - u, f), y ? Oy(b, m, w, A, s * i / 2) : Oy(b, m, w, 0, s / 2)), p = 0;\n          const M = s * i + w;\n          v.lineOffset = Math.max(w, a), d += M, ++g;\n        }\n        var x;\n        const v = d,\n          {\n            horizontalAlign: b,\n            verticalAlign: w\n          } = Ly(o);\n        (function (t, e, r, n, i, s) {\n          const o = (e - r) * i,\n            a = -s * n;\n          for (const e of t) for (const t of e.positionedGlyphs) t.x += o, t.y += a;\n        })(t.positionedLines, m, b, w, f, v), t.top += -w * v, t.bottom = t.top + v, t.left += -b * f, t.right = t.left + f, t.hasBaseline = y;\n      }(_, e, r, n, g, o, a, l, h, u, p, f), !function (t) {\n        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n        return !0;\n      }(w)) return _;\n    }\n    const Ty = {\n        9: !0,\n        10: !0,\n        11: !0,\n        12: !0,\n        13: !0,\n        32: !0\n      },\n      By = {\n        10: !0,\n        32: !0,\n        38: !0,\n        40: !0,\n        41: !0,\n        43: !0,\n        45: !0,\n        47: !0,\n        173: !0,\n        183: !0,\n        8203: !0,\n        8208: !0,\n        8211: !0,\n        8231: !0\n      };\n    function Vy(t, e, r, n, i, s) {\n      if (e.image) {\n        const t = n.get(e.image.toString());\n        return t ? t.displaySize[0] * e.scale * ry / s + i : 0;\n      }\n      {\n        const n = r[e.fontStack],\n          s = n && n.glyphs[t];\n        return s ? s.metrics.advance * e.scale + i : 0;\n      }\n    }\n    function Fy(t, e, r, n) {\n      const i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n    function Cy(t, e, r) {\n      let n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n    function Dy(t, e, r, n, i, s) {\n      let o = null,\n        a = Fy(e, r, i, s);\n      for (const t of n) {\n        const n = Fy(e - t.x, r, i, s) + t.badness;\n        n <= a && (o = t, a = n);\n      }\n      return {\n        index: t,\n        x: e,\n        priorBreak: o,\n        badness: a\n      };\n    }\n    function Ry(t) {\n      return t ? Ry(t.priorBreak).concat(t.index) : [];\n    }\n    function Ly(t) {\n      let e = .5,\n        r = .5;\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          e = 1;\n          break;\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          e = 0;\n      }\n      switch (t) {\n        case \"bottom\":\n        case \"bottom-right\":\n        case \"bottom-left\":\n          r = 1;\n          break;\n        case \"top\":\n        case \"top-right\":\n        case \"top-left\":\n          r = 0;\n      }\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n    function Oy(t, e, r, n, i) {\n      if (!(e || r || n || i)) return;\n      const s = t.length - 1,\n        o = t[s],\n        a = (o.x + o.metrics.advance * o.scale) * e;\n      for (let e = 0; e <= s; e++) t[e].x -= a, t[e].y += r + n + i;\n    }\n    function Uy(t) {\n      return void 0 !== t.imagePrimary && void 0 !== t.top && void 0 !== t.bottom && void 0 !== t.left && void 0 !== t.right;\n    }\n    function Ny(t, e, r, n) {\n      const {\n          horizontalAlign: i,\n          verticalAlign: s\n        } = Ly(n),\n        o = r[0] - t.displaySize[0] * i,\n        a = r[1] - t.displaySize[1] * s;\n      return {\n        imagePrimary: t,\n        imageSecondary: e,\n        top: a,\n        bottom: a + t.displaySize[1],\n        left: o,\n        right: o + t.displaySize[0]\n      };\n    }\n    function jy(t, e, r, n, i, s) {\n      const o = t.imagePrimary;\n      let a;\n      if (o.content) {\n        const t = o.content,\n          e = o.pixelRatio || 1;\n        a = [t[0] / e, t[1] / e, o.displaySize[0] - t[2] / e, o.displaySize[1] - t[3] / e];\n      }\n      const l = e.left * s,\n        u = e.right * s;\n      let c, h, p, d;\n      \"width\" === r || \"both\" === r ? (d = i[0] + l - n[3], h = i[0] + u + n[1]) : (d = i[0] + (l + u - o.displaySize[0]) / 2, h = d + o.displaySize[0]);\n      const f = e.top * s,\n        m = e.bottom * s;\n      return \"height\" === r || \"both\" === r ? (c = i[1] + f - n[0], p = i[1] + m + n[2]) : (c = i[1] + (f + m - o.displaySize[1]) / 2, p = c + o.displaySize[1]), {\n        imagePrimary: o,\n        imageSecondary: void 0,\n        top: c,\n        right: h,\n        bottom: p,\n        left: d,\n        collisionPadding: a\n      };\n    }\n    function $y(t) {\n      return !t.imagePrimary.stretchX;\n    }\n    function Gy(t) {\n      return !t.imagePrimary.stretchY;\n    }\n    function Hy(t) {\n      return {\n        width: t.right - t.left,\n        height: t.bottom - t.top\n      };\n    }\n    const qy = 128;\n    function Xy(t, e, r) {\n      const {\n        expression: n\n      } = e;\n      if (\"constant\" === n.kind) return {\n        kind: \"constant\",\n        layoutSize: n.evaluate(new wo(t + 1, {\n          worldview: r\n        }))\n      };\n      if (\"source\" === n.kind) return {\n        kind: \"source\"\n      };\n      {\n        const {\n          zoomStops: e,\n          interpolationType: i\n        } = n;\n        let s = 0;\n        for (; s < e.length && e[s] <= t;) s++;\n        s = Math.max(0, s - 1);\n        let o = s;\n        for (; o < e.length && e[o] < t + 1;) o++;\n        o = Math.min(e.length - 1, o);\n        const a = e[s],\n          l = e[o];\n        return \"composite\" === n.kind ? {\n          kind: \"composite\",\n          minZoom: a,\n          maxZoom: l,\n          interpolationType: i\n        } : {\n          kind: \"camera\",\n          minZoom: a,\n          maxZoom: l,\n          minSize: n.evaluate(new wo(a, {\n            worldview: r\n          })),\n          maxSize: n.evaluate(new wo(l, {\n            worldview: r\n          })),\n          interpolationType: i\n        };\n      }\n    }\n    function Zy(t, _ref64, _ref65) {\n      let {\n        uSize: e,\n        uSizeT: r\n      } = _ref64;\n      let {\n        lowerSize: n,\n        upperSize: i\n      } = _ref65;\n      return \"source\" === t.kind ? n / qy : \"composite\" === t.kind ? ur(n / qy, i / qy, r) : e;\n    }\n    function Wy(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      let n = 0,\n        i = 0;\n      if (\"constant\" === t.kind) i = t.layoutSize * r;else if (\"source\" !== t.kind) {\n        const {\n            interpolationType: s,\n            minZoom: o,\n            maxZoom: a\n          } = t,\n          l = s ? Tt(Hi.interpolationFactor(s, e, o, a), 0, 1) : 0;\n        \"camera\" === t.kind ? i = ur(t.minSize, t.maxSize, l) * r : n = l * r;\n      }\n      return {\n        uSizeT: n,\n        uSize: i\n      };\n    }\n    class Yy extends wt {\n      constructor(t, e, r, n, i) {\n        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);\n      }\n      clone() {\n        return new Yy(this.x, this.y, this.z, this.angle, this.segment);\n      }\n    }\n    function Ky(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      let s = e,\n        o = e.segment + 1,\n        a = 0;\n      for (; a > -r / 2;) {\n        if (o--, o < 0) return !1;\n        a -= t[o].dist(s), s = t[o];\n      }\n      a += t[o].dist(t[o + 1]), o++;\n      const l = [];\n      let u = 0;\n      for (; a < r / 2;) {\n        const e = t[o],\n          r = t[o + 1];\n        if (!r) return !1;\n        let s = t[o - 1].angleTo(e) - e.angleTo(r);\n        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n          distance: a,\n          angleDelta: s\n        }), u += s; a - l[0].distance > n;) u -= l.shift().angleDelta;\n        if (u > i) return !1;\n        o++, a += e.dist(r);\n      }\n      return !0;\n    }\n    function Jy(t) {\n      let e = 0;\n      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n      return e;\n    }\n    function Qy(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n    function tg(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n    function eg(t, e, r, n, i, s) {\n      const o = Qy(r, i, s),\n        a = tg(r, n) * s;\n      let l = 0;\n      const u = Jy(t) / 2;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1],\n          s = n.dist(i);\n        if (l + s > u) {\n          const c = (u - l) / s,\n            h = ur(n.x, i.x, c),\n            p = ur(n.y, i.y, c),\n            d = new Yy(h, p, 0, i.angleTo(n), r);\n          return !o || Ky(t, d, a, o, e) ? d : void 0;\n        }\n        l += s;\n      }\n    }\n    function rg(t, e, r, n, i, s, o, a, l) {\n      const u = Qy(n, s, o),\n        c = tg(n, i),\n        h = c * o,\n        p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n      return e - h < e / 4 && (e = h + e / 4), ng(t, p ? e / 2 * a % e : (c / 2 + 2 * s) * o * a % e, e, u, r, h, p, !1, l);\n    }\n    function ng(t, e, r, n, i, s, o, a, l) {\n      const u = s / 2,\n        c = Jy(t);\n      let h = 0,\n        p = e - r,\n        d = [];\n      for (let e = 0; e < t.length - 1; e++) {\n        const o = t[e],\n          a = t[e + 1],\n          f = o.dist(a),\n          m = a.angleTo(o);\n        for (; p + r < h + f;) {\n          p += r;\n          const y = (p - h) / f,\n            g = ur(o.x, a.x, y),\n            x = ur(o.y, a.y, y);\n          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {\n            const r = new Yy(g, x, 0, m, e);\n            n && !Ky(t, r, s, n, i) || d.push(r);\n          }\n        }\n        h += f;\n      }\n      return a || d.length || o || (d = ng(t, h / 2, r, n, i, s, o, !0, l)), d;\n    }\n    function ig(t) {\n      let e = 0,\n        r = 0;\n      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n      t.sort((t, e) => e.h - t.h);\n      const n = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }];\n      let i = 0,\n        s = 0;\n      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n        const r = n[t];\n        if (!(e.w > r.w || e.h > r.h)) {\n          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n            const e = n.pop();\n            e && t < n.length && (n[t] = e);\n          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n            x: r.x + e.w,\n            y: r.y,\n            w: r.w - e.w,\n            h: e.h\n          }), r.y += e.h, r.h -= e.h);\n          break;\n        }\n      }\n      return {\n        w: i,\n        h: s,\n        fill: e / (i * s) || 0\n      };\n    }\n    Ws(Yy, \"Anchor\");\n    const sg = 1;\n    class og {\n      static getImagePositionScale(t, e, r) {\n        if (e && t && t.options && t.options.transform) {\n          const e = t.options.transform;\n          return {\n            x: e.a,\n            y: e.d\n          };\n        }\n        return {\n          x: r,\n          y: r\n        };\n      }\n      constructor(t, e, r, n) {\n        this.paddedRect = t;\n        const {\n          pixelRatio: i,\n          version: s,\n          stretchX: o,\n          stretchY: a,\n          content: l,\n          sdf: u,\n          usvg: c\n        } = e;\n        this.pixelRatio = i, this.stretchX = o, this.stretchY = a, this.content = l, this.version = s, this.padding = r, this.sdf = u, this.usvg = c, this.scale = og.getImagePositionScale(n, c, i);\n      }\n      get tl() {\n        return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];\n      }\n      get br() {\n        return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];\n      }\n      get displaySize() {\n        return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];\n      }\n    }\n    function ag(t, e, r) {\n      const n = Fr.parse(t),\n        i = function (t, e) {\n          let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1];\n          return {\n            x: 0,\n            y: 0,\n            w: (t.data ? t.data.width : t.width * r[0]) + 2 * e,\n            h: (t.data ? t.data.height : t.height * r[1]) + 2 * e\n          };\n        }(e, r, [n.options.transform.a, n.options.transform.d]);\n      return {\n        bin: i,\n        imagePosition: new og(i, e, r, n),\n        imageVariant: n\n      };\n    }\n    class lg {\n      constructor(t, e, r) {\n        const n = new Map(),\n          i = new Map();\n        this.haveRenderCallbacks = [];\n        const s = [];\n        this.addImages(t, n, sg, s), this.addImages(e, i, 2, s);\n        const {\n            w: o,\n            h: a\n          } = ig(s),\n          l = new xh({\n            width: o || 1,\n            height: a || 1\n          });\n        for (const [e, r] of t.entries()) {\n          const t = n.get(e).paddedRect;\n          xh.copy(r.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: t.x + sg,\n            y: t.y + sg\n          }, r.data, null, r.sdf);\n        }\n        for (const [t, n] of e.entries()) {\n          const e = i.get(t),\n            s = e.paddedRect;\n          let o = e.padding;\n          const a = s.x + o,\n            u = s.y + o,\n            c = n.data.width,\n            h = n.data.height;\n          o = o > 1 ? o - 1 : o, xh.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: a,\n            y: u\n          }, n.data, r), xh.copy(n.data, l, {\n            x: 0,\n            y: h - o\n          }, {\n            x: a,\n            y: u - o\n          }, {\n            width: c,\n            height: o\n          }, r), xh.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: a,\n            y: u + h\n          }, {\n            width: c,\n            height: o\n          }, r), xh.copy(n.data, l, {\n            x: c - o,\n            y: 0\n          }, {\n            x: a - o,\n            y: u\n          }, {\n            width: o,\n            height: h\n          }, r), xh.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: a + c,\n            y: u\n          }, {\n            width: o,\n            height: h\n          }, r), xh.copy(n.data, l, {\n            x: c - o,\n            y: h - o\n          }, {\n            x: a - o,\n            y: u - o\n          }, {\n            width: o,\n            height: o\n          }, r), xh.copy(n.data, l, {\n            x: 0,\n            y: h - o\n          }, {\n            x: a + c,\n            y: u - o\n          }, {\n            width: o,\n            height: o\n          }, r), xh.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: a + c,\n            y: u + h\n          }, {\n            width: o,\n            height: o\n          }, r), xh.copy(n.data, l, {\n            x: c - o,\n            y: 0\n          }, {\n            x: a - o,\n            y: u + h\n          }, {\n            width: o,\n            height: o\n          }, r);\n        }\n        this.lut = r, this.image = l, this.iconPositions = n, this.patternPositions = i;\n      }\n      addImages(t, e, r, n) {\n        for (const [i, s] of t.entries()) {\n          const {\n            bin: t,\n            imagePosition: o,\n            imageVariant: a\n          } = ag(i, s, r);\n          e.set(i, o), n.push(t), s.hasRenderCallback && this.haveRenderCallbacks.push(a.id);\n        }\n      }\n      patchUpdatedImages(t, e, r) {\n        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e, r)), t.dispatchRenderCallbacks(this.haveRenderCallbacks, r);\n        for (const n of t.getUpdatedImages(r)) {\n          for (const i of this.iconPositions.keys()) {\n            const s = Fr.parse(i);\n            if (er.isEqual(s.id, n)) {\n              const s = t.getImage(n, r);\n              this.patchUpdatedImage(this.iconPositions.get(i), s, e, null);\n            }\n          }\n          for (const i of this.patternPositions.keys()) {\n            const s = Fr.parse(i);\n            if (er.isEqual(s.id, n)) {\n              const s = t.getImage(n, r);\n              this.patchUpdatedImage(this.patternPositions.get(i), s, e, this.lut);\n            }\n          }\n        }\n      }\n      patchUpdatedImage(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        if (!t || !e) return;\n        if (t.version === e.version) return;\n        t.version = e.version;\n        const [i, s] = t.tl,\n          o = t.sdf;\n        if (this.lut || o) {\n          const t = {\n              width: e.data.width,\n              height: e.data.height\n            },\n            a = new xh(t);\n          xh.copy(e.data, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: 0,\n            y: 0\n          }, t, n, o), r.update(a, {\n            position: {\n              x: i,\n              y: s\n            }\n          });\n        } else r.update(e.data, {\n          position: {\n            x: i,\n            y: s\n          }\n        });\n      }\n    }\n    Ws(og, \"ImagePosition\"), Ws(lg, \"ImageAtlas\");\n    const ug = 1e20;\n    function cg(t, e, r, n, i, s, o, a, l) {\n      for (let u = e; u < e + n; u++) hg(t, r * s + u, s, i, o, a, l);\n      for (let u = r; u < r + i; u++) hg(t, u * s + e, 1, n, o, a, l);\n    }\n    function hg(t, e, r, n, i, s, o) {\n      s[0] = 0, o[0] = -ug, o[1] = ug, i[0] = t[e];\n      for (let a = 1, l = 0, u = 0; a < n; a++) {\n        i[a] = t[e + a * r];\n        const n = a * a;\n        do {\n          const t = s[l];\n          u = (i[a] - i[t] + n - t * t) / (a - t) / 2;\n        } while (u <= o[l] && --l > -1);\n        l++, s[l] = a, o[l] = u, o[l + 1] = ug;\n      }\n      for (let a = 0, l = 0; a < n; a++) {\n        for (; o[l + 1] < a;) l++;\n        const n = s[l],\n          u = a - n;\n        t[e + a * r] = i[n] + u * u;\n      }\n    }\n    const pg = 2,\n      dg = {\n        none: 0,\n        ideographs: 1,\n        all: 2\n      };\n    class fg {\n      constructor(t, e, r) {\n        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.url = \"\", this.entries = {}, this.localGlyphs = {\n          200: {},\n          400: {},\n          500: {},\n          900: {}\n        };\n      }\n      setURL(t) {\n        this.url = t;\n      }\n      getGlyphs(t, e) {\n        const r = [],\n          n = this.url || ne.GLYPHS_URL;\n        for (const e in t) for (const n of t[e]) r.push({\n          stack: e,\n          id: n\n        });\n        Ft(r, (_ref66, r) => {\n          let {\n            stack: t,\n            id: e\n          } = _ref66;\n          let i = this.entries[t];\n          i || (i = this.entries[t] = {\n            glyphs: {},\n            requests: {},\n            ranges: {},\n            ascender: void 0,\n            descender: void 0\n          });\n          let s = i.glyphs[e];\n          if (void 0 !== s) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          if (s = this._tinySDF(i, t, e), s) return i.glyphs[e] = s, void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          const o = Math.floor(e / 256);\n          if (256 * o > 65535) return Gt(\"glyphs > 65535 not supported\"), void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          if (i.ranges[o]) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          let a = i.requests[o];\n          a || (a = i.requests[o] = [], fg.loadGlyphRange(t, o, n, this.requestManager, (t, e) => {\n            if (e) {\n              i.ascender = e.ascender, i.descender = e.descender;\n              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (i.glyphs[+t] = e.glyphs[+t]);\n              i.ranges[o] = !0;\n            }\n            for (const r of a) r(t, e);\n            delete i.requests[o];\n          })), a.push((n, i) => {\n            n ? r(n) : i && r(null, {\n              stack: t,\n              id: e,\n              glyph: i.glyphs[e] || null\n            });\n          });\n        }, (t, r) => {\n          if (t) e(t);else if (r) {\n            const t = {};\n            for (const {\n              stack: e,\n              id: n,\n              glyph: i\n            } of r) void 0 === t[e] && (t[e] = {}), void 0 === t[e].glyphs && (t[e].glyphs = {}), t[e].glyphs[n] = i && {\n              id: i.id,\n              bitmap: i.bitmap.clone(),\n              metrics: i.metrics\n            }, t[e].ascender = this.entries[e].ascender, t[e].descender = this.entries[e].descender;\n            e(null, t);\n          }\n        });\n      }\n      _doesCharSupportLocalGlyph(t) {\n        return this.localGlyphMode !== dg.none && (this.localGlyphMode === dg.all ? !!this.localFontFamily : !!this.localFontFamily && (to[\"CJK Unified Ideographs\"](t) || to[\"Hangul Syllables\"](t) || to.Hiragana(t) || to.Katakana(t) || to[\"CJK Symbols and Punctuation\"](t) || to[\"CJK Unified Ideographs Extension A\"](t) || to[\"CJK Unified Ideographs Extension B\"](t) || to.Osage(t)));\n      }\n      _tinySDF(t, e, r) {\n        const n = this.localFontFamily;\n        if (!n || !this._doesCharSupportLocalGlyph(r)) return;\n        let i = t.tinySDF;\n        if (!i) {\n          let r = \"400\";\n          /bold/i.test(e) ? r = \"900\" : /medium/i.test(e) ? r = \"500\" : /light/i.test(e) && (r = \"200\"), i = t.tinySDF = new fg.TinySDF({\n            fontFamily: n,\n            fontWeight: r,\n            fontSize: 24 * pg,\n            buffer: 3 * pg,\n            radius: 8 * pg\n          }), i.fontWeight = r;\n        }\n        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];\n        const s = String.fromCodePoint(r),\n          {\n            data: o,\n            width: a,\n            height: l,\n            glyphWidth: u,\n            glyphHeight: c,\n            glyphLeft: h,\n            glyphTop: p,\n            glyphAdvance: d\n          } = i.draw(s);\n        return this.localGlyphs[i.fontWeight][r] = {\n          id: r,\n          bitmap: new gh({\n            width: a,\n            height: l\n          }, o),\n          metrics: {\n            width: u / pg,\n            height: c / pg,\n            left: h / pg,\n            top: p / pg - 27,\n            advance: d / pg,\n            localGlyph: !0\n          }\n        };\n      }\n    }\n    fg.loadGlyphRange = function (t, e, r, n, i) {\n      const s = 256 * e,\n        o = s + 255,\n        a = n.transformRequest(n.normalizeGlyphsURL(r).replace(\"{fontstack}\", t).replace(\"{range}\", \"\".concat(s, \"-\").concat(o)), Be.Glyphs);\n      De(a, (t, e) => {\n        if (t) i(t);else if (e) {\n          const t = {},\n            r = function (t) {\n              return new cy(t).readFields(Ay, {});\n            }(e);\n          for (const e of r.glyphs) t[e.id] = e;\n          i(null, {\n            glyphs: t,\n            ascender: r.ascender,\n            descender: r.descender\n          });\n        }\n      });\n    }, fg.TinySDF = class {\n      constructor() {\n        let {\n          fontSize: t = 24,\n          buffer: e = 3,\n          radius: r = 8,\n          cutoff: n = .25,\n          fontFamily: i = \"sans-serif\",\n          fontWeight: s = \"normal\",\n          fontStyle: o = \"normal\",\n          lang: a = null\n        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.buffer = e, this.cutoff = n, this.radius = r, this.lang = a;\n        const l = this.size = t + 4 * e,\n          u = this._createCanvas(l),\n          c = this.ctx = u.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n        c.font = \"\".concat(o, \" \").concat(s, \" \").concat(t, \"px \").concat(i), c.textBaseline = \"alphabetic\", c.textAlign = \"left\", c.fillStyle = \"black\", this.gridOuter = new Float64Array(l * l), this.gridInner = new Float64Array(l * l), this.f = new Float64Array(l), this.z = new Float64Array(l + 1), this.v = new Uint16Array(l);\n      }\n      _createCanvas(t) {\n        const e = document.createElement(\"canvas\");\n        return e.width = e.height = t, e;\n      }\n      draw(t) {\n        const {\n            width: e,\n            actualBoundingBoxAscent: r,\n            actualBoundingBoxDescent: n,\n            actualBoundingBoxLeft: i,\n            actualBoundingBoxRight: s\n          } = this.ctx.measureText(t),\n          o = Math.ceil(r),\n          a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))),\n          l = Math.min(this.size - this.buffer, o + Math.ceil(n)),\n          u = a + 2 * this.buffer,\n          c = l + 2 * this.buffer,\n          h = Math.max(u * c, 0),\n          p = new Uint8ClampedArray(h),\n          d = {\n            data: p,\n            width: u,\n            height: c,\n            glyphWidth: a,\n            glyphHeight: l,\n            glyphTop: o,\n            glyphLeft: 0,\n            glyphAdvance: e\n          };\n        if (0 === a || 0 === l) return d;\n        const {\n          ctx: f,\n          buffer: m,\n          gridInner: y,\n          gridOuter: g\n        } = this;\n        this.lang && (f.lang = this.lang), f.clearRect(m, m, a, l), f.fillText(t, m, m + o);\n        const x = f.getImageData(m, m, a, l);\n        g.fill(ug, 0, h), y.fill(0, 0, h);\n        for (let t = 0; t < l; t++) for (let e = 0; e < a; e++) {\n          const r = x.data[4 * (t * a + e) + 3] / 255;\n          if (0 === r) continue;\n          const n = (t + m) * u + e + m;\n          if (1 === r) g[n] = 0, y[n] = ug;else {\n            const t = .5 - r;\n            g[n] = t > 0 ? t * t : 0, y[n] = t < 0 ? t * t : 0;\n          }\n        }\n        cg(g, 0, 0, u, c, u, this.f, this.v, this.z), cg(y, m, m, a, l, u, this.f, this.v, this.z);\n        for (let t = 0; t < h; t++) {\n          const e = Math.sqrt(g[t]) - Math.sqrt(y[t]);\n          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));\n        }\n        return d;\n      }\n    };\n    const mg = sg;\n    function yg(t, e) {\n      return t + e[1] - e[0];\n    }\n    function gg(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n      const s = [],\n        o = t.imagePrimary,\n        a = o.pixelRatio,\n        l = o.paddedRect.w - 2 * mg,\n        u = o.paddedRect.h - 2 * mg,\n        c = (t.right - t.left) * i,\n        h = (t.bottom - t.top) * i,\n        p = o.stretchX || [[0, l]],\n        d = o.stretchY || [[0, u]],\n        f = p.reduce(yg, 0),\n        m = d.reduce(yg, 0),\n        y = l - f,\n        g = u - m;\n      let x = 0,\n        v = f,\n        b = 0,\n        w = m,\n        _ = 0,\n        A = y,\n        M = 0,\n        I = g;\n      if (o.content && n) {\n        const t = o.content;\n        x = xg(p, 0, t[0]), b = xg(d, 0, t[1]), v = xg(p, t[0], t[2]), w = xg(d, t[1], t[3]), _ = t[0] - x, M = t[1] - b, A = t[2] - t[0] - v, I = t[3] - t[1] - w;\n      }\n      const S = (n, s, l, u) => {\n        const p = bg(n.stretch - x, v, c, t.left * i),\n          d = wg(n.fixed - _, A, n.stretch, f),\n          y = bg(s.stretch - b, w, h, t.top * i),\n          g = wg(s.fixed - M, I, s.stretch, m),\n          S = bg(l.stretch - x, v, c, t.left * i),\n          P = wg(l.fixed - _, A, l.stretch, f),\n          k = bg(u.stretch - b, w, h, t.top * i),\n          z = wg(u.fixed - M, I, u.stretch, m),\n          E = new wt(p, y),\n          T = new wt(S, y),\n          B = new wt(S, k),\n          V = new wt(p, k),\n          F = new wt(d / a, g / a),\n          C = new wt(P / a, z / a),\n          D = e * Math.PI / 180;\n        if (D) {\n          const t = Math.sin(D),\n            e = Math.cos(D),\n            r = [e, -t, t, e];\n          E._matMult(r), T._matMult(r), V._matMult(r), B._matMult(r);\n        }\n        const R = n.stretch + n.fixed,\n          L = l.stretch + l.fixed,\n          O = s.stretch + s.fixed,\n          U = u.stretch + u.fixed,\n          N = t.imageSecondary;\n        return {\n          tl: E,\n          tr: T,\n          bl: V,\n          br: B,\n          texPrimary: {\n            x: o.paddedRect.x + mg + R,\n            y: o.paddedRect.y + mg + O,\n            w: L - R,\n            h: U - O\n          },\n          texSecondary: N ? {\n            x: N.paddedRect.x + mg + R,\n            y: N.paddedRect.y + mg + O,\n            w: L - R,\n            h: U - O\n          } : void 0,\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: F,\n          pixelOffsetBR: C,\n          minFontScaleX: A / a / c,\n          minFontScaleY: I / a / h,\n          isSDF: r\n        };\n      };\n      if (n && (o.stretchX || o.stretchY)) {\n        const t = vg(p, y, f),\n          e = vg(d, g, m);\n        for (let r = 0; r < t.length - 1; r++) {\n          const n = t[r],\n            i = t[r + 1];\n          for (let t = 0; t < e.length - 1; t++) s.push(S(n, e[t], i, e[t + 1]));\n        }\n      } else s.push(S({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }, {\n        fixed: 0,\n        stretch: u + 1\n      }));\n      return s;\n    }\n    function xg(t, e, r) {\n      let n = 0;\n      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n      return n;\n    }\n    function vg(t, e, r) {\n      const n = [{\n        fixed: -mg,\n        stretch: 0\n      }];\n      for (const [e, r] of t) {\n        const t = n[n.length - 1];\n        n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch\n        }), n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch + (r - e)\n        });\n      }\n      return n.push({\n        fixed: e + mg,\n        stretch: r\n      }), n;\n    }\n    function bg(t, e, r, n) {\n      return t / e * r + n;\n    }\n    function wg(t, e, r, n) {\n      return t - e * r / n;\n    }\n    function _g(t, e, r, n) {\n      const i = e + t.positionedLines[n].lineOffset;\n      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;\n    }\n    function Ag(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      let n = 1 / 0,\n        i = 1 / 0,\n        s = -1 / 0,\n        o = -1 / 0;\n      const a = t[0];\n      for (let t = 0; t < a.length; t++) {\n        const e = a[t];\n        (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > o) && (o = e.y);\n      }\n      const l = Math.min(s - n, o - i);\n      let u = l / 2;\n      const c = new Dn([], Mg);\n      if (0 === l) return new wt(n, i);\n      for (let e = n; e < s; e += l) for (let r = i; r < o; r += l) c.push(new Ig(e + u, r + u, u, t));\n      let h = function (t) {\n          let e = 0,\n            r = 0,\n            n = 0;\n          const i = t[0];\n          for (let t = 0, s = i.length, o = s - 1; t < s; o = t++) {\n            const s = i[t],\n              a = i[o],\n              l = s.x * a.y - a.x * s.y;\n            r += (s.x + a.x) * l, n += (s.y + a.y) * l, e += 3 * l;\n          }\n          return new Ig(r / e, n / e, 0, t);\n        }(t),\n        p = c.length;\n      for (; c.length;) {\n        const n = c.pop();\n        (n.d > h.d || !h.d) && (h = n, r && console.log(\"found best %d after %d probes\", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new Ig(n.p.x - u, n.p.y - u, u, t)), c.push(new Ig(n.p.x + u, n.p.y - u, u, t)), c.push(new Ig(n.p.x - u, n.p.y + u, u, t)), c.push(new Ig(n.p.x + u, n.p.y + u, u, t)), p += 4);\n      }\n      return r && (console.log(\"num probes: \".concat(p)), console.log(\"best distance: \".concat(h.d))), h.p;\n    }\n    function Mg(t, e) {\n      return e.max - t.max;\n    }\n    class Ig {\n      constructor(t, e, r, n) {\n        this.p = new wt(t, e), this.h = r, this.d = function (t, e) {\n          let r = !1,\n            n = 1 / 0;\n          for (let i = 0; i < e.length; i++) {\n            const s = e[i];\n            for (let e = 0, i = s.length, o = i - 1; e < i; o = e++) {\n              const i = s[e],\n                a = s[o];\n              i.y > t.y != a.y > t.y && t.x < (a.x - i.x) * (t.y - i.y) / (a.y - i.y) + i.x && (r = !r), n = Math.min(n, lc(t, i, a));\n            }\n          }\n          return (r ? 1 : -1) * Math.sqrt(n);\n        }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n      }\n    }\n    const Sg = Object.keys,\n      Pg = Number.POSITIVE_INFINITY,\n      kg = Math.sqrt(2);\n    function zg(t, _ref67) {\n      let [e, r] = _ref67;\n      let n = 0,\n        i = 0;\n      if (r === Pg) {\n        e < 0 && (e = 0);\n        const r = e / kg;\n        switch (t) {\n          case \"top-right\":\n          case \"top-left\":\n            i = r - 7;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n            i = 7 - r;\n            break;\n          case \"bottom\":\n            i = 7 - e;\n            break;\n          case \"top\":\n            i = e - 7;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n            n = -r;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n            n = r;\n            break;\n          case \"left\":\n            n = e;\n            break;\n          case \"right\":\n            n = -e;\n        }\n      } else {\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case \"top-right\":\n          case \"top-left\":\n          case \"top\":\n            i = r - 7;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n          case \"bottom\":\n            i = 7 - r;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n          case \"right\":\n            n = -e;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n          case \"left\":\n            n = e;\n        }\n      }\n      return [n, i];\n    }\n    function Eg(t, e, r, n, i, s, o, a, l) {\n      if (!e || !e.usvg) return;\n      const u = Hy(n),\n        c = Hy(i),\n        h = \"both\" !== s && \"width\" !== s || !$y(n) ? 1 : c.width / u.width,\n        p = \"both\" !== s && \"height\" !== s || !Gy(n) ? 1 : c.height / u.height;\n      r.scaleSelf(h, p);\n      const d = r.toString();\n      o.set(d, r), a.set(d, e);\n      const {\n        imagePosition: f\n      } = ag(d, e, sg);\n      l.set(d, f);\n    }\n    function Tg(t, e, r, n, i, s, o, a, l) {\n      if (!t) return;\n      const u = function (t, e, r, n, i, s) {\n        if (\"camera\" === t.kind) return t.maxSize;\n        if (\"composite\" === t.kind) {\n          const n = e.possiblyEvaluate(new wo(t.maxZoom, {\n              worldview: s\n            }), r).evaluate(i, {}, r),\n            o = e.possiblyEvaluate(new wo(t.minZoom, {\n              worldview: s\n            }), r).evaluate(i, {}, r);\n          return Math.max(n, o);\n        }\n        return e.possiblyEvaluate(new wo(n, {\n          worldview: s\n        })).evaluate(i, {}, r);\n      }(e, r, n, i, s, l);\n      return t.scaleSelf(u * a * o);\n    }\n    function Bg(t, e, r, n, i, s, o, a, l) {\n      return {\n        iconPrimary: Tg(t.getPrimary(), e, r, n, i, s, o, a, l),\n        iconSecondary: Tg(t.getSecondary(), e, r, n, i, s, o, a, l)\n      };\n    }\n    function Vg(t, e, r) {\n      if (!e) return;\n      const n = r.get(t.toString()),\n        i = r.get(e.toString());\n      n && i && (n.paddedRect.w === i.paddedRect.w && n.paddedRect.h === i.paddedRect.h || Gt(\"Mismatch in icon variant sizes: \".concat(t.toString(), \" and \").concat(e.toString())), n.usvg !== i.usvg && Gt(\"Mismatch in icon variant image types: \".concat(t.id, \" and \").concat(e.id)));\n    }\n    function Fg(t, e, r, n) {\n      if (!t) return;\n      const i = e.get(r.toString());\n      if (t.imagePrimary = i, n) {\n        const r = e.get(n.toString());\n        t.imageSecondary = r;\n      }\n    }\n    function Cg(t, e) {\n      for (const r in t.horizontal) Dg(t.horizontal[r], e);\n      Dg(t.vertical, e);\n    }\n    function Dg(t, e) {\n      if (t) for (const r of t.positionedLines) for (const t of r.positionedGlyphs) if (null !== t.image) {\n        const r = t.image.toString();\n        t.rect = e.get(r).paddedRect;\n      }\n    }\n    function Rg(t) {\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          return \"right\";\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          return \"left\";\n      }\n      return \"center\";\n    }\n    function Lg(t, e, r, n, i, s, o, a, l) {\n      const u = $g(s.horizontal) || s.vertical,\n        c = r.get(\"icon-text-fit-padding\").evaluate(n, {}, i);\n      let h,\n        p = e;\n      return e && \"none\" !== l && (t.allowVerticalPlacement && s.vertical && (h = jy(e, s.vertical, l, c, a, o)), u && (p = jy(e, u, l, c, a, o))), {\n        defaultShapedIcon: p,\n        verticallyShapedIcon: h\n      };\n    }\n    function Og(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v) {\n      let b = o.textMaxSize.evaluate(e, {}, p);\n      void 0 === b ? b = a * o.textScaleFactor : b *= o.textScaleFactor;\n      const w = t.layers[0].layout,\n        _ = $g(r.horizontal) || r.vertical,\n        A = \"globe\" === d.name,\n        M = ry,\n        I = t.tilePixelRatio * b / M,\n        S = (B = t.overscaling, t.zoom > 18 && B > 2 && (B >>= 1), Math.max(Rn / (512 * B), 1) * w.get(\"symbol-spacing\")),\n        P = w.get(\"text-padding\") * t.tilePixelRatio,\n        k = w.get(\"icon-padding\") * t.tilePixelRatio,\n        z = It(w.get(\"text-max-angle\")),\n        E = \"map\" === w.get(\"icon-rotation-alignment\") && \"point\" !== v,\n        T = S / 2;\n      var B;\n      !1 === t.hasAnyIconTextFit && \"none\" !== y && (t.hasAnyIconTextFit = !0);\n      const V = e.properties ? +e.properties[Bu] : null,\n        F = V && t.elevationFeatureIdToIndex ? t.elevationFeatureIdToIndex.get(V) : 65535,\n        C = (a, l, v) => {\n          if (l.x < 0 || l.x >= Rn || l.y < 0 || l.y >= Rn) return;\n          let b = null;\n          if (A) {\n            const {\n              x: t,\n              y: e,\n              z: r\n            } = d.projectTilePoint(l.x, l.y, v);\n            b = {\n              anchor: new Yy(t, e, r, 0, void 0),\n              up: d.upVector(v, l.x, l.y)\n            };\n          }\n          !function (t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g, x, v, b, w, _, A, M, I, S, P, k) {\n            const z = t.addToLineVertexArray(e, n);\n            let E,\n              T,\n              B,\n              V,\n              F,\n              C,\n              D,\n              R = 0,\n              L = 0,\n              O = 0,\n              U = 0,\n              N = -1,\n              j = -1;\n            const $ = {};\n            let G = We(\"\");\n            const H = r ? r.anchor : e,\n              q = \"none\" !== P;\n            let X = 0,\n              Z = 0;\n            if (void 0 === l._unevaluatedLayout.getValue(\"text-radial-offset\")) {\n              const t = l.layout.get(\"text-offset\").evaluate(b, {}, M);\n              X = t[0] * ry, Z = t[1] * ry;\n            } else X = l.layout.get(\"text-radial-offset\").evaluate(b, {}, M) * ry, Z = Pg;\n            if (t.allowVerticalPlacement && i.vertical) {\n              const t = i.vertical;\n              if (f) C = Hg(t), a && (D = Hg(a));else {\n                const r = l.layout.get(\"text-rotate\").evaluate(b, {}, M) + 90;\n                B = Gg(u, H, e, c, h, p, t, d, r, m), a && (V = Gg(u, H, e, c, h, p, a, g, r));\n              }\n            }\n            if (s) {\n              const n = t.iconSizeData,\n                i = l.layout.get(\"icon-rotate\").evaluate(b, {}, M),\n                o = gg(s, i, _, q, w.iconScaleFactor),\n                d = a ? gg(a, i, _, q, w.iconScaleFactor) : void 0;\n              T = Gg(u, H, e, c, h, p, s, g, i, null), R = 4 * o.length;\n              let f = null;\n              \"source\" === n.kind ? (f = [qy * l.layout.get(\"icon-size\").evaluate(b, {}, M) * w.iconScaleFactor], f[0] > Ng && Gt(\"\".concat(t.layerIds[0], \": Value for \\\"icon-size\\\" is >= \").concat(Ug, \". Reduce your \\\"icon-size\\\".\"))) : \"composite\" === n.kind && (f = [qy * w.compositeIconSizes[0].evaluate(b, {}, M) * w.iconScaleFactor, qy * w.compositeIconSizes[1].evaluate(b, {}, M) * w.iconScaleFactor], (f[0] > Ng || f[1] > Ng) && Gt(\"\".concat(t.layerIds[0], \": Value for \\\"icon-size\\\" is >= \").concat(Ug, \". Reduce your \\\"icon-size\\\".\"))), t.addSymbols(t.icon, o, f, v, x, b, void 0, r, e, z.lineStartIndex, z.lineLength, -1, A, M, I, S), N = t.icon.placedSymbolArray.length - 1, d && (L = 4 * d.length, t.addSymbols(t.icon, d, f, v, x, b, Py.vertical, r, e, z.lineStartIndex, z.lineLength, -1, A, M, I, S), j = t.icon.placedSymbolArray.length - 1);\n            }\n            for (const n in i.horizontal) {\n              const s = n,\n                a = i.horizontal[s];\n              E || (G = We(a.text), f ? F = Hg(a) : E = Gg(u, H, e, c, h, p, a, d, l.layout.get(\"text-rotate\").evaluate(b, {}, M), m));\n              const y = 1 === a.positionedLines.length;\n              if (O += jg(t, r, e, a, o, l, f, b, m, z, i.vertical ? Py.horizontal : Py.horizontalOnly, y ? Sg(i.horizontal) : [s], $, N, w, A, M, I), y) break;\n            }\n            i.vertical && (U += jg(t, r, e, i.vertical, o, l, f, b, m, z, Py.vertical, [\"vertical\"], $, j, w, A, M, I));\n            let W = -1;\n            const Y = (t, e) => t ? Math.max(t, e) : e;\n            W = Y(F, W), W = Y(C, W), W = Y(D, W);\n            const K = W > -1 ? 1 : 0;\n            t.glyphOffsetArray.length >= 65535 && Gt(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, H.x, H.y, H.z, $.right >= 0 ? $.right : -1, $.center >= 0 ? $.center : -1, $.left >= 0 ? $.left : -1, $.vertical >= 0 ? $.vertical : -1, N, j, G, void 0 !== E ? E : t.collisionBoxArray.length, void 0 !== E ? E + 1 : t.collisionBoxArray.length, void 0 !== B ? B : t.collisionBoxArray.length, void 0 !== B ? B + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, V || t.collisionBoxArray.length, V ? V + 1 : t.collisionBoxArray.length, c, O, U, R, L, K, 0, X, Z, W, 0, q ? 1 : 0, k);\n          }(t, l, b, a, r, n, s, i, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, P, x, u, 0, k, E, g, e, o, c, h, p, f, m, y, F);\n        };\n      if (\"line\" === v) for (const i of Sd(e.geometry, 0, 0, Rn, Rn)) {\n        const e = rg(i, S, z, r.vertical || _, n, M, I, t.overscaling, Rn);\n        for (const r of e) _ && qg(t, _.text, T, r) || C(i, r, p);\n      } else if (\"line-center\" === v) {\n        for (const t of e.geometry) if (t.length > 1) {\n          const e = eg(t, z, r.vertical || _, n, M, I);\n          e && C(t, e, p);\n        }\n      } else if (\"Polygon\" === e.type) for (const t of Kh(e.geometry, 0)) {\n        const e = Ag(t, 16);\n        C(t[0], new Yy(e.x, e.y, 0, 0, void 0), p);\n      } else if (\"LineString\" === e.type) for (const t of e.geometry) C(t, new Yy(t[0].x, t[0].y, 0, 0, void 0), p);else if (\"Point\" === e.type) for (const t of e.geometry) for (const e of t) C([e], new Yy(e.x, e.y, 0, 0, void 0), p);\n    }\n    const Ug = 255,\n      Ng = Ug * qy;\n    function jg(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m, y, g) {\n      const x = function (t, e, r, n, i, s, o, a) {\n          const l = [];\n          if (0 === e.positionedLines.length) return l;\n          const u = n.layout.get(\"text-rotate\").evaluate(s, {}) * Math.PI / 180,\n            c = function (t) {\n              const e = t[0],\n                r = t[1],\n                n = e * r;\n              return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];\n            }(r);\n          let h = Math.abs(e.top - e.bottom);\n          for (const t of e.positionedLines) h -= t.lineOffset;\n          const p = e.positionedLines.length,\n            d = h / p;\n          let f = e.top - r[1];\n          for (let t = 0; t < p; ++t) {\n            const n = e.positionedLines[t];\n            f = _g(e, d, f, t);\n            for (const t of n.positionedGlyphs) {\n              if (!t.rect) continue;\n              const n = t.rect || {};\n              let s = Sy + 1,\n                h = !0,\n                p = 1,\n                d = 0;\n              if (t.image) {\n                const e = o.get(t.image.toString());\n                if (!e) continue;\n                if (e.sdf) {\n                  Gt(\"SDF images are not supported in formatted text and will be ignored.\");\n                  continue;\n                }\n                h = !1, p = e.pixelRatio, s = sg / p;\n              }\n              const m = (i || a) && t.vertical,\n                y = t.metrics.advance * t.scale / 2,\n                g = t.metrics,\n                x = t.rect;\n              if (null === x) continue;\n              a && e.verticalizable && (d = t.image ? y - t.metrics.width * t.scale / 2 : 0);\n              const v = i ? [t.x + y, t.y] : [0, 0];\n              let b = [0, 0],\n                w = [0, 0],\n                _ = !1;\n              i || (m ? (w = [t.x + y + c[0], t.y + c[1] - d], _ = !0) : b = [t.x + y + r[0], t.y + r[1] - d]);\n              const A = x.w * t.scale / (p * (t.localGlyph ? pg : 1)),\n                M = x.h * t.scale / (p * (t.localGlyph ? pg : 1));\n              let I, S, P, k;\n              if (m) {\n                const e = t.y - f,\n                  r = new wt(-y, y - e),\n                  n = -Math.PI / 2,\n                  i = new wt(...w);\n                I = new wt(-y + b[0], b[1]), I._rotateAround(n, r)._add(i), I.x += -e + y, I.y -= (g.left - s) * t.scale;\n                const o = t.image ? g.advance * t.scale : ry * t.scale,\n                  a = String.fromCodePoint(t.glyph);\n                sy(a) ? I.x += (1 - s) * t.scale : oy(a) ? I.x += o - g.height * t.scale + (-s - 1) * t.scale : I.x += t.image || g.width + 2 * s === x.w && g.height + 2 * s === x.h ? (o - M) / 2 : (o - (g.height + 2 * s) * t.scale) / 2, S = new wt(I.x, I.y - A), P = new wt(I.x + M, I.y), k = new wt(I.x + M, I.y - A);\n              } else {\n                const e = (g.left - s) * t.scale - y + b[0],\n                  r = (-g.top - s) * t.scale + b[1],\n                  n = e + A,\n                  i = r + M;\n                I = new wt(e, r), S = new wt(n, r), P = new wt(e, i), k = new wt(n, i);\n              }\n              if (u) {\n                let t;\n                t = i ? new wt(0, 0) : _ ? new wt(c[0], c[1]) : new wt(r[0], r[1]), I._rotateAround(u, t), S._rotateAround(u, t), P._rotateAround(u, t), k._rotateAround(u, t);\n              }\n              const z = new wt(0, 0),\n                E = new wt(0, 0);\n              l.push({\n                tl: I,\n                tr: S,\n                bl: P,\n                br: k,\n                texPrimary: n,\n                texSecondary: void 0,\n                writingMode: e.writingMode,\n                glyphOffset: v,\n                sectionIndex: t.sectionIndex,\n                isSDF: h,\n                pixelOffsetTL: z,\n                pixelOffsetBR: E,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n          return l;\n        }(0, n, l, s, o, a, i, t.allowVerticalPlacement),\n        v = t.textSizeData;\n      let b = null;\n      \"source\" === v.kind ? (b = [qy * s.layout.get(\"text-size\").evaluate(a, {}, y) * f.textScaleFactor], b[0] > Ng && Gt(\"\".concat(t.layerIds[0], \": Value for \\\"text-size\\\" is >= \").concat(Ug, \". Reduce your \\\"text-size\\\".\"))) : \"composite\" === v.kind && (b = [qy * f.compositeTextSizes[0].evaluate(a, {}, y) * f.textScaleFactor, qy * f.compositeTextSizes[1].evaluate(a, {}, y) * f.textScaleFactor], (b[0] > Ng || b[1] > Ng) && Gt(\"\".concat(t.layerIds[0], \": Value for \\\"text-size\\\" is >= \").concat(Ug, \". Reduce your \\\"text-size\\\".\"))), t.addSymbols(t.text, x, b, l, o, a, c, e, r, u.lineStartIndex, u.lineLength, d, m, y, g, !1);\n      for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;\n      return 4 * x.length;\n    }\n    function $g(t) {\n      for (const e in t) return t[e];\n      return null;\n    }\n    function Gg(t, e, r, n, i, s, o, a, l, u) {\n      let c = o.top,\n        h = o.bottom,\n        p = o.left,\n        d = o.right;\n      if (Uy(o) && o.collisionPadding) {\n        const t = o.collisionPadding;\n        p -= t[0], c -= t[1], d += t[2], h += t[3];\n      }\n      if (l) {\n        const t = new wt(p, c),\n          e = new wt(d, c),\n          r = new wt(p, h),\n          n = new wt(d, h),\n          i = It(l);\n        let s = new wt(0, 0);\n        u && (s = new wt(u[0], u[1])), t._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t.x, e.x, r.x, n.x), d = Math.max(t.x, e.x, r.x, n.x), c = Math.min(t.y, e.y, r.y, n.y), h = Math.max(t.y, e.y, r.y, n.y);\n      }\n      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, d, h, a, n, i, s), t.length - 1;\n    }\n    function Hg(t) {\n      Uy(t) && t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);\n      const e = t.bottom - t.top;\n      return e > 0 ? Math.max(10, e) : null;\n    }\n    function qg(t, e, r, n) {\n      const i = t.compareText;\n      if (e in i) {\n        const t = i[e];\n        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n      } else i[e] = [];\n      return i[e].push(n), !1;\n    }\n    function Xg(t, e) {\n      const r = t.fovAboveCenter,\n        n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,\n        i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),\n        s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01));\n      let o = Math.sin(t._pitch) * s + i;\n      const a = i * (1 / t._horizonShift);\n      if (!t.elevation || 0 === t.elevation.exaggeration()) {\n        let e = Math.max(t.zoom - 17, 0);\n        t.isOrthographic && (e /= 10), o *= 1 + e;\n      }\n      return Math.min(1.01 * o, a);\n    }\n    function Zg(t, e) {\n      if (!e.isReprojectedInTileSpace) return {\n        scale: 1 << t.z,\n        x: t.x,\n        y: t.y,\n        x2: t.x + 1,\n        y2: t.y + 1,\n        projection: e\n      };\n      const r = Math.pow(2, -t.z),\n        n = t.x * r,\n        i = (t.x + 1) * r,\n        s = t.y * r,\n        o = (t.y + 1) * r,\n        a = au(n),\n        l = au(i),\n        u = lu(s),\n        c = lu(o),\n        h = e.project(a, u),\n        p = e.project(l, u),\n        d = e.project(l, c),\n        f = e.project(a, c);\n      let m = Math.min(h.x, p.x, d.x, f.x),\n        y = Math.min(h.y, p.y, d.y, f.y),\n        g = Math.max(h.x, p.x, d.x, f.x),\n        x = Math.max(h.y, p.y, d.y, f.y);\n      const v = r / 16;\n      function b(t, r, n, i, s, o) {\n        const a = (n + s) / 2,\n          l = (i + o) / 2,\n          u = e.project(au(a), lu(l)),\n          c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);\n        m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, a, l), b(u, r, a, l, s, o));\n      }\n      b(h, p, n, s, i, s), b(p, d, i, s, i, o), b(d, f, i, o, n, o), b(f, h, n, o, n, s), m -= v, y -= v, g += v, x += v;\n      const w = 1 / Math.max(g - m, x - y);\n      return {\n        scale: w,\n        x: m * w,\n        y: y * w,\n        x2: g * w,\n        y2: x * w,\n        projection: e\n      };\n    }\n    function Wg(t, _ref68) {\n      let {\n        x: e,\n        y: r\n      } = _ref68;\n      let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return new wt(((e - n) * t.scale - t.x) * Rn, (r * t.scale - t.y) * Rn);\n    }\n    const Yg = l(new Float32Array(16));\n    class Kg {\n      constructor(t) {\n        this.spec = t, this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = \"meters\", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [\"custom\"], this.center = [0, 0], this.range = [3.5, 7];\n      }\n      project(t, e) {\n        return {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        return new Ql(0, 0);\n      }\n      projectTilePoint(t, e, r) {\n        return {\n          x: t,\n          y: e,\n          z: 0\n        };\n      }\n      locationPoint(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n        return t._coordinatePoint(t.locationCoordinate(e, r), n);\n      }\n      pixelsPerMeter(t, e) {\n        return ou(1, t) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        return 1;\n      }\n      farthestPixelDistance(t) {\n        return Xg(t, t.pixelsPerMeter);\n      }\n      pointCoordinate(t, e, r, n) {\n        const i = t.horizonLineFromTop(!1),\n          s = new wt(e, Math.max(i, r));\n        return t.rayIntersectionCoordinate(t.pointRayIntersection(s, n));\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = new wt(e, r);\n        if (t.elevation) return t.elevation.pointCoordinate(n);\n        {\n          const e = this.pointCoordinate(t, n.x, n.y, 0);\n          return [e.x, e.y, e.z];\n        }\n      }\n      isPointAboveHorizon(t, e) {\n        if (t.elevation && t.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t, e.x, e.y);\n        const r = t.horizonLineFromTop();\n        return e.y < r;\n      }\n      createInversionMatrix(t, e) {\n        return Yg;\n      }\n      createTileMatrix(t, e, r) {\n        let n, i, s;\n        const o = r.canonical,\n          a = l(new Float64Array(16));\n        if (this.isReprojectedInTileSpace) {\n          const l = Zg(o, this);\n          n = 1, i = l.x + r.wrap * l.scale, s = l.y, p(a, a, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);\n        } else n = e / t.zoomScale(o.z), i = (o.x + Math.pow(2, o.z) * r.wrap) * n, s = o.y * n;\n        return h(a, a, [i, s, 0]), p(a, a, [n / Rn, n / Rn, 1]), a;\n      }\n      upVector(t, e, r) {\n        return [0, 0, 1];\n      }\n      upVectorScale(t, e, r) {\n        return {\n          metersToTile: 1\n        };\n      }\n    }\n    class Jg extends Kg {\n      constructor(t) {\n        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];\n        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],\n          n = Math.sin(It(e));\n        this.n = (n + Math.sin(It(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;\n      }\n      project(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          s = It(t - this.center[0]),\n          o = It(e),\n          a = Math.sqrt(n - 2 * r * Math.sin(o)) / r;\n        return {\n          x: a * Math.sin(s * r),\n          y: a * Math.cos(s * r) - i,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          s = i + e;\n        let o = Math.atan2(t, Math.abs(s)) * Math.sign(s);\n        s * r < 0 && (o -= Math.PI * Math.sign(t) * Math.sign(s));\n        const a = It(this.center[0]) * r;\n        o = Vt(o, -Math.PI - a, Math.PI - a);\n        const l = Tt(St(o / r) + this.center[0], -180, 180),\n          u = Math.asin(Tt((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),\n          c = Tt(St(u), -cu, cu);\n        return new Ql(l, c);\n      }\n    }\n    const Qg = 1.340264,\n      tx = -.081106,\n      ex = 893e-6,\n      rx = .003796,\n      nx = Math.sqrt(3) / 2;\n    class ix extends Kg {\n      project(t, e) {\n        e = e / 180 * Math.PI, t = t / 180 * Math.PI;\n        const r = Math.asin(nx * Math.sin(e)),\n          n = r * r,\n          i = n * n * n;\n        return {\n          x: .5 * (t * Math.cos(r) / (nx * (Qg + 3 * tx * n + i * (7 * ex + 9 * rx * n))) / Math.PI + .5),\n          y: 1 - .5 * (r * (Qg + tx * n + i * (ex + rx * n)) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = r * r,\n          i = n * n * n;\n        for (let t, s, o, a = 0; a < 12 && (s = r * (Qg + tx * n + i * (ex + rx * n)) - e, o = Qg + 3 * tx * n + i * (7 * ex + 9 * rx * n), t = s / o, r = Tt(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++a);\n        const s = nx * t * (Qg + 3 * tx * n + i * (7 * ex + 9 * rx * n)) / Math.cos(r),\n          o = Math.asin(Math.sin(r) / nx),\n          a = Tt(180 * s / Math.PI, -180, 180),\n          l = Tt(180 * o / Math.PI, -cu, cu);\n        return new Ql(a, l);\n      }\n    }\n    class sx extends Kg {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        return {\n          x: .5 + t / 360,\n          y: .5 - e / 360,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = 360 * (t - .5),\n          n = Tt(360 * (.5 - e), -cu, cu);\n        return new Ql(r, n);\n      }\n    }\n    const ox = Math.PI / 2;\n    function ax(t) {\n      return Math.tan((ox + t) / 2);\n    }\n    class lx extends Kg {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 30];\n        const [e, r] = this.parallels = t.parallels || [30, 30];\n        let n = It(e),\n          i = It(r);\n        this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);\n        const s = Math.cos(n),\n          o = ax(n);\n        this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(ax(i) / o), this.f = s * Math.pow(ax(n), this.n) / this.n;\n      }\n      project(t, e) {\n        e = It(e), this.southernCenter && (e = -e), t = It(t - this.center[0]);\n        const r = 1e-6,\n          {\n            n,\n            f: i\n          } = this;\n        i > 0 ? e < -ox + r && (e = -ox + r) : e > ox - r && (e = ox - r);\n        const s = i / Math.pow(ax(e), n);\n        let o = s * Math.sin(n * t),\n          a = i - s * Math.cos(n * t);\n        return o = .5 * (o / Math.PI + .5), a = .5 * (a / Math.PI + .5), {\n          x: o,\n          y: this.southernCenter ? a : 1 - a,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;\n        const {\n            n: r,\n            f: n\n          } = this,\n          i = n - e,\n          s = Math.sign(i),\n          o = Math.sign(r) * Math.sqrt(t * t + i * i);\n        let a = Math.atan2(t, Math.abs(i)) * s;\n        i * r < 0 && (a -= Math.PI * Math.sign(t) * s);\n        const l = Tt(St(a / r) + this.center[0], -180, 180),\n          u = Tt(St(2 * Math.atan(Math.pow(n / o, 1 / r)) - ox), -cu, cu);\n        return new Ql(l, this.southernCenter ? -u : u);\n      }\n    }\n    class ux extends Kg {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;\n      }\n      project(t, e) {\n        return {\n          x: iu(t),\n          y: su(e),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = au(t),\n          n = lu(e);\n        return new Ql(r, n);\n      }\n    }\n    const cx = It(cu);\n    class hx extends Kg {\n      project(t, e) {\n        const r = (e = It(e)) * e,\n          n = r * r;\n        return {\n          x: .5 * ((t = It(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),\n          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = 25,\n          i = 0,\n          s = r * r;\n        do {\n          s = r * r;\n          const t = s * s;\n          i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = Tt(r - i, -cx, cx);\n        } while (Math.abs(i) > 1e-6 && --n > 0);\n        s = r * r;\n        const o = Tt(St(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),\n          a = St(r);\n        return new Ql(o, a);\n      }\n    }\n    const px = It(cu);\n    class dx extends Kg {\n      project(t, e) {\n        e = It(e), t = It(t);\n        const r = Math.cos(e),\n          n = 2 / Math.PI,\n          i = Math.acos(r * Math.cos(t / 2)),\n          s = Math.sin(i) / i,\n          o = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,\n          a = .5 * (e + Math.sin(e) / s) || 0;\n        return {\n          x: .5 * (o / Math.PI + .5),\n          y: 1 - .5 * (a / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        let r = t = (2 * t - .5) * Math.PI,\n          n = e = (2 * (1 - e) - 1) * Math.PI,\n          i = 25;\n        const s = 1e-6;\n        let o = 0,\n          a = 0;\n        do {\n          const i = Math.cos(n),\n            s = Math.sin(n),\n            l = 2 * s * i,\n            u = s * s,\n            c = i * i,\n            h = Math.cos(r / 2),\n            p = Math.sin(r / 2),\n            d = 2 * h * p,\n            f = p * p,\n            m = 1 - c * h * h,\n            y = m ? 1 / m : 0,\n            g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0,\n            x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t,\n            v = .5 * (g * s + n) - e,\n            b = .5 * y * (c * f + g * i * h * u) + 1 / Math.PI,\n            w = y * (d * l / 4 - g * s * p),\n            _ = .125 * y * (l * p - g * s * c * d),\n            A = .5 * y * (u * h + g * f * i) + .5,\n            M = w * _ - A * b;\n          o = (v * w - x * A) / M, a = (x * _ - v * b) / M, r = Tt(r - o, -Math.PI, Math.PI), n = Tt(n - a, -px, px);\n        } while ((Math.abs(o) > s || Math.abs(a) > s) && --i > 0);\n        return new Ql(St(r), St(n));\n      }\n    }\n    class fx extends Kg {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(It(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        const {\n          scale: r,\n          cosPhi: n\n        } = this;\n        return {\n          x: It(t) * n * r + .5,\n          y: -Math.sin(It(e)) / n * r + .5,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            scale: r,\n            cosPhi: n\n          } = this,\n          i = -(e - .5) / r,\n          s = Tt(St((t - .5) / r) / n, -180, 180),\n          o = Math.asin(Tt(i * n, -1, 1)),\n          a = Tt(St(o), -cu, cu);\n        return new Ql(s, a);\n      }\n    }\n    class mx extends ux {\n      constructor(t) {\n        super(t), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = \"pixels\", this.unsupportedLayers = [\"debug\"], this.range = [3, 5];\n      }\n      projectTilePoint(t, e, r) {\n        const n = jc(t, e, r);\n        return O(n, n, Hc(Dc(r))), {\n          x: n[0],\n          y: n[1],\n          z: n[2]\n        };\n      }\n      locationPoint(t, e, r) {\n        const n = Yl(e.lat, e.lng),\n          i = C([], n),\n          s = r ? t._centerAltitude + r : t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;\n        T(n, n, i, ou(1, 0) * Rn * s);\n        const o = l(new Float64Array(16));\n        return c(o, t.pixelMatrix, t.globeMatrix), O(n, n, o), new wt(n[0], n[1]);\n      }\n      pixelsPerMeter(t, e) {\n        return ou(1, 0) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        const n = ou(1, t) * e,\n          i = ur(ou(1, 45) * e, n, r);\n        return this.pixelsPerMeter(t, e) / i;\n      }\n      createTileMatrix(t, e, r) {\n        const n = qc(Dc(r.canonical));\n        return c(new Float64Array(16), t.globeMatrix, n);\n      }\n      createInversionMatrix(t, e) {\n        const {\n            center: r\n          } = t,\n          n = Hc(Dc(e));\n        return f(n, n, It(r.lng)), d(n, n, It(r.lat)), p(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]), Float32Array.from(n);\n      }\n      pointCoordinate(t, e, r, n) {\n        return Vc(t, e, r, !0) || new mu(0, 0);\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = this.pointCoordinate(t, e, r, 0);\n        return [n.x, n.y, n.z];\n      }\n      isPointAboveHorizon(t, e) {\n        return !Vc(t, e.x, e.y, !1);\n      }\n      farthestPixelDistance(t) {\n        const e = function (t, e) {\n            const r = t.cameraToCenterDistance,\n              n = t._centerAltitude * e,\n              i = t._camera,\n              s = t._camera.forward(),\n              o = I([], E([], s, -r), [0, 0, n]),\n              a = t.worldSize / (2 * Math.PI),\n              l = [0, 0, -a],\n              u = t.width / t.height,\n              c = Math.tan(t.fovAboveCenter),\n              h = E([], i.up(), c),\n              p = E([], i.right(), c * u),\n              d = C([], I([], I([], s, h), p)),\n              f = [];\n            let m;\n            if (new Uu(o, d).closestPointOnSphere(l, a, f)) {\n              const e = I([], f, l),\n                r = G([], e, o);\n              m = Math.cos(t.fovAboveCenter) * _(r);\n            } else {\n              const t = G([], o, l),\n                e = G([], l, o);\n              C(e, e);\n              const r = _(t) - a;\n              m = Math.sqrt(r * (r + 2 * a));\n              const n = Math.acos(m / (a + r)) - Math.acos(D(s, e));\n              m *= Math.cos(n);\n            }\n            return 1.01 * m;\n          }(t, this.pixelsPerMeter(t.center.lat, t.worldSize)),\n          r = Yc(t.zoom);\n        if (r > 0) {\n          const n = Xg(t, ou(1, t.center.lat) * t.worldSize),\n            i = t.worldSize / (2 * Math.PI),\n            s = Math.max(t.width, t.height) / t.worldSize * Math.PI;\n          return ur(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));\n        }\n        return e;\n      }\n      upVector(t, e, r) {\n        return jc(e, r, t, 1);\n      }\n      upVectorScale(t) {\n        return {\n          metersToTile: Tc($c(Dc(t)))\n        };\n      }\n    }\n    function yx(t) {\n      const e = t.parallels,\n        r = !!e && Math.abs(e[0] + e[1]) < .01;\n      switch (t.name) {\n        case \"mercator\":\n          return new ux(t);\n        case \"equirectangular\":\n          return new sx(t);\n        case \"naturalEarth\":\n          return new hx(t);\n        case \"equalEarth\":\n          return new ix(t);\n        case \"winkelTripel\":\n          return new dx(t);\n        case \"albers\":\n          return r ? new fx(t) : new Jg(t);\n        case \"lambertConformalConic\":\n          return r ? new fx(t) : new lx(t);\n        case \"globe\":\n          return new mx(t);\n      }\n      throw new Error(\"Invalid projection name: \".concat(t.name));\n    }\n    const gx = Iu.types,\n      xx = [{\n        name: \"a_fade_opacity\",\n        components: 1,\n        type: \"Uint8\",\n        offset: 0\n      }];\n    function vx(t, e, r, n, i, s, o, a, l, u, c, h, p) {\n      const d = a ? Math.min(Ng, Math.round(a[0])) : 0,\n        f = a ? Math.min(Ng, Math.round(a[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, o, (d << 1) + (l ? 1 : 0), f, 16 * u, 16 * c, 256 * h, 256 * p);\n    }\n    function bx(t, e, r) {\n      t.emplaceBack(e, r);\n    }\n    function wx(t, e, r, n, i, s, o) {\n      t.emplaceBack(e, r, n, i, s, o);\n    }\n    const _x = (t, e, r, n) => {\n      for (let i = 0; i < e; i++) t.emplaceBack(r[0], r[1], r[2], n[0], n[1], n[2]);\n    };\n    function Ax(t, e, r, n, i) {\n      t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i);\n    }\n    function Mx(t) {\n      for (const e of t.sections) if (uo(e.text)) return !0;\n      return !1;\n    }\n    class Ix {\n      constructor(t) {\n        this.layoutVertexArray = new wa(), this.indexArray = new Ea(), this.programConfigurations = t, this.segments = new al(), this.dynamicLayoutVertexArray = new Aa(), this.opacityVertexArray = new Ma(), this.placedSymbolArray = new Za(), this.iconTransitioningVertexArray = new Ia(), this.globeExtVertexArray = new _a(), this.zOffsetVertexArray = new pa(), this.orientationVertexArray = new Va();\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;\n      }\n      upload(t, e, r, n, i) {\n        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, qm.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Zm.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, xx, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t.createVertexBuffer(this.iconTransitioningVertexArray, Km.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Xm.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t.createVertexBuffer(this.zOffsetVertexArray, Wm.members, !0)), !this.orientationVertexBuffer && this.orientationVertexArray && this.orientationVertexArray.length > 0 && (this.orientationVertexBuffer = t.createVertexBuffer(this.orientationVertexArray, Ym.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.orientationVertexBuffer && this.orientationVertexBuffer.destroy());\n      }\n    }\n    Ws(Ix, \"SymbolBuffers\");\n    class Sx {\n      constructor(t, e, r) {\n        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new al(), this.collisionVertexArray = new za(), this.collisionVertexArrayExt = new Aa();\n      }\n      upload(t) {\n        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Jm.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Qm.members, !0);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());\n      }\n    }\n    Ws(Sx, \"CollisionBuffers\");\n    class Px {\n      constructor(t) {\n        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = l([]), this.placementViewportMatrix = l([]);\n        const e = this.layers[0]._unevaluatedLayout._values;\n        this.worldview = t.worldview, this.textSizeData = Xy(this.zoom, e[\"text-size\"], this.worldview), this.iconSizeData = Xy(this.zoom, e[\"icon-size\"], this.worldview);\n        const r = this.layers[0].layout,\n          n = r.get(\"symbol-sort-key\"),\n          i = r.get(\"symbol-z-order\");\n        this.lut = t.lut, this.canOverlap = r.get(\"text-allow-overlap\") || r.get(\"icon-allow-overlap\") || r.get(\"text-ignore-placement\") || r.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = (\"viewport-y\" === i || \"auto\" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get(\"text-writing-mode\").map(t => Py[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = \"none\", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.hasAnySecondaryIcon = !1;\n      }\n      createArrays() {\n        this.text = new Ix(new Cl(this.layers, {\n          zoom: this.zoom,\n          lut: this.lut\n        }, t => t.startsWith(\"text\") || t.startsWith(\"symbol\"))), this.icon = new Ix(new Cl(this.layers, {\n          zoom: this.zoom,\n          lut: this.lut\n        }, t => t.startsWith(\"icon\") || t.startsWith(\"symbol\"))), this.glyphOffsetArray = new Ka(), this.lineVertexArray = new Ja(), this.symbolInstances = new Ya();\n      }\n      calculateGlyphDependencies(t, e, r, n, i) {\n        for (const r of t) {\n          const t = r.codePointAt(0);\n          if (void 0 === t) break;\n          if (e[t] = !0, n && i && t <= 65535) {\n            const t = iy[r];\n            t && (e[t.charCodeAt(0)] = !0);\n          }\n        }\n      }\n      updateFootprints(t, e) {}\n      updateReplacement(t, e) {\n        if (e.updateTime === this.replacementUpdateTime) return !1;\n        this.replacementUpdateTime = e.updateTime;\n        const r = e.getReplacementRegionsForTile(t.toUnwrapped(), !0);\n        return !Dp(this.activeReplacements, r) && (this.activeReplacements = r, !0);\n      }\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          s = i.layout,\n          o = \"globe\" === this.projection.name,\n          a = s.get(\"text-font\"),\n          l = s.get(\"text-field\"),\n          u = s.get(\"icon-image\"),\n          [c, h] = s.get(\"icon-size-scale-range\"),\n          p = Tt(e.scaleFactor || 1, c, h),\n          d = (\"constant\" !== l.value.kind || l.value.value instanceof Vr && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && (\"constant\" !== a.value.kind || a.value.value.length > 0),\n          f = \"constant\" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0,\n          m = s.get(\"symbol-sort-key\");\n        if (this.features = [], !d && !f) return;\n        const y = e.iconDependencies,\n          g = e.glyphDependencies,\n          x = e.availableImages,\n          v = new wo(this.zoom, {\n            worldview: this.worldview\n          });\n        for (const {\n          feature: e,\n          id: l,\n          index: u,\n          sourceLayerIndex: c\n        } of t) {\n          const t = i._featureFilter.needGeometry,\n            h = Mu(e, t);\n          if (!i._featureFilter.filter(v, h, r)) continue;\n          if (t || (h.geometry = Au(e, r, n)), o && 1 !== e.type && r.z <= 5) {\n            const t = h.geometry,\n              e = .98078528056,\n              n = (t, n) => D(jc(t.x, t.y, r, 1), jc(n.x, n.y, r, 1)) < e;\n            for (let e = 0; e < t.length; e++) t[e] = vu(t[e], n);\n          }\n          let b, w;\n          if (d) {\n            const t = i.getValueAndResolveTokens(\"text-field\", h, r, x),\n              e = Vr.factory(t);\n            Mx(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === xo() || this.hasRTLText && bo.isParsed()) && (b = ny(e, i, h));\n          }\n          if (f) {\n            const t = i.getValueAndResolveTokens(\"icon-image\", h, r, x);\n            w = \"string\" == typeof t ? Cr.build(t) : t;\n          }\n          if (!b && !w) continue;\n          const _ = this.sortFeaturesByKey ? m.evaluate(h, {}, r) : void 0,\n            A = {\n              id: l,\n              text: b,\n              icon: w,\n              index: u,\n              sourceLayerIndex: c,\n              geometry: h.geometry,\n              properties: e.properties,\n              type: gx[e.type],\n              sortKey: _\n            };\n          if (this.features.push(A), w) {\n            const t = this.layers[0]._unevaluatedLayout._values,\n              {\n                iconPrimary: e,\n                iconSecondary: n\n              } = Bg(w, this.iconSizeData, t[\"icon-size\"], r, this.zoom, A, this.pixelRatio, p, this.worldview),\n              i = e.id.toString();\n            if (y.has(i) ? y.get(i).push(e) : y.set(i, [e]), n) {\n              this.hasAnySecondaryIcon = !0;\n              const t = n.id.toString();\n              y.has(t) ? y.get(t).push(n) : y.set(t, [n]);\n            }\n          }\n          if (b) {\n            const t = a.evaluate(h, {}, r).join(\",\"),\n              e = \"map\" === s.get(\"text-rotation-alignment\") && \"point\" !== s.get(\"symbol-placement\");\n            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Py.vertical) >= 0;\n            for (const r of b.sections) if (r.image) {\n              const t = r.image.getPrimary().scaleSelf(this.pixelRatio),\n                e = t.id.toString(),\n                n = y.get(e) || [];\n              n.push(t), y.set(e, n);\n            } else {\n              const n = eo(b.toString()),\n                i = r.fontStack || t,\n                s = g[i] = g[i] || {};\n              this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);\n            }\n          }\n        }\n        if (\"line\" === s.get(\"symbol-placement\") && (this.features = function (t) {\n          const e = {},\n            r = {},\n            n = [];\n          let i = 0;\n          function s(e) {\n            n.push(t[e]), i++;\n          }\n          function o(t, e, i) {\n            const s = r[t];\n            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;\n          }\n          function a(t, r, i) {\n            const s = e[r];\n            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;\n          }\n          function l(t, e, r) {\n            const n = r ? e[0][e[0].length - 1] : e[0][0];\n            return \"\".concat(t, \":\").concat(n.x, \":\").concat(n.y);\n          }\n          for (let u = 0; u < t.length; u++) {\n            const c = t[u],\n              h = c.geometry,\n              p = c.text ? c.text.toString() : null;\n            if (!p) {\n              s(u);\n              continue;\n            }\n            const d = l(p, h),\n              f = l(p, h, !0);\n            if (d in r && f in e && r[d] !== e[f]) {\n              const t = a(d, f, h),\n                i = o(d, f, n[t].geometry);\n              delete e[d], delete r[f], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n            } else d in r ? o(d, f, h) : f in e ? a(d, f, h) : (s(u), e[d] = i - 1, r[f] = i - 1);\n          }\n          return n.filter(t => t.geometry);\n        }(this.features)), \"hd-road-markup\" === s.get(\"symbol-elevation-reference\")) {\n          if (this.elevationType = \"road\", e.elevationFeatures) {\n            !this.elevationFeatures && e.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = new Map());\n            for (const t of e.elevationFeatures) this.elevationFeatureIdToIndex.set(t.id, this.elevationFeatures.length), this.elevationFeatures.push(t);\n          }\n        } else s.get(\"symbol-z-elevate\") && (this.elevationType = \"offset\");\n        \"none\" !== this.elevationType && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n      }\n      update(t, e, r, n, i, s, o) {\n        this.text.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o, this.worldview), this.icon.programConfigurations.updatePaintArrays(t, e, i, r, n, s, o, this.worldview);\n      }\n      updateRoadElevation(t) {\n        if (\"road\" !== this.elevationType || !this.elevationFeatures) return;\n        if (this.elevationStateComplete) return;\n        this.elevationStateComplete = !0, this.hasAnyZOffset = !1;\n        let e = !1;\n        const r = fu(t),\n          n = 1 / r;\n        let i = !1,\n          s = !1;\n        for (let t = 0; t < this.symbolInstances.length; t++) {\n          const o = this.symbolInstances.get(t),\n            a = A(1, 0, 0),\n            l = A(0, 1, 0),\n            {\n              numHorizontalGlyphVertices: u,\n              numVerticalGlyphVertices: c,\n              numIconVertices: h,\n              numVerticalIconVertices: p\n            } = o,\n            d = u > 0 || c > 0,\n            f = h > 0,\n            m = this.elevationFeatures[o.elevationFeatureIndex];\n          if (m) {\n            const t = new wt(o.tileAnchorX, o.tileAnchorY),\n              u = .075 + m.pointElevation(t);\n            o.zOffset !== u && (e = !0, o.zOffset = u);\n            const c = m.computeSlopeNormal(t, n),\n              h = st(K(), A(0, 0, 1), c);\n            N(a, a, h), N(l, l, h), a[2] *= r, l[2] *= r, 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === l[0] && 1 === l[1] && 0 === l[2] || (i = i || d, s = s || f);\n          }\n          if (d && (_x(this.text.orientationVertexArray, u, a, l), _x(this.text.orientationVertexArray, c, a, l)), f) {\n            const {\n              placedIconSymbolIndex: t,\n              verticalPlacedIconSymbolIndex: e\n            } = o;\n            t >= 0 && _x(this.icon.orientationVertexArray, h, a, l), e >= 0 && _x(this.icon.orientationVertexArray, p, a, l);\n          }\n        }\n        i || (this.text.orientationVertexArray = void 0), s || (this.icon.orientationVertexArray = void 0), e && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0);\n      }\n      updateZOffset() {\n        const t = (t, e, n) => {\n            r += e, r > t.length && t.resize(r);\n            for (let i = -e; i < 0; i++) t.emplace(i + r, n);\n          },\n          e = (t, e, r) => {\n            n += e, n > t.length && t.resize(n);\n            for (let i = -e; i < 0; i++) t.emplace(i + n, r);\n          };\n        if (!this.zOffsetBuffersNeedUpload) return;\n        this.zOffsetBuffersNeedUpload = !1;\n        let r = 0,\n          n = 0;\n        for (let r = 0; r < this.symbolInstances.length; r++) {\n          const n = this.symbolInstances.get(r),\n            {\n              numHorizontalGlyphVertices: i,\n              numVerticalGlyphVertices: s,\n              numIconVertices: o\n            } = n,\n            a = n.zOffset,\n            l = o > 0;\n          if ((i > 0 || s > 0) && (t(this.text.zOffsetVertexArray, i, a), t(this.text.zOffsetVertexArray, s, a)), l) {\n            const {\n              placedIconSymbolIndex: t,\n              verticalPlacedIconSymbolIndex: r\n            } = n;\n            t >= 0 && e(this.icon.zOffsetVertexArray, o, a), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, a);\n          }\n        }\n        this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);\n      }\n      isEmpty() {\n        return 0 === this.symbolInstances.length && !this.hasRTLText;\n      }\n      uploadPending() {\n        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;\n      }\n      destroyDebugData() {\n        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n      }\n      getProjection() {\n        return this.projectionInstance || (this.projectionInstance = yx(this.projection)), this.projectionInstance;\n      }\n      destroy() {\n        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n      }\n      addToLineVertexArray(t, e) {\n        const r = this.lineVertexArray.length;\n        if (void 0 !== t.segment) for (const {\n          x: t,\n          y: r\n        } of e) this.lineVertexArray.emplaceBack(t, r);\n        return {\n          lineStartIndex: r,\n          lineLength: this.lineVertexArray.length - r\n        };\n      }\n      addSymbols(t, e, r, n, i, s, o, a, l, u, c, h, p, d, f, m) {\n        const y = t.indexArray,\n          g = t.layoutVertexArray,\n          x = t.globeExtVertexArray,\n          v = t.segments.prepareSegment(4 * e.length, g, y, this.canOverlap ? s.sortKey : void 0),\n          b = this.glyphOffsetArray.length,\n          w = v.vertexLength,\n          _ = this.allowVerticalPlacement && o === Py.vertical ? Math.PI / 2 : 0,\n          A = s.text && s.text.sections;\n        for (let n = 0; n < e.length; n++) {\n          const {\n              tl: i,\n              tr: o,\n              bl: u,\n              br: c,\n              texPrimary: h,\n              texSecondary: b,\n              pixelOffsetTL: w,\n              pixelOffsetBR: M,\n              minFontScaleX: I,\n              minFontScaleY: S,\n              glyphOffset: P,\n              isSDF: k,\n              sectionIndex: z\n            } = e[n],\n            E = v.vertexLength,\n            T = P[1];\n          if (vx(g, l.x, l.y, i.x, T + i.y, h.x, h.y, r, k, w.x, w.y, I, S), vx(g, l.x, l.y, o.x, T + o.y, h.x + h.w, h.y, r, k, M.x, w.y, I, S), vx(g, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, k, w.x, M.y, I, S), vx(g, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, k, M.x, M.y, I, S), a) {\n            const {\n                x: e,\n                y: r,\n                z: n\n              } = a.anchor,\n              [i, s, o] = a.up;\n            wx(x, e, r, n, i, s, o), wx(x, e, r, n, i, s, o), wx(x, e, r, n, i, s, o), wx(x, e, r, n, i, s, o), Ax(t.dynamicLayoutVertexArray, e, r, n, _);\n          } else Ax(t.dynamicLayoutVertexArray, l.x, l.y, l.z, _);\n          if (m) {\n            const e = b || h;\n            bx(t.iconTransitioningVertexArray, e.x, e.y), bx(t.iconTransitioningVertexArray, e.x + e.w, e.y), bx(t.iconTransitioningVertexArray, e.x, e.y + e.h), bx(t.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);\n          }\n          y.emplaceBack(E, E + 1, E + 2), y.emplaceBack(E + 1, E + 2, E + 3), v.vertexLength += 4, v.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), n !== e.length - 1 && z === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(g.length, s, s.index, {}, p, d, f, A && A[z], this.worldview);\n        }\n        const M = a ? a.anchor : l;\n        t.placedSymbolArray.emplaceBack(M.x, M.y, M.z, l.x, l.y, b, this.glyphOffsetArray.length - b, w, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], o, 0, 0, 0, h, 0);\n      }\n      _commitLayoutVertex(t, e, r, n, i, s, o) {\n        t.emplaceBack(e, r, n, i, s, Math.round(o.x), Math.round(o.y));\n      }\n      _addCollisionDebugVertices(t, e, r, n, i, s, o) {\n        const a = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),\n          l = a.vertexLength,\n          u = o.tileAnchorX,\n          c = o.tileAnchorY;\n        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);\n        this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t.padding, o.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new wt(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new wt(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new wt(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new wt(t.x1, t.y2)), a.vertexLength += 4;\n        const h = r.indexArray;\n        h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), a.primitiveLength += 4;\n      }\n      _addTextDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let o = n; o < i; o++) {\n          const n = r.get(o),\n            i = this.getSymbolInstanceTextSize(t, s, e, o);\n          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n      _addIconDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let o = n; o < i; o++) {\n          const n = r.get(o),\n            i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);\n          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n      generateCollisionDebugBuffers(t, e, r) {\n        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Sx(Pa, ty.members, Ia), this.iconCollisionBox = new Sx(Pa, ty.members, Ia);\n        const n = Wy(this.iconSizeData, t),\n          i = Wy(this.textSizeData, t, r);\n        for (let r = 0; r < this.symbolInstances.length; r++) {\n          const s = this.symbolInstances.get(r);\n          this._addTextDebugCollisionBoxes(i, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(i, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);\n        }\n      }\n      getSymbolInstanceTextSize(t, e, r, n) {\n        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),\n          s = Zy(this.textSizeData, t, i) / ry;\n        return this.tilePixelRatio * s;\n      }\n      getSymbolInstanceIconSize(t, e, r) {\n        const n = this.icon.placedSymbolArray.get(r),\n          i = Zy(this.iconSizeData, t, n);\n        return this.tilePixelRatio * i;\n      }\n      _commitDebugCollisionVertexUpdate(t, e, r, n) {\n        t.emplaceBack(e, -r, -r, n), t.emplaceBack(e, r, -r, n), t.emplaceBack(e, r, r, n), t.emplaceBack(e, -r, r, n);\n      }\n      _updateTextDebugCollisionBoxes(t, e, r, n, i, s, o) {\n        for (let o = n; o < i; o++) {\n          const n = r.get(o),\n            i = this.getSymbolInstanceTextSize(t, s, e, o);\n          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);\n        }\n      }\n      _updateIconDebugCollisionBoxes(t, e, r, n, i, s, o) {\n        for (let o = n; o < i; o++) {\n          const n = r.get(o),\n            i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);\n          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);\n        }\n      }\n      updateCollisionDebugBuffers(t, e, r, n) {\n        if (!this.hasDebugData()) return;\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();\n        const i = Wy(this.iconSizeData, t, n),\n          s = Wy(this.textSizeData, t, r);\n        for (let o = 0; o < this.symbolInstances.length; o++) {\n          const a = this.symbolInstances.get(o);\n          this._updateTextDebugCollisionBoxes(s, t, e, a.textBoxStartIndex, a.textBoxEndIndex, a, r), this._updateTextDebugCollisionBoxes(s, t, e, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a, r), this._updateIconDebugCollisionBoxes(i, t, e, a.iconBoxStartIndex, a.iconBoxEndIndex, a, n), this._updateIconDebugCollisionBoxes(i, t, e, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex, a, n);\n        }\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);\n      }\n      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, o, a, l) {\n        const u = {};\n        if (e < r) {\n          const {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: s,\n            padding: o,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(e);\n          u.textBox = {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: s,\n            padding: o,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.textFeatureIndex = d;\n        }\n        if (n < i) {\n          const {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: s,\n            padding: o,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(n);\n          u.verticalTextBox = {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: s,\n            padding: o,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalTextFeatureIndex = d;\n        }\n        if (s < o) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: o,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(s);\n          u.iconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: o,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.iconFeatureIndex = d;\n        }\n        if (a < l) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(a);\n          u.verticalIconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalIconFeatureIndex = d;\n        }\n        return u;\n      }\n      deserializeCollisionBoxes(t) {\n        this.collisionArrays = [];\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n        }\n      }\n      hasTextData() {\n        return this.text.segments.get().length > 0;\n      }\n      hasIconData() {\n        return this.icon.segments.get().length > 0;\n      }\n      hasDebugData() {\n        return this.textCollisionBox && this.iconCollisionBox;\n      }\n      hasTextCollisionBoxData() {\n        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n      }\n      hasIconCollisionBoxData() {\n        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n      }\n      hasIconTextFit() {\n        return this.hasAnyIconTextFit;\n      }\n      addIndicesForPlacedSymbol(t, e) {\n        const r = t.placedSymbolArray.get(e),\n          n = r.vertexStartIndex + 4 * r.numGlyphs;\n        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n      }\n      getSortedSymbolIndexes(t) {\n        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n        const e = Math.sin(t),\n          r = Math.cos(t),\n          n = [],\n          i = [],\n          s = [];\n        for (let t = 0; t < this.symbolInstances.length; ++t) {\n          s.push(t);\n          const o = this.symbolInstances.get(t);\n          n.push(0 | Math.round(e * o.tileAnchorX + r * o.tileAnchorY)), i.push(o.featureIndex);\n        }\n        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;\n      }\n      getSortedIndexesByZOffset() {\n        if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;\n        if (!this.symbolInstanceIndexesSortedZOffset) {\n          this.symbolInstanceIndexesSortedZOffset = [];\n          for (let t = 0; t < this.symbolInstances.length; ++t) this.symbolInstanceIndexesSortedZOffset.push(t);\n        }\n        return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t, e) => this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t).zOffset);\n      }\n      addToSortKeyRanges(t, e) {\n        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n          sortKey: e,\n          symbolInstanceStart: t,\n          symbolInstanceEnd: t + 1\n        });\n      }\n      sortFeatures(t) {\n        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n          for (const t of this.symbolInstanceIndexes) {\n            const e = this.symbolInstances.get(t);\n            this.featureSortOrder.push(e.featureIndex);\n            const {\n              rightJustifiedTextSymbolIndex: r,\n              centerJustifiedTextSymbolIndex: n,\n              leftJustifiedTextSymbolIndex: i,\n              verticalPlacedTextSymbolIndex: s,\n              placedIconSymbolIndex: o,\n              verticalPlacedIconSymbolIndex: a\n            } = e;\n            r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a);\n          }\n          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n        }\n      }\n    }\n    let kx, zx, Ex;\n    Ws(Px, \"SymbolBucket\", {\n      omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n    }), Px.addDynamicAttributes = Ax;\n    class Tx {\n      constructor(t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : fr, this.defaultValue = t;\n      }\n      evaluate(t) {\n        if (t.formattedSection) {\n          const e = this.defaultValue.property.overrides;\n          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n        }\n        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n      }\n      eachChild(t) {\n        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return null;\n      }\n    }\n    Ws(Tx, \"FormatSectionOverride\", {\n      omit: [\"defaultValue\"]\n    });\n    const Bx = () => Ex || (Ex = {\n      layout: kx || (kx = new Vo({\n        \"symbol-placement\": new Eo(Fo.layout_symbol[\"symbol-placement\"]),\n        \"symbol-spacing\": new Eo(Fo.layout_symbol[\"symbol-spacing\"]),\n        \"symbol-avoid-edges\": new Eo(Fo.layout_symbol[\"symbol-avoid-edges\"]),\n        \"symbol-sort-key\": new To(Fo.layout_symbol[\"symbol-sort-key\"]),\n        \"symbol-z-order\": new Eo(Fo.layout_symbol[\"symbol-z-order\"]),\n        \"symbol-z-elevate\": new Eo(Fo.layout_symbol[\"symbol-z-elevate\"]),\n        \"symbol-elevation-reference\": new Eo(Fo.layout_symbol[\"symbol-elevation-reference\"]),\n        \"icon-allow-overlap\": new Eo(Fo.layout_symbol[\"icon-allow-overlap\"]),\n        \"icon-ignore-placement\": new Eo(Fo.layout_symbol[\"icon-ignore-placement\"]),\n        \"icon-optional\": new Eo(Fo.layout_symbol[\"icon-optional\"]),\n        \"icon-rotation-alignment\": new Eo(Fo.layout_symbol[\"icon-rotation-alignment\"]),\n        \"icon-size\": new To(Fo.layout_symbol[\"icon-size\"]),\n        \"icon-size-scale-range\": new Eo(Fo.layout_symbol[\"icon-size-scale-range\"]),\n        \"icon-text-fit\": new To(Fo.layout_symbol[\"icon-text-fit\"]),\n        \"icon-text-fit-padding\": new To(Fo.layout_symbol[\"icon-text-fit-padding\"]),\n        \"icon-image\": new To(Fo.layout_symbol[\"icon-image\"]),\n        \"icon-image-use-theme\": new Eo({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-constant\"\n        }),\n        \"icon-rotate\": new To(Fo.layout_symbol[\"icon-rotate\"]),\n        \"icon-padding\": new Eo(Fo.layout_symbol[\"icon-padding\"]),\n        \"icon-keep-upright\": new Eo(Fo.layout_symbol[\"icon-keep-upright\"]),\n        \"icon-offset\": new To(Fo.layout_symbol[\"icon-offset\"]),\n        \"icon-anchor\": new To(Fo.layout_symbol[\"icon-anchor\"]),\n        \"icon-pitch-alignment\": new Eo(Fo.layout_symbol[\"icon-pitch-alignment\"]),\n        \"text-pitch-alignment\": new Eo(Fo.layout_symbol[\"text-pitch-alignment\"]),\n        \"text-rotation-alignment\": new Eo(Fo.layout_symbol[\"text-rotation-alignment\"]),\n        \"text-field\": new To(Fo.layout_symbol[\"text-field\"]),\n        \"text-font\": new To(Fo.layout_symbol[\"text-font\"]),\n        \"text-size\": new To(Fo.layout_symbol[\"text-size\"]),\n        \"text-size-scale-range\": new Eo(Fo.layout_symbol[\"text-size-scale-range\"]),\n        \"text-max-width\": new To(Fo.layout_symbol[\"text-max-width\"]),\n        \"text-line-height\": new To(Fo.layout_symbol[\"text-line-height\"]),\n        \"text-letter-spacing\": new To(Fo.layout_symbol[\"text-letter-spacing\"]),\n        \"text-justify\": new To(Fo.layout_symbol[\"text-justify\"]),\n        \"text-radial-offset\": new To(Fo.layout_symbol[\"text-radial-offset\"]),\n        \"text-variable-anchor\": new Eo(Fo.layout_symbol[\"text-variable-anchor\"]),\n        \"text-anchor\": new To(Fo.layout_symbol[\"text-anchor\"]),\n        \"text-max-angle\": new Eo(Fo.layout_symbol[\"text-max-angle\"]),\n        \"text-writing-mode\": new Eo(Fo.layout_symbol[\"text-writing-mode\"]),\n        \"text-rotate\": new To(Fo.layout_symbol[\"text-rotate\"]),\n        \"text-padding\": new Eo(Fo.layout_symbol[\"text-padding\"]),\n        \"text-keep-upright\": new Eo(Fo.layout_symbol[\"text-keep-upright\"]),\n        \"text-transform\": new To(Fo.layout_symbol[\"text-transform\"]),\n        \"text-offset\": new To(Fo.layout_symbol[\"text-offset\"]),\n        \"text-allow-overlap\": new Eo(Fo.layout_symbol[\"text-allow-overlap\"]),\n        \"text-ignore-placement\": new Eo(Fo.layout_symbol[\"text-ignore-placement\"]),\n        \"text-optional\": new Eo(Fo.layout_symbol[\"text-optional\"]),\n        visibility: new Eo(Fo.layout_symbol.visibility)\n      })),\n      paint: zx || (zx = new Vo({\n        \"icon-opacity\": new To(Fo.paint_symbol[\"icon-opacity\"]),\n        \"icon-occlusion-opacity\": new To(Fo.paint_symbol[\"icon-occlusion-opacity\"]),\n        \"icon-emissive-strength\": new To(Fo.paint_symbol[\"icon-emissive-strength\"]),\n        \"text-emissive-strength\": new To(Fo.paint_symbol[\"text-emissive-strength\"]),\n        \"icon-color\": new To(Fo.paint_symbol[\"icon-color\"]),\n        \"icon-halo-color\": new To(Fo.paint_symbol[\"icon-halo-color\"]),\n        \"icon-halo-width\": new To(Fo.paint_symbol[\"icon-halo-width\"]),\n        \"icon-halo-blur\": new To(Fo.paint_symbol[\"icon-halo-blur\"]),\n        \"icon-translate\": new Eo(Fo.paint_symbol[\"icon-translate\"]),\n        \"icon-translate-anchor\": new Eo(Fo.paint_symbol[\"icon-translate-anchor\"]),\n        \"icon-image-cross-fade\": new Eo(Fo.paint_symbol[\"icon-image-cross-fade\"]),\n        \"text-opacity\": new To(Fo.paint_symbol[\"text-opacity\"]),\n        \"text-occlusion-opacity\": new To(Fo.paint_symbol[\"text-occlusion-opacity\"]),\n        \"text-color\": new To(Fo.paint_symbol[\"text-color\"], {\n          runtimeType: xr,\n          getOverride: t => t.textColor,\n          hasOverride: t => !!t.textColor\n        }),\n        \"text-halo-color\": new To(Fo.paint_symbol[\"text-halo-color\"]),\n        \"text-halo-width\": new To(Fo.paint_symbol[\"text-halo-width\"]),\n        \"text-halo-blur\": new To(Fo.paint_symbol[\"text-halo-blur\"]),\n        \"text-translate\": new Eo(Fo.paint_symbol[\"text-translate\"]),\n        \"text-translate-anchor\": new Eo(Fo.paint_symbol[\"text-translate-anchor\"]),\n        \"icon-color-saturation\": new Eo(Fo.paint_symbol[\"icon-color-saturation\"]),\n        \"icon-color-contrast\": new Eo(Fo.paint_symbol[\"icon-color-contrast\"]),\n        \"icon-color-brightness-min\": new Eo(Fo.paint_symbol[\"icon-color-brightness-min\"]),\n        \"icon-color-brightness-max\": new Eo(Fo.paint_symbol[\"icon-color-brightness-max\"]),\n        \"symbol-z-offset\": new To(Fo.paint_symbol[\"symbol-z-offset\"]),\n        \"icon-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"icon-halo-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"text-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"text-halo-color-use-theme\": new To({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        })\n      }))\n    }, Ex);\n    class Vx extends na {\n      constructor(t, e, r, n) {\n        super(t, Bx(), e, r, n, t.layout ? t.layout[\"icon-image-use-theme\"] : null), this._colorAdjustmentMatrix = l([]), this.hasOcclusionOpacityProperties = void 0 !== t.paint && (\"icon-occlusion-opacity\" in t.paint || \"text-occlusion-opacity\" in t.paint);\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"icon-occlusion-opacity\" !== t && \"text-occlusion-opacity\" !== t || (this.hasOcclusionOpacityProperties = !0);\n      }\n      recalculate(t, e) {\n        super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\"));\n        const r = this.layout.get(\"text-writing-mode\");\n        if (r) {\n          const t = [];\n          for (const e of r) t.indexOf(e) < 0 && t.push(e);\n          this.layout._values[\"text-writing-mode\"] = t;\n        } else this.layout._values[\"text-writing-mode\"] = \"point\" === this.layout.get(\"symbol-placement\") ? [\"horizontal\"] : [\"horizontal\", \"vertical\"];\n        this._setPaintOverrides();\n      }\n      getColorAdjustmentMatrix(t, e, r, n) {\n        return this._saturation === t && this._contrast === e && this._brightnessMin === r && this._brightnessMax === n || (this._colorAdjustmentMatrix = function (t, e, r, n) {\n          t = ee(t), e = te(e);\n          const i = a(),\n            s = t / 3,\n            o = 1 - 2 * s,\n            l = [o, s, s, 0, s, o, s, 0, s, s, o, 0, 0, 0, 0, 1],\n            u = .5 - .5 * e,\n            h = n - r;\n          return c(i, [h, 0, 0, 0, 0, h, 0, 0, 0, 0, h, 0, r, r, r, 1], [e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, u, u, u, 1]), c(i, i, l), i;\n        }(t, e, r, n), this._saturation = t, this._contrast = e, this._brightnessMin = r, this._brightnessMax = n), this._colorAdjustmentMatrix;\n      }\n      getValueAndResolveTokens(t, e, r, n) {\n        const i = this.layout.get(t).evaluate(e, {}, r, n),\n          s = this._unevaluatedLayout._values[t];\n        return s.isDataDriven() || Rs(s.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n        }(e.properties, i);\n      }\n      createBucket(t) {\n        return new Px(t);\n      }\n      queryRadius() {\n        return 0;\n      }\n      queryIntersectsFeature() {\n        return !1;\n      }\n      _setPaintOverrides() {\n        for (const t of Bx().paint.overridableProperties) {\n          if (!Vx.hasPaintOverride(this.layout, t)) continue;\n          const e = this.paint.get(t),\n            r = new Tx(e),\n            n = new Ds(r, e.property.specification, this.scope, this.options, this.layout.get(\"icon-image-use-theme\"));\n          let i = null;\n          i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new Os(\"source\", n) : new Us(\"composite\", n, e.value.zoomStops, e.value.interpolationType), this.paint._values[t] = new ko(e.property, i, e.parameters);\n        }\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && Vx.hasPaintOverride(this.layout, t);\n      }\n      static hasPaintOverride(t, e) {\n        const r = t.get(\"text-field\"),\n          n = Bx().paint.properties[e];\n        let i = !1;\n        const s = t => {\n          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n        };\n        if (\"constant\" === r.value.kind && r.value.value instanceof Vr) s(r.value.value.sections);else if (\"source\" === r.value.kind) {\n          const t = e => {\n              i || (e instanceof Ur && Lr(e.value) === _r ? s(e.value.sections) : e instanceof Gr ? s(e.sections) : e.eachChild(t));\n            },\n            e = r.value;\n          e._styleExpression && t(e._styleExpression.expression);\n        }\n        return i;\n      }\n      getProgramIds() {\n        return [\"symbol\"];\n      }\n      getDefaultProgramParams(t, e, r) {\n        return {\n          config: new Fl(this, {\n            zoom: e,\n            lut: r\n          }),\n          overrideFog: !1\n        };\n      }\n      hasElevation() {\n        return this.layout && \"hd-road-markup\" === this.layout.get(\"symbol-elevation-reference\");\n      }\n    }\n    let Fx, Cx, Dx, Rx;\n    var Lx = aa([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }, {\n      name: \"a_texture_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    function Ox(t, e, r, n, i, a, l, u) {\n      const c = [t, e, 1, r, n, 1, i, a, 1],\n        h = [l, u, 1],\n        p = s([], c),\n        [d, f, m] = U(h, h, p);\n      return o(c, c, [d, 0, 0, 0, f, 0, 0, 0, m]);\n    }\n    function Ux(t, e, r, n, i, a, l, u) {\n      const c = function (t, e, r, n, i, a, l, u) {\n        const c = Ox(0, 0, 1, 0, 1, 1, 0, 1),\n          h = Ox(t, e, r, n, i, a, l, u);\n        return o(h, h, s([], c));\n      }(t, e, r, n, i, a, l, u);\n      return [c[2] / c[8] / Rn, c[5] / c[8] / Rn];\n    }\n    function Nx(t) {\n      return [t[0], Math.min(Math.max(t[1], -cu), cu)];\n    }\n    class jx extends tr {\n      constructor(t, e, r, n) {\n        super(), this.id = t, this.dispatcher = r, this.coordinates = e.coordinates, this.type = \"image\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;\n      }\n      load(t, e) {\n        if (this._loaded = e || !1, this.fire(new Ye(\"dataloading\", {\n          dataType: \"source\"\n        })), this.url = this.options.url, !this.url) return t && (this.coordinates = t), this._loaded = !0, void this._finishLoading();\n        this._imageRequest = Ne(this.map._requestManager.transformRequest(this.url, Be.Image), (e, r) => {\n          this._imageRequest = null, this._loaded = !0, e ? this.fire(new Ke(e)) : r && (this.image = r instanceof HTMLImageElement ? de.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading());\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      updateImage(t) {\n        return t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t.url, this.load(t.coordinates, this._loaded), this) : this;\n      }\n      setTexture(t) {\n        if (!(t.handle instanceof WebGLTexture)) throw new Error(\"The provided handle is not a WebGLTexture instance\");\n        return this.texture = new bf(this.map.painter.context, t.handle), this.width = t.dimensions[0], this.height = t.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;\n      }\n      _finishLoading() {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new Ye(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"metadata\"\n        })));\n      }\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n      onRemove(t) {\n        this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof bf || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());\n      }\n      setCoordinates(t) {\n        if (this.coordinates = t, this._boundsArray = void 0, this._unsupportedCoords = !1, !t.length) return this;\n        this.onNorthPole = !1, this.onSouthPole = !1;\n        let e = t[0][1],\n          r = t[0][1];\n        for (const n of t) n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);\n        const n = (r + e) / 2;\n        if (n > cu ? this.onNorthPole = !0 : n < -cu && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {\n          const e = t.map(mu.fromLngLat);\n          this.tileID = function (t) {\n            let e = 1 / 0,\n              r = 1 / 0,\n              n = -1 / 0,\n              i = -1 / 0;\n            for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n            const s = Math.max(n - e, i - r),\n              o = Math.max(0, Math.floor(-Math.log2(s))),\n              a = Math.pow(2, o);\n            let l = Math.floor((e + n) / 2 * a);\n            return l > 1 && (l -= 1), new _c(o, l, Math.floor((r + i) / 2 * a));\n          }(e), this.minzoom = this.maxzoom = this.tileID.z;\n        }\n        return this.fire(new Ye(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"content\"\n        })), this;\n      }\n      _clear() {\n        !this.texture || this.texture instanceof bf || (this.texture.destroy(), this._dirty = !0), this.texture = null, this._boundsArray = void 0, this._unsupportedCoords = !1;\n      }\n      _prepareData(t) {\n        for (const t in this.tiles) {\n          const e = this.tiles[t];\n          \"loaded\" !== e.state && (e.state = \"loaded\", e.texture = this.texture);\n        }\n        if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;\n        const e = Zg(new _c(0, 0, 0), this.map.transform.projection),\n          r = [e.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e.projection.project(this.coordinates[3][0], this.coordinates[3][1])];\n        if (!function (t) {\n          const e = t[1].x - t[0].x,\n            r = t[1].y - t[0].y,\n            n = t[2].x - t[1].x,\n            i = t[2].y - t[1].y,\n            s = t[3].x - t[2].x,\n            o = t[3].y - t[2].y,\n            a = t[0].x - t[3].x,\n            l = t[0].y - t[3].y,\n            u = e * i - n * r,\n            c = n * o - s * i,\n            h = s * l - a * o,\n            p = a * r - e * l;\n          return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;\n        }(r)) return console.warn(\"Image source coordinates are defining non-convex area in the Mercator projection\"), void (this._unsupportedCoords = !0);\n        const n = Zg(this.tileID, this.map.transform.projection),\n          [i, a, l, u] = this.coordinates.map(t => {\n            const e = n.projection.project(t[0], t[1]);\n            return Wg(n, e)._round();\n          });\n        this.perspectiveTransform = Ux(i.x, i.y, a.x, a.y, l.x, l.y, u.x, u.y);\n        const c = this._boundsArray = new ha();\n        c.emplaceBack(i.x, i.y, 0, 0), c.emplaceBack(a.x, a.y, Rn, 0), c.emplaceBack(u.x, u.y, 0, Rn), c.emplaceBack(l.x, l.y, Rn, Rn), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t.createVertexBuffer(c, Lx.members), this.boundsSegments = al.simpleSegment(0, 0, 4, 2);\n        const h = [],\n          p = [Nx((d = this.coordinates)[0]), Nx(d[1]), Nx(d[2]), Nx(d[3])];\n        var d;\n        const [f, m, y, g] = function (t) {\n          let e = t[0][0],\n            r = e,\n            n = t[0][1],\n            i = n;\n          for (let s = 1; s < t.length; s++) t[s][0] < e ? e = t[s][0] : t[s][0] > r && (r = t[s][0]), t[s][1] < n ? n = t[s][1] : t[s][1] > i && (i = t[s][1]);\n          return [e, n, r - e, i - n];\n        }(p);\n        {\n          const n = new ha(),\n            [i, a, l, u] = function (t) {\n              let e = t[0].x,\n                r = e,\n                n = t[0].y,\n                i = n;\n              for (let s = 1; s < t.length; s++) t[s].x < e ? e = t[s].x : t[s].x > r && (r = t[s].x), t[s].y < n ? n = t[s].y : t[s].y > i && (i = t[s].y);\n              return [e, n, r - e, i - n];\n            }(r),\n            c = t => [(t.x - i) / l, (t.y - a) / u],\n            [p, d, x, v] = r.map(c),\n            b = function (t, e, r, n, i, a, l, u) {\n              const c = Ox(0, 0, 1, 0, 1, 1, 0, 1);\n              return o(c, c, s([], Ox(t, e, r, n, i, a, l, u)));\n            }(p[0], p[1], d[0], d[1], x[0], x[1], v[0], v[1]);\n          this.elevatedGlobePerspectiveTransform = Ux(p[0], p[1], d[0], d[1], x[0], x[1], v[0], v[1]);\n          const w = (t, e) => {\n              h.push(t.lng);\n              const r = Math.round((t.lng - f) / y * Rn),\n                i = Math.round((t.lat - m) / g * Rn),\n                s = c(e),\n                o = U([], [s[0], s[1], 1], b),\n                a = Math.round(o[0] / o[2] * Rn),\n                l = Math.round(o[1] / o[2] * Rn);\n              n.emplaceBack(r, i, a, l);\n            },\n            _ = r[3].x - r[0].x,\n            A = r[3].y - r[0].y,\n            M = r[2].x - r[1].x,\n            I = r[2].y - r[1].y;\n          for (let t = 0; t < 65; t++) {\n            const n = t / 64,\n              i = [r[0].x + n * _, r[0].y + n * A],\n              s = [r[1].x + n * M, r[1].y + n * I],\n              o = s[0] - i[0],\n              a = s[1] - i[1];\n            for (let t = 0; t < 65; t++) {\n              const r = t / 64,\n                n = {\n                  x: i[0] + o * r,\n                  y: i[1] + a * r\n                };\n              w(e.projection.unproject(n.x, n.y), n);\n            }\n          }\n          this.elevatedGlobeVertexBuffer = t.createVertexBuffer(n, Lx.members);\n        }\n        {\n          this.maxLongitudeTriangleSize = 0;\n          let e = [],\n            r = new Ea();\n          const n = (t, n, i) => {\n            r.emplaceBack(t, n, i);\n            const s = h[t],\n              o = h[n],\n              a = h[i],\n              l = Math.min(Math.min(s, o), a),\n              u = Math.max(Math.max(s, o), a) - l;\n            u > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u), e.push(l + u / 2);\n          };\n          for (let t = 0; t < 64; t++) for (let e = 0; e < 64; e++) {\n            const r = 65 * t + e,\n              i = r + 1,\n              s = r + 65,\n              o = s + 1;\n            n(r, s, i), n(i, s, o);\n          }\n          [e, r] = function (t, e) {\n            const r = Array.from({\n              length: t.length\n            }, (t, e) => e);\n            r.sort((e, r) => t[e] - t[r]);\n            const n = [],\n              i = new Ea();\n            for (let s = 0; s < r.length; s++) {\n              const o = r[s];\n              n.push(t[o]);\n              const a = 3 * o,\n                l = a + 1;\n              i.emplaceBack(e.uint16[a], e.uint16[l], e.uint16[l + 1]);\n            }\n            return [n, i];\n          }(e, r), this.elevatedGlobeTrianglesCenterLongitudes = e, this.elevatedGlobeIndexBuffer = t.createIndexBuffer(r);\n        }\n        this.elevatedGlobeSegments = al.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, y / Rn, 0, g / Rn, 0, 0, m, f, 0]);\n      }\n      prepare() {\n        const t = 0 !== Object.keys(this.tiles).length;\n        if (this.tileID && !t) return;\n        const e = this.map.painter.context,\n          r = e.gl;\n        !this._dirty || this.texture instanceof bf || (this.texture ? this.texture.update(this.image) : (this.texture = new vf(e, this.image, r.RGBA8), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t && this._prepareData(e);\n      }\n      loadTile(t, e) {\n        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = \"errored\", e(null));\n      }\n      serialize() {\n        return {\n          type: \"image\",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }\n      hasTransition() {\n        return !1;\n      }\n      getSegmentsForLongitude(t) {\n        const e = this.elevatedGlobeSegments;\n        if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;\n        const r = this.elevatedGlobeTrianglesCenterLongitudes;\n        let n = (i = t + 180) + 360 * Math.round((r[0] - i) / 360);\n        var i;\n        const s = new al(),\n          o = (t, r) => {\n            s.segments.push({\n              vertexOffset: 0,\n              primitiveOffset: t,\n              vertexLength: e.segments[0].vertexLength,\n              primitiveLength: r,\n              sortKey: void 0,\n              vaos: {}\n            });\n          },\n          a = .51 * this.maxLongitudeTriangleSize;\n        if (Math.abs(r[0] - n) <= a) {\n          const t = Qt(r, 0, r.length, n + a);\n          return t === r.length || o(t, Jt(r, t + 1, r.length, n + 360 - a) - t), s;\n        }\n        n < r[0] && (n += 360);\n        const l = Jt(r, 0, r.length, n - a);\n        if (l === r.length) return o(0, r.length), s;\n        o(0, l - 0);\n        const u = Qt(r, l + 1, r.length, n + a);\n        return u !== r.length && o(u, r.length - u), s;\n      }\n    }\n    const $x = (Math.pow(256, 2) - 1) / 16907520;\n    class Gx extends na {\n      constructor(t, e, r, n) {\n        super(t, {\n          layout: Dx || (Dx = new Vo({\n            visibility: new Eo(Fo.layout_raster.visibility)\n          })),\n          paint: Rx || (Rx = new Vo({\n            \"raster-opacity\": new Eo(Fo.paint_raster[\"raster-opacity\"]),\n            \"raster-color\": new Bo(Fo.paint_raster[\"raster-color\"]),\n            \"raster-color-mix\": new Eo(Fo.paint_raster[\"raster-color-mix\"]),\n            \"raster-color-range\": new Eo(Fo.paint_raster[\"raster-color-range\"]),\n            \"raster-hue-rotate\": new Eo(Fo.paint_raster[\"raster-hue-rotate\"]),\n            \"raster-brightness-min\": new Eo(Fo.paint_raster[\"raster-brightness-min\"]),\n            \"raster-brightness-max\": new Eo(Fo.paint_raster[\"raster-brightness-max\"]),\n            \"raster-saturation\": new Eo(Fo.paint_raster[\"raster-saturation\"]),\n            \"raster-contrast\": new Eo(Fo.paint_raster[\"raster-contrast\"]),\n            \"raster-resampling\": new Eo(Fo.paint_raster[\"raster-resampling\"]),\n            \"raster-fade-duration\": new Eo(Fo.paint_raster[\"raster-fade-duration\"]),\n            \"raster-emissive-strength\": new Eo(Fo.paint_raster[\"raster-emissive-strength\"]),\n            \"raster-array-band\": new Eo(Fo.paint_raster[\"raster-array-band\"]),\n            \"raster-elevation\": new Eo(Fo.paint_raster[\"raster-elevation\"]),\n            \"raster-color-use-theme\": new To({\n              type: \"string\",\n              default: \"default\",\n              \"property-type\": \"data-driven\"\n            })\n          }))\n        }, e, r, n), this.updateColorRamp(), this._curRampRange = [NaN, NaN];\n      }\n      getProgramIds() {\n        return [\"raster\"];\n      }\n      hasColorMap() {\n        return !!this._transitionablePaint._values[\"raster-color\"].value.value;\n      }\n      tileCoverLift() {\n        return this.paint.get(\"raster-elevation\");\n      }\n      isDraped(t) {\n        return !(t && t._source instanceof jx && (t._source.onNorthPole || t._source.onSouthPole)) && 0 === this.paint.get(\"raster-elevation\");\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"raster-color\" !== t && \"raster-color-range\" !== t || (this._curRampRange = [NaN, NaN], this.updateColorRamp());\n      }\n      _clear() {\n        this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n      }\n      updateColorRamp(t) {\n        if (!this.hasColorMap()) return;\n        if (!this._curRampRange) return;\n        const e = this._transitionablePaint._values[\"raster-color\"].value.expression,\n          [r, n] = t || this._transitionablePaint._values[\"raster-color-range\"].value.expression.evaluate({\n            zoom: 0\n          }) || [NaN, NaN];\n        isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = bh({\n          expression: e,\n          evaluationKey: \"rasterValue\",\n          image: this.colorRamp,\n          clips: [{\n            start: r,\n            end: n\n          }],\n          resolution: 256\n        }), this.colorRampTexture = null, this._curRampRange = [r, n]);\n      }\n    }\n    let Hx, qx, Xx, Zx, Wx;\n    class Yx extends na {\n      constructor(t, e, r, n) {\n        super(t, {\n          layout: Hx || (Hx = new Vo({\n            visibility: new Eo(Fo[\"layout_raster-particle\"].visibility)\n          })),\n          paint: qx || (qx = new Vo({\n            \"raster-particle-array-band\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-array-band\"]),\n            \"raster-particle-count\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-count\"]),\n            \"raster-particle-color\": new Bo(Fo[\"paint_raster-particle\"][\"raster-particle-color\"]),\n            \"raster-particle-max-speed\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-max-speed\"]),\n            \"raster-particle-speed-factor\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-speed-factor\"]),\n            \"raster-particle-fade-opacity-factor\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-fade-opacity-factor\"]),\n            \"raster-particle-reset-rate-factor\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-reset-rate-factor\"]),\n            \"raster-particle-elevation\": new Eo(Fo[\"paint_raster-particle\"][\"raster-particle-elevation\"]),\n            \"raster-particle-color-use-theme\": new To({\n              type: \"string\",\n              default: \"default\",\n              \"property-type\": \"data-driven\"\n            })\n          }))\n        }, e, r, n), this._updateColorRamp(), this.lastInvalidatedAt = de.now();\n      }\n      _clear() {\n        this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this.tileFramebuffer && (this.tileFramebuffer.destroy(), this.tileFramebuffer = null), this.particleFramebuffer && (this.particleFramebuffer.destroy(), this.particleFramebuffer = null);\n      }\n      onRemove(t) {\n        this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();\n      }\n      hasColorMap() {\n        return !!this._transitionablePaint._values[\"raster-particle-color\"].value.value;\n      }\n      getProgramIds() {\n        return [\"rasterParticle\"];\n      }\n      hasOffscreenPass() {\n        return \"none\" !== this.visibility;\n      }\n      isDraped(t) {\n        return !1;\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"raster-particle-color\" !== t && \"raster-particle-max-speed\" !== t || (this._updateColorRamp(), this._invalidateAnimationState()), \"raster-particle-count\" === t && this._invalidateAnimationState();\n      }\n      _updateColorRamp() {\n        if (!this.hasColorMap()) return;\n        const t = this._transitionablePaint._values[\"raster-particle-color\"].value.expression,\n          e = this._transitionablePaint._values[\"raster-particle-max-speed\"].value.expression.evaluate({\n            zoom: 0\n          });\n        this.colorRamp = bh({\n          expression: t,\n          evaluationKey: \"rasterParticleSpeed\",\n          image: this.colorRamp,\n          clips: [{\n            start: 0,\n            end: e\n          }],\n          resolution: 256\n        }), this.colorRampTexture = null;\n      }\n      _invalidateAnimationState() {\n        this.lastInvalidatedAt = de.now();\n      }\n      tileCoverLift() {\n        return this.paint.get(\"raster-particle-elevation\");\n      }\n    }\n    class Kx extends na {\n      constructor(t, e) {\n        super(t, {}, e, null), this.implementation = t, t.slot && (this.slot = t.slot);\n      }\n      is3D(t) {\n        return \"3d\" === this.implementation.renderingMode;\n      }\n      hasOffscreenPass() {\n        return void 0 !== this.implementation.prerender;\n      }\n      isDraped(t) {\n        return void 0 !== this.implementation.renderToTile;\n      }\n      shouldRedrape() {\n        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();\n      }\n      recalculate() {}\n      updateTransitions() {}\n      hasTransition() {\n        return !1;\n      }\n      serialize() {}\n      onAdd(t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }\n      onRemove(t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }\n    }\n    function Jx(t, e, r) {\n      const n = [0, 0, 1],\n        i = J([]);\n      return tt(i, i, r ? -It(t) + Math.PI : It(t)), Q(i, i, -It(e)), N(n, n, i), C(n, n);\n    }\n    const Qx = {\n      None: 0,\n      Model: 1,\n      Symbol: 2,\n      FillExtrusion: 4\n    };\n    class tv {\n      constructor(t, e, r, n) {\n        this.message = (t ? \"\".concat(t, \": \") : \"\") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n      }\n    }\n    function ev(t, e) {\n      const r = -1 === t.indexOf(\"://\");\n      try {\n        return new URL(t, r && e ? \"http://example.com\" : void 0), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    class rv {\n      constructor(t, e) {\n        this.feature = t, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];\n      }\n    }\n    class nv {\n      constructor() {\n        this.instancedDataArray = new Na(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};\n      }\n    }\n    class iv {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.projection = t.projection, this.index = t.index, this.worldview = t.worldview, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z + 1 ? 0 : this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {\n          id: null,\n          timestamp: 0\n        }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t.styleDefinedModelURLs;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.tileToMeter = fu(r);\n        const i = this.layers[0]._featureFilter.needGeometry;\n        this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);\n        for (const {\n          feature: s,\n          id: o,\n          index: a,\n          sourceLayerIndex: l\n        } of t) {\n          const t = null != o ? o : s.properties && s.properties.hasOwnProperty(\"id\") ? s.properties.id : void 0,\n            u = Mu(s, i);\n          if (!this.layers[0]._featureFilter.filter(new wo(this.zoom, {\n            worldview: this.worldview\n          }), u, r)) continue;\n          const c = {\n              id: t,\n              sourceLayerIndex: l,\n              index: a,\n              geometry: i ? u.geometry : Au(s, r, n),\n              properties: s.properties,\n              type: s.type,\n              patterns: {}\n            },\n            h = this.addFeature(c, c.geometry, u);\n          h && e.featureIndex.insert(s, c.geometry, a, l, this.index, this.instancesPerModel[h].instancedDataArray.length, Rn / 32);\n        }\n        this.lookup = null;\n      }\n      update(t, e, r, n) {\n        for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          for (const e in t) r.idToFeaturesIndex.hasOwnProperty(e) && (this.evaluate(r.features[r.idToFeaturesIndex[e]], t[e], r, !0), this.uploaded = !1);\n        }\n        this.maxHeight = 0;\n      }\n      updateZoomBasedPaintProperties() {\n        if (!this.hasZoomDependentProperties) return !1;\n        let t = !1;\n        for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          for (const e of r.features) {\n            const n = this.layers[0],\n              i = e.feature,\n              s = this.canonical,\n              o = n.paint.get(\"model-rotation\").evaluate(i, {}, s),\n              a = n.paint.get(\"model-scale\").evaluate(i, {}, s),\n              l = n.paint.get(\"model-translation\").evaluate(i, {}, s);\n            $(e.rotation, o) && $(e.scale, a) && $(e.translation, l) || (this.evaluate(e, e.featureStates, r, !0), t = !0);\n          }\n        }\n        return t;\n      }\n      updateReplacement(t, e, r, n) {\n        if (e.updateTime === this.replacementUpdateTime) return !1;\n        this.replacementUpdateTime = e.updateTime;\n        const i = e.getReplacementRegionsForTile(t.toUnwrapped(), !0);\n        if (Dp(this.activeReplacements, i)) return !1;\n        this.activeReplacements = i;\n        let s = !1;\n        for (const e in this.instancesPerModel) {\n          const i = this.instancesPerModel[e],\n            o = i.instancedDataArray;\n          for (const e of i.features) {\n            const i = e.instancedDataOffset,\n              a = e.instancedDataCount;\n            for (let e = 0; e < a; e++) {\n              const a = 16 * (e + i);\n              let l = o.float32[a + 0];\n              const u = l > Rn;\n              l = u ? l - Rn : l;\n              const c = Math.floor(l),\n                h = o.float32[a + 1];\n              let p = !1;\n              for (const e of this.activeReplacements) if (!Bp(e, r, Qx.Model, n) && !(e.min.x > c || c > e.max.x || e.min.y > h || h > e.max.y) && (p = jp(Np(c, h, t.canonical, e.footprintTileId.canonical), e.footprint), p)) break;\n              o.float32[a] = p ? l + Rn : l, s = s || p !== u;\n            }\n          }\n        }\n        return s;\n      }\n      isEmpty() {\n        for (const t in this.instancesPerModel) if (0 !== this.instancesPerModel[t].instancedDataArray.length) return !1;\n        return !0;\n      }\n      uploadPending() {\n        return !this.uploaded;\n      }\n      upload(t) {\n        if (!this.uploaded) for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t.createVertexBuffer(r.instancedDataArray, Sf.members, !0, void 0, this.instanceCount));\n        }\n        this.uploaded = !0;\n      }\n      destroy() {\n        for (const t in this.instancesPerModel) {\n          const e = this.instancesPerModel[t];\n          0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();\n        }\n        const t = this.layers[0].modelManager;\n        if (t && this.modelUris && this.modelsRequested) for (const e of this.modelUris) t.removeModel(e, \"\", !0);\n      }\n      addFeature(t, e, r) {\n        const n = this.layers[0],\n          i = n.layout.get(\"model-id\").evaluate(r, {}, this.canonical);\n        if (!i) return Gt(\"modelId is not evaluated for layer \".concat(n.id, \" and it is not going to get rendered.\")), i;\n        (ev(i, !1) || void 0 !== this.styleDefinedModelURLs[i]) && (this.modelUris.includes(i) || this.modelUris.push(i)), this.instancesPerModel[i] || (this.instancesPerModel[i] = new nv());\n        const s = this.instancesPerModel[i],\n          o = s.instancedDataArray,\n          a = new rv(r, o.length);\n        for (const t of e) for (const e of t) {\n          if (e.x < 0 || e.x >= Rn || e.y < 0 || e.y >= Rn) continue;\n          if (0 !== this.lookupDim) {\n            const t = (this.lookupDim - 1) / Rn,\n              r = this.lookupDim * (e.y * t | 0) + e.x * t | 0;\n            if (this.lookup) {\n              if (0 !== this.lookup[r]) continue;\n              this.lookup[r] = 1;\n            }\n          }\n          this.instanceCount++;\n          const t = o.length;\n          o.resize(t + 1), s.instancesEvaluatedElevation.push(0), o.float32[16 * t] = e.x, o.float32[16 * t + 1] = e.y;\n        }\n        return a.instancedDataCount = s.instancedDataArray.length - a.instancedDataOffset, a.instancedDataCount > 0 && (t.id && (s.idToFeaturesIndex[t.id] = s.features.length), s.features.push(a), this.evaluate(a, {}, s, !1)), i;\n      }\n      getModelUris() {\n        return this.modelUris;\n      }\n      evaluate(t, e, r, n) {\n        const i = this.layers[0],\n          s = t.feature,\n          o = this.canonical,\n          a = t.rotation = i.paint.get(\"model-rotation\").evaluate(s, e, o),\n          l = t.scale = i.paint.get(\"model-scale\").evaluate(s, e, o),\n          u = t.translation = i.paint.get(\"model-translation\").evaluate(s, e, o),\n          c = i.paint.get(\"model-color\").evaluate(s, e, o);\n        c.a = i.paint.get(\"model-color-mix-intensity\").evaluate(s, e, o);\n        const h = [];\n        this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), Ff(h, a, l);\n        const p = Math.round(100 * c.a) + c.b / 1.05;\n        for (let e = 0; e < t.instancedDataCount; ++e) {\n          const i = t.instancedDataOffset + e,\n            s = 16 * i,\n            a = r.instancedDataArray.float32;\n          let l = 0;\n          n && (l = a[s + 6] - r.instancesEvaluatedElevation[i]);\n          const d = 0 | a[s + 1];\n          a[s] = (0 | a[s]) + c.r / 1.05, a[s + 1] = d + c.g / 1.05, a[s + 2] = p, a[s + 3] = 1 / (o.z > 10 ? this.tileToMeter : fu(o, d)), a[s + 4] = u[0], a[s + 5] = u[1], a[s + 6] = u[2] + l, a[s + 7] = h[0], a[s + 8] = h[1], a[s + 9] = h[2], a[s + 10] = h[4], a[s + 11] = h[5], a[s + 12] = h[6], a[s + 13] = h[8], a[s + 14] = h[9], a[s + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];\n        }\n      }\n    }\n    let sv, ov;\n    Ws(iv, \"ModelBucket\", {\n      omit: [\"layers\"]\n    }), Ws(nv, \"PerModelAttributes\"), Ws(rv, \"ModelFeature\");\n    class av {\n      constructor(t, e, r) {\n        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;\n      }\n      static create(t, e, r) {\n        const n = r || t.findDEMTileFor(e);\n        if (!n || !n.dem) return;\n        const i = n.dem,\n          s = n.tileID,\n          o = 1 << e.canonical.z - s.canonical.z;\n        return new av(n, i.dim / Rn / o, [(e.canonical.x / o - s.canonical.x) * i.dim, (e.canonical.y / o - s.canonical.y) * i.dim]);\n      }\n      tileCoordToPixel(t, e) {\n        const r = e * this._scale + this._offset[1];\n        return new wt(Math.floor(t * this._scale + this._offset[0]), Math.floor(r));\n      }\n      getElevationAt(t, e, r, n) {\n        const i = t * this._scale + this._offset[0],\n          s = e * this._scale + this._offset[1],\n          o = Math.floor(i),\n          a = Math.floor(s),\n          l = this._dem;\n        return n = !!n, r ? ur(ur(l.get(o, a, n), l.get(o, a + 1, n), s - a), ur(l.get(o + 1, a, n), l.get(o + 1, a + 1, n), s - a), i - o) : l.get(o, a, n);\n      }\n      getElevationAtPixel(t, e, r) {\n        return this._dem.get(t, e, !!r);\n      }\n      getMeterToDEM(t) {\n        return (1 << this._demTile.tileID.canonical.z) * ou(1, t) * this._dem.stride;\n      }\n    }\n    const lv = new Float32Array(262144),\n      uv = new Uint8Array(262144);\n    function cv(t) {\n      let e = 0;\n      if (t.meshes) for (const r of t.meshes) e = Math.max(e, r.aabb.max[2]);\n      if (t.children) for (const r of t.children) e = Math.max(e, cv(r));\n      return e;\n    }\n    function hv(t, e, r) {\n      if (t.meshes) for (const n of t.meshes) {\n        if (n.aabb.min[0] === 1 / 0) continue;\n        const i = Xu.applyTransform(n.aabb, t.matrix);\n        r.insert(e, i.min[0], i.min[1], i.max[0], i.max[1]);\n      }\n      if (t.children) for (const n of t.children) hv(n, e, r);\n    }\n    const pv = [\"\", \"wall\", \"door\", \"roof\", \"window\", \"lamp\", \"logo\"];\n    class dv {\n      constructor(t) {\n        this.node = t, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedTranslation = [0, 0, 0], this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {\n          type: \"Point\",\n          id: t.id,\n          geometry: [],\n          properties: {\n            height: cv(t)\n          }\n        }, this.aabb = this._getLocalBounds(), this.state = null;\n      }\n      _getLocalBounds() {\n        if (!this.node.meshes) return new Xu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);\n        if (!this.aabb) {\n          let t = 0;\n          const e = new Xu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);\n          for (const r of this.node.meshes) this.node.lightMeshIndex !== t && (r.transformedAabb = Xu.applyTransformFast(r.aabb, this.node.matrix), e.encapsulate(r.transformedAabb)), t++;\n          this.aabb = e;\n        }\n        return this.aabb;\n      }\n    }\n    class fv {\n      constructor(t, e, r, n, i, s, o, a) {\n        this.id = r, this.layers = t, this.layerIds = this.layers.map(t => t.fqid), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.modelTraits |= Of.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, n && (this.modelTraits |= Of.HasMapboxMeshFeatures), i && (this.modelTraits |= Of.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {\n          name: \"mercator\"\n        }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s, this.worldview = a, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = [];\n        for (const t of e) this.nodesInfo.push(new dv(t)), hv(t, o.featureIndexArray.length, o.grid), o.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, o.bucketLayerIDs.length - 1, 0);\n        this.states = {};\n      }\n      updateFootprints(t, e) {\n        for (const r of this.getNodesInfo()) {\n          const n = r.node;\n          n.footprint && e.push({\n            footprint: n.footprint,\n            id: t\n          });\n        }\n      }\n      update(t) {\n        const e = 0 !== Object.keys(t).length;\n        if (e && !this.stateDependentLayers.length) return;\n        const r = e ? this.stateDependentLayers : this.layers;\n        if (!_t(t, this.states)) for (const e of r) this.evaluate(e, t);\n        this.states = structuredClone(t);\n      }\n      populate() {\n        console.log(\"populate 3D model bucket\");\n      }\n      uploadPending() {\n        return !this.uploaded || this.needsUpload;\n      }\n      upload(t) {\n        if (!this.needsUpload) return;\n        const e = this.getNodesInfo();\n        for (const r of e) {\n          const e = r.node;\n          this.uploaded ? this.updatePbrBuffer(e) : $f(e, t, !0);\n        }\n        for (const t of e) Gf(t.node);\n        this.uploaded = !0, this.needsUpload = !1;\n      }\n      updatePbrBuffer(t) {\n        let e = !1;\n        if (!t.meshes) return e;\n        for (const r of t.meshes) r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);\n        return e;\n      }\n      needsReEvaluation(t, e, r) {\n        const n = t.transform.projectionOptions,\n          i = t.style.getBrightness(),\n          s = this.brightness !== i;\n        if (!this.uploaded || this.dirty || n.name !== this.projection.name || mv(r.paint.get(\"model-color\").value, s) || mv(r.paint.get(\"model-color-mix-intensity\").value, s) || mv(r.paint.get(\"model-roughness\").value, s) || mv(r.paint.get(\"model-emissive-strength\").value, s) || mv(r.paint.get(\"model-height-based-emissive-strength-multiplier\").value, s)) {\n          this.projection = n, this.brightness = i;\n          const t = this.getNodesInfo();\n          for (const e of t) e.state = null;\n          return !0;\n        }\n        return !1;\n      }\n      evaluateTransform(t, e) {\n        if (t.transform.zoom === this.zoom) return;\n        this.zoom = t.transform.zoom;\n        const r = this.getNodesInfo(),\n          n = this.id.canonical;\n        for (const t of r) {\n          const r = t.feature;\n          t.evaluatedTranslation = e.paint.get(\"model-translation\").evaluate(r, {}, n), t.evaluatedScale = e.paint.get(\"model-scale\").evaluate(r, {}, n);\n        }\n      }\n      evaluate(t, e) {\n        const r = this.getNodesInfo();\n        for (const n of r) {\n          if (!n.node.meshes) continue;\n          const r = n.feature,\n            i = e && e[r.id];\n          if (_t(i, n.state)) continue;\n          n.state = structuredClone(i);\n          const s = n.node.meshes && n.node.meshes[0].featureData,\n            o = n.evaluatedColor[2],\n            a = n.evaluatedRMEA[2],\n            l = this.id.canonical;\n          if (n.hasTranslucentParts = !1, s) {\n            for (let e = 0; e < pv.length; e++) {\n              const s = pv[e];\n              s.length && (r.properties.part = s);\n              const o = t.paint.get(\"model-color\").evaluate(r, i, l).toPremultipliedRenderColor(null),\n                a = t.paint.get(\"model-color-mix-intensity\").evaluate(r, i, l);\n              n.evaluatedColor[e] = [o.r, o.g, o.b, a], n.evaluatedRMEA[e][0] = t.paint.get(\"model-roughness\").evaluate(r, i, l), n.evaluatedRMEA[e][2] = t.paint.get(\"model-emissive-strength\").evaluate(r, i, l), n.evaluatedRMEA[e][3] = o.a, n.emissionHeightBasedParams[e] = t.paint.get(\"model-height-based-emissive-strength-multiplier\").evaluate(r, i, l), !n.hasTranslucentParts && o.a < 1 && (n.hasTranslucentParts = !0);\n            }\n            delete r.properties.part, gv(n, o !== n.evaluatedColor[2] || a !== n.evaluatedRMEA[2], this.modelTraits);\n          } else n.evaluatedRMEA[0][2] = t.paint.get(\"model-emissive-strength\").evaluate(r, i, l);\n          n.evaluatedTranslation = t.paint.get(\"model-translation\").evaluate(r, i, l), n.evaluatedScale = t.paint.get(\"model-scale\").evaluate(r, i, l), this.updatePbrBuffer(n.node) || (this.needsUpload = !0);\n        }\n        this.dirty = !1;\n      }\n      elevationUpdate(t, e, r, n) {\n        const i = t.findDEMTileFor(r);\n        if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {\n          if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {\n            this.elevationReadFromZ = i.tileID.overscaledZ;\n            const e = av.create(t, r, i);\n            if (!e) return;\n            this.modelTraits & Of.HasMapboxMeshFeatures && this.updateDEM(t, e, r, n);\n            for (const t of this.getNodesInfo()) {\n              const r = t.node;\n              if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;\n              const n = r.footprint.vertices;\n              let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);\n              for (let t = 1; t < n.length; t++) i = Math.min(i, e.getElevationAt(n[t].x, n[t].y, !0, !0));\n              r.elevation = i;\n            }\n          }\n          this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;\n        }\n      }\n      updateDEM(t, e, r, n) {\n        let i = e._dem._modifiedForSources[n];\n        if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;\n        const s = e._dem.dim;\n        i.push(r.canonical);\n        let o = !1;\n        for (const t of this.getNodesInfo()) {\n          const r = t.node;\n          if (!r.footprint || !r.footprint.grid) continue;\n          const n = r.footprint.grid,\n            i = e.tileCoordToPixel(n.min.x, n.min.y),\n            a = e.tileCoordToPixel(n.max.x, n.max.y),\n            l = Math.min(Math.min(s - a.y, i.x), Math.min(i.y, s - a.x));\n          if (l < 0) continue;\n          const u = Tt(l, 2, 5);\n          let c = Math.max(0, i.x - u),\n            h = Math.max(0, i.y - u),\n            p = Math.min(a.x + u, s - 1),\n            d = Math.min(a.y + u, s - 1);\n          for (let t = h; t <= d; ++t) for (let e = c; e <= p; ++e) uv[t * s + e] = 255;\n          let f = 0,\n            m = 0;\n          for (let t = 0; t < n.cellsY; ++t) for (let r = 0; r < n.cellsX; ++r) {\n            if (!n.cells[t * n.cellsX + r]) continue;\n            const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t / n.yScale),\n              o = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t + 1) / n.yScale);\n            for (let t = i.y; t <= Math.min(o.y + 1, s - 1); ++t) for (let r = i.x; r <= Math.min(o.x + 1, s - 1); ++r) 255 === uv[t * s + r] && (uv[t * s + r] = 0, f += e.getElevationAtPixel(r, t), m++);\n          }\n          const y = f / m;\n          c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(a.x + u, s - 2), d = Math.min(a.y + u, s - 2), o = !0;\n          for (let t = h; t <= d; ++t) for (let r = c; r <= p; ++r) 0 === uv[t * s + r] && (lv[t * s + r] = e._dem.set(r, t, y));\n          for (let t = 1; t < u; ++t) {\n            c = Math.max(1, i.x - t), h = Math.max(1, i.y - t), p = Math.min(a.x + t, s - 2), d = Math.min(a.y + t, s - 2);\n            for (let r = h; r <= d; ++r) for (let n = c; n <= p; ++n) {\n              const i = r * s + n;\n              if (255 === uv[i]) {\n                let o = 0,\n                  a = 0,\n                  l = -1,\n                  c = -1;\n                for (let e = -1; e <= 1; ++e) for (let i = -1; i <= 1; ++i) {\n                  const u = (r + e) * s + n + i;\n                  if (uv[u] >= t) continue;\n                  const h = lv[u],\n                    p = Math.abs(h);\n                  p > a && (o = h, a = p, l = i, c = e);\n                }\n                if (a > .1) {\n                  const s = 1 - (t + .5 * Math.abs(l * c)) / u;\n                  let a = e._dem.get(n, r) + o * s;\n                  const h = e._dem.get(n + l, r + c),\n                    p = e._dem.get(n - l, r - c, !0);\n                  (a - h) * (a - p) > 0 && (a = (h + p) / 2), lv[i] = e._dem.set(n, r, a), uv[i] = t;\n                }\n              }\n            }\n          }\n        }\n        o && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = de.now());\n      }\n      setFilter(t) {\n        this.filter = t ? Lo(t) : null;\n      }\n      getNodesInfo() {\n        return this.filter ? this.nodesInfo.filter(t => this.filter.filter(new wo(this.id.overscaledZ, {\n          worldview: this.worldview\n        }), t.feature, this.id.canonical)) : this.nodesInfo;\n      }\n      destroy() {\n        const t = this.getNodesInfo();\n        for (const e of t) Gf(e.node), Hf(e.node);\n      }\n      isEmpty() {\n        return !this.nodesInfo.length;\n      }\n      updateReplacement(t, e) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const r = e.getReplacementRegionsForTile(t.toUnwrapped());\n        for (const t of this.getNodesInfo()) {\n          const e = t.node.footprint;\n          t.hiddenByReplacement = !!e && !r.find(t => t.footprint === e);\n        }\n      }\n      getHeightAtTileCoord(t, e) {\n        const r = [],\n          n = [0, 0, 0],\n          i = l([]);\n        for (const s of this.getNodesInfo()) {\n          const o = s.node.meshes[0],\n            a = o.transformedAabb;\n          if (t < a.min[0] || e < a.min[1] || t > a.max[0] || e > a.max[1]) continue;\n          if (!0 === s.node.hidden) return {\n            height: 1 / 0,\n            maxHeight: s.feature.properties.height,\n            hidden: !1,\n            verticalScale: s.evaluatedScale[2]\n          };\n          u(i, s.node.matrix), n[0] = t, n[1] = e, O(n, n, i);\n          const l = (n[0] - o.aabb.min[0]) / (o.aabb.max[0] - o.aabb.min[0]) * Lf | 0,\n            c = Math.min(63, (n[1] - o.aabb.min[1]) / (o.aabb.max[1] - o.aabb.min[1]) * Lf | 0) * Lf + Math.min(63, l),\n            h = o.heightmap[c];\n          if (!(h < 0 && s.node.footprint)) {\n            if (s.hiddenByReplacement) return;\n            return {\n              height: h,\n              maxHeight: s.feature.properties.height,\n              hidden: !1,\n              verticalScale: s.evaluatedScale[2]\n            };\n          }\n          if (s.node.footprint.grid.query(new wt(t, e), new wt(t, e), r), r.length > 0) return {\n            height: void 0,\n            maxHeight: s.feature.properties.height,\n            hidden: s.hiddenByReplacement,\n            verticalScale: s.evaluatedScale[2]\n          };\n        }\n      }\n    }\n    function mv(t, e) {\n      return t instanceof Os && !t.isLightConstant && e;\n    }\n    function yv(t, e, r, n, i, s, o, a) {\n      let l = (61440 & e | (61440 & e) >> 4) >> 8,\n        u = (3840 & e | (3840 & e) >> 4) >> 4,\n        c = 240 & e | (240 & e) >> 4;\n      r[3] > 0 && (l = ur(l, 255 * r[0], r[3]), u = ur(u, 255 * r[1], r[3]), c = ur(c, 255 * r[2], r[3]));\n      const h = l << 8 | u,\n        p = c << 8 | Math.floor(255 * n[3]),\n        d = function (t) {\n          const e = Tt(t, 0, 2);\n          return Math.min(Math.round(.5 * e * 255), 255);\n        }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1],\n        f = Tt(i[0], 0, 1),\n        m = Tt(i[1], 0, 1),\n        y = Tt(i[2], 0, 1),\n        g = Tt(i[3], 0, 1);\n      let x, v, b, w;\n      if (f !== m && o !== s && m !== f) {\n        const t = o - s;\n        v = 1 / (t * (m - f)), b = -(s + t * f) / (t * (m - f));\n        const e = Tt(i[4], -1, 1);\n        w = Math.pow(10, e), x = 255 * y << 8 | 255 * g;\n      } else x = 65535, v = 0, b = 1, w = 1;\n      if (t.emplaceBack(h, p, d, x, v, b, w), a) {\n        const t = a.length;\n        a.clear();\n        for (let e = 0; e < t; e++) a.emplaceBack(h, p, d, x, v, b, w);\n      }\n    }\n    function gv(t, e, r) {\n      const n = t.node;\n      let i = 0;\n      const s = r & Of.HasMeshoptCompression;\n      for (const r of n.meshes) {\n        if (n.lights && n.lightMeshIndex === i) continue;\n        if (!r.featureData) continue;\n        r.featureArray = new ja(), r.featureArray.reserve(r.featureData.length);\n        let o = e;\n        for (const e of r.featureData) {\n          const i = s ? 65535 & e : e >> 16 & 65535,\n            a = s ? e >> 16 & 65535 : 65535 & e,\n            l = (15 & a) < 8 ? 15 & a : 0,\n            u = t.evaluatedRMEA[l],\n            c = t.evaluatedColor[l],\n            h = t.emissionHeightBasedParams[l];\n          let p;\n          if (o && 2 === l && n.lights && (p = new ja(), p.resize(10 * n.lights.length)), yv(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && o) {\n            o = !1;\n            const t = n.meshes[n.lightMeshIndex];\n            t.featureArray = p, t.featureArray._trim();\n          }\n        }\n        r.featureArray._trim(), i++;\n      }\n    }\n    function xv(t, e, r, n) {\n      const i = 1 << t.z;\n      e.lat = lu((n / Rn + t.y) / i), e.lng = au((r / Rn + t.x) / i);\n    }\n    function vv(t, e, r, n) {\n      const i = t.getNodesInfo()[e];\n      if (!i || i.hiddenByReplacement || !i.node.meshes) return;\n      let s = Number.MAX_VALUE;\n      const o = i.node,\n        a = r.tile,\n        l = n.calculatePosMatrix(a.tileID.toUnwrapped(), n.worldSize),\n        u = i.evaluatedScale;\n      let d = 0;\n      n.elevation && o.elevation && (d = o.elevation * n.elevation.exaggeration()), h(l, l, [(o.anchor ? o.anchor[0] : 0) * (u[0] - 1), (o.anchor ? o.anchor[1] : 0) * (u[1] - 1), d]), p(l, l, u);\n      const f = r.queryGeometry,\n        m = f.isPointQuery() ? f.screenBounds : f.screenGeometry,\n        y = function (t) {\n          const e = c([], l, t.matrix);\n          c(e, n.expandedFarZProjMatrix, e);\n          for (let r = 0; r < t.meshes.length; ++r) {\n            const i = t.meshes[r];\n            if (r === t.lightMeshIndex) continue;\n            const o = Rf(m, n, e, i.aabb);\n            null != o && (s = Math.min(o, s));\n          }\n          if (t.children) for (const e of t.children) y(e);\n        };\n      if (y(o), s === Number.MAX_VALUE) return;\n      const g = new Ql(0, 0);\n      return xv(a.tileID.canonical, g, i.node.anchor[0], i.node.anchor[1]), {\n        intersectionZ: s,\n        position: g,\n        feature: i.feature\n      };\n    }\n    Ws(fv, \"Tiled3dModelBucket\", {\n      omit: [\"layers\"]\n    }), Ws(dv, \"Tiled3dModelFeature\");\n    const bv = {\n        circle: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: vc || (vc = new Vo({\n                \"circle-sort-key\": new To(Fo.layout_circle[\"circle-sort-key\"]),\n                \"circle-elevation-reference\": new Eo(Fo.layout_circle[\"circle-elevation-reference\"]),\n                visibility: new Eo(Fo.layout_circle.visibility)\n              })),\n              paint: bc || (bc = new Vo({\n                \"circle-radius\": new To(Fo.paint_circle[\"circle-radius\"]),\n                \"circle-color\": new To(Fo.paint_circle[\"circle-color\"]),\n                \"circle-blur\": new To(Fo.paint_circle[\"circle-blur\"]),\n                \"circle-opacity\": new To(Fo.paint_circle[\"circle-opacity\"]),\n                \"circle-translate\": new Eo(Fo.paint_circle[\"circle-translate\"]),\n                \"circle-translate-anchor\": new Eo(Fo.paint_circle[\"circle-translate-anchor\"]),\n                \"circle-pitch-scale\": new Eo(Fo.paint_circle[\"circle-pitch-scale\"]),\n                \"circle-pitch-alignment\": new Eo(Fo.paint_circle[\"circle-pitch-alignment\"]),\n                \"circle-stroke-width\": new To(Fo.paint_circle[\"circle-stroke-width\"]),\n                \"circle-stroke-color\": new To(Fo.paint_circle[\"circle-stroke-color\"]),\n                \"circle-stroke-opacity\": new To(Fo.paint_circle[\"circle-stroke-opacity\"]),\n                \"circle-emissive-strength\": new Eo(Fo.paint_circle[\"circle-emissive-strength\"]),\n                \"circle-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"circle-stroke-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n);\n          }\n          createBucket(t) {\n            return new Ju(t);\n          }\n          queryRadius(t) {\n            const e = t;\n            return mc(\"circle-radius\", this, e) + mc(\"circle-stroke-width\", this, e) + yc(this.paint.get(\"circle-translate\"));\n          }\n          queryIntersectsFeature(t, e, r, n, i, s, o, a) {\n            const l = xc(this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n              u = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r);\n            return ih(t, n, s, o, a, \"map\" === this.paint.get(\"circle-pitch-alignment\"), \"map\" === this.paint.get(\"circle-pitch-scale\"), l, u);\n          }\n          getProgramIds() {\n            return [\"circle\"];\n          }\n          getDefaultProgramParams(t, e, r) {\n            const n = nh(this);\n            return {\n              config: new Fl(this, {\n                zoom: e,\n                lut: r\n              }),\n              defines: n,\n              overrideFog: !1\n            };\n          }\n          is3D(t) {\n            return !t && !!this.layout && \"none\" !== this.layout.get(\"circle-elevation-reference\");\n          }\n          hasElevation() {\n            return this.layout && \"none\" !== this.layout.get(\"circle-elevation-reference\");\n          }\n        },\n        heatmap: class extends na {\n          createBucket(t) {\n            return new uh(t);\n          }\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: ch || (ch = new Vo({\n                visibility: new Eo(Fo.layout_heatmap.visibility)\n              })),\n              paint: hh || (hh = new Vo({\n                \"heatmap-radius\": new To(Fo.paint_heatmap[\"heatmap-radius\"]),\n                \"heatmap-weight\": new To(Fo.paint_heatmap[\"heatmap-weight\"]),\n                \"heatmap-intensity\": new Eo(Fo.paint_heatmap[\"heatmap-intensity\"]),\n                \"heatmap-color\": new Bo(Fo.paint_heatmap[\"heatmap-color\"]),\n                \"heatmap-opacity\": new Eo(Fo.paint_heatmap[\"heatmap-opacity\"]),\n                \"heatmap-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n), this._updateColorRamp();\n          }\n          _handleSpecialPaintPropertyUpdate(t) {\n            \"heatmap-color\" === t && this._updateColorRamp();\n          }\n          _updateColorRamp() {\n            this.colorRamp = bh({\n              expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n              evaluationKey: \"heatmapDensity\",\n              image: this.colorRamp\n            }), this.colorRampTexture = null;\n          }\n          resize() {\n            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n          }\n          _clear() {\n            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n          }\n          queryRadius(t) {\n            return mc(\"heatmap-radius\", this, t);\n          }\n          queryIntersectsFeature(t, e, r, n, i, s, o, a) {\n            const l = this.paint.get(\"heatmap-radius\").evaluate(e, r);\n            return ih(t, n, s, o, a, !0, !0, new wt(0, 0), l);\n          }\n          hasOffscreenPass() {\n            return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n          }\n          getProgramIds() {\n            return [\"heatmap\", \"heatmapTexture\"];\n          }\n          getDefaultProgramParams(t, e, r) {\n            return \"heatmap\" === t ? {\n              config: new Fl(this, {\n                zoom: e,\n                lut: r\n              }),\n              overrideFog: !1\n            } : {};\n          }\n        },\n        hillshade: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: ph || (ph = new Vo({\n                visibility: new Eo(Fo.layout_hillshade.visibility)\n              })),\n              paint: dh || (dh = new Vo({\n                \"hillshade-illumination-direction\": new Eo(Fo.paint_hillshade[\"hillshade-illumination-direction\"]),\n                \"hillshade-illumination-anchor\": new Eo(Fo.paint_hillshade[\"hillshade-illumination-anchor\"]),\n                \"hillshade-exaggeration\": new Eo(Fo.paint_hillshade[\"hillshade-exaggeration\"]),\n                \"hillshade-shadow-color\": new Eo(Fo.paint_hillshade[\"hillshade-shadow-color\"]),\n                \"hillshade-highlight-color\": new Eo(Fo.paint_hillshade[\"hillshade-highlight-color\"]),\n                \"hillshade-accent-color\": new Eo(Fo.paint_hillshade[\"hillshade-accent-color\"]),\n                \"hillshade-emissive-strength\": new Eo(Fo.paint_hillshade[\"hillshade-emissive-strength\"]),\n                \"hillshade-shadow-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"hillshade-highlight-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"hillshade-accent-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n);\n          }\n          shouldRedrape() {\n            return this.hasOffscreenPass() && \"viewport\" === this.paint.get(\"hillshade-illumination-anchor\");\n          }\n          hasOffscreenPass() {\n            return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n          }\n          getProgramIds() {\n            return [\"hillshade\", \"hillshadePrepare\"];\n          }\n          getDefaultProgramParams(t, e, r) {\n            return {\n              overrideFog: !1\n            };\n          }\n        },\n        fill: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: yp || (yp = new Vo({\n                \"fill-sort-key\": new To(Fo.layout_fill[\"fill-sort-key\"]),\n                visibility: new Eo(Fo.layout_fill.visibility),\n                \"fill-elevation-reference\": new Eo(Fo.layout_fill[\"fill-elevation-reference\"]),\n                \"fill-construct-bridge-guard-rail\": new To(Fo.layout_fill[\"fill-construct-bridge-guard-rail\"])\n              })),\n              paint: gp || (gp = new Vo({\n                \"fill-antialias\": new Eo(Fo.paint_fill[\"fill-antialias\"]),\n                \"fill-opacity\": new To(Fo.paint_fill[\"fill-opacity\"]),\n                \"fill-color\": new To(Fo.paint_fill[\"fill-color\"]),\n                \"fill-outline-color\": new To(Fo.paint_fill[\"fill-outline-color\"]),\n                \"fill-translate\": new Eo(Fo.paint_fill[\"fill-translate\"]),\n                \"fill-translate-anchor\": new Eo(Fo.paint_fill[\"fill-translate-anchor\"]),\n                \"fill-pattern\": new To(Fo.paint_fill[\"fill-pattern\"]),\n                \"fill-pattern-cross-fade\": new Eo(Fo.paint_fill[\"fill-pattern-cross-fade\"]),\n                \"fill-emissive-strength\": new Eo(Fo.paint_fill[\"fill-emissive-strength\"]),\n                \"fill-z-offset\": new To(Fo.paint_fill[\"fill-z-offset\"]),\n                \"fill-bridge-guard-rail-color\": new To(Fo.paint_fill[\"fill-bridge-guard-rail-color\"]),\n                \"fill-tunnel-structure-color\": new To(Fo.paint_fill[\"fill-tunnel-structure-color\"]),\n                \"fill-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"fill-outline-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"fill-bridge-guard-rail-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"fill-tunnel-structure-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n);\n          }\n          getProgramIds() {\n            const t = this.paint.get(\"fill-pattern\"),\n              e = t && t.constantOr(1),\n              r = [e ? \"fillPattern\" : \"fill\"];\n            return this.paint.get(\"fill-antialias\") && r.push(e && !this.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\"), r;\n          }\n          getDefaultProgramParams(t, e, r) {\n            return {\n              config: new Fl(this, {\n                zoom: e,\n                lut: r\n              }),\n              overrideFog: !1\n            };\n          }\n          recalculate(t, e) {\n            super.recalculate(t, e);\n            const r = this.paint._values[\"fill-outline-color\"];\n            \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n          }\n          createBucket(t) {\n            return new mp(t);\n          }\n          queryRadius() {\n            return yc(this.paint.get(\"fill-translate\"));\n          }\n          queryIntersectsFeature(t, e, r, n, i, s) {\n            return !t.queryGeometry.isAboveHorizon && ec(gc(t.tilespaceGeometry, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor), n);\n          }\n          isTileClipped() {\n            return 0 === this.paint.get(\"fill-z-offset\").constantOr(1);\n          }\n          is3D(t) {\n            if (0 !== this.paint.get(\"fill-z-offset\").constantOr(1)) return !0;\n            const e = this.layout && \"none\" !== this.layout.get(\"fill-elevation-reference\");\n            return null != t ? e && !t : e;\n          }\n          hasElevation() {\n            return this.layout && \"none\" !== this.layout.get(\"fill-elevation-reference\");\n          }\n          hasShadowPass() {\n            return this.layout && \"none\" !== this.layout.get(\"fill-elevation-reference\");\n          }\n        },\n        \"fill-extrusion\": class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: bd || (bd = new Vo({\n                visibility: new Eo(Fo[\"layout_fill-extrusion\"].visibility),\n                \"fill-extrusion-edge-radius\": new Eo(Fo[\"layout_fill-extrusion\"][\"fill-extrusion-edge-radius\"])\n              })),\n              paint: wd || (wd = new Vo({\n                \"fill-extrusion-opacity\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n                \"fill-extrusion-color\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n                \"fill-extrusion-translate\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n                \"fill-extrusion-translate-anchor\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n                \"fill-extrusion-pattern\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n                \"fill-extrusion-pattern-cross-fade\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-pattern-cross-fade\"]),\n                \"fill-extrusion-height\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n                \"fill-extrusion-base\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n                \"fill-extrusion-height-alignment\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-height-alignment\"]),\n                \"fill-extrusion-base-alignment\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-base-alignment\"]),\n                \"fill-extrusion-vertical-gradient\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"]),\n                \"fill-extrusion-ambient-occlusion-intensity\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-intensity\"]),\n                \"fill-extrusion-ambient-occlusion-radius\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-radius\"]),\n                \"fill-extrusion-ambient-occlusion-wall-radius\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-wall-radius\"]),\n                \"fill-extrusion-ambient-occlusion-ground-radius\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-ground-radius\"]),\n                \"fill-extrusion-ambient-occlusion-ground-attenuation\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-ground-attenuation\"]),\n                \"fill-extrusion-flood-light-color\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-color\"]),\n                \"fill-extrusion-flood-light-intensity\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-intensity\"]),\n                \"fill-extrusion-flood-light-wall-radius\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-wall-radius\"]),\n                \"fill-extrusion-flood-light-ground-radius\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-ground-radius\"]),\n                \"fill-extrusion-flood-light-ground-attenuation\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-ground-attenuation\"]),\n                \"fill-extrusion-vertical-scale\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-scale\"]),\n                \"fill-extrusion-rounded-roof\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-rounded-roof\"]),\n                \"fill-extrusion-cutoff-fade-range\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-cutoff-fade-range\"]),\n                \"fill-extrusion-emissive-strength\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-emissive-strength\"]),\n                \"fill-extrusion-line-width\": new To(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-line-width\"]),\n                \"fill-extrusion-cast-shadows\": new Eo(Fo[\"paint_fill-extrusion\"][\"fill-extrusion-cast-shadows\"]),\n                \"fill-extrusion-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"fill-extrusion-flood-light-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n), this._stats = {\n              numRenderedVerticesInShadowPass: 0,\n              numRenderedVerticesInTransparentPass: 0\n            };\n          }\n          createBucket(t) {\n            return new ud(t);\n          }\n          queryRadius() {\n            return yc(this.paint.get(\"fill-extrusion-translate\"));\n          }\n          is3D(t) {\n            return !0;\n          }\n          hasShadowPass() {\n            return this.paint.get(\"fill-extrusion-cast-shadows\");\n          }\n          cutoffRange() {\n            return this.paint.get(\"fill-extrusion-cutoff-fade-range\");\n          }\n          canCastShadows() {\n            return !0;\n          }\n          getProgramIds() {\n            return [this.paint.get(\"fill-extrusion-pattern\").constantOr(1) ? \"fillExtrusionPattern\" : \"fillExtrusion\"];\n          }\n          queryIntersectsFeature(t, e, r, n, i, s, o, a, l) {\n            const u = xc(this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n              c = this.paint.get(\"fill-extrusion-height\").evaluate(e, r),\n              h = this.paint.get(\"fill-extrusion-base\").evaluate(e, r),\n              p = [0, 0],\n              d = a && s.elevation,\n              f = s.elevation ? s.elevation.exaggeration() : 1,\n              m = t.tile.getBucket(this);\n            if (d && m instanceof ud) {\n              const t = m.centroidVertexArray,\n                e = l + 1;\n              e < t.length && (p[0] = t.geta_centroid_pos0(e), p[1] = t.geta_centroid_pos1(e));\n            }\n            if (0 === p[0] && 1 === p[1]) return !1;\n            \"globe\" === s.projection.name && (n = xd([n], [new wt(0, 0), new wt(Rn, Rn)], t.tileID.canonical).map(t => t.polygon).flat());\n            const y = d ? a : null,\n              [g, x] = function (t, e, r, n, i, s, o, a, l, u, c) {\n                return \"globe\" === t.projection.name ? function (t, e, r, n, i, s, o, a, l, u, c) {\n                  const h = [],\n                    p = [],\n                    d = t.projection.upVectorScale(c, t.center.lat, t.worldSize).metersToTile,\n                    f = [0, 0, 0, 1],\n                    m = [0, 0, 0, 1],\n                    y = (t, e, r, n) => {\n                      t[0] = e, t[1] = r, t[2] = n, t[3] = 1;\n                    },\n                    g = gd();\n                  r > 0 && (r += g), n += g;\n                  for (const g of e) {\n                    const e = [],\n                      x = [];\n                    for (const h of g) {\n                      const p = h.x + i.x,\n                        g = h.y + i.y,\n                        v = t.projection.projectTilePoint(p, g, c),\n                        b = t.projection.upVector(c, h.x, h.y);\n                      let w = r,\n                        _ = n;\n                      if (o) {\n                        const t = Td(p, g, r, n, o, a, l, u);\n                        w += t.base, _ += t.top;\n                      }\n                      0 !== r ? y(f, v.x + b[0] * d * w, v.y + b[1] * d * w, v.z + b[2] * d * w) : y(f, v.x, v.y, v.z), y(m, v.x + b[0] * d * _, v.y + b[1] * d * _, v.z + b[2] * d * _), O(f, f, s), O(m, m, s), e.push(new _d(f[0], f[1], f[2])), x.push(new _d(m[0], m[1], m[2]));\n                    }\n                    h.push(e), p.push(x);\n                  }\n                  return [h, p];\n                }(t, e, r, n, i, s, o, a, l, u, c) : o ? function (t, e, r, n, i, s, o, a, l) {\n                  const u = [],\n                    c = [],\n                    h = [0, 0, 0, 1];\n                  for (const p of t) {\n                    const t = [],\n                      d = [];\n                    for (const u of p) {\n                      const c = u.x + n.x,\n                        p = u.y + n.y,\n                        f = Td(c, p, e, r, s, o, a, l);\n                      h[0] = c, h[1] = p, h[2] = f.base, h[3] = 1, Y(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                      const m = new _d(h[0] / h[3], h[1] / h[3], h[2] / h[3]);\n                      h[0] = c, h[1] = p, h[2] = f.top, h[3] = 1, Y(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                      const y = new _d(h[0] / h[3], h[1] / h[3], h[2] / h[3]);\n                      t.push(m), d.push(y);\n                    }\n                    u.push(t), c.push(d);\n                  }\n                  return [u, c];\n                }(e, r, n, i, s, o, a, l, u) : function (t, e, r, n, i) {\n                  const s = [],\n                    o = [],\n                    a = i[8] * e,\n                    l = i[9] * e,\n                    u = i[10] * e,\n                    c = i[11] * e,\n                    h = i[8] * r,\n                    p = i[9] * r,\n                    d = i[10] * r,\n                    f = i[11] * r;\n                  for (const e of t) {\n                    const t = [],\n                      r = [];\n                    for (const s of e) {\n                      const e = s.x + n.x,\n                        o = s.y + n.y,\n                        m = i[0] * e + i[4] * o + i[12],\n                        y = i[1] * e + i[5] * o + i[13],\n                        g = i[2] * e + i[6] * o + i[14],\n                        x = i[3] * e + i[7] * o + i[15],\n                        v = m + a,\n                        b = y + l,\n                        w = g + u,\n                        _ = Math.max(x + c, 1e-5),\n                        A = m + h,\n                        M = y + p,\n                        I = g + d,\n                        S = Math.max(x + f, 1e-5);\n                      t.push(new _d(v / _, b / _, w / _)), r.push(new _d(A / S, M / S, I / S));\n                    }\n                    s.push(t), o.push(r);\n                  }\n                  return [s, o];\n                }(e, r, n, i, s);\n              }(s, n, h, c, u, o, y, p, f, s.center.lat, t.tileID.canonical),\n              v = t.queryGeometry;\n            return function (t, e, r) {\n              let n = 1 / 0;\n              ec(r, e) && (n = Ed(r, e[0]));\n              for (let i = 0; i < e.length; i++) {\n                const s = e[i],\n                  o = t[i];\n                for (let t = 0; t < s.length - 1; t++) {\n                  const e = s[t],\n                    i = [e, s[t + 1], o[t + 1], o[t], e];\n                  Qu(r, i) && (n = Math.min(n, Ed(r, i)));\n                }\n              }\n              return n !== 1 / 0 && n;\n            }(g, x, v.isPointQuery() ? v.screenBounds : v.screenGeometry);\n          }\n        },\n        building: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: xm || (xm = new Vo({\n                visibility: new Eo(Fo.layout_building.visibility),\n                \"building-facade\": new To(Fo.layout_building[\"building-facade\"]),\n                \"building-facade-floors\": new To(Fo.layout_building[\"building-facade-floors\"]),\n                \"building-facade-unit-width\": new To(Fo.layout_building[\"building-facade-unit-width\"]),\n                \"building-facade-window\": new To(Fo.layout_building[\"building-facade-window\"]),\n                \"building-roof-shape\": new To(Fo.layout_building[\"building-roof-shape\"]),\n                \"building-height\": new To(Fo.layout_building[\"building-height\"]),\n                \"building-base\": new To(Fo.layout_building[\"building-base\"]),\n                \"building-flood-light-wall-radius\": new To(Fo.layout_building[\"building-flood-light-wall-radius\"]),\n                \"building-flood-light-ground-radius\": new To(Fo.layout_building[\"building-flood-light-ground-radius\"]),\n                \"building-flip-roof-orientation\": new To(Fo.layout_building[\"building-flip-roof-orientation\"])\n              })),\n              paint: vm || (vm = new Vo({\n                \"building-opacity\": new Eo(Fo.paint_building[\"building-opacity\"]),\n                \"building-ambient-occlusion-intensity\": new Eo(Fo.paint_building[\"building-ambient-occlusion-intensity\"]),\n                \"building-ambient-occlusion-ground-intensity\": new Eo(Fo.paint_building[\"building-ambient-occlusion-ground-intensity\"]),\n                \"building-ambient-occlusion-ground-radius\": new Eo(Fo.paint_building[\"building-ambient-occlusion-ground-radius\"]),\n                \"building-ambient-occlusion-ground-attenuation\": new Eo(Fo.paint_building[\"building-ambient-occlusion-ground-attenuation\"]),\n                \"building-vertical-scale\": new Eo(Fo.paint_building[\"building-vertical-scale\"]),\n                \"building-cast-shadows\": new Eo(Fo.paint_building[\"building-cast-shadows\"]),\n                \"building-color\": new To(Fo.paint_building[\"building-color\"]),\n                \"building-emissive-strength\": new To(Fo.paint_building[\"building-emissive-strength\"]),\n                \"building-facade-emissive-chance\": new Eo(Fo.paint_building[\"building-facade-emissive-chance\"]),\n                \"building-cutoff-fade-range\": new Eo(Fo.paint_building[\"building-cutoff-fade-range\"]),\n                \"building-flood-light-color\": new Eo(Fo.paint_building[\"building-flood-light-color\"]),\n                \"building-flood-light-intensity\": new Eo(Fo.paint_building[\"building-flood-light-intensity\"]),\n                \"building-flood-light-ground-attenuation\": new Eo(Fo.paint_building[\"building-flood-light-ground-attenuation\"]),\n                \"building-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"building-flood-light-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n), this._stats = {\n              numRenderedVerticesInShadowPass: 0,\n              numRenderedVerticesInTransparentPass: 0\n            };\n          }\n          createBucket(t) {\n            return new ym(t);\n          }\n          cutoffRange() {\n            return this.paint.get(\"building-cutoff-fade-range\");\n          }\n          hasShadowPass() {\n            return this.paint.get(\"building-cast-shadows\");\n          }\n          hasLightBeamPass() {\n            return !0;\n          }\n          canCastShadows() {\n            return !0;\n          }\n          is3D(t) {\n            return !0;\n          }\n        },\n        line: class extends na {\n          constructor(t, e, r, n) {\n            const i = jm();\n            super(t, i, e, r, n), i.layout && (this.layout = new zo(i.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;\n          }\n          _handleSpecialPaintPropertyUpdate(t) {\n            if (\"line-gradient\" === t) {\n              const t = this._transitionablePaint._values[\"line-gradient\"].value.expression;\n              this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Si, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;\n            }\n          }\n          gradientExpression() {\n            return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n          }\n          widthExpression() {\n            return this._transitionablePaint._values[\"line-width\"].value.expression;\n          }\n          recalculate(t, e) {\n            super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = (() => {\n              if (Gm) return Gm;\n              const t = jm();\n              return Gm = new $m(t.paint.properties[\"line-width\"].specification), Gm.useIntegerZoom = !0, Gm;\n            })().possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n          }\n          createBucket(t) {\n            return new Tm(t);\n          }\n          getProgramIds() {\n            return [this.paint.get(\"line-pattern\").constantOr(1) ? \"linePattern\" : \"line\"];\n          }\n          getDefaultProgramParams(t, e, r) {\n            const n = Om(this);\n            return {\n              config: new Fl(this, {\n                zoom: e,\n                lut: r\n              }),\n              defines: n,\n              overrideFog: !1\n            };\n          }\n          queryRadius(t) {\n            const e = t,\n              r = Hm(mc(\"line-width\", this, e), mc(\"line-gap-width\", this, e)),\n              n = mc(\"line-offset\", this, e);\n            return r / 2 + Math.abs(n) + yc(this.paint.get(\"line-translate\"));\n          }\n          queryIntersectsFeature(t, e, r, n, i, s) {\n            if (t.queryGeometry.isAboveHorizon) return !1;\n            const o = gc(t.tilespaceGeometry, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n              a = t.pixelToTileUnitsFactor / 2 * Hm(this.paint.get(\"line-width\").evaluate(e, r), this.paint.get(\"line-gap-width\").evaluate(e, r)),\n              l = this.paint.get(\"line-offset\").evaluate(e, r);\n            return l && (n = function (t, e) {\n              const r = [],\n                n = new wt(0, 0);\n              for (let i = 0; i < t.length; i++) {\n                const s = t[i],\n                  o = [];\n                for (let t = 0; t < s.length; t++) {\n                  const r = s[t],\n                    i = s[t + 1],\n                    a = 0 === t ? n : r.sub(s[t - 1])._unit()._perp(),\n                    l = t === s.length - 1 ? n : i.sub(r)._unit()._perp(),\n                    u = a._add(l)._unit();\n                  u._mult(1 / (u.x * l.x + u.y * l.y)), o.push(u._mult(e)._add(r));\n                }\n                r.push(o);\n              }\n              return r;\n            }(n, l * t.pixelToTileUnitsFactor)), function (t, e, r) {\n              for (let n = 0; n < e.length; n++) {\n                const i = e[n];\n                if (t.length >= 3) for (let e = 0; e < i.length; e++) if (cc(t, i[e])) return !0;\n                if (rc(t, i, r)) return !0;\n              }\n              return !1;\n            }(o, n, a);\n          }\n          isTileClipped() {\n            return this.hasNonElevatedBuckets;\n          }\n          isDraped(t) {\n            return !this.hasElevatedBuckets || this.layout && \"hd-road-markup\" === this.layout.get(\"line-elevation-reference\");\n          }\n          hasElevation() {\n            return this.layout && \"none\" !== this.layout.get(\"line-elevation-reference\");\n          }\n        },\n        symbol: Vx,\n        background: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: Fx || (Fx = new Vo({\n                visibility: new Eo(Fo.layout_background.visibility)\n              })),\n              paint: Cx || (Cx = new Vo({\n                \"background-pitch-alignment\": new Eo(Fo.paint_background[\"background-pitch-alignment\"]),\n                \"background-color\": new Eo(Fo.paint_background[\"background-color\"]),\n                \"background-pattern\": new Eo(Fo.paint_background[\"background-pattern\"]),\n                \"background-opacity\": new Eo(Fo.paint_background[\"background-opacity\"]),\n                \"background-emissive-strength\": new Eo(Fo.paint_background[\"background-emissive-strength\"]),\n                \"background-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n);\n          }\n          getProgramIds() {\n            return [this.paint.get(\"background-pattern\") ? \"backgroundPattern\" : \"background\"];\n          }\n          getDefaultProgramParams(t, e, r) {\n            return {\n              overrideFog: !1\n            };\n          }\n          is3D(t) {\n            return \"viewport\" === this.paint.get(\"background-pitch-alignment\");\n          }\n        },\n        raster: Gx,\n        \"raster-particle\": Yx,\n        sky: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: Xx || (Xx = new Vo({\n                visibility: new Eo(Fo.layout_sky.visibility)\n              })),\n              paint: Zx || (Zx = new Vo({\n                \"sky-type\": new Eo(Fo.paint_sky[\"sky-type\"]),\n                \"sky-atmosphere-sun\": new Eo(Fo.paint_sky[\"sky-atmosphere-sun\"]),\n                \"sky-atmosphere-sun-intensity\": new Eo(Fo.paint_sky[\"sky-atmosphere-sun-intensity\"]),\n                \"sky-gradient-center\": new Eo(Fo.paint_sky[\"sky-gradient-center\"]),\n                \"sky-gradient-radius\": new Eo(Fo.paint_sky[\"sky-gradient-radius\"]),\n                \"sky-gradient\": new Bo(Fo.paint_sky[\"sky-gradient\"]),\n                \"sky-atmosphere-halo-color\": new Eo(Fo.paint_sky[\"sky-atmosphere-halo-color\"]),\n                \"sky-atmosphere-color\": new Eo(Fo.paint_sky[\"sky-atmosphere-color\"]),\n                \"sky-opacity\": new Eo(Fo.paint_sky[\"sky-opacity\"]),\n                \"sky-gradient-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"sky-atmosphere-halo-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                }),\n                \"sky-atmosphere-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n), this._updateColorRamp();\n          }\n          _clear() {\n            this.skyboxFbo && (this.skyboxFbo.destroy(), this.skyboxFbo = null), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null), this._skyboxInvalidated = !0;\n          }\n          _handleSpecialPaintPropertyUpdate(t) {\n            \"sky-gradient\" === t ? this._updateColorRamp() : \"sky-atmosphere-sun\" !== t && \"sky-atmosphere-halo-color\" !== t && \"sky-atmosphere-color\" !== t && \"sky-atmosphere-sun-intensity\" !== t || (this._skyboxInvalidated = !0);\n          }\n          _updateColorRamp() {\n            this.colorRamp = bh({\n              expression: this._transitionablePaint._values[\"sky-gradient\"].value.expression,\n              evaluationKey: \"skyRadialProgress\"\n            }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n          }\n          needsSkyboxCapture(t) {\n            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;\n            if (!this.paint.get(\"sky-atmosphere-sun\")) {\n              const e = t.style.light.properties.get(\"position\");\n              return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;\n            }\n            return !1;\n          }\n          getCenter(t, e) {\n            if (\"atmosphere\" === this.paint.get(\"sky-type\")) {\n              const r = this.paint.get(\"sky-atmosphere-sun\"),\n                n = !r,\n                i = t.style.light,\n                s = i.properties.get(\"position\");\n              return n && \"viewport\" === i.properties.get(\"anchor\") && Gt(\"The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.\"), n ? Jx(s.azimuthal, 90 - s.polar, e) : Jx(r[0], 90 - r[1], e);\n            }\n            const r = this.paint.get(\"sky-gradient-center\");\n            return Jx(r[0], 90 - r[1], e);\n          }\n          isSky() {\n            return !0;\n          }\n          markSkyboxValid(t) {\n            this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get(\"position\");\n          }\n          hasOffscreenPass() {\n            return !0;\n          }\n          getProgramIds() {\n            const t = this.paint.get(\"sky-type\");\n            return \"atmosphere\" === t ? [\"skyboxCapture\", \"skybox\"] : \"gradient\" === t ? [\"skyboxGradient\"] : null;\n          }\n        },\n        slot: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              paint: Wx || (Wx = new Vo({}))\n            }, e, null);\n          }\n        },\n        model: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: sv || (sv = new Vo({\n                visibility: new Eo(Fo.layout_model.visibility),\n                \"model-id\": new To(Fo.layout_model[\"model-id\"])\n              })),\n              paint: ov || (ov = new Vo({\n                \"model-opacity\": new To(Fo.paint_model[\"model-opacity\"]),\n                \"model-rotation\": new To(Fo.paint_model[\"model-rotation\"]),\n                \"model-scale\": new To(Fo.paint_model[\"model-scale\"]),\n                \"model-translation\": new To(Fo.paint_model[\"model-translation\"]),\n                \"model-color\": new To(Fo.paint_model[\"model-color\"]),\n                \"model-color-mix-intensity\": new To(Fo.paint_model[\"model-color-mix-intensity\"]),\n                \"model-type\": new Eo(Fo.paint_model[\"model-type\"]),\n                \"model-cast-shadows\": new Eo(Fo.paint_model[\"model-cast-shadows\"]),\n                \"model-receive-shadows\": new Eo(Fo.paint_model[\"model-receive-shadows\"]),\n                \"model-ambient-occlusion-intensity\": new Eo(Fo.paint_model[\"model-ambient-occlusion-intensity\"]),\n                \"model-emissive-strength\": new To(Fo.paint_model[\"model-emissive-strength\"]),\n                \"model-roughness\": new To(Fo.paint_model[\"model-roughness\"]),\n                \"model-height-based-emissive-strength-multiplier\": new To(Fo.paint_model[\"model-height-based-emissive-strength-multiplier\"]),\n                \"model-cutoff-fade-range\": new Eo(Fo.paint_model[\"model-cutoff-fade-range\"]),\n                \"model-front-cutoff\": new Eo(Fo.paint_model[\"model-front-cutoff\"]),\n                \"model-elevation-reference\": new Eo(Fo.paint_model[\"model-elevation-reference\"]),\n                \"model-color-use-theme\": new To({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-driven\"\n                })\n              }))\n            }, e, r, n), this._stats = {\n              numRenderedVerticesInShadowPass: 0,\n              numRenderedVerticesInTransparentPass: 0\n            };\n          }\n          createBucket(t) {\n            return new iv(t);\n          }\n          getProgramIds() {\n            return [\"model\"];\n          }\n          is3D(t) {\n            return !0;\n          }\n          hasShadowPass() {\n            return !0;\n          }\n          canCastShadows() {\n            return !0;\n          }\n          hasLightBeamPass() {\n            return !0;\n          }\n          cutoffRange() {\n            return this.paint.get(\"model-cutoff-fade-range\");\n          }\n          queryRadius(t) {\n            return t instanceof fv ? Rn - 1 : 0;\n          }\n          queryIntersectsFeature(t, e, r, n, i, s) {\n            if (!this.modelManager) return !1;\n            const o = this.modelManager,\n              l = t.tile.getBucket(this);\n            if (!(l && l instanceof iv)) return !1;\n            for (const r in l.instancesPerModel) {\n              const n = l.instancesPerModel[r],\n                i = void 0 !== e.id ? e.id : e.properties && e.properties.hasOwnProperty(\"id\") ? e.properties.id : void 0;\n              if (n.idToFeaturesIndex.hasOwnProperty(i)) {\n                const e = n.features[n.idToFeaturesIndex[i]],\n                  u = o.getModel(r, this.scope);\n                if (!u) return !1;\n                let h = a();\n                const p = new Ql(0, 0),\n                  d = l.canonical;\n                let f = Number.MAX_VALUE;\n                for (let r = 0; r < e.instancedDataCount; ++r) {\n                  const i = 16 * (e.instancedDataOffset + r),\n                    o = n.instancedDataArray.float32,\n                    a = [o[i + 4], o[i + 5], o[i + 6]];\n                  xv(d, p, o[i], 0 | o[i + 1]), Uf(h, u, s, p, e.rotation, e.scale, a, !1, !1, !1), \"globe\" === s.projection.name && (h = Df(h, s));\n                  const l = c([], s.projMatrix, h),\n                    m = t.queryGeometry,\n                    y = Rf(m.isPointQuery() ? m.screenBounds : m.screenGeometry, s, l, u.aabb);\n                  null != y && (f = Math.min(y, f));\n                }\n                return f !== Number.MAX_VALUE && f;\n              }\n            }\n            return !1;\n          }\n          _handleOverridablePaintPropertyUpdate(t, e, r) {\n            return !(!this.layout || e.isDataDriven() || r.isDataDriven() || \"model-color\" !== t && \"model-color-mix-intensity\" !== t && \"model-rotation\" !== t && \"model-scale\" !== t && \"model-translation\" !== t && \"model-emissive-strength\" !== t);\n          }\n          _isPropertyZoomDependent(t) {\n            const e = this._transitionablePaint._values[t];\n            return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof Us;\n          }\n          isZoomDependent() {\n            return this._isPropertyZoomDependent(\"model-scale\") || this._isPropertyZoomDependent(\"model-rotation\") || this._isPropertyZoomDependent(\"model-translation\");\n          }\n        },\n        clip: class extends na {\n          constructor(t, e, r, n) {\n            super(t, {\n              layout: xp || (xp = new Vo({\n                \"clip-layer-types\": new Eo(Fo.layout_clip[\"clip-layer-types\"]),\n                \"clip-layer-scope\": new Eo(Fo.layout_clip[\"clip-layer-scope\"])\n              })),\n              paint: vp || (vp = new Vo({}))\n            }, e, r, n);\n          }\n          recalculate(t, e) {\n            super.recalculate(t, e);\n          }\n          createBucket(t) {\n            return new _p(t);\n          }\n          is3D(t) {\n            return !0;\n          }\n        }\n      },\n      wv = new sr(0, 0, 0),\n      _v = {\n        PATH_RULE_NON_ZERO: 1,\n        PATH_RULE_EVEN_ODD: 2\n      },\n      Av = {\n        LINE_CAP_BUTT: 1,\n        LINE_CAP_ROUND: 2,\n        LINE_CAP_SQUARE: 3\n      },\n      Mv = {\n        LINE_JOIN_MITER: 1,\n        LINE_JOIN_MITER_CLIP: 2,\n        LINE_JOIN_ROUND: 3,\n        LINE_JOIN_BEVEL: 4\n      },\n      Iv = {\n        PAINT_ORDER_FILL_AND_STROKE: 1\n      },\n      Sv = {\n        PATH_COMMAND_MOVE: 1,\n        PATH_COMMAND_LINE: 2,\n        PATH_COMMAND_QUAD: 3,\n        PATH_COMMAND_CUBIC: 4,\n        PATH_COMMAND_CLOSE: 5\n      },\n      Pv = {\n        MASK_TYPE_LUMINANCE: 1\n      };\n    function kv(t, e, r) {\n      1 === t && e.icons.push(function (t, e) {\n        return function (t) {\n          if (t.usvg_tree.height || (t.usvg_tree.height = t.usvg_tree.width), !t.metadata) return t;\n          const {\n            metadata: e\n          } = t;\n          if (e.content_area) {\n            const {\n              content_area: r\n            } = e;\n            null == r.left && (r.left = 0), null == r.top && (r.top = r.left), null == r.width && (r.width = t.usvg_tree.width), null == r.height && (r.height = r.width);\n          }\n          if (e.text_placeholder) {\n            const {\n              text_placeholder: t\n            } = e;\n            null == t.top && (t.top = t.left), null == t.height && (t.height = t.width);\n          }\n          return e.stretch_x && e.stretch_x.length && zv(e, \"x\"), e.stretch_y && e.stretch_y.length && zv(e, \"y\"), t;\n        }(t.readFields(Ev, {\n          name: void 0\n        }, e));\n      }(r, r.readVarint() + r.pos));\n    }\n    function zv(t, e) {\n      const r = [],\n        n = t[\"stretch_\".concat(e)];\n      let i = null;\n      for (let t = 0; t < n.length; t++) null === i ? i = 0 === r.length ? n[0] : r[r.length - 1][1] + n[t] : (r.push([i, i + n[t]]), i = null);\n      t[\"stretch_\".concat(e, \"_areas\")] = r;\n    }\n    function Ev(t, e, r) {\n      1 === t ? e.name = r.readString() : 2 === t ? e.metadata = function (t, e) {\n        return t.readFields(Tv, {\n          stretch_x: null,\n          stretch_y: null,\n          stretch_x_areas: null,\n          stretch_y_areas: null,\n          variables: []\n        }, e);\n      }(r, r.readVarint() + r.pos) : 3 === t && (e.usvg_tree = function (t, e) {\n        return t.readFields(Cv, {\n          width: 20,\n          children: [],\n          linear_gradients: [],\n          radial_gradients: [],\n          clip_paths: [],\n          masks: []\n        }, e);\n      }(r, r.readVarint() + r.pos), e.data = \"usvg_tree\");\n    }\n    function Tv(t, e, r) {\n      1 === t ? e.stretch_x = r.readPackedVarint() : 2 === t ? e.stretch_y = r.readPackedVarint() : 3 === t ? e.content_area = Bv(r, r.readVarint() + r.pos) : 4 === t ? e.variables.push(function (t, e) {\n        return t.readFields(Fv, {\n          name: void 0\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 5 === t && (e.text_placeholder = Bv(r, r.readVarint() + r.pos));\n    }\n    function Bv(t, e) {\n      return t.readFields(Vv, {}, e);\n    }\n    function Vv(t, e, r) {\n      1 === t ? e.left = r.readVarint() : 2 === t ? e.width = r.readVarint() : 3 === t ? e.top = r.readVarint() : 4 === t && (e.height = r.readVarint());\n    }\n    function Fv(t, e, r) {\n      1 === t ? e.name = r.readString() : 2 === t && (e.rgb_color = $v(r.readVarint()), e.value = \"rgb_color\");\n    }\n    function Cv(t, e, r) {\n      1 === t ? e.width = e.height = r.readVarint() : 2 === t ? e.height = r.readVarint() : 3 === t ? e.children.push(Dv(r, r.readVarint() + r.pos)) : 4 === t ? e.linear_gradients.push(function (t, e) {\n        return t.readFields(Hv, {\n          spread_method: 1,\n          stops: [],\n          x1: 0,\n          y1: 0,\n          x2: 1,\n          y2: 0\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 5 === t ? e.radial_gradients.push(function (t, e) {\n        return t.readFields(Zv, {\n          spread_method: 1,\n          stops: [],\n          cx: .5,\n          cy: .5,\n          r: .5,\n          fx: .5,\n          fy: .5,\n          fr: 0\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 7 === t ? e.clip_paths.push(function (t, e) {\n        return t.readFields(Wv, {\n          children: []\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 8 === t && e.masks.push(function (t, e) {\n        const r = t.readFields(Yv, {\n          left: 0,\n          width: 20,\n          mask_type: Pv.MASK_TYPE_LUMINANCE,\n          children: []\n        }, e);\n        return null == r.height && (r.height = r.width), null == r.top && (r.top = r.left), r;\n      }(r, r.readVarint() + r.pos));\n    }\n    function Dv(t, e) {\n      return t.readFields(Rv, {}, e);\n    }\n    function Rv(t, e, r) {\n      1 === t ? (e.group = function (t, e) {\n        return t.readFields(Lv, {\n          opacity: 255,\n          children: []\n        }, e);\n      }(r, r.readVarint() + r.pos), e.node = \"group\") : 2 === t && (e.path = function (t, e) {\n        return t.readFields(Nv, {\n          paint_order: 1,\n          commands: [],\n          step: 1,\n          diffs: [],\n          rule: _v.PATH_RULE_NON_ZERO\n        }, e);\n      }(r, r.readVarint() + r.pos), e.node = \"path\");\n    }\n    function Lv(t, e, r) {\n      1 === t ? e.transform = Ov(r, r.readVarint() + r.pos) : 2 === t ? e.opacity = r.readVarint() : 5 === t ? e.clip_path_idx = r.readVarint() : 6 === t ? e.mask_idx = r.readVarint() : 7 === t && e.children.push(Dv(r, r.readVarint() + r.pos));\n    }\n    function Ov(t, e) {\n      return t.readFields(Uv, {\n        sx: 1,\n        ky: 0,\n        kx: 0,\n        sy: 1,\n        tx: 0,\n        ty: 0\n      }, e);\n    }\n    function Uv(t, e, r) {\n      1 === t ? e.sx = r.readFloat() : 2 === t ? e.ky = r.readFloat() : 3 === t ? e.kx = r.readFloat() : 4 === t ? e.sy = r.readFloat() : 5 === t ? e.tx = r.readFloat() : 6 === t && (e.ty = r.readFloat());\n    }\n    function Nv(t, e, r) {\n      1 === t ? e.fill = function (t, e) {\n        return t.readFields(jv, {\n          rgb_color: wv,\n          paint: \"rgb_color\",\n          opacity: 255\n        }, e);\n      }(r, r.readVarint() + r.pos) : 2 === t ? e.stroke = function (t, e) {\n        return t.readFields(Gv, {\n          rgb_color: wv,\n          paint: \"rgb_color\",\n          dasharray: [],\n          dashoffset: 0,\n          miterlimit: 4,\n          opacity: 255,\n          width: 1,\n          linecap: 1,\n          linejoin: 1\n        }, e);\n      }(r, r.readVarint() + r.pos) : 3 === t ? e.paint_order = r.readVarint() : 5 === t ? r.readPackedVarint(e.commands) : 6 === t ? e.step = r.readFloat() : 7 === t ? r.readPackedSVarint(e.diffs) : 8 === t && (e.rule = r.readVarint());\n    }\n    function jv(t, e, r) {\n      1 === t ? (e.rgb_color = $v(r.readVarint()), e.paint = \"rgb_color\") : 2 === t ? (e.linear_gradient_idx = r.readVarint(), e.paint = \"linear_gradient_idx\") : 3 === t ? (e.radial_gradient_idx = r.readVarint(), e.paint = \"radial_gradient_idx\") : 5 === t && (e.opacity = r.readVarint());\n    }\n    function $v(t) {\n      return new sr((t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255, 1);\n    }\n    function Gv(t, e, r) {\n      1 === t ? (e.rgb_color = $v(r.readVarint()), e.paint = \"rgb_color\") : 2 === t ? (e.linear_gradient_idx = r.readVarint(), e.paint = \"linear_gradient_idx\") : 3 === t ? (e.radial_gradient_idx = r.readVarint(), e.paint = \"radial_gradient_idx\") : 5 === t ? r.readPackedFloat(e.dasharray) : 6 === t ? e.dashoffset = r.readFloat() : 7 === t ? e.miterlimit = r.readFloat() : 8 === t ? e.opacity = r.readVarint() : 9 === t ? e.width = r.readFloat() : 10 === t ? e.linecap = r.readVarint() : 11 === t && (e.linejoin = r.readVarint());\n    }\n    function Hv(t, e, r) {\n      1 === t ? e.transform = Ov(r, r.readVarint() + r.pos) : 2 === t ? e.spread_method = r.readVarint() : 3 === t ? e.stops.push(qv(r, r.readVarint() + r.pos)) : 4 === t ? e.x1 = r.readFloat() : 5 === t ? e.y1 = r.readFloat() : 6 === t ? e.x2 = r.readFloat() : 7 === t && (e.y2 = r.readFloat());\n    }\n    function qv(t, e) {\n      return t.readFields(Xv, {\n        offset: 0,\n        opacity: 255,\n        rgb_color: wv\n      }, e);\n    }\n    function Xv(t, e, r) {\n      1 === t ? e.offset = r.readFloat() : 2 === t ? e.opacity = r.readVarint() : 3 === t && (e.rgb_color = $v(r.readVarint()));\n    }\n    function Zv(t, e, r) {\n      1 === t ? e.transform = Ov(r, r.readVarint() + r.pos) : 2 === t ? e.spread_method = r.readVarint() : 3 === t ? e.stops.push(qv(r, r.readVarint() + r.pos)) : 4 === t ? e.cx = r.readFloat() : 5 === t ? e.cy = r.readFloat() : 6 === t ? e.r = r.readFloat() : 7 === t ? e.fx = r.readFloat() : 8 === t ? e.fy = r.readFloat() : 9 === t && (e.fr = r.readFloat());\n    }\n    function Wv(t, e, r) {\n      1 === t ? e.transform = Ov(r, r.readVarint() + r.pos) : 2 === t ? e.clip_path_idx = r.readVarint() : 3 === t && e.children.push(Dv(r, r.readVarint() + r.pos));\n    }\n    function Yv(t, e, r) {\n      1 === t ? e.left = e.top = r.readFloat() : 2 === t ? e.width = e.height = r.readFloat() : 3 === t ? e.top = r.readFloat() : 4 === t ? e.height = r.readFloat() : 5 === t ? e.mask_type = r.readVarint() : 6 === t ? e.mask_idx = r.readVarint() : 7 === t && e.children.push(Dv(r, r.readVarint() + r.pos));\n    }\n    class Kv {\n      static calculate() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        const r = new Map(),\n          n = new Map();\n        if (0 === Object.keys(t).length) return r;\n        e.forEach(t => {\n          n.set(t.name, t.rgb_color || new sr(0, 0, 0));\n        });\n        for (const [e, i] of Object.entries(t)) n.has(e) ? r.set(n.get(e).toString(), i) : console.warn(\"Ignoring unknown image variable \\\"\".concat(e, \"\\\"\"));\n        return r;\n      }\n    }\n    function Jv(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n      let r = arguments.length > 2 ? arguments[2] : undefined;\n      const n = e / 255,\n        i = t.toString(),\n        s = r.has(i) ? r.get(i).clone() : t.clone();\n      return s.a *= n, s.toString();\n    }\n    function Qv(t, e) {\n      if (!pe()) {\n        const r = document.createElement(\"canvas\");\n        return r.width = t, r.height = e, r;\n      }\n      return new OffscreenCanvas(t, e);\n    }\n    function tb(t, e) {\n      const r = Kv.calculate(e.params, t.metadata ? t.metadata.variables : []),\n        n = t.usvg_tree,\n        i = n.width,\n        s = n.height,\n        o = e.transform ? e.transform : new DOMMatrix(),\n        a = Math.max(1, Math.round(i * o.a)),\n        l = Math.max(1, Math.round(s * o.d)),\n        u = new DOMMatrix([a / i, 0, 0, l / s, 0, 0]),\n        c = Qv(a, l).getContext(\"2d\");\n      return eb(c, u, n, n, r), c.getImageData(0, 0, a, l);\n    }\n    function eb(t, e, r, n, i) {\n      for (const s of n.children) rb(t, e, r, s, i);\n    }\n    function rb(t, e, r, n, i) {\n      n.group ? (t.save(), function (t, e, r, n, i) {\n        const s = null != n.mask_idx ? r.masks[n.mask_idx] : null,\n          o = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;\n        if (n.transform && (e = hb(n.transform).preMultiplySelf(e)), !function (t, e, r) {\n          return 255 !== t.opacity || e || r;\n        }(n, null != o, null != s)) return void eb(t, e, r, n, i);\n        const a = Qv(t.canvas.width, t.canvas.height),\n          l = a.getContext(\"2d\");\n        eb(l, e, r, n, i), o && ub(l, e, r, o), s && cb(l, e, r, s, i), t.globalAlpha = n.opacity / 255, t.drawImage(a, 0, 0);\n      }(t, e, r, n.group, i), t.restore()) : n.path && (t.save(), function (t, e, r, n, i) {\n        t.setTransform(e), n.paint_order === Iv.PAINT_ORDER_FILL_AND_STROKE ? (nb(t, r, n, i), sb(t, r, n, i)) : (sb(t, r, n, i), nb(t, r, n, i));\n      }(t, e, r, n.path, i), t.restore());\n    }\n    function nb(t, e, r, n) {\n      const i = r.fill;\n      if (!i) return;\n      const s = i.opacity / 255;\n      switch (t.save(), t.beginPath(), pb(r, t), i.paint) {\n        case \"rgb_color\":\n          t.fillStyle = Jv(i.rgb_color, i.opacity, n);\n          break;\n        case \"linear_gradient_idx\":\n          {\n            const r = e.linear_gradients[i.linear_gradient_idx];\n            r.transform && t.setTransform(hb(r.transform).preMultiplySelf(t.getTransform())), t.fillStyle = ob(t, r, s, n);\n            break;\n          }\n        case \"radial_gradient_idx\":\n          {\n            const r = e.radial_gradients[i.radial_gradient_idx];\n            r.transform && t.setTransform(hb(r.transform).preMultiplySelf(t.getTransform())), t.fillStyle = ab(t, r, s, n);\n          }\n      }\n      t.fill(ib(r)), t.restore();\n    }\n    function ib(t) {\n      return t.rule === _v.PATH_RULE_NON_ZERO ? \"nonzero\" : t.rule === _v.PATH_RULE_EVEN_ODD ? \"evenodd\" : void 0;\n    }\n    function sb(t, e, r, n) {\n      const i = r.stroke;\n      if (!i) return;\n      const s = db(r);\n      t.lineWidth = i.width, t.miterLimit = i.miterlimit, t.setLineDash(i.dasharray), t.lineDashOffset = i.dashoffset;\n      const o = i.opacity / 255;\n      switch (i.paint) {\n        case \"rgb_color\":\n          t.strokeStyle = Jv(i.rgb_color, i.opacity, n);\n          break;\n        case \"linear_gradient_idx\":\n          t.strokeStyle = ob(t, e.linear_gradients[i.linear_gradient_idx], o, n, !0);\n          break;\n        case \"radial_gradient_idx\":\n          t.strokeStyle = ab(t, e.radial_gradients[i.radial_gradient_idx], o, n, !0);\n      }\n      switch (i.linejoin) {\n        case Mv.LINE_JOIN_MITER_CLIP:\n        case Mv.LINE_JOIN_MITER:\n          t.lineJoin = \"miter\";\n          break;\n        case Mv.LINE_JOIN_ROUND:\n          t.lineJoin = \"round\";\n          break;\n        case Mv.LINE_JOIN_BEVEL:\n          t.lineJoin = \"bevel\";\n      }\n      switch (i.linecap) {\n        case Av.LINE_CAP_BUTT:\n          t.lineCap = \"butt\";\n          break;\n        case Av.LINE_CAP_ROUND:\n          t.lineCap = \"round\";\n          break;\n        case Av.LINE_CAP_SQUARE:\n          t.lineCap = \"square\";\n      }\n      t.stroke(s);\n    }\n    function ob(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n      if (1 === e.stops.length) {\n        const t = e.stops[0];\n        return Jv(t.rgb_color, t.opacity * r, n);\n      }\n      const {\n        x1: s,\n        y1: o,\n        x2: a,\n        y2: l\n      } = e;\n      let u = new DOMPoint(s, o),\n        c = new DOMPoint(a, l);\n      if (i) {\n        const t = hb(e.transform);\n        u = t.transformPoint(u), c = t.transformPoint(c);\n      }\n      const h = t.createLinearGradient(u.x, u.y, c.x, c.y);\n      for (const t of e.stops) h.addColorStop(t.offset, Jv(t.rgb_color, t.opacity * r, n));\n      return h;\n    }\n    function ab(t, e, r, n) {\n      let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n      if (1 === e.stops.length) {\n        const t = e.stops[0];\n        return Jv(t.rgb_color, t.opacity * r, n);\n      }\n      const s = hb(e.transform),\n        {\n          fx: o,\n          fy: a,\n          fr: l,\n          cx: u,\n          cy: c,\n          r: h\n        } = e;\n      let p = new DOMPoint(o, a),\n        d = new DOMPoint(u, c),\n        f = l,\n        m = h;\n      if (i) {\n        p = s.transformPoint(p), d = s.transformPoint(d);\n        const t = (s.a + s.d) / 2;\n        f = l * t, m = e.r * t;\n      }\n      const y = t.createRadialGradient(p.x, p.y, f, d.x, d.y, m);\n      for (const t of e.stops) y.addColorStop(t.offset, Jv(t.rgb_color, t.opacity * r, n));\n      return y;\n    }\n    function lb(t, e, r, n) {\n      const i = n.transform ? hb(n.transform).preMultiplySelf(e) : e,\n        s = Qv(t.canvas.width, t.canvas.height),\n        o = s.getContext(\"2d\");\n      for (const t of n.children) if (t.group) lb(o, i, r, t.group);else if (t.path) {\n        const e = t.path,\n          r = new Path2D();\n        r.addPath(db(e), i), o.fill(r, ib(e));\n      }\n      const a = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;\n      a && ub(o, i, r, a), t.globalCompositeOperation = \"source-over\", t.drawImage(s, 0, 0);\n    }\n    function ub(t, e, r, n) {\n      const i = Qv(t.canvas.width, t.canvas.height);\n      lb(i.getContext(\"2d\"), e, r, n), t.globalCompositeOperation = \"destination-in\", t.drawImage(i, 0, 0);\n    }\n    function cb(t, e, r, n, i) {\n      if (0 === n.children.length) return;\n      const s = null != n.mask_idx ? r.masks[n.mask_idx] : null;\n      s && cb(t, e, r, s, i);\n      const o = t.canvas.width,\n        a = t.canvas.height,\n        l = Qv(o, a),\n        u = l.getContext(\"2d\"),\n        c = n.width,\n        h = n.height,\n        p = n.left,\n        d = n.top,\n        f = new Path2D(),\n        m = new Path2D();\n      m.rect(p, d, c, h), f.addPath(m, e), u.clip(f);\n      for (const t of n.children) rb(u, e, r, t, i);\n      const y = u.getImageData(0, 0, o, a),\n        g = y.data;\n      if (n.mask_type === Pv.MASK_TYPE_LUMINANCE) for (let t = 0; t < g.length; t += 4) g[t + 3] = g[t + 3] / 255 * (.2126 * g[t] + .7152 * g[t + 1] + .0722 * g[t + 2]);\n      u.putImageData(y, 0, 0), t.globalCompositeOperation = \"destination-in\", t.drawImage(l, 0, 0);\n    }\n    function hb(t) {\n      return t ? new DOMMatrix([t.sx, t.ky, t.kx, t.sy, t.tx, t.ty]) : new DOMMatrix();\n    }\n    function pb(t, e) {\n      const r = t.step;\n      let n = t.diffs[0] * r,\n        i = t.diffs[1] * r;\n      e.moveTo(n, i);\n      for (let s = 0, o = 2; s < t.commands.length; s++) switch (t.commands[s]) {\n        case Sv.PATH_COMMAND_MOVE:\n          n += t.diffs[o++] * r, i += t.diffs[o++] * r, e.moveTo(n, i);\n          break;\n        case Sv.PATH_COMMAND_LINE:\n          n += t.diffs[o++] * r, i += t.diffs[o++] * r, e.lineTo(n, i);\n          break;\n        case Sv.PATH_COMMAND_QUAD:\n          {\n            const s = n + t.diffs[o++] * r,\n              a = i + t.diffs[o++] * r;\n            n = s + t.diffs[o++] * r, i = a + t.diffs[o++] * r, e.quadraticCurveTo(s, a, n, i);\n            break;\n          }\n        case Sv.PATH_COMMAND_CUBIC:\n          {\n            const s = n + t.diffs[o++] * r,\n              a = i + t.diffs[o++] * r,\n              l = s + t.diffs[o++] * r,\n              u = a + t.diffs[o++] * r;\n            n = l + t.diffs[o++] * r, i = u + t.diffs[o++] * r, e.bezierCurveTo(s, a, l, u, n, i);\n            break;\n          }\n        case Sv.PATH_COMMAND_CLOSE:\n          e.closePath();\n      }\n      return e;\n    }\n    function db(t) {\n      return pb(t, new Path2D());\n    }\n    class fb {\n      constructor(t) {\n        this.capacity = t, this.cache = new Map();\n      }\n      get(t) {\n        if (!this.cache.has(t)) return;\n        const e = this.cache.get(t);\n        return this.cache.delete(t), this.cache.set(t, e), e;\n      }\n      put(t, e) {\n        this.cache.has(t) ? this.cache.delete(t) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t, e);\n      }\n      delete(t) {\n        this.cache.delete(t);\n      }\n    }\n    Ws(fb, \"LRUCache\");\n    class mb {\n      constructor() {\n        this.cacheMap = new Map(), this.cacheDependenciesMap = new Map();\n      }\n      static _getImage(t) {\n        return new xh(t, t.data);\n      }\n      getFromCache(t, e, r) {\n        return this.cacheMap.has(r) || this.cacheMap.set(r, new fb(150)), this.cacheMap.get(r).get(Ko(t.toString(), e));\n      }\n      setInCache(t, e, r, n) {\n        this.cacheDependenciesMap.has(n) || this.cacheDependenciesMap.set(n, new Map()), this.cacheMap.has(n) || this.cacheMap.set(n, new fb(150));\n        const i = this.cacheDependenciesMap.get(n),\n          s = Ko(t.id.toString(), r);\n        i.get(s) || i.set(s, new Set());\n        const o = this.cacheMap.get(n),\n          a = t.toString();\n        i.get(s).add(a), o.put(Ko(t.toString(), r), e);\n      }\n      removeImagesFromCacheByIds(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        if (!this.cacheMap.has(r) || !this.cacheDependenciesMap.has(r)) return;\n        const n = this.cacheMap.get(r),\n          i = this.cacheDependenciesMap.get(r);\n        for (const r of t) {\n          const t = Ko(r.toString(), e);\n          if (i.has(t)) {\n            for (const e of i.get(t)) n.delete(e);\n            i.delete(t);\n          }\n        }\n      }\n      rasterize(t, e, r, n) {\n        let i = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tb;\n        const s = this.getFromCache(t, r, n);\n        if (s) return s.clone();\n        const o = i(e.icon, t.options),\n          a = mb._getImage(o);\n        return this.setInCache(t, a, r, n), a.clone();\n      }\n    }\n    class yb {\n      constructor(t) {\n        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];\n      }\n      getElevation(t, e) {\n        const r = this.toIdx(t, e);\n        return {\n          min: this.minimums[r],\n          max: this.maximums[r]\n        };\n      }\n      isLeaf(t, e) {\n        return this.leaves[this.toIdx(t, e)];\n      }\n      toIdx(t, e) {\n        return e * this.size + t;\n      }\n    }\n    function gb(t, e, r, n) {\n      let i = 0,\n        s = Number.MAX_VALUE;\n      for (let o = 0; o < 3; o++) if (Math.abs(n[o]) < 1e-15) {\n        if (r[o] < t[o] || r[o] > e[o]) return null;\n      } else {\n        const a = 1 / n[o];\n        let l = (t[o] - r[o]) * a,\n          u = (e[o] - r[o]) * a;\n        if (l > u) {\n          const t = l;\n          l = u, u = t;\n        }\n        if (l > i && (i = l), u < s && (s = u), i > s) return null;\n      }\n      return i;\n    }\n    function xb(t, e, r, n, i, s, o, a, l, u, c) {\n      const h = n - t,\n        p = i - e,\n        d = s - r,\n        f = o - t,\n        m = a - e,\n        y = l - r,\n        g = c[1] * y - c[2] * m,\n        x = c[2] * f - c[0] * y,\n        v = c[0] * m - c[1] * f,\n        b = h * g + p * x + d * v;\n      if (Math.abs(b) < 1e-15) return null;\n      const w = 1 / b,\n        _ = u[0] - t,\n        A = u[1] - e,\n        M = u[2] - r,\n        I = (_ * g + A * x + M * v) * w;\n      if (I < 0 || I > 1) return null;\n      const S = A * d - M * p,\n        P = M * h - _ * d,\n        k = _ * p - A * h,\n        z = (c[0] * S + c[1] * P + c[2] * k) * w;\n      return z < 0 || I + z > 1 ? null : (f * S + m * P + y * k) * w;\n    }\n    function vb(t, e, r) {\n      return (t - e) / (r - e);\n    }\n    function bb(t, e, r, n, i, s, o, a, l) {\n      const u = 1 << r,\n        c = s - n,\n        h = o - i,\n        p = (t + 1) / u * c + n,\n        d = (e + 0) / u * h + i,\n        f = (e + 1) / u * h + i;\n      a[0] = (t + 0) / u * c + n, a[1] = d, l[0] = p, l[1] = f;\n    }\n    class wb {\n      constructor(t) {\n        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;\n        const e = function (t) {\n            const e = Math.ceil(Math.log2(t.dim / 8)),\n              r = [];\n            let n = Math.ceil(Math.pow(2, e));\n            const i = 1 / n,\n              s = (t, e, r, n, i) => {\n                const s = n ? 1 : 0,\n                  o = (t + 1) * r - s,\n                  a = e * r,\n                  l = (e + 1) * r - s;\n                i[0] = t * r, i[1] = a, i[2] = o, i[3] = l;\n              };\n            let o = new yb(n);\n            const a = [];\n            for (let e = 0; e < n * n; e++) {\n              s(e % n, Math.floor(e / n), i, !1, a);\n              const r = Ab(a[0], a[1], t),\n                l = Ab(a[2], a[1], t),\n                u = Ab(a[2], a[3], t),\n                c = Ab(a[0], a[3], t);\n              o.minimums.push(Math.min(r, l, u, c)), o.maximums.push(Math.max(r, l, u, c)), o.leaves.push(1);\n            }\n            for (r.push(o), n /= 2; n >= 1; n /= 2) {\n              const t = r[r.length - 1];\n              o = new yb(n);\n              for (let e = 0; e < n * n; e++) {\n                s(e % n, Math.floor(e / n), 2, !0, a);\n                const r = t.getElevation(a[0], a[1]),\n                  i = t.getElevation(a[2], a[1]),\n                  l = t.getElevation(a[2], a[3]),\n                  u = t.getElevation(a[0], a[3]),\n                  c = t.isLeaf(a[0], a[1]),\n                  h = t.isLeaf(a[2], a[1]),\n                  p = t.isLeaf(a[2], a[3]),\n                  d = t.isLeaf(a[0], a[3]),\n                  f = Math.min(r.min, i.min, l.min, u.min),\n                  m = Math.max(r.max, i.max, l.max, u.max),\n                  y = c && h && p && d;\n                o.maximums.push(m), o.minimums.push(f), o.leaves.push(m - f <= 5 && y ? 1 : 0);\n              }\n              r.push(o);\n            }\n            return r;\n          }(this.dem),\n          r = e.length - 1,\n          n = e[r];\n        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);\n      }\n      raycastRoot(t, e, r, n, i, s) {\n        let o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n        return gb([t, e, -100], [r, n, this.maximums[0] * o], i, s);\n      }\n      raycast(t, e, r, n, i, s) {\n        let o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n        if (!this.nodeCount) return null;\n        const a = this.raycastRoot(t, e, r, n, i, s, o);\n        if (null == a) return null;\n        const l = [],\n          u = [],\n          c = [],\n          h = [],\n          p = [{\n            idx: 0,\n            t: a,\n            nodex: 0,\n            nodey: 0,\n            depth: 0\n          }];\n        for (; p.length > 0;) {\n          const {\n            idx: a,\n            t: d,\n            nodex: f,\n            nodey: m,\n            depth: y\n          } = p.pop();\n          if (this.leaves[a]) {\n            bb(f, m, y, t, e, r, n, c, h);\n            const a = 1 << y,\n              l = (f + 0) / a,\n              u = (f + 1) / a,\n              p = (m + 0) / a,\n              g = (m + 1) / a,\n              x = Ab(l, p, this.dem) * o,\n              v = Ab(u, p, this.dem) * o,\n              b = Ab(u, g, this.dem) * o,\n              w = Ab(l, g, this.dem) * o,\n              _ = xb(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),\n              A = xb(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s),\n              M = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);\n            if (M !== Number.MAX_VALUE) return M;\n            {\n              const t = T([], i, s, d);\n              if (_b(x, v, w, b, vb(t[0], c[0], h[0]), vb(t[1], c[1], h[1])) >= t[2]) return d;\n            }\n            continue;\n          }\n          let g = 0;\n          for (let p = 0; p < this._siblingOffset.length; p++) {\n            bb((f << 1) + this._siblingOffset[p][0], (m << 1) + this._siblingOffset[p][1], y + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[a] + p] * o;\n            const d = gb(c, h, i, s);\n            if (null != d) {\n              const t = d;\n              l[p] = t;\n              let e = !1;\n              for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);\n              e || (u[g] = p), g++;\n            }\n          }\n          for (let t = 0; t < g; t++) {\n            const e = u[t];\n            p.push({\n              idx: this.childOffsets[a] + e,\n              t: l[e],\n              nodex: (f << 1) + this._siblingOffset[e][0],\n              nodey: (m << 1) + this._siblingOffset[e][1],\n              depth: y + 1\n            });\n          }\n        }\n        return null;\n      }\n      _addNode(t, e, r) {\n        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;\n      }\n      _construct(t, e, r, n, i) {\n        if (1 === t[n].isLeaf(e, r)) return;\n        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);\n        const s = n - 1,\n          o = t[s];\n        let a = 0,\n          l = 0;\n        for (let t = 0; t < this._siblingOffset.length; t++) {\n          const n = 2 * e + this._siblingOffset[t][0],\n            i = 2 * r + this._siblingOffset[t][1],\n            s = o.getElevation(n, i),\n            u = o.isLeaf(n, i),\n            c = this._addNode(s.min, s.max, u);\n          u && (a |= 1 << t), l || (l = c);\n        }\n        for (let n = 0; n < this._siblingOffset.length; n++) a & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);\n      }\n    }\n    function _b(t, e, r, n, i, s) {\n      return ur(ur(t, r, s), ur(e, n, s), i);\n    }\n    function Ab(t, e, r) {\n      const n = r.dim,\n        i = Tt(t * n - .5, 0, n - 1),\n        s = Tt(e * n - .5, 0, n - 1),\n        o = Math.floor(i),\n        a = Math.floor(s),\n        l = Math.min(o + 1, n - 1),\n        u = Math.min(a + 1, n - 1);\n      return _b(r.get(o, a), r.get(l, a), r.get(o, u), r.get(l, u), i - o, s - a);\n    }\n    const Mb = {\n      mapbox: [6553.6, 25.6, .1, 1e4],\n      terrarium: [256, 1, 1 / 256, 32768]\n    };\n    function Ib(t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }\n    function Sb(t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }\n    class Pb {\n      get tree() {\n        return this._tree || this._buildQuadTree(), this._tree;\n      }\n      constructor(t, e, r) {\n        let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n        if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n        if (r && \"mapbox\" !== r && \"terrarium\" !== r) return void Gt(\"\\\"\".concat(r, \"\\\" is not a valid encoding type. Valid types include \\\"mapbox\\\" and \\\"terrarium\\\".\"));\n        this.stride = e.height;\n        const i = this.dim = e.height - 2,\n          s = new Uint32Array(e.data.buffer);\n        if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {\n          for (let t = 0; t < i; t++) s[this._idx(-1, t)] = s[this._idx(0, t)], s[this._idx(i, t)] = s[this._idx(i - 1, t)], s[this._idx(t, -1)] = s[this._idx(t, 0)], s[this._idx(t, i)] = s[this._idx(t, i - 1)];\n          s[this._idx(-1, -1)] = s[this._idx(0, 0)], s[this._idx(i, -1)] = s[this._idx(i - 1, 0)], s[this._idx(-1, i)] = s[this._idx(0, i - 1)], s[this._idx(i, i)] = s[this._idx(i - 1, i - 1)];\n        }\n        const o = \"terrarium\" === r ? Sb : Ib;\n        for (let t = 0; t < s.length; ++t) {\n          const e = 4 * t;\n          this.floatView[t] = o(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);\n        }\n        this._timestamp = de.now();\n      }\n      _buildQuadTree() {\n        this._tree = new wb(this);\n      }\n      get(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        r && (t = Tt(t, -1, this.dim), e = Tt(e, -1, this.dim));\n        const n = this._idx(t, e);\n        return this.floatView[n];\n      }\n      set(t, e, r) {\n        const n = this._idx(t, e),\n          i = this.floatView[n];\n        return this.floatView[n] = r, r - i;\n      }\n      static getUnpackVector(t) {\n        return Mb[t];\n      }\n      _idx(t, e) {\n        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n        return (e + 1) * this.stride + (t + 1);\n      }\n      static pack(t, e) {\n        const r = [0, 0, 0, 0],\n          n = Pb.getUnpackVector(e);\n        let i = Math.floor((t + n[3]) / n[2]);\n        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;\n      }\n      getPixels() {\n        return new vh({\n          width: this.stride,\n          height: this.stride\n        }, this.pixels);\n      }\n      backfillBorder(t, e, r) {\n        if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n        let n = e * this.dim,\n          i = e * this.dim + this.dim,\n          s = r * this.dim,\n          o = r * this.dim + this.dim;\n        switch (e) {\n          case -1:\n            n = i - 1;\n            break;\n          case 1:\n            i = n + 1;\n        }\n        switch (r) {\n          case -1:\n            s = o - 1;\n            break;\n          case 1:\n            o = s + 1;\n        }\n        const a = -e * this.dim,\n          l = -r * this.dim;\n        for (let e = s; e < o; e++) for (let r = n; r < i; r++) {\n          const n = 4 * this._idx(r, e),\n            i = 4 * this._idx(r + a, e + l);\n          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];\n        }\n      }\n      onDeserialize() {\n        this._tree && (this._tree.dem = this);\n      }\n    }\n    function kb(t, e, r) {\n      1 === t ? e.headerLength = r.readFixed32() : 2 === t ? e.x = r.readVarint() : 3 === t ? e.y = r.readVarint() : 4 === t ? e.z = r.readVarint() : 5 === t && e.layers.push(function (t, e) {\n        return t.readFields(Vb, {\n          version: 0,\n          name: \"\",\n          units: \"\",\n          tileSize: 0,\n          buffer: 0,\n          pixelFormat: 0,\n          dataIndex: []\n        }, e);\n      }(r, r.readVarint() + r.pos));\n    }\n    function zb(t, e, r) {\n      1 === t ? (e.delta_filter = function (t, e) {\n        return t.readFields(Eb, {\n          blockSize: 0\n        }, e);\n      }(r, r.readVarint() + r.pos), e.filter = \"delta_filter\") : 2 === t ? (r.readVarint(), e.filter = \"zigzag_filter\") : 3 === t ? (r.readVarint(), e.filter = \"bitshuffle_filter\") : 4 === t && (r.readVarint(), e.filter = \"byteshuffle_filter\");\n    }\n    function Eb(t, e, r) {\n      1 === t && (e.blockSize = r.readVarint());\n    }\n    function Tb(t, e, r) {\n      1 === t ? (r.readVarint(), e.codec = \"gzip_data\") : 2 === t ? (r.readVarint(), e.codec = \"jpeg_image\") : 3 === t ? (r.readVarint(), e.codec = \"webp_image\") : 4 === t && (r.readVarint(), e.codec = \"png_image\");\n    }\n    function Bb(t, e, r) {\n      let n = 0,\n        i = 0;\n      1 === t ? e.firstByte = r.readFixed64() : 2 === t ? e.lastByte = r.readFixed64() : 3 === t ? e.filters.push(function (t, e) {\n        return t.readFields(zb, {}, e);\n      }(r, r.readVarint() + r.pos)) : 4 === t ? e.codec = function (t, e) {\n        return t.readFields(Tb, {}, e);\n      }(r, r.readVarint() + r.pos) : 5 === t ? i = r.readFloat() : 6 === t ? n = r.readFloat() : 7 === t ? e.bands.push(r.readString()) : 8 === t ? e.offset = r.readDouble() : 9 === t && (e.scale = r.readDouble()), 0 === e.offset && (e.offset = i), 0 === e.scale && (e.scale = n);\n    }\n    function Vb(t, e, r) {\n      1 === t ? e.version = r.readVarint() : 2 === t ? e.name = r.readString() : 3 === t ? e.units = r.readString() : 4 === t ? e.tileSize = r.readVarint() : 5 === t ? e.buffer = r.readVarint() : 6 === t ? e.pixelFormat = r.readVarint() : 7 === t && e.dataIndex.push(function (t, e) {\n        return t.readFields(Bb, {\n          firstByte: 0,\n          lastByte: 0,\n          filters: [],\n          codec: null,\n          offset: 0,\n          scale: 0,\n          bands: []\n        }, e);\n      }(r, r.readVarint() + r.pos));\n    }\n    function Fb(t, e, r) {\n      if (2 === t) !function (t, e, r) {\n        t.readFields(Cb, r, e);\n      }(r, r.readVarint() + r.pos, e);else if (3 === t) throw new Error(\"Not implemented\");\n    }\n    function Cb(t, e, r) {\n      if (1 === t) {\n        let t = 0;\n        const n = r.readVarint() + r.pos;\n        for (; r.pos < n;) e[t++] = r.readVarint();\n      }\n    }\n    function Db(t, e) {\n      if (4 !== e.length) throw new Error(\"Expected data of dimension 4 but got \".concat(e.length, \".\"));\n      let r = e[3];\n      for (let n = 2; n >= 1; n--) {\n        const i = 1 === n ? 1 : 0,\n          s = 2 === n ? 1 : 0;\n        for (let n = 0; n < e[0]; n++) {\n          const o = e[1] * n;\n          for (let n = i; n < e[1]; n++) {\n            const i = e[2] * (n + o);\n            for (let n = s; n < e[2]; n++) {\n              const s = e[3] * (n + i);\n              for (let n = 0; n < e[3]; n++) {\n                const e = s + n;\n                t[e] += t[e - r];\n              }\n            }\n          }\n        }\n        r *= e[n];\n      }\n      return t;\n    }\n    function Rb(t) {\n      for (let e = 0, r = t.length; e < r; e++) t[e] = t[e] >>> 1 ^ -(1 & t[e]);\n      return t;\n    }\n    function Lb(t, e) {\n      switch (e) {\n        case \"uint32\":\n          return t;\n        case \"uint16\":\n          for (let e = 0; e < t.length; e += 2) {\n            const r = t[e],\n              n = t[e + 1];\n            t[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;\n          }\n          return t;\n        case \"uint8\":\n          for (let e = 0; e < t.length; e += 4) {\n            const r = t[e],\n              n = t[e + 1],\n              i = t[e + 2],\n              s = t[e + 3];\n            t[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & s, t[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & s) << 2, t[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & s) << 4, t[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & s) << 6;\n          }\n          return t;\n        default:\n          throw new Error(\"Invalid pixel format, \\\"\".concat(e, \"\\\"\"));\n      }\n    }\n    Ws(Pb, \"DEMData\"), Ws(wb, \"DemMinMaxQuadTree\", {\n      omit: [\"dem\"]\n    });\n    var Ob = Uint8Array,\n      Ub = Uint16Array,\n      Nb = Int32Array,\n      jb = new Ob([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),\n      $b = new Ob([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),\n      Gb = new Ob([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n      Hb = function (t, e) {\n        for (var r = new Ub(31), n = 0; n < 31; ++n) r[n] = e += 1 << t[n - 1];\n        var i = new Nb(r[30]);\n        for (n = 1; n < 30; ++n) for (var s = r[n]; s < r[n + 1]; ++s) i[s] = s - r[n] << 5 | n;\n        return {\n          b: r,\n          r: i\n        };\n      },\n      qb = Hb(jb, 2),\n      Xb = qb.b,\n      Zb = qb.r;\n    Xb[28] = 258, Zb[258] = 28;\n    for (var Wb = Hb($b, 0).b, Yb = new Ub(32768), Kb = 0; Kb < 32768; ++Kb) {\n      var Jb = (43690 & Kb) >> 1 | (21845 & Kb) << 1;\n      Yb[Kb] = ((65280 & (Jb = (61680 & (Jb = (52428 & Jb) >> 2 | (13107 & Jb) << 2)) >> 4 | (3855 & Jb) << 4)) >> 8 | (255 & Jb) << 8) >> 1;\n    }\n    var Qb = function (t, e, r) {\n        for (var n = t.length, i = 0, s = new Ub(e); i < n; ++i) t[i] && ++s[t[i] - 1];\n        var o,\n          a = new Ub(e);\n        for (i = 1; i < e; ++i) a[i] = a[i - 1] + s[i - 1] << 1;\n        o = new Ub(1 << e);\n        var l = 15 - e;\n        for (i = 0; i < n; ++i) if (t[i]) for (var u = i << 4 | t[i], c = e - t[i], h = a[t[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h) o[Yb[h] >> l] = u;\n        return o;\n      },\n      tw = new Ob(288);\n    for (Kb = 0; Kb < 144; ++Kb) tw[Kb] = 8;\n    for (Kb = 144; Kb < 256; ++Kb) tw[Kb] = 9;\n    for (Kb = 256; Kb < 280; ++Kb) tw[Kb] = 7;\n    for (Kb = 280; Kb < 288; ++Kb) tw[Kb] = 8;\n    var ew = new Ob(32);\n    for (Kb = 0; Kb < 32; ++Kb) ew[Kb] = 5;\n    var rw = Qb(tw, 9),\n      nw = Qb(ew, 5),\n      iw = function (t) {\n        for (var e = t[0], r = 1; r < t.length; ++r) t[r] > e && (e = t[r]);\n        return e;\n      },\n      sw = function (t, e, r) {\n        var n = e / 8 | 0;\n        return (t[n] | t[n + 1] << 8) >> (7 & e) & r;\n      },\n      ow = function (t, e) {\n        var r = e / 8 | 0;\n        return (t[r] | t[r + 1] << 8 | t[r + 2] << 16) >> (7 & e);\n      },\n      aw = [\"unexpected EOF\", \"invalid block type\", \"invalid length/literal\", \"invalid distance\", \"stream finished\", \"no stream handler\",, \"no callback\", \"invalid UTF-8 data\", \"extra field too long\", \"date not in range 1980-2099\", \"filename too long\", \"stream finishing\", \"invalid zip data\"],\n      lw = function (t, e, r) {\n        var n = new Error(e || aw[t]);\n        if (n.code = t, Error.captureStackTrace && Error.captureStackTrace(n, lw), !r) throw n;\n        return n;\n      },\n      uw = new Ob(0),\n      cw = \"undefined\" != typeof TextDecoder && new TextDecoder();\n    try {\n      cw.decode(uw, {\n        stream: !0\n      });\n    } catch (t) {}\n    const hw = {\n      gzip_data: \"gzip\"\n    };\n    class pw extends Error {\n      constructor(t) {\n        super(t), this.name = \"MRTError\";\n      }\n    }\n    const dw = {\n        0: \"uint32\",\n        1: \"uint32\",\n        2: \"uint16\",\n        3: \"uint8\"\n      },\n      fw = {\n        uint32: 1,\n        uint16: 2,\n        uint8: 4\n      },\n      mw = {\n        uint32: Uint32Array,\n        uint16: Uint16Array,\n        uint8: Uint8Array\n      };\n    let yw;\n    class gw {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n        this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t;\n      }\n      getLayer(t) {\n        const e = this.layers[t];\n        if (!e) throw new pw(\"Layer '\".concat(t, \"' not found\"));\n        return e;\n      }\n      getHeaderLength(t) {\n        const e = new Uint8Array(t),\n          r = new DataView(t);\n        if (13 !== e[0]) throw new pw(\"File is not a valid MRT.\");\n        return r.getUint32(1, !0);\n      }\n      parseHeader(t) {\n        const e = new Uint8Array(t),\n          r = this.getHeaderLength(t);\n        if (e.length < r) throw new pw(\"Expected header with length >= \".concat(r, \" but got buffer of length \").concat(e.length));\n        const n = new yw(e.subarray(0, r)).readFields(kb, {\n          headerLength: 0,\n          x: 0,\n          y: 0,\n          z: 0,\n          layers: []\n        }, void 0);\n        if (!isNaN(this.x) && (this.x !== n.x || this.y !== n.y || this.z !== n.z)) throw new pw(\"Invalid attempt to parse header \".concat(n.z, \"/\").concat(n.x, \"/\").concat(n.y, \" for tile \").concat(this.z, \"/\").concat(this.x, \"/\").concat(this.y));\n        this.x = n.x, this.y = n.y, this.z = n.z;\n        for (const t of n.layers) this.layers[t.name] = new xw(t, {\n          cacheSize: this._cacheSize\n        });\n        return this;\n      }\n      createDecodingTask(t) {\n        const e = [],\n          r = this.getLayer(t.layerName);\n        for (let n of t.blockIndices) {\n          const i = r.dataIndex[n],\n            s = i.firstByte - t.firstByte,\n            o = i.lastByte - t.firstByte;\n          if (r._blocksInProgress.has(n)) continue;\n          const a = {\n            layerName: r.name,\n            firstByte: s,\n            lastByte: o,\n            pixelFormat: r.pixelFormat,\n            blockIndex: n,\n            blockShape: [i.bands.length].concat(r.bandShape),\n            buffer: r.buffer,\n            codec: i.codec.codec,\n            filters: i.filters.map(t => t.filter)\n          };\n          r._blocksInProgress.add(n), e.push(a);\n        }\n        return new vw(e, () => {\n          e.forEach(t => r._blocksInProgress.delete(t.blockIndex));\n        }, (t, n) => {\n          if (e.forEach(t => r._blocksInProgress.delete(t.blockIndex)), t) throw t;\n          n.forEach(t => {\n            this.getLayer(t.layerName).processDecodedData(t);\n          });\n        });\n      }\n    }\n    class xw {\n      constructor(_ref69, a) {\n        let {\n          version: t,\n          name: e,\n          units: r,\n          tileSize: n,\n          pixelFormat: i,\n          buffer: s,\n          dataIndex: o\n        } = _ref69;\n        if (this.version = t, 1 !== this.version) throw new pw(\"Cannot parse raster layer encoded with MRT version \".concat(t));\n        this.name = e, this.units = r, this.tileSize = n, this.buffer = s, this.pixelFormat = dw[i], this.dataIndex = o, this.bandShape = [n + 2 * s, n + 2 * s, fw[this.pixelFormat]], this._decodedBlocks = new fb(a ? a.cacheSize : 5), this._blocksInProgress = new Set();\n      }\n      get dimension() {\n        return fw[this.pixelFormat];\n      }\n      get cacheSize() {\n        return this._decodedBlocks.capacity;\n      }\n      getBandList() {\n        return this.dataIndex.map(_ref70 => {\n          let {\n            bands: t\n          } = _ref70;\n          return t;\n        }).flat();\n      }\n      processDecodedData(t) {\n        const e = t.blockIndex.toString();\n        this._decodedBlocks.get(e) || this._decodedBlocks.put(e, t.data);\n      }\n      getBlockForBand(t) {\n        let e = 0;\n        switch (typeof t) {\n          case \"string\":\n            for (const [r, n] of this.dataIndex.entries()) {\n              for (const [i, s] of n.bands.entries()) if (s === t) return {\n                bandIndex: e + i,\n                blockIndex: r,\n                blockBandIndex: i\n              };\n              e += n.bands.length;\n            }\n            break;\n          case \"number\":\n            for (const [r, n] of this.dataIndex.entries()) {\n              if (t >= e && t < e + n.bands.length) return {\n                bandIndex: t,\n                blockIndex: r,\n                blockBandIndex: t - e\n              };\n              e += n.bands.length;\n            }\n            break;\n          default:\n            throw new pw(\"Invalid band `\".concat(JSON.stringify(t), \"`. Expected string or integer.\"));\n        }\n        return {\n          blockIndex: -1,\n          blockBandIndex: -1\n        };\n      }\n      getDataRange(t) {\n        let e = 1 / 0,\n          r = -1 / 0;\n        const n = [],\n          i = new Set();\n        for (const s of t) {\n          const {\n            blockIndex: t\n          } = this.getBlockForBand(s);\n          if (t < 0) throw new pw(\"Invalid band: \".concat(JSON.stringify(s)));\n          const o = this.dataIndex[t];\n          n.includes(t) || n.push(t), i.add(t), e = Math.min(e, o.firstByte), r = Math.max(r, o.lastByte);\n        }\n        if (i.size > this.cacheSize) throw new pw(\"Number of blocks to decode (\".concat(i.size, \") exceeds cache size (\").concat(this.cacheSize, \").\"));\n        return {\n          layerName: this.name,\n          firstByte: e,\n          lastByte: r,\n          blockIndices: n\n        };\n      }\n      hasBand(t) {\n        const {\n          blockIndex: e\n        } = this.getBlockForBand(t);\n        return e >= 0;\n      }\n      hasDataForBand(t) {\n        const {\n          blockIndex: e\n        } = this.getBlockForBand(t);\n        return e >= 0 && !!this._decodedBlocks.get(e.toString());\n      }\n      getBandView(t) {\n        const {\n          blockIndex: e,\n          blockBandIndex: r\n        } = this.getBlockForBand(t);\n        if (e < 0) throw new pw(\"Band not found: \".concat(JSON.stringify(t)));\n        const n = this._decodedBlocks.get(e.toString());\n        if (!n) throw new pw(\"Data for band \".concat(JSON.stringify(t), \" of layer \\\"\").concat(this.name, \"\\\" not decoded.\"));\n        const i = this.dataIndex[e],\n          s = this.bandShape.reduce((t, e) => t * e, 1),\n          o = r * s,\n          a = n.subarray(o, o + s);\n        return {\n          data: a,\n          bytes: new Uint8Array(a.buffer).subarray(a.byteOffset, a.byteOffset + a.byteLength),\n          tileSize: this.tileSize,\n          buffer: this.buffer,\n          pixelFormat: this.pixelFormat,\n          dimension: this.dimension,\n          offset: i.offset,\n          scale: i.scale\n        };\n      }\n    }\n    gw.setPbf = function (t) {\n      yw = t;\n    };\n    class vw {\n      constructor(t, e, r) {\n        this.tasks = t, this._onCancel = e, this._onComplete = r, this._finalized = !1;\n      }\n      cancel() {\n        this._finalized || (this._onCancel(), this._finalized = !0);\n      }\n      complete(t, e) {\n        this._finalized || (this._onComplete(t, e), this._finalized = !0);\n      }\n    }\n    gw.performDecoding = function (t, e) {\n      const r = new Uint8Array(t);\n      return Promise.all(e.tasks.map(t => {\n        const {\n            layerName: e,\n            firstByte: n,\n            lastByte: i,\n            pixelFormat: s,\n            blockShape: o,\n            blockIndex: a,\n            filters: l,\n            codec: u\n          } = t,\n          c = r.subarray(n, i + 1),\n          h = new Uint32Array(o[0] * o[1] * o[2]);\n        let p;\n        if (\"gzip_data\" !== u) throw new pw(\"Unhandled codec: \".concat(u));\n        return p = function (t, e) {\n          if (!globalThis.DecompressionStream && \"gzip_data\" === e) return Promise.resolve(((s = function (t) {\n            31 == t[0] && 139 == t[1] && 8 == t[2] || lw(6, \"invalid gzip data\");\n            var e = t[3],\n              r = 10;\n            4 & e && (r += 2 + (t[10] | t[11] << 8));\n            for (var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t[r++]);\n            return r + (2 & e);\n          }(i = t)) + 8 > i.length && lw(6, \"invalid gzip data\"), function (t, e, r, n) {\n            var i = t.length;\n            if (!i || e.f && !e.l) return r || new Ob(0);\n            var s = !r,\n              o = s || 2 != e.i,\n              a = e.i;\n            s && (r = new Ob(3 * i));\n            var l,\n              u,\n              c = function (t) {\n                var e = r.length;\n                if (t > e) {\n                  var n = new Ob(Math.max(2 * e, t));\n                  n.set(r), r = n;\n                }\n              },\n              h = e.f || 0,\n              p = e.p || 0,\n              d = e.b || 0,\n              f = e.l,\n              m = e.d,\n              y = e.m,\n              g = e.n,\n              x = 8 * i;\n            do {\n              if (!f) {\n                h = sw(t, p, 1);\n                var v = sw(t, p + 1, 3);\n                if (p += 3, !v) {\n                  var b = t[(T = 4 + ((p + 7) / 8 | 0)) - 4] | t[T - 3] << 8,\n                    w = T + b;\n                  if (w > i) {\n                    a && lw(0);\n                    break;\n                  }\n                  o && c(d + b), r.set(t.subarray(T, w), d), e.b = d += b, e.p = p = 8 * w, e.f = h;\n                  continue;\n                }\n                if (1 == v) f = rw, m = nw, y = 9, g = 5;else if (2 == v) {\n                  var _ = sw(t, p, 31) + 257,\n                    A = sw(t, p + 10, 15) + 4,\n                    M = _ + sw(t, p + 5, 31) + 1;\n                  p += 14;\n                  for (var I = new Ob(M), S = new Ob(19), P = 0; P < A; ++P) S[Gb[P]] = sw(t, p + 3 * P, 7);\n                  p += 3 * A;\n                  var k = iw(S),\n                    z = (1 << k) - 1,\n                    E = Qb(S, k);\n                  for (P = 0; P < M;) {\n                    var T,\n                      B = E[sw(t, p, z)];\n                    if (p += 15 & B, (T = B >> 4) < 16) I[P++] = T;else {\n                      var V = 0,\n                        F = 0;\n                      for (16 == T ? (F = 3 + sw(t, p, 3), p += 2, V = I[P - 1]) : 17 == T ? (F = 3 + sw(t, p, 7), p += 3) : 18 == T && (F = 11 + sw(t, p, 127), p += 7); F--;) I[P++] = V;\n                    }\n                  }\n                  var C = I.subarray(0, _),\n                    D = I.subarray(_);\n                  y = iw(C), g = iw(D), f = Qb(C, y), m = Qb(D, g);\n                } else lw(1);\n                if (p > x) {\n                  a && lw(0);\n                  break;\n                }\n              }\n              o && c(d + 131072);\n              for (var R = (1 << y) - 1, L = (1 << g) - 1, O = p;; O = p) {\n                var U = (V = f[ow(t, p) & R]) >> 4;\n                if ((p += 15 & V) > x) {\n                  a && lw(0);\n                  break;\n                }\n                if (V || lw(2), U < 256) r[d++] = U;else {\n                  if (256 == U) {\n                    O = p, f = null;\n                    break;\n                  }\n                  var N = U - 254;\n                  U > 264 && (N = sw(t, p, (1 << (G = jb[P = U - 257])) - 1) + Xb[P], p += G);\n                  var j = m[ow(t, p) & L],\n                    $ = j >> 4;\n                  if (j || lw(3), p += 15 & j, D = Wb[$], $ > 3) {\n                    var G = $b[$];\n                    D += ow(t, p) & (1 << G) - 1, p += G;\n                  }\n                  if (p > x) {\n                    a && lw(0);\n                    break;\n                  }\n                  o && c(d + 131072);\n                  var H = d + N;\n                  if (d < D) {\n                    var q = 0 - D,\n                      X = Math.min(D, H);\n                    for (q + d < 0 && lw(3); d < X; ++d) r[d] = (void 0)[q + d];\n                  }\n                  for (; d < H; ++d) r[d] = r[d - D];\n                }\n              }\n              e.l = f, e.p = O, e.b = d, e.f = h, f && (h = 1, e.m = y, e.d = m, e.n = g);\n            } while (!h);\n            return d != r.length && s ? (l = r, (null == (u = d) || u > l.length) && (u = l.length), new Ob(l.subarray(0, u))) : r.subarray(0, d);\n          }(i.subarray(s, -8), {\n            i: 2\n          }, new Ob(((r = i)[(n = r.length) - 4] | r[n - 3] << 8 | r[n - 2] << 16 | r[n - 1] << 24) >>> 0))));\n          var r, n, i, s;\n          const o = hw[e];\n          if (!o) throw new Error(\"Unhandled codec: \".concat(e));\n          const a = new globalThis.DecompressionStream(o);\n          return new Response(new Blob([t]).stream().pipeThrough(a)).arrayBuffer().then(t => new Uint8Array(t));\n        }(c, u).then(t => (function (t, e) {\n          t.readFields(Fb, e);\n        }(new yw(t), h), new (0, mw[s])(h.buffer))), p.then(t => {\n          for (let e = l.length - 1; e >= 0; e--) switch (l[e]) {\n            case \"delta_filter\":\n              Db(t, o);\n              break;\n            case \"zigzag_filter\":\n              Rb(t);\n              break;\n            case \"bitshuffle_filter\":\n              Lb(t, s);\n              break;\n            default:\n              throw new pw(\"Unhandled filter \\\"\".concat(l[e], \"\\\"\"));\n          }\n          return {\n            layerName: e,\n            blockIndex: a,\n            data: t\n          };\n        }).catch(t => {\n          throw t;\n        });\n      }));\n    }, Ws(vw, \"MRTDecodingBatch\", {\n      omit: [\"_onCancel\", \"_onComplete\"]\n    }), Ws(gw, \"MapboxRasterTile\"), Ws(xw, \"MapboxRasterLayer\", {\n      omit: [\"_blocksInProgress\"]\n    });\n    class bw {\n      constructor(t) {\n        this._stringToNumber = {}, this._numberToString = [];\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          this._stringToNumber[r] = e, this._numberToString[e] = r;\n        }\n      }\n      encode(t) {\n        return this._stringToNumber[t];\n      }\n      decode(t) {\n        return this._numberToString[t];\n      }\n    }\n    const ww = [\"id\", \"tile\", \"layer\", \"source\", \"sourceLayer\", \"state\"];\n    class _w {\n      constructor(t, e, r, n, i) {\n        this.type = \"Feature\", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;\n      }\n      clone() {\n        const t = new _w(this._vectorTileFeature, this._z, this._x, this._y, this.id);\n        return this.state && (t.state = Object.assign({}, this.state)), this.layer && (t.layer = Object.assign({}, this.layer)), this.source && (t.source = this.source), this.sourceLayer && (t.sourceLayer = this.sourceLayer), t;\n      }\n      get geometry() {\n        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;\n      }\n      set geometry(t) {\n        this._geometry = t;\n      }\n      toJSON() {\n        const t = {\n          type: \"Feature\",\n          state: void 0,\n          geometry: this.geometry,\n          properties: this.properties\n        };\n        for (const e of ww) void 0 !== this[e] && (t[e] = this[e]);\n        return t;\n      }\n    }\n    class Aw {\n      constructor(t, e) {\n        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Xs(Rn, 16, 0), this.featureIndexArray = new tl(), this.promoteId = e, this.is3DTile = !1, this.serializedLayersCache = new Map();\n      }\n      insert(t, e, r, n, i) {\n        let s = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n        let o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n        const a = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(r, n, i, s);\n        const l = this.grid;\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t],\n            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n          }\n          0 !== o && (n[0] -= o, n[1] -= o, n[2] += o, n[3] += o), n[0] < Rn && n[1] < Rn && n[2] >= 0 && n[3] >= 0 && l.insert(a, n[0], n[1], n[2], n[3]);\n        }\n      }\n      loadVTLayers() {\n        if (!this.vtLayers) {\n          this.vtLayers = new Eu(new cy(this.rawTileData)).layers, this.sourceLayerCoder = new bw(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"]), this.vtFeatures = {};\n          for (const t in this.vtLayers) this.vtFeatures[t] = [];\n        }\n        return this.vtLayers;\n      }\n      query(t, e) {\n        var _this = this;\n        const {\n          tilespaceGeometry: r,\n          transform: n,\n          tileTransform: i,\n          pixelPosMatrix: s,\n          availableImages: o,\n          worldview: a\n        } = e;\n        this.loadVTLayers(), this.serializedLayersCache.clear();\n        const l = r.bufferedTilespaceBounds,\n          u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, n, i) => hc(r.bufferedTilespaceGeometry, t, e, n, i));\n        u.sort(Iw);\n        let c = null;\n        n.elevation && u.length > 0 && (c = av.create(n.elevation, this.tileID));\n        const h = {};\n        let p;\n        for (let e = 0; e < u.length; e++) {\n          const l = u[e];\n          if (l === p) continue;\n          p = l;\n          const d = this.featureIndexArray.get(l);\n          let f = null;\n          this.is3DTile ? this.loadMatchingModelFeature(h, d, t, r, n, a) : this.loadMatchingFeature(h, d, t, o, a, function (t, e, o) {\n            let a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n            return f || (f = Au(t, _this.tileID.canonical, i)), e.queryIntersectsFeature(r, t, o, f, _this.z, n, s, c, a);\n          });\n        }\n        return h;\n      }\n      loadMatchingFeature(t, e, r, n, i, s) {\n        const {\n            featureIndex: o,\n            bucketIndex: a,\n            sourceLayerIndex: l,\n            layoutVertexArrayOffset: u\n          } = e,\n          c = this.bucketLayerIDs[a],\n          h = r.layers,\n          p = Object.keys(h);\n        if (p.length && !jt(p, c)) return;\n        const d = r.sourceCache,\n          f = this.sourceLayerCoder.decode(l),\n          m = this.vtLayers[f].feature(o),\n          y = this.getId(m, f);\n        for (let e = 0; e < c.length; e++) {\n          const r = c[e];\n          if (!h[r]) continue;\n          const {\n            styleLayer: a,\n            targets: l\n          } = h[r];\n          let p = {};\n          void 0 !== y && (p = d.getFeatureState(a.sourceLayer, y));\n          const f = !s || s(m, a, p, u);\n          if (!f) continue;\n          const g = new _w(m, this.z, this.x, this.y, y);\n          g.tile = this.tileID.canonical, g.state = p;\n          let x = this.serializedLayersCache.get(r);\n          x || (x = a.serialize(), x.id = r, this.serializedLayersCache.set(r, x)), g.source = x.source, g.sourceLayer = x[\"source-layer\"], g.layer = Object.assign({}, x), g.layer.paint = Mw(x.paint, a.paint, m, p, n), g.layer.layout = Mw(x.layout, a.layout, m, p, n);\n          let v = !1;\n          for (const t of l) {\n            this.updateFeatureProperties(g, t);\n            const {\n              filter: e\n            } = t;\n            if (e) if (m.properties = g.properties, e.needGeometry) {\n              const t = Mu(m, !0);\n              if (!e.filter(new wo(this.tileID.overscaledZ, {\n                worldview: i\n              }), t, this.tileID.canonical)) continue;\n            } else if (!e.filter(new wo(this.tileID.overscaledZ, {\n              worldview: i\n            }), m)) continue;\n            v = !0, t.targetId && this.addFeatureVariant(g, t);\n          }\n          v && this.appendToResult(t, r, o, g, f);\n        }\n      }\n      loadMatchingModelFeature(t, e, r, n, i, s) {\n        const {\n            featureIndex: o,\n            bucketIndex: a\n          } = e,\n          l = this.bucketLayerIDs[a],\n          u = r.layers,\n          c = Object.keys(u);\n        if (!c.length || jt(c, l)) for (let e = 0; e < l.length; e++) {\n          const a = l[e],\n            {\n              styleLayer: c,\n              targets: h\n            } = u[a];\n          if (\"model\" !== c.type) continue;\n          const p = n.tile,\n            d = p.getBucket(c);\n          if (!(d && d instanceof fv)) continue;\n          const f = vv(d, o, n, i);\n          if (!f) continue;\n          const {\n              z: m,\n              x: y,\n              y: g\n            } = p.tileID.canonical,\n            {\n              feature: x,\n              intersectionZ: v,\n              position: b\n            } = f;\n          let w = {};\n          void 0 !== x.id && (w = r.sourceCache.getFeatureState(c.sourceLayer, x.id));\n          const _ = new _w({}, m, y, g, x.id);\n          _.tile = this.tileID.canonical, _.state = w, _.properties = x.properties, _.geometry = {\n            type: \"Point\",\n            coordinates: [b.lng, b.lat]\n          };\n          let A = this.serializedLayersCache.get(a);\n          A || (A = c.serialize(), A.id = a, this.serializedLayersCache.set(a, A)), _.source = A.source, _.sourceLayer = A[\"source-layer\"], _.layer = Object.assign({}, A);\n          let M = !1;\n          for (const t of h) {\n            this.updateFeatureProperties(_, t);\n            const {\n              filter: e\n            } = t;\n            if (e) if (x.properties = _.properties, e.needGeometry) {\n              if (!e.filter(new wo(this.tileID.overscaledZ, {\n                worldview: s\n              }), x, this.tileID.canonical)) continue;\n            } else if (!e.filter(new wo(this.tileID.overscaledZ, {\n              worldview: s\n            }), x)) continue;\n            M = !0, t.targetId && this.addFeatureVariant(_, t);\n          }\n          M && this.appendToResult(t, a, o, _, v);\n        }\n      }\n      updateFeatureProperties(t, e, r) {\n        if (e.properties) {\n          const n = {};\n          for (const i in e.properties) {\n            const s = e.properties[i].evaluate({\n              zoom: this.z\n            }, t._vectorTileFeature, t.state, t.tile, r);\n            null != s && (n[i] = s);\n          }\n          t.properties = n;\n        }\n      }\n      addFeatureVariant(t, e, r) {\n        const n = {\n          target: e.target,\n          namespace: e.namespace,\n          uniqueFeatureID: e.uniqueFeatureID\n        };\n        e.properties && (n.properties = t.properties), t.variants = t.variants || {}, t.variants[e.targetId] = t.variants[e.targetId] || [], t.variants[e.targetId].push(n);\n      }\n      appendToResult(t, e, r, n, i) {\n        let s = t[e];\n        void 0 === s && (s = t[e] = []), s.push({\n          featureIndex: r,\n          feature: n,\n          intersectionZ: i\n        });\n      }\n      lookupSymbolFeatures(t, e, r, n, i, s) {\n        const o = {};\n        this.loadVTLayers();\n        for (const a of t) this.loadMatchingFeature(o, {\n          bucketIndex: e,\n          sourceLayerIndex: r,\n          featureIndex: a,\n          layoutVertexArrayOffset: 0\n        }, n, i, s);\n        return o;\n      }\n      loadFeature(t) {\n        const {\n          featureIndex: e,\n          sourceLayerIndex: r\n        } = t;\n        this.loadVTLayers();\n        const n = this.sourceLayerCoder.decode(r),\n          i = this.vtFeatures[n];\n        if (i[e]) return i[e];\n        const s = this.vtLayers[n].feature(e);\n        return i[e] = s, s;\n      }\n      hasLayer(t) {\n        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n        return !1;\n      }\n      getId(t, e) {\n        let r = t.id;\n        if (this.promoteId) {\n          const n = Array.isArray(this.promoteId) || \"object\" != typeof this.promoteId ? this.promoteId : this.promoteId[e];\n          if (null != n) if (Array.isArray(n)) {\n            if (!this.promoteIdExpression) {\n              const t = Ls(n);\n              if (\"success\" !== t.result) {\n                const e = t.value.map(t => \"\".concat(t.key, \": \").concat(t.message)).join(\", \");\n                return void Gt(\"Failed to create expression for promoteId: \".concat(e));\n              }\n              this.promoteIdExpression = t.value;\n            }\n            this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new tn()), r = this.promoteIdExpression.evaluate({\n              zoom: 0\n            }, t);\n          } else r = t.properties[n];\n          \"boolean\" == typeof r && (r = Number(r));\n        }\n        return r;\n      }\n    }\n    function Mw(t, e, r, n, i) {\n      return Ot(t, (t, s) => {\n        const o = e instanceof zo ? e.get(s) : null;\n        return o && o.evaluate ? o.evaluate(r, n, void 0, i) : o;\n      });\n    }\n    function Iw(t, e) {\n      return e - t;\n    }\n    Ws(Aw, \"FeatureIndex\", {\n      omit: [\"rawTileData\", \"sourceLayerCoder\"]\n    });\n    const Sw = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n    class Pw {\n      static from(t) {\n        if (!(t instanceof ArrayBuffer)) throw new Error(\"Data must be an instance of ArrayBuffer.\");\n        const [e, r] = new Uint8Array(t, 0, 2);\n        if (219 !== e) throw new Error(\"Data does not appear to be in a KDBush format.\");\n        const n = r >> 4;\n        if (1 !== n) throw new Error(\"Got v\".concat(n, \" data when expected v1.\"));\n        const i = Sw[15 & r];\n        if (!i) throw new Error(\"Unrecognized array type.\");\n        const [s] = new Uint16Array(t, 2, 1),\n          [o] = new Uint32Array(t, 4, 1);\n        return new Pw(o, s, i, t);\n      }\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float64Array;\n        let n = arguments.length > 3 ? arguments[3] : undefined;\n        if (isNaN(t) || t < 0) throw new Error(\"Unpexpected numItems value: \".concat(t, \".\"));\n        this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;\n        const i = Sw.indexOf(this.ArrayType),\n          s = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,\n          o = t * this.IndexArrayType.BYTES_PER_ELEMENT,\n          a = (8 - o % 8) % 8;\n        if (i < 0) throw new Error(\"Unexpected typed array class: \".concat(r, \".\"));\n        n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + o + a, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + o + a), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + o + a, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t);\n      }\n      add(t, e) {\n        const r = this._pos >> 1;\n        return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = e, r;\n      }\n      finish() {\n        const t = this._pos >> 1;\n        if (t !== this.numItems) throw new Error(\"Added \".concat(t, \" items when expected \").concat(this.numItems, \".\"));\n        return kw(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;\n      }\n      range(t, e, r, n) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: i,\n            coords: s,\n            nodeSize: o\n          } = this,\n          a = [0, i.length - 1, 0],\n          l = [];\n        for (; a.length;) {\n          const u = a.pop() || 0,\n            c = a.pop() || 0,\n            h = a.pop() || 0;\n          if (c - h <= o) {\n            for (let o = h; o <= c; o++) {\n              const a = s[2 * o],\n                u = s[2 * o + 1];\n              a >= t && a <= r && u >= e && u <= n && l.push(i[o]);\n            }\n            continue;\n          }\n          const p = h + c >> 1,\n            d = s[2 * p],\n            f = s[2 * p + 1];\n          d >= t && d <= r && f >= e && f <= n && l.push(i[p]), (0 === u ? t <= d : e <= f) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? r >= d : n >= f) && (a.push(p + 1), a.push(c), a.push(1 - u));\n        }\n        return l;\n      }\n      within(t, e, r) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: n,\n            coords: i,\n            nodeSize: s\n          } = this,\n          o = [0, n.length - 1, 0],\n          a = [],\n          l = r * r;\n        for (; o.length;) {\n          const u = o.pop() || 0,\n            c = o.pop() || 0,\n            h = o.pop() || 0;\n          if (c - h <= s) {\n            for (let r = h; r <= c; r++) Bw(i[2 * r], i[2 * r + 1], t, e) <= l && a.push(n[r]);\n            continue;\n          }\n          const p = h + c >> 1,\n            d = i[2 * p],\n            f = i[2 * p + 1];\n          Bw(d, f, t, e) <= l && a.push(n[p]), (0 === u ? t - r <= d : e - r <= f) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? t + r >= d : e + r >= f) && (o.push(p + 1), o.push(c), o.push(1 - u));\n        }\n        return a;\n      }\n    }\n    function kw(t, e, r, n, i, s) {\n      if (i - n <= r) return;\n      const o = n + i >> 1;\n      zw(t, e, o, n, i, s), kw(t, e, r, n, o - 1, 1 - s), kw(t, e, r, o + 1, i, 1 - s);\n    }\n    function zw(t, e, r, n, i, s) {\n      for (; i > n;) {\n        if (i - n > 600) {\n          const o = i - n + 1,\n            a = r - n + 1,\n            l = Math.log(o),\n            u = .5 * Math.exp(2 * l / 3),\n            c = .5 * Math.sqrt(l * u * (o - u) / o) * (a - o / 2 < 0 ? -1 : 1);\n          zw(t, e, r, Math.max(n, Math.floor(r - a * u / o + c)), Math.min(i, Math.floor(r + (o - a) * u / o + c)), s);\n        }\n        const o = e[2 * r + s];\n        let a = n,\n          l = i;\n        for (Ew(t, e, n, r), e[2 * i + s] > o && Ew(t, e, n, i); a < l;) {\n          for (Ew(t, e, a, l), a++, l--; e[2 * a + s] < o;) a++;\n          for (; e[2 * l + s] > o;) l--;\n        }\n        e[2 * n + s] === o ? Ew(t, e, n, l) : (l++, Ew(t, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);\n      }\n    }\n    function Ew(t, e, r, n) {\n      Tw(t, r, n), Tw(e, 2 * r, 2 * n), Tw(e, 2 * r + 1, 2 * n + 1);\n    }\n    function Tw(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function Bw(t, e, r, n) {\n      const i = t - r,\n        s = e - n;\n      return i * i + s * s;\n    }\n    t.$ = Yr, t.A = Fr, t.B = Ko, t.C = 2, t.D = Ld, t.E = tr, t.F = og, t.G = ig, t.H = Xr, t.I = er, t.J = Co, t.K = qr, t.L = Wr, t.M = Ps, t.N = Ms, t.O = Ss, t.P = wt, t.Q = Rs, t.R = Be, t.S = Do, t.T = vf, t.U = Ls, t.V = tv, t.W = Ns, t.X = gi, t.Y = fi, t.Z = mi, t._ = en, t.a = function (t) {\n      return ne.API_CDN_URL_REGEX.test(t);\n    }, t.a$ = lu, t.a0 = Zr, t.a1 = ir, t.a2 = Ro, t.a3 = class extends tv {}, t.a4 = ks, t.a5 = Is, t.a6 = Fo, t.a7 = function (t) {\n      const e = t.value;\n      return e ? Zr(e) ? ev(e, !0) ? [] : [new tv(t.key, e, \"invalid url \\\"\".concat(e, \"\\\"\"))] : [new tv(t.key, e, \"string expected, \\\"\".concat(qr(e), \"\\\" found\"))] : [];\n    }, t.a8 = Mo, t.a9 = Vo, t.aA = Tt, t.aB = c, t.aC = Y, t.aD = Nl, t.aE = cc, t.aF = iu, t.aG = gu, t.aH = function (t, e) {\n      const r = {};\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n      return r;\n    }, t.aI = tu, t.aJ = su, t.aK = class {\n      constructor(t) {\n        this.entries = {}, this.scheduler = t;\n      }\n      request(t, e, r, n) {\n        const i = this.entries[t] = this.entries[t] || {\n          callbacks: []\n        };\n        if (i.result) {\n          const [t, r] = i.result;\n          return this.scheduler ? this.scheduler.add(() => {\n            n(t, r);\n          }, e) : n(t, r), () => {};\n        }\n        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {\n          i.result = [r, n];\n          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {\n            t(r, n);\n          }, e) : t(r, n);\n          setTimeout(() => delete this.entries[t], 3e3);\n        })), () => {\n          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));\n        };\n      }\n    }, t.aL = function (t, e, r) {\n      const n = JSON.stringify(t.request);\n      return t.data && (this.deduped.entries[n] = {\n        result: [null, t.data]\n      }), this.deduped.request(n, {\n        type: \"parseTile\",\n        isSymbolTile: t.isSymbolTile,\n        zoom: t.tileZoom\n      }, e => {\n        const n = De(t.request, (t, n, i, s) => {\n          t ? e(t) : n && e(null, {\n            vectorTile: r ? void 0 : new Eu(new cy(n)),\n            rawData: n,\n            cacheControl: i,\n            expires: s\n          });\n        });\n        return () => {\n          n.cancel(), e();\n        };\n      }, e);\n    }, t.aM = function (t) {\n      Me++, Me > xe && (t.getActor().send(\"enforceCacheSizeLimit\", ge), Me = 0);\n    }, t.aN = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log2(t)));\n    }, t.aO = Mc, t.aP = Gx, t.aQ = Yx, t.aR = Ql, t.aS = jx, t.aT = function (t, e) {\n      const r = document.createElement(\"video\");\n      r.muted = !0, r.onloadstart = function () {\n        e(null, r);\n      };\n      for (let e = 0; e < t.length; e++) {\n        const n = document.createElement(\"source\");\n        Re(t[e]) || (r.crossOrigin = \"Anonymous\"), n.src = t[e], r.appendChild(n);\n      }\n      return {\n        cancel: () => {}\n      };\n    }, t.aU = bf, t.aV = function (t) {\n      return fetch(t).then(t => t.arrayBuffer()).then(e => yf(e, 0, t));\n    }, t.aW = Qf, t.aX = class {\n      constructor(t, e, r, n) {\n        this.id = t, this.position = null != e ? new Ql(e[0], e[1]) : new Ql(0, 0), this.orientation = null != r ? r : [0, 0, 0], this.nodes = n, this.uploaded = !1, this.aabb = new Xu([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];\n      }\n      _applyTransformations(t, e) {\n        if (c(t.matrix, e, t.matrix), t.meshes) for (const e of t.meshes) {\n          const r = Xu.applyTransformFast(e.aabb, t.matrix);\n          this.aabb.encapsulate(r);\n        }\n        if (t.children) for (const e of t.children) this._applyTransformations(e, t.matrix);\n      }\n      computeBoundsAndApplyParent() {\n        const t = l([]);\n        for (const e of this.nodes) this._applyTransformations(e, t);\n      }\n      computeModelMatrix(t, e, r, n, i, s) {\n        let o = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;\n        Uf(this.matrix, this, t.transform, this.position, e, r, n, i, s, o);\n      }\n      upload(t) {\n        if (!this.uploaded) {\n          for (const e of this.nodes) $f(e, t);\n          for (const t of this.nodes) Gf(t);\n          this.uploaded = !0;\n        }\n      }\n      destroy() {\n        for (const t of this.nodes) Hf(t);\n      }\n    }, t.aY = Lt, t.aZ = Zg, t.a_ = au, t.aa = Eo, t.ab = class {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return Xt(t.expression.evaluate(e));\n      }\n      interpolate(t, e, r) {\n        return {\n          x: ur(t.x, e.x, r),\n          y: ur(t.y, e.y, r),\n          z: ur(t.z, e.z, r),\n          azimuthal: ur(t.azimuthal, e.azimuthal, r),\n          polar: ur(t.polar, e.polar, r)\n        };\n      }\n    }, t.ac = wo, t.ad = Us, t.ae = mu, t.af = O, t.ag = _, t.ah = Bt, t.ai = zo, t.aj = Yc, t.ak = ur, t.al = Rn, t.am = cr, t.an = It, t.ao = sr, t.ap = class {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return function (_ref71) {\n          let [t, e] = _ref71;\n          const r = Xt([1, t, e]);\n          return {\n            x: r.x,\n            y: r.y,\n            z: r.z\n          };\n        }(t.expression.evaluate(e));\n      }\n      interpolate(t, e, r) {\n        return {\n          x: ur(t.x, e.x, r),\n          y: ur(t.y, e.y, r),\n          z: ur(t.z, e.z, r)\n        };\n      }\n    }, t.aq = function (t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n      const i = new wt(r, r),\n        s = t.sub(i),\n        o = e.add(i),\n        a = [s, new wt(o.x, s.y), o, new wt(s.x, o.y)];\n      return n && a.push(s.clone()), a;\n    }, t.ar = function (t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; n++) {\n        const i = Vt(n - 1, -1, t.length - 1),\n          s = Vt(n + 1, -1, t.length - 1),\n          o = t[n],\n          a = t[s],\n          l = t[i].sub(o).unit(),\n          u = a.sub(o).unit(),\n          c = u.angleWithSep(l.x, l.y),\n          h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));\n        r.push(o.add(h));\n      }\n      return r;\n    }, t.as = Wg, t.at = hc, t.au = function (t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return A(((e.x - r) * t.scale - t.x) * Rn, (e.y * t.scale - t.y) * Rn, uu(e.z, e.y));\n    }, t.av = G, t.aw = C, t.ax = Uu, t.ay = Cm, t.az = function (t) {\n      let e = 1 / 0,\n        r = 1 / 0,\n        n = -1 / 0,\n        i = -1 / 0;\n      for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n      return {\n        min: new wt(e, r),\n        max: new wt(n, i)\n      };\n    }, t.b = function (t) {\n      return ne.API_FONTS_REGEX.test(t);\n    }, t.b$ = jp, t.b0 = ha, t.b1 = Ea, t.b2 = Dt, t.b3 = qa, t.b4 = Px, t.b5 = function () {\n      bo.isLoading() || bo.isLoaded() || \"deferred\" !== xo() || vo();\n    }, t.b6 = Lo, t.b7 = Mu, t.b8 = _w, t.b9 = Wt, t.bA = l, t.bB = m, t.bC = a, t.bD = function (t, e) {\n      const {\n          x: r,\n          y: n\n        } = t.point,\n        i = Wc(r, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);\n      return c(i, i, qc(Dc(e)));\n    }, t.bE = n, t.bF = j, t.bG = function (t, e) {\n      var r = e[0] - t[0],\n        n = e[1] - t[1],\n        i = e[2] - t[2];\n      return Math.sqrt(r * r + n * n + i * i);\n    }, t.bH = T, t.bI = R, t.bJ = D, t.bK = Wy, t.bL = Py, t.bM = Zy, t.bN = function (t, e, r, n, i) {\n      const s = 5 * e + 2;\n      t.float32[s + 0] = r, t.float32[s + 1] = n, t.float32[s + 2] = i;\n    }, t.bO = Ax, t.bP = at, t.bQ = ht, t.bR = ut, t.bS = gt, t.bT = Vt, t.bU = function (t, e, n, i) {\n      var s = new r(4);\n      return s[0] = t, s[1] = e, s[2] = n, s[3] = i, s;\n    }, t.bV = Sd, t.bW = Qu, t.bX = ry, t.bY = Bp, t.bZ = Qx, t.b_ = Np, t.ba = Tm, t.bb = mp, t.bc = Au, t.bd = ua, t.be = Ua, t.bf = Ec, t.bg = al, t.bh = Ih, t.bi = Lx, t.bj = function (t, e) {\n      const r = Yc(e.zoom);\n      if (0 === r) return Dc(t);\n      const n = Uc(t),\n        i = Nc(n),\n        s = iu(n.getWest()) * e.worldSize,\n        o = iu(n.getEast()) * e.worldSize,\n        a = su(n.getNorth()) * e.worldSize,\n        l = su(n.getSouth()) * e.worldSize,\n        c = [s, a, 0],\n        h = [o, a, 0],\n        p = [s, l, 0],\n        d = [o, l, 0],\n        f = u([], e.globeMatrix);\n      return O(c, c, f), O(h, h, f), O(p, p, f), O(d, d, f), i[0] = Rc(i[0], p, r), i[1] = Rc(i[1], d, r), i[2] = Rc(i[2], h, r), i[3] = Rc(i[3], c, r), Xu.fromPoints(i);\n    }, t.bk = Hc, t.bl = u, t.bm = jc, t.bn = Rc, t.bo = ca, t.bp = zc, t.bq = y, t.br = h, t.bs = gw, t.bt = cy, t.bu = De, t.bv = function (t, e) {\n      const r = [];\n      for (const n in t) n in e || r.push(n);\n      return r;\n    }, t.bw = Ft, t.bx = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"], t.by = _t, t.bz = function (t) {\n      var e = new r(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.c = se, t.c$ = function (t) {\n      return t * t * t * t * t;\n    }, t.c0 = Ly, t.c1 = zg, t.c2 = Rg, t.c3 = Pw, t.c4 = E, t.c5 = q, t.c6 = J, t.c7 = function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3],\n        a = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + i * a, t[1] = i * l - n * a, t[2] = s * l + o * a, t[3] = o * l - s * a, t;\n    }, t.c8 = Q, t.c9 = Kt, t.cA = qu, t.cB = zf, t.cC = _c, t.cD = Oc, t.cE = function (t, e, r, n, i, s, o, a, l) {\n      if (\"globe\" === l.name) return Oc(t, e, new _c(r, n, i), !1);\n      const u = Zg({\n        z: r,\n        x: n,\n        y: i\n      }, l);\n      return new Xu([(s + u.x / u.scale) * e, e * (u.y / u.scale), o], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), a]);\n    }, t.cF = function (t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t[3] = Math.min(e[3], r[3]), t;\n    }, t.cG = function (t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t[3] = Math.max(e[3], r[3]), t;\n    }, t.cH = function (t) {\n      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;\n      return Pt[e];\n    }, t.cI = cu, t.cJ = Z, t.cK = $l, t.cL = function (t) {\n      const e = l(new Float64Array(16));\n      c(e, t.pixelMatrix, t.globeMatrix);\n      const r = [0, Xl, 0],\n        n = [0, Zl, 0];\n      return O(r, r, e), O(n, n, e), [r[0] > 0 && r[0] <= t.width && r[1] > 0 && r[1] <= t.height && !Jc(t, new Ql(t.center.lat, 90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Jc(t, new Ql(t.center.lat, -90))];\n    }, t.cM = function (t, e) {\n      const {\n          scale: r\n        } = t.tileTransform,\n        n = r * Rn / (t.tileSize * Math.pow(2, e.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));\n      return function (t, e, r) {\n        var n = e[1],\n          i = e[2],\n          s = e[3],\n          o = r[0],\n          a = r[1];\n        return t[0] = e[0] * o, t[1] = n * o, t[2] = i * a, t[3] = s * a, t;\n      }(new Float32Array(4), e.inverseAdjustmentMatrix, [n, n]);\n    }, t.cN = Ef, t.cO = v, t.cP = kf, t.cQ = function (t) {\n      const e = kf(t, !0);\n      return n([], [e[0], e[1], e[4], e[5]]);\n    }, t.cR = p, t.cS = Nu, t.cT = d, t.cU = function (t) {\n      const {\n          x: e,\n          y: r\n        } = t.point,\n        {\n          lng: n,\n          lat: i\n        } = t._center;\n      return Wc(e, r, t.worldSize, n, i);\n    }, t.cV = P, t.cW = St, t.cX = Ic, t.cY = pc, t.cZ = jl, t.c_ = function (t, e, r) {\n      let n = 0;\n      for (let r = 0; r < 2; ++r) {\n        const i = 0;\n        t[r] > i && (n += (t[r] - i) * (t[r] - i)), e[r] < i && (n += (i - e[r]) * (i - e[r]));\n      }\n      return n;\n    }, t.ca = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;\n    }, t.cb = x, t.cc = function (t, e, r, n, i) {\n      var s = 1 / Math.tan(e / 2);\n      if (t[0] = s / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0) {\n        var o = 1 / (n - i);\n        t[10] = (i + n) * o, t[14] = 2 * i * n * o;\n      } else t[10] = -1, t[14] = -2 * n;\n      return t;\n    }, t.cd = function (t, e, r, n, i, s, o) {\n      var a = 1 / (e - r),\n        l = 1 / (n - i),\n        u = 1 / (s - o);\n      return t[0] = -2 * a, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * a, t[13] = (i + n) * l, t[14] = (o + s) * u, t[15] = 1, t;\n    }, t.ce = ou, t.cf = function (t, e, r) {\n      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];\n    }, t.cg = gl, t.ch = bl, t.ci = xl, t.cj = vl, t.ck = Ml, t.cl = yx, t.cm = function () {\n      var t = new r(4);\n      return r != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n    }, t.cn = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        o = e[3],\n        a = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + s * a, t[1] = i * l + o * a, t[2] = n * -a + s * l, t[3] = i * -a + o * l, t;\n    }, t.co = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n    }, t.cp = $, t.cq = function (t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2],\n        i = t[3];\n      return Math.sqrt(e * e + r * r + n * n + i * i);\n    }, t.cr = it, t.cs = N, t.ct = Ac, t.cu = 3, t.cv = 2, t.cw = 7, t.cx = 6, t.cy = L, t.cz = b, t.d = function (t) {\n      return ne.API_TILEJSON_REGEX.test(t);\n    }, t.d$ = Om, t.d0 = nu, t.d1 = 45, t.d2 = wl, t.d3 = function (t, e, r) {\n      const n = Math.sqrt(t * t + e * e + r * r),\n        i = n > 0 ? Math.acos(r / n) * Mt : 0;\n      let s = 0 !== t || 0 !== e ? Math.atan2(-e, -t) * Mt + 90 : 0;\n      return s < 0 && (s += 360), [n, s, i];\n    }, t.d4 = A, t.d5 = Xt, t.d6 = fu, t.d7 = I, t.d8 = Xu, t.d9 = S, t.dA = function (t, e, r) {\n      const n = Yc(r.zoom),\n        i = t.style.map._antialias,\n        s = t.terrain && t.terrain.exaggeration() > 0;\n      return 0 === n && !i && !s;\n    }, t.dB = function (t) {\n      const e = t.pixelsPerMeter,\n        r = e / ou(1, t.center.lat),\n        n = l(new Float64Array(16));\n      return h(n, n, [t.point.x, t.point.y, 0]), p(n, n, [r, r, e]), Float32Array.from(n);\n    }, t.dC = Uc, t.dD = function (t) {\n      const e = cu - 5;\n      t = Tt(t, -e, e) / e * 90;\n      const r = Math.pow(Math.abs(Math.sin(It(t))), 3);\n      return Math.round(r * (ql.length - 1));\n    }, t.dE = function (t, e, r, n) {\n      const i = e.getNorth(),\n        s = e.getSouth(),\n        a = e.getWest(),\n        l = e.getEast(),\n        u = 1 << t.z,\n        c = l - a,\n        h = i - s,\n        p = c / Hl,\n        d = -h / ql[r],\n        f = [0, p, 0, d, 0, 0, i, a, 0];\n      if (t.z > 0) {\n        const t = 180 / n;\n        o(f, f, [t / c + 1, 0, 0, 0, t / h + 1, 0, -.5 * t / p, .5 * t / d, 1]);\n      }\n      return f[2] = u, f[5] = t.x, f[8] = t.y, f;\n    }, t.dF = Dc, t.dG = function (t, e, r) {\n      const n = l(new Float64Array(16)),\n        i = (e / (1 << t) - .5) * Math.PI * 2;\n      return f(n, r.globeMatrix, i), Float32Array.from(n);\n    }, t.dH = class {\n      isDataAvailableAtPoint(t) {\n        const e = this._source();\n        if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;\n        const r = e.getSource().maxzoom,\n          n = 1 << r,\n          i = Math.floor(t.x),\n          s = Math.floor((t.x - i) * n),\n          o = Math.floor(t.y * n),\n          a = this.findDEMTileFor(new Mc(r, i, r, s, o));\n        return !(!a || !a.dem);\n      }\n      getAtPointOrZero(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        return this.getAtPoint(t, e) || 0;\n      }\n      getAtPoint(t, e) {\n        let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n        if (this.isUsingMockSource()) return null;\n        null == e && (e = null);\n        const n = this._source();\n        if (!n) return e;\n        if (t.y < 0 || t.y > 1) return e;\n        const i = n.getSource().maxzoom,\n          s = 1 << i,\n          o = Math.floor(t.x),\n          a = t.x - o,\n          l = new Mc(i, o, i, Math.floor(a * s), Math.floor(t.y * s)),\n          u = this.findDEMTileFor(l);\n        if (!u || !u.dem) return e;\n        const c = u.dem,\n          h = 1 << u.tileID.canonical.z,\n          p = (a * h - u.tileID.canonical.x) * c.dim,\n          d = (t.y * h - u.tileID.canonical.y) * c.dim,\n          f = Math.floor(p),\n          m = Math.floor(d);\n        return (r ? this.exaggeration() : 1) * ur(ur(c.get(f, m), c.get(f, m + 1), d - m), ur(c.get(f + 1, m), c.get(f + 1, m + 1), d - m), p - f);\n      }\n      getAtTileOffset(t, e, r) {\n        const n = 1 << t.canonical.z;\n        return this.getAtPointOrZero(new mu(t.wrap + (t.canonical.x + e / Rn) / n, (t.canonical.y + r / Rn) / n));\n      }\n      getAtTileOffsetFunc(t, e, r, n) {\n        return i => {\n          const s = this.getAtTileOffset(t, i.x, i.y),\n            o = n.upVector(t.canonical, i.x, i.y);\n          return E(o, o, s * n.upVectorScale(t.canonical, e, r).metersToTile), o;\n        };\n      }\n      getForTilePoints(t, e, r, n) {\n        if (this.isUsingMockSource()) return !1;\n        const i = av.create(this, t, n);\n        return !!i && (e.forEach(t => {\n          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);\n        }), !0);\n      }\n      getMinMaxForTile(t) {\n        if (this.isUsingMockSource()) return null;\n        const e = this.findDEMTileFor(t);\n        if (!e || !e.dem) return null;\n        const r = e.dem.tree,\n          n = e.tileID,\n          i = 1 << t.canonical.z - n.canonical.z;\n        let s = t.canonical.x / i - n.canonical.x,\n          o = t.canonical.y / i - n.canonical.y,\n          a = 0;\n        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[a]; e++) {\n          s *= 2, o *= 2;\n          const t = 2 * Math.floor(o) + Math.floor(s);\n          a = r.childOffsets[a] + t, s %= 1, o %= 1;\n        }\n        return {\n          min: this.exaggeration() * r.minimums[a],\n          max: this.exaggeration() * r.maximums[a]\n        };\n      }\n      getMinElevationBelowMSL() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      raycast(t, e, r) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      pointCoordinate(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      _source() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      isUsingMockSource() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      exaggeration() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      findDEMTileFor(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      get visibleDemTiles() {\n        throw new Error(\"Getter must be implemented in subclass.\");\n      }\n      getMinMaxForVisibleTiles() {\n        const t = this.visibleDemTiles;\n        if (0 === t.length) return null;\n        let e = !1,\n          r = Number.MAX_VALUE,\n          n = Number.MIN_VALUE;\n        for (const i of t) {\n          const t = this.getMinMaxForTile(i.tileID);\n          t && (r = Math.min(r, t.min), n = Math.max(n, t.max), e = !0);\n        }\n        return e ? {\n          min: r,\n          max: n\n        } : null;\n      }\n    }, t.dI = vh, t.dJ = Tc, t.dK = function (t, e) {\n      return [Math.pow(t[0], 2.2) * e, Math.pow(t[1], 2.2) * e, Math.pow(t[2], 2.2) * e];\n    }, t.dL = i, t.dM = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, t.dN = U, t.dO = Zc, t.dP = te, t.dQ = ee, t.dR = 256, t.dS = function (t, e) {\n      const r = [0, 0, 0];\n      return O(r, r, Hc(Dc(e.canonical))), O(r, r, t), r;\n    }, t.dT = t => ({\n      u_matrix: new Ml(t),\n      u_texsize: new vl(t),\n      u_pixels_to_tile_units: new Pl(t),\n      u_device_pixel_ratio: new xl(t),\n      u_width_scale: new xl(t),\n      u_floor_width_scale: new xl(t),\n      u_image: new gl(t),\n      u_units_to_pixels: new vl(t),\n      u_tile_units_to_pixels: new xl(t),\n      u_alpha_discard_threshold: new xl(t),\n      u_trim_offset: new vl(t),\n      u_trim_fade_range: new vl(t),\n      u_trim_color: new wl(t),\n      u_emissive_strength: new xl(t),\n      u_zbias_factor: new xl(t),\n      u_tile_to_meter: new xl(t),\n      u_ground_shadow_factor: new bl(t),\n      u_pattern_transition: new xl(t)\n    }), t.dU = t => ({\n      u_matrix: new Ml(t),\n      u_pixels_to_tile_units: new Pl(t),\n      u_device_pixel_ratio: new xl(t),\n      u_width_scale: new xl(t),\n      u_floor_width_scale: new xl(t),\n      u_units_to_pixels: new vl(t),\n      u_dash_image: new gl(t),\n      u_gradient_image: new gl(t),\n      u_image_height: new xl(t),\n      u_texsize: new vl(t),\n      u_tile_units_to_pixels: new xl(t),\n      u_alpha_discard_threshold: new xl(t),\n      u_trim_offset: new vl(t),\n      u_trim_fade_range: new vl(t),\n      u_trim_color: new wl(t),\n      u_emissive_strength: new xl(t),\n      u_zbias_factor: new xl(t),\n      u_tile_to_meter: new xl(t),\n      u_ground_shadow_factor: new bl(t)\n    }), t.dV = t => ({\n      u_camera_to_center_distance: new xl(t),\n      u_extrude_scale: new Pl(t),\n      u_device_pixel_ratio: new xl(t),\n      u_matrix: new Ml(t),\n      u_inv_rot_matrix: new Ml(t),\n      u_merc_center: new vl(t),\n      u_tile_id: new bl(t),\n      u_zoom_transition: new xl(t),\n      u_up_dir: new bl(t),\n      u_emissive_strength: new xl(t)\n    }), t.dW = ka, t.dX = ey, t.dY = class {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = n, this.size = r, this.texture = t.gl.createTexture();\n        const [i, s, o] = this.size,\n          {\n            gl: a\n          } = t;\n        a.bindTexture(a.TEXTURE_3D, this.texture), t.pixelStoreUnpackFlipY.set(!1), t.pixelStoreUnpack.set(1), t.pixelStoreUnpackPremultiplyAlpha.set(!1), \"data\" in e && e.data && a.texImage3D(a.TEXTURE_3D, 0, this.format, i, s, o, 0, gf(this.format), xf(this.format), e.data);\n      }\n      bind(t, e) {\n        const {\n            context: r\n          } = this,\n          {\n            gl: n\n          } = r;\n        n.bindTexture(n.TEXTURE_3D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, t), this.minFilter = t), e !== this.wrapS && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n    }, t.dZ = nh, t.d_ = (t, e, r, n, i, s) => {\n      const o = t.transform,\n        a = \"globe\" === o.projection.name;\n      let l;\n      if (\"map\" === s.paint.get(\"circle-pitch-alignment\")) {\n        if (a) {\n          const t = Zc(o.zoom, e.canonical) * o._pixelsPerMercatorPixel;\n          l = Float32Array.from([t, 0, 0, t]);\n        } else l = o.calculatePixelsToTileUnitsMatrix(r);\n      } else l = new Float32Array([o.pixelsToGLUnits[0], 0, 0, o.pixelsToGLUnits[1]]);\n      const u = {\n        u_camera_to_center_distance: t.transform.getCameraToCenterDistance(o.projection),\n        u_matrix: t.translatePosMatrix(e.projMatrix, r, s.paint.get(\"circle-translate\"), s.paint.get(\"circle-translate-anchor\")),\n        u_device_pixel_ratio: de.devicePixelRatio,\n        u_extrude_scale: l,\n        u_inv_rot_matrix: rh,\n        u_merc_center: [0, 0],\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_up_dir: [0, 0, 0],\n        u_emissive_strength: s.paint.get(\"circle-emissive-strength\")\n      };\n      if (a) {\n        u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], u.u_zoom_transition = Yc(o.zoom);\n        const t = i[0] * Rn,\n          r = i[1] * Rn;\n        u.u_up_dir = o.projection.upVector(new _c(0, 0, 0), t, r);\n      }\n      return u;\n    }, t.da = function (t) {\n      return [Math.pow(t[0], 1 / 2.2), Math.pow(t[1], 1 / 2.2), Math.pow(t[2], 1 / 2.2)];\n    }, t.db = ev, t.dc = function (t, e) {\n      return t.readFields(kv, {\n        icons: []\n      }, e);\n    }, t.dd = Nd, t.de = fg, t.df = dg, t.dg = Fe, t.dh = mo, t.di = me, t.dj = We, t.dk = Nt, t.dl = function (t) {\n      const e = t.indexOf(Yo);\n      return e >= 0 ? t.slice(0, e) : t;\n    }, t.dm = function (t) {\n      return t.indexOf(Yo) >= 0;\n    }, t.dn = function (t) {\n      const e = t.lastIndexOf(Yo);\n      return e >= 0 ? t.slice(e + 1) : \"\";\n    }, t.dp = function (t) {\n      const e = [],\n        r = t.id;\n      return void 0 === r && e.push({\n        message: \"layers.\".concat(r, \": missing required property \\\"id\\\"\")\n      }), void 0 === t.render && e.push({\n        message: \"layers.\".concat(r, \": missing required method \\\"render\\\"\")\n      }), t.renderingMode && \"2d\" !== t.renderingMode && \"3d\" !== t.renderingMode && e.push({\n        message: \"layers.\".concat(r, \": property \\\"renderingMode\\\" must be either \\\"2d\\\" or \\\"3d\\\"\")\n      }), e;\n    }, t.dq = function (t, e, r, n) {\n      return \"custom\" === t.type ? new Kx(t, e) : new bv[t.type](t, e, r, n);\n    }, t.dr = Ut, t.ds = function (t) {\n      const e = t.indexOf(Yo);\n      return e >= 0 ? t.slice(e + 1) : \"\";\n    }, t.dt = class extends _w {\n      constructor(t, e) {\n        super(t._vectorTileFeature, t._z, t._x, t._y, t.id), t.state && (this.state = Object.assign({}, t.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && (\"featuresetId\" in this.target && !this.target.importId || \"layerId\" in this.target) && (this.source = t.source, this.sourceLayer = t.sourceLayer, this.layer = t.layer);\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return t.target = this.target, t.namespace = this.namespace, t;\n      }\n    }, t.du = go, t.dv = Ce, t.dw = function (t) {\n      return t({\n        pluginStatus: po,\n        pluginURL: fo\n      }), go.on(\"pluginStateChange\", t), t;\n    }, t.dx = _l, t.dy = class extends yl {\n      constructor(t) {\n        super(t), this.current = Il;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 9; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);\n          break;\n        }\n      }\n    }, t.dz = kt, t.e = ne, t.e$ = function () {\n      const t = Od;\n      t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(Dd), Od = null) : console.warn(\"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()\"));\n    }, t.e0 = Cr, t.e1 = (t, e, r, n, i, s, o, a, l, u) => {\n      const c = t.transform,\n        h = c.pitch < 15 ? Dm(.07, .7, Tt((14 - c.zoom) / 5, 0, 1)) : .07,\n        p = \"none\" === r.paint.get(\"line-trim-color-use-theme\").constantOr(\"default\");\n      return {\n        u_matrix: Lm(t, e, r, n),\n        u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0],\n        u_pixels_to_tile_units: c.calculatePixelsToTileUnitsMatrix(e),\n        u_device_pixel_ratio: i,\n        u_width_scale: s,\n        u_floor_width_scale: o,\n        u_image: 0,\n        u_tile_units_to_pixels: Rm(e, c),\n        u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]],\n        u_alpha_discard_threshold: 0,\n        u_trim_offset: a,\n        u_trim_fade_range: r.paint.get(\"line-trim-fade-range\"),\n        u_trim_color: r.paint.get(\"line-trim-color\").toPremultipliedRenderColor(p ? null : r.lut).toArray01(),\n        u_emissive_strength: r.paint.get(\"line-emissive-strength\"),\n        u_zbias_factor: h,\n        u_tile_to_meter: fu(e.tileID.canonical, 0),\n        u_ground_shadow_factor: l,\n        u_pattern_transition: u\n      };\n    }, t.e2 = (t, e, r, n, i, s, o, a, l, u) => {\n      const c = t.transform,\n        h = c.calculatePixelsToTileUnitsMatrix(e),\n        p = \"none\" === r.paint.get(\"line-trim-color-use-theme\").constantOr(\"default\"),\n        d = c.pitch < 15 ? Dm(.07, .7, Tt((14 - c.zoom) / 5, 0, 1)) : .07;\n      return {\n        u_matrix: Lm(t, e, r, n),\n        u_pixels_to_tile_units: h,\n        u_device_pixel_ratio: s,\n        u_width_scale: o,\n        u_floor_width_scale: a,\n        u_units_to_pixels: [1 / c.pixelsToGLUnits[0], 1 / c.pixelsToGLUnits[1]],\n        u_dash_image: 0,\n        u_gradient_image: 1,\n        u_image_height: i,\n        u_texsize: Um(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0],\n        u_tile_units_to_pixels: Rm(e, t.transform),\n        u_alpha_discard_threshold: 0,\n        u_trim_offset: l,\n        u_trim_fade_range: r.paint.get(\"line-trim-fade-range\"),\n        u_trim_color: r.paint.get(\"line-trim-color\").toPremultipliedRenderColor(p ? null : r.lut).toArray01(),\n        u_emissive_strength: r.paint.get(\"line-emissive-strength\"),\n        u_zbias_factor: d,\n        u_tile_to_meter: fu(e.tileID.canonical, 0),\n        u_ground_shadow_factor: u\n      };\n    }, t.e3 = Rt, t.e4 = bh, t.e5 = uu, t.e6 = Sc, t.e7 = ud, t.e8 = gd, t.e9 = Kp, t.eA = Ia, t.eB = La, t.eC = function (t, e, n, i, s, o, a, l, u, c, h, p, d, f, m, y) {\n      var g = new r(16);\n      return g[0] = t, g[1] = e, g[2] = n, g[3] = i, g[4] = s, g[5] = o, g[6] = a, g[7] = l, g[8] = u, g[9] = c, g[10] = h, g[11] = p, g[12] = d, g[13] = f, g[14] = m, g[15] = y, g;\n    }, t.eD = Kl, t.eE = Ra, t.eF = Da, t.eG = class {\n      constructor() {\n        this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {\n          min: new wt(1 / 0, 1 / 0),\n          max: new wt(-1 / 0, -1 / 0)\n        };\n      }\n      clear() {\n        this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];\n      }\n      get updateTime() {\n        return this._updateTime;\n      }\n      getReplacementRegionsForTile(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        const r = Rp(new wt(0, 0), new wt(Rn, Rn), t),\n          n = [];\n        if (e && !Cp(r, this._globalClipBounds)) return n;\n        for (const e of this._activeRegions) {\n          if (e.hiddenByOverlap) continue;\n          if (!Cp(r, e)) continue;\n          const i = Lp(e.min, e.max, t);\n          n.push({\n            min: i.min,\n            max: i.max,\n            sourceId: this._sourceIds[e.priority],\n            footprint: e.footprint,\n            footprintTileId: e.tileId,\n            order: e.order,\n            clipMask: e.clipMask,\n            clipScope: e.clipScope\n          });\n        }\n        return n;\n      }\n      setSources(t) {\n        this._setSources(t.map(t => ({\n          getSourceId: () => t.cache.id,\n          getFootprints: () => {\n            const e = [];\n            for (const r of t.cache.getVisibleCoordinates()) {\n              const n = t.cache.getTile(r).buckets[t.layer];\n              n && n.updateFootprints(r.toUnwrapped(), e);\n            }\n            return e;\n          },\n          getOrder: () => t.order,\n          getClipMask: () => t.clipMask,\n          getClipScope: () => t.clipScope\n        })));\n      }\n      _addSource(t) {\n        const e = t.getFootprints();\n        if (0 === e.length) return;\n        const r = t.getOrder(),\n          n = t.getClipMask(),\n          i = t.getClipScope();\n        for (const t of e) {\n          if (!t.footprint) continue;\n          const e = Rp(t.footprint.min, t.footprint.max, t.id);\n          this._activeRegions.push({\n            min: e.min,\n            max: e.max,\n            hiddenByOverlap: !1,\n            priority: this._sourceIds.length,\n            tileId: t.id,\n            footprint: t.footprint,\n            order: r,\n            clipMask: n,\n            clipScope: i\n          });\n        }\n        this._sourceIds.push(t.getSourceId());\n      }\n      _computeReplacement() {\n        this._activeRegions.sort((t, e) => t.priority - e.priority || Vp(t.min, e.min) || Vp(t.max, e.max) || t.order - e.order || t.clipMask - e.clipMask || function (t, e) {\n          const r = (t, e) => t + e;\n          return t.length - e.length || t.reduce(r, \"\").localeCompare(e.reduce(r, \"\"));\n        }(t.clipScope, e.clipScope));\n        let t = this._activeRegions.length !== this._prevRegions.length;\n        if (!t) {\n          let e = 0;\n          for (; !t && e !== this._activeRegions.length;) {\n            const r = this._activeRegions[e],\n              n = this._prevRegions[e];\n            t = r.priority !== n.priority || !Fp(r, n) || r.order !== n.order || r.clipMask !== n.clipMask || !_t(r.clipScope, n.clipScope), ++e;\n          }\n        }\n        if (t) {\n          ++this._updateTime;\n          for (const t of this._activeRegions) t.order !== Ep && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t.max.y));\n          const t = t => {\n            const e = this._activeRegions;\n            if (t >= e.length) return t;\n            const r = e[t].priority;\n            for (; t < e.length && e[t].priority === r;) ++t;\n            return t;\n          };\n          if (this._sourceIds.length > 1) {\n            let e = 0,\n              r = t(e);\n            for (; e !== r;) {\n              let n = e;\n              const i = e;\n              for (; n !== r;) {\n                const t = this._activeRegions[n];\n                t.hiddenByOverlap = !1;\n                for (let e = 0; e < i; e++) {\n                  const r = this._activeRegions[e];\n                  if (!r.hiddenByOverlap && t.order === Ep && Cp(t, r) && (t.hiddenByOverlap = Up(t.footprint, t.tileId, r.footprint, r.tileId), t.hiddenByOverlap)) break;\n                }\n                ++n;\n              }\n              e = r, r = t(e);\n            }\n          }\n        }\n      }\n      _setSources(t) {\n        [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];\n        for (let e = t.length - 1; e >= 0; e--) this._addSource(t[e]);\n        this._computeReplacement();\n      }\n    }, t.eH = Ep, t.eI = class {\n      constructor(t) {\n        this._createGrid(t), this._createPoles(t);\n      }\n      destroy() {\n        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();\n        for (const t of this._poleSegments) t.destroy();\n        for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();\n      }\n      _fillGridMeshWithLods(t, e) {\n        const r = new ua(),\n          n = new Ea(),\n          i = [],\n          s = t + 1 + 2,\n          o = e[0] + 1,\n          a = e[0] + 1 + (1 + e.length),\n          l = (t, e, r) => {\n            let n = t === s - 1 ? t - 2 : 0 === t ? t : t - 1;\n            return n += r ? 24575 : 0, [n, e];\n          };\n        for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, 0, !0));\n        for (let t = 0; t < o; ++t) for (let e = 0; e < s; ++e) r.emplaceBack(...l(e, t, (0 === e || e === s - 1) && !0));\n        for (let t = 0; t < e.length; ++t) {\n          const n = e[t];\n          for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, n, !0));\n        }\n        for (let t = 0; t < e.length; ++t) {\n          const o = n.length,\n            l = e[t] + 1 + 2,\n            u = new Ea();\n          for (let r = 0; r < l - 1; r++) {\n            const i = r === l - 2,\n              o = i ? s * (a - e.length + t - r) : s;\n            for (let t = 0; t < s - 1; t++) {\n              const e = r * s + t;\n              0 === r || i || 0 === t || t === s - 2 ? (u.emplaceBack(e + 1, e, e + o), u.emplaceBack(e + o, e + o + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + o), n.emplaceBack(e + o, e + o + 1, e + 1));\n            }\n          }\n          const c = al.simpleSegment(0, o, r.length, n.length - o);\n          for (let t = 0; t < u.uint16.length; t += 3) n.emplaceBack(u.uint16[t], u.uint16[t + 1], u.uint16[t + 2]);\n          const h = al.simpleSegment(0, o, r.length, n.length - o);\n          i.push({\n            withoutSkirts: c,\n            withSkirts: h\n          });\n        }\n        return {\n          vertices: r,\n          indices: n,\n          segments: i\n        };\n      }\n      _createGrid(t) {\n        const e = this._fillGridMeshWithLods(Hl, ql);\n        this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, Ec.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);\n      }\n      _createPoles(t) {\n        const e = new Ea();\n        for (let t = 0; t <= Hl; t++) e.emplaceBack(0, t + 1, t + 2);\n        this._poleIndexBuffer = t.createIndexBuffer(e, !0);\n        const r = new Fa(),\n          n = new Fa(),\n          i = new Fa(),\n          s = new Fa();\n        this._poleSegments = [];\n        for (let t = 0, e = 0; t < jl; t++) {\n          const o = 360 / (1 << t);\n          r.emplaceBack(0, -Nl, 0, .5, 0), n.emplaceBack(0, -Nl, 0, .5, 1), i.emplaceBack(0, -Nl, 0, .5, .5), s.emplaceBack(0, -Nl, 0, .5, .5);\n          for (let t = 0; t <= Hl; t++) {\n            let e = t / Hl,\n              a = 0;\n            const l = ur(0, o, e),\n              [u, c, h] = Wl(th, eh, l, Nl);\n            r.emplaceBack(u, c, h, e, a), n.emplaceBack(u, c, h, e, 1 - a);\n            const p = It(l);\n            e = .5 + .5 * Math.sin(p), a = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, a), s.emplaceBack(u, c, h, e, 1 - a);\n          }\n          this._poleSegments.push(al.simpleSegment(e, 0, 66, 64)), e += 66;\n        }\n        this._poleNorthVertexBuffer = t.createVertexBuffer(r, kc, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, kc, !1), this._texturedPoleNorthVertexBuffer = t.createVertexBuffer(i, kc, !1), this._texturedPoleSouthVertexBuffer = t.createVertexBuffer(s, kc, !1);\n      }\n      getGridBuffers(t, e) {\n        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];\n      }\n      getPoleBuffers(t, e) {\n        return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];\n      }\n    }, t.eJ = Tp, t.eK = zt, t.eL = function () {\n      return !!document.fullscreenElement || !!document.webkitFullscreenElement;\n    }, t.eM = Et, t.eN = du, t.eO = function (t, e, r) {\n      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;\n    }, t.eP = H, t.eQ = Yl, t.eR = V, t.eS = M, t.eT = function (_ref72) {\n      let [t, e, r] = _ref72;\n      const n = Math.hypot(t, e, r),\n        i = Math.atan2(t, r),\n        s = .5 * Math.PI - Math.acos(-e / n);\n      return new Ql(St(i), St(s));\n    }, t.eU = W, t.eV = Bf, t.eW = function (t) {\n      const e = t.navigator ? t.navigator.userAgent : null;\n      return !!function (t) {\n        if (null == Yt) {\n          const e = t.navigator ? t.navigator.userAgent : null;\n          Yt = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n        }\n        return Yt;\n      }(t) && !(!e || !(e.match(\"Version/15.4\") || e.match(\"Version/15.5\") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));\n    }, t.eX = function (t, e) {\n      ge = t, xe = e;\n    }, t.eY = Jc, t.eZ = Kc, t.e_ = function (t) {\n      const e = [0, 0, 0],\n        r = l(new Float64Array(16));\n      return c(r, t.pixelMatrix, t.globeMatrix), O(e, e, r), new wt(e[0], e[1]);\n    }, t.ea = 450, t.eb = 7, t.ec = pu, t.ed = function (t, e) {\n      if (t === e) {\n        var r = e[1],\n          n = e[2],\n          i = e[3],\n          s = e[6],\n          o = e[7],\n          a = e[11];\n        t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = r, t[6] = e[9], t[7] = e[13], t[8] = n, t[9] = s, t[11] = e[14], t[12] = i, t[13] = o, t[14] = a;\n      } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];\n      return t;\n    }, t.ee = $x, t.ef = aa, t.eg = $a, t.eh = 256, t.ei = qc, t.ej = ga, t.ek = f, t.el = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;\n    }, t.em = Fa, t.en = Ca, t.eo = fs, t.ep = function (t, e, r, n, i) {\n      return Tt((t - e) / (r - e) * (i - n) + n, n, i);\n    }, t.eq = tt, t.er = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        o = e[4],\n        a = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = c * o - a * u,\n        p = -c * s + a * l,\n        d = u * s - o * l,\n        f = r * h + n * p + i * d;\n      return f ? (t[0] = h * (f = 1 / f), t[1] = (-c * n + i * u) * f, t[2] = (a * n - i * o) * f, t[3] = p * f, t[4] = (c * r - i * l) * f, t[5] = (-a * r + i * s) * f, t[6] = d * f, t[7] = (-u * r + n * l) * f, t[8] = (o * r - n * s) * f, t) : null;\n    }, t.es = 2, t.et = F, t.eu = Df, t.ev = [1, 1, 1], t.ew = av, t.ex = X, t.ey = function (t, e, r, n) {\n      var i = e[0],\n        s = e[1],\n        o = e[2],\n        a = e[3];\n      return t[0] = i + n * (r[0] - i), t[1] = s + n * (r[1] - s), t[2] = o + n * (r[2] - o), t[3] = a + n * (r[3] - a), t;\n    }, t.ez = Of, t.f = function (t) {\n      return btoa(encodeURIComponent(t).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number(\"0x\" + e))));\n    }, t.f0 = function () {\n      Nd().acquire(Dd);\n    }, t.f1 = xo, t.f2 = function (t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      if (po === co.deferred || po === co.loading || po === co.loaded) throw new Error(\"setRTLTextPlugin cannot be called multiple times.\");\n      fo = de.resolveURL(t), po = co.deferred, ho = e, yo(), r || vo();\n    }, t.f3 = function (t) {\n      qd = de.resolveURL(t), Zd || (Zd = new Ld(Nd(), new tr())), Zd.broadcast(\"setMeshoptUrl\", qd);\n    }, t.f4 = Qd, t.f5 = function (t) {\n      Gd = de.resolveURL(t), Zd || (Zd = new Ld(Nd(), new tr())), Zd.broadcast(\"setDracoUrl\", Gd);\n    }, t.f6 = Jd, t.f7 = Cd, t.f8 = function (t) {\n      const e = _e();\n      if (!e) return;\n      const r = e.delete(ye);\n      t && r.then(() => t()).catch(t);\n    }, t.f9 = Rd, t.fA = function (t) {\n      Ae(), null != be && be.then(e => {\n        e.keys().then(r => {\n          for (let n = 0; n < r.length - t; n++) e.delete(r[n]).catch(t => Gt(t.message));\n        }).catch(t => Gt(t.message));\n      }).catch(t => Gt(t.message));\n    }, t.fa = Ws, t.fb = gh, t.fc = pg, t.fd = bw, t.fe = Aw, t.ff = Pm, t.fg = Bu, t.fh = \"hd_road_elevation\", t.fi = Yu, t.fj = Ot, t.fk = np, t.fl = ag, t.fm = sg, t.fn = function (t, e, r, n, i, s, o) {\n      let a = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;\n      let l = arguments.length > 8 ? arguments[8] : undefined;\n      let u = arguments.length > 9 ? arguments[9] : undefined;\n      let c = arguments.length > 10 ? arguments[10] : undefined;\n      t.createArrays(), t.tilePixelRatio = Rn / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      const h = t.layers[0].layout,\n        p = t.layers[0]._unevaluatedLayout._values,\n        d = {};\n      d.scaleFactor = a, d.textSizeScaleRange = h.get(\"text-size-scale-range\"), d.iconSizeScaleRange = h.get(\"icon-size-scale-range\");\n      const [f, m] = d.textSizeScaleRange,\n        [y, g] = d.iconSizeScaleRange;\n      d.textScaleFactor = Tt(d.scaleFactor, f, m), d.iconScaleFactor = Tt(d.scaleFactor, y, g);\n      const x = p[\"text-size\"],\n        v = p[\"icon-size\"];\n      if (\"composite\" === t.textSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.textSizeData;\n        d.compositeTextSizes = [x.possiblyEvaluate(new wo(e, {\n          worldview: c\n        }), s), x.possiblyEvaluate(new wo(r, {\n          worldview: c\n        }), s)];\n      }\n      if (\"composite\" === t.iconSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.iconSizeData;\n        d.compositeIconSizes = [v.possiblyEvaluate(new wo(e, {\n          worldview: c\n        }), s), v.possiblyEvaluate(new wo(r, {\n          worldview: c\n        }), s)];\n      }\n      d.layoutTextSize = x.possiblyEvaluate(new wo(o + 1, {\n        worldview: c\n      }), s), d.layoutIconSize = v.possiblyEvaluate(new wo(o + 1, {\n        worldview: c\n      }), s), d.textMaxSize = x.possiblyEvaluate(new wo(18, {\n        worldview: c\n      }), s);\n      const b = h.get(\"symbol-placement\"),\n        w = \"map\" === h.get(\"text-rotation-alignment\") && \"point\" !== b,\n        _ = h.get(\"text-size\");\n      let A = !1;\n      const M = [];\n      for (const o of t.features) {\n        const a = h.get(\"text-font\").evaluate(o, {}, s).join(\",\"),\n          f = _.evaluate(o, {}, s) * d.textScaleFactor,\n          m = d.layoutTextSize.evaluate(o, {}, s) * d.textScaleFactor,\n          y = d.layoutIconSize.evaluate(o, {}, s) * d.iconScaleFactor,\n          g = {\n            horizontal: {},\n            vertical: void 0\n          },\n          x = o.text;\n        let v,\n          I = [0, 0];\n        if (x) {\n          const n = x.toString(),\n            u = h.get(\"text-letter-spacing\").evaluate(o, {}, s) * ry,\n            c = h.get(\"text-line-height\").evaluate(o, {}, s) * ry,\n            p = ro(n) ? u : 0,\n            d = h.get(\"text-anchor\").evaluate(o, {}, s),\n            y = h.get(\"text-variable-anchor\");\n          if (!y) {\n            const t = h.get(\"text-radial-offset\").evaluate(o, {}, s);\n            if (t) I = zg(d, [t * ry, Pg]);else {\n              const t = h.get(\"text-offset\").evaluate(o, {}, s);\n              I = [t[0] * ry, t[1] * ry];\n            }\n          }\n          let v = w ? \"center\" : h.get(\"text-justify\").evaluate(o, {}, s);\n          const _ = \"point\" === b,\n            A = _ ? h.get(\"text-max-width\").evaluate(o, {}, s) * ry : 1 / 0,\n            M = s => {\n              t.allowVerticalPlacement && eo(n) && (g.vertical = Ey(x, e, r, i, a, A, c, d, s, p, I, Py.vertical, !0, m, f, l));\n            };\n          if (!w && y) {\n            const t = \"auto\" === v ? y.map(t => Rg(t)) : [v];\n            let n = !1;\n            for (let s = 0; s < t.length; s++) {\n              const o = t[s];\n              if (!g.horizontal[o]) if (n) g.horizontal[o] = g.horizontal[0];else {\n                const t = Ey(x, e, r, i, a, A, c, \"center\", o, p, I, Py.horizontal, !1, m, f, l);\n                t && (g.horizontal[o] = t, n = 1 === t.positionedLines.length);\n              }\n            }\n            M(\"left\");\n          } else {\n            if (\"auto\" === v && (v = Rg(d)), _ || h.get(\"text-writing-mode\").indexOf(\"horizontal\") >= 0 || !eo(n)) {\n              const t = Ey(x, e, r, i, a, A, c, d, v, p, I, Py.horizontal, !1, m, f, l);\n              t && (g.horizontal[v] = t);\n            }\n            M(_ ? \"left\" : v);\n          }\n        }\n        let S,\n          P,\n          k,\n          z,\n          E,\n          T,\n          B = !1;\n        const V = h.get(\"icon-text-fit\").evaluate(o, {}, s);\n        if (o.icon && o.icon.hasPrimary()) {\n          const e = Bg(o.icon, t.iconSizeData, p[\"icon-size\"], s, t.zoom, o, l, d.iconScaleFactor, c);\n          S = e.iconPrimary, k = e.iconSecondary;\n          const r = S.toString();\n          if (P = n.get(r), P && (E = h.get(\"icon-offset\").evaluate(o, {}, s), T = h.get(\"icon-anchor\").evaluate(o, {}, s), v = Ny(i.get(r), k ? i.get(k.toString()) : void 0, E, T), B = P.sdf, void 0 === t.sdfIcons ? t.sdfIcons = P.sdf : t.sdfIcons !== P.sdf && Gt(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (P.pixelRatio !== t.pixelRatio || 0 !== h.get(\"icon-rotate\").constantOr(1)) && (t.iconsNeedLinear = !0)), k) {\n            const t = k.toString();\n            z = n.get(t);\n          }\n        }\n        A = A || !(!o.icon || !o.icon.hasSecondary());\n        const F = $g(g.horizontal) || g.vertical;\n        t.iconsInText || (t.iconsInText = !!F && F.iconsInText);\n        const C = m * d.textScaleFactor / ry,\n          {\n            defaultShapedIcon: D,\n            verticallyShapedIcon: R\n          } = Lg(t, v, h, o, s, g, C, E, V);\n        \"none\" !== V && v && ($y(v) || Gy(v)) && (Eg(0, P, S, v, D, V, u, n, i), Eg(0, z, k, v, D, V, u, n, i), R && (Eg(0, P, S, v, R, V, u, n, i), Eg(0, z, k, v, R, V, u, n, i))), v = D, M.push({\n          feature: o,\n          shapedTextOrientations: g,\n          shapedText: F,\n          shapedIcon: v,\n          iconPrimary: S,\n          iconSecondary: k,\n          iconOffset: E,\n          iconAnchor: T,\n          verticallyShapedIcon: R,\n          layoutTextSize: m,\n          layoutIconSize: y,\n          textOffset: I,\n          isSDFIcon: B,\n          iconTextFit: V\n        });\n      }\n      return {\n        featureData: M,\n        sizes: d,\n        hasAnySecondaryIcon: A,\n        textAlongLine: w,\n        symbolPlacement: b\n      };\n    }, t.fo = lg, t.fp = function (t, e, r, n, i, s, o, a, l, u) {\n      const {\n        featureData: c,\n        hasAnySecondaryIcon: h,\n        sizes: p,\n        textAlongLine: d,\n        symbolPlacement: f\n      } = e;\n      for (const e of c) {\n        const {\n          shapedIcon: r,\n          verticallyShapedIcon: s,\n          feature: c,\n          shapedTextOrientations: m,\n          shapedText: y,\n          layoutTextSize: g,\n          textOffset: x,\n          isSDFIcon: v,\n          iconPrimary: b,\n          iconSecondary: w,\n          iconTextFit: _,\n          iconOffset: A\n        } = e;\n        Fg(r, u.iconPositions, b, w), Fg(s, u.iconPositions, b, w), Cg(m, u.iconPositions), Vg(b, w, u.iconPositions), (y || r) && Og(t, c, m, r, s, l, p, g, 0, x, v, n, i, o, a, h, _, A, d, f);\n      }\n      r && t.generateCollisionDebugBuffers(s, t.collisionBoxArray, p.textScaleFactor);\n    }, t.fq = Eu, t.fr = Pb, t.fs = Iu, t.ft = function (t) {\n      let e = 0;\n      if (new Uint32Array(t, 0, 1)[0] !== cf) {\n        const r = new Uint32Array(t, 0, 7),\n          [,, n, i, s, o] = r;\n        e = r.byteLength + i + s + o + s, (n !== t.byteLength || e >= t.byteLength) && Gt(\"Invalid b3dm header information.\");\n      }\n      return yf(t, e);\n    }, t.fu = function (t, e) {\n      const r = Qf(t);\n      for (const t of r) {\n        for (const e of t.meshes) tm(e);\n        t.lights && (t.lightMeshIndex = t.meshes.length, t.meshes.push(rm(t.lights, e)));\n      }\n      return r;\n    }, t.fv = fv, t.fw = Zt, t.fx = Fd, t.fy = bo, t.fz = co, t.g = function (t, e) {\n      return Ce(Object.assign(t, {\n        method: \"GET\"\n      }), e);\n    }, t.h = function (t) {\n      return 0 === t.indexOf(\"mapbox:\");\n    }, t.i = function (t) {\n      return ne.API_STYLE_REGEX.test(t) && !se(t);\n    }, t.j = ie, t.k = Ie, t.l = function (t) {\n      return decodeURIComponent(atob(t).split(\"\").map(t => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n    }, t.m = function (t, e) {\n      return Ce(Object.assign(t, {\n        type: \"json\"\n      }), e);\n    }, t.n = Ne, t.o = de, t.p = function (t, e) {\n      return Ce(Object.assign(t, {\n        method: \"POST\"\n      }), e);\n    }, t.q = xh, t.r = pe, t.s = function (t) {\n      try {\n        const e = self[t];\n        return e.setItem(\"_mapbox_test_\", 1), e.removeItem(\"_mapbox_test_\"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }, t.t = function () {\n      return Ud || (Ud = new Rd()), Ud;\n    }, t.u = function () {\n      return function t(e) {\n        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }, t.v = function (t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }, t.w = Gt, t.x = mb, t.y = Ke, t.z = Ye;\n  });\n  define([\"./shared\"], function (e) {\n    function t(e) {\n      const t = e ? e.url.toString() : void 0;\n      return t ? performance.getEntriesByName(t) : [];\n    }\n    function s(e) {\n      if (\"number\" == typeof e || \"boolean\" == typeof e || \"string\" == typeof e || null == e) return JSON.stringify(e);\n      if (Array.isArray(e)) {\n        let t = \"[\";\n        for (const i of e) t += \"\".concat(s(i), \",\");\n        return \"\".concat(t, \"]\");\n      }\n      let t = \"{\";\n      for (const i of Object.keys(e).sort()) t += \"\".concat(i, \":\").concat(s(e[i]), \",\");\n      return \"\".concat(t, \"}\");\n    }\n    function i(t) {\n      let i = \"\";\n      for (const o of e.bx) i += \"/\".concat(s(t[o]));\n      return i;\n    }\n    class o {\n      constructor(e) {\n        this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);\n      }\n      replace(e, t) {\n        this._layerConfigs = {}, this._layers = {}, this.update(e, [], t);\n      }\n      update(t, o, n) {\n        this._options = n;\n        for (const s of t) this._layerConfigs[s.id] = s, (this._layers[s.id] = e.dq(s, this.scope, null, this._options)).compileFilter(n), this.keyCache[s.id] && delete this.keyCache[s.id];\n        for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];\n        this.familiesBySource = {};\n        const r = function (e, t) {\n          const o = {};\n          for (let n = 0; n < e.length; n++) {\n            const r = e[n];\n            let a = t && t[r.id];\n            a || (\"symbol\" === r.type ? a = r.id : (a = i(r), \"line\" === r.type && r.paint && function e(t) {\n              return \"string\" == typeof t && \"line-progress\" === t || (Array.isArray(t) ? t.some(e) : !(!t || \"object\" != typeof t) && Object.values(t).some(e));\n            }(r.paint[\"line-width\"]) && (a += \"/\".concat(s(r.paint[\"line-width\"]))))), t && (t[r.id] = a);\n            let l = o[a];\n            l || (l = o[a] = []), l.push(r);\n          }\n          const n = [];\n          for (const e in o) n.push(o[e]);\n          return n;\n        }(Object.values(this._layerConfigs), this.keyCache);\n        for (const e of r) {\n          const t = e.map(e => this._layers[e.id]),\n            s = t[0];\n          if (\"none\" === s.visibility) continue;\n          const i = s.source || \"\";\n          let o = this.familiesBySource[i];\n          o || (o = this.familiesBySource[i] = {});\n          const n = s.sourceLayer || \"_geojsonTileLayer\";\n          let r = o[n];\n          r || (r = o[n] = []), r.push(t);\n        }\n      }\n    }\n    const n = 1 * e.fc;\n    class r {\n      constructor(t) {\n        const s = {},\n          i = [];\n        for (const e in t) {\n          const o = t[e],\n            r = s[e] = {};\n          for (const e in o.glyphs) {\n            const t = o.glyphs[+e];\n            if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue;\n            const s = t.metrics.localGlyph ? n : 1,\n              a = {\n                x: 0,\n                y: 0,\n                w: t.bitmap.width + 2 * s,\n                h: t.bitmap.height + 2 * s\n              };\n            i.push(a), r[e] = a;\n          }\n        }\n        const {\n            w: o,\n            h: r\n          } = e.G(i),\n          a = new e.fb({\n            width: o || 1,\n            height: r || 1\n          });\n        for (const i in t) {\n          const o = t[i];\n          for (const t in o.glyphs) {\n            const r = o.glyphs[+t];\n            if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height) continue;\n            const l = s[i][t],\n              c = r.metrics.localGlyph ? n : 1;\n            e.fb.copy(r.bitmap, a, {\n              x: 0,\n              y: 0\n            }, {\n              x: l.x + c,\n              y: l.y + c\n            }, r.bitmap);\n          }\n        }\n        this.image = a, this.positions = s;\n      }\n    }\n    e.fa(r, \"GlyphAtlas\");\n    class a {\n      constructor(t) {\n        this.tileID = new e.aO(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.lut = t.lut, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.scope = t.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.request && t.request.collectResourceTiming, this.promoteId = t.promoteId, this.isSymbolTile = t.isSymbolTile, this.tileTransform = e.aZ(t.tileID.canonical, t.projection), this.projection = t.projection, this.worldview = t.worldview, this.localizableLayerIds = t.localizableLayerIds, this.brightness = t.brightness, this.extraShadowCaster = !!t.extraShadowCaster, this.tessellationStep = t.tessellationStep, this.scaleFactor = t.scaleFactor, this.worldview = t.worldview;\n      }\n      parse(t, s, i, o, n, a) {\n        this.status = \"parsing\", this.data = t, this.collisionBoxArray = new e.b3();\n        const c = new e.fd(Object.keys(t.layers).sort()),\n          h = new e.fe(this.tileID, this.promoteId);\n        h.bucketLayerIDs = [];\n        const u = {},\n          d = new e.ff(256, 256),\n          f = {\n            featureIndex: h,\n            iconDependencies: new Map(),\n            patternDependencies: new Map(),\n            glyphDependencies: {},\n            lineAtlas: d,\n            availableImages: i,\n            brightness: this.brightness,\n            scaleFactor: this.scaleFactor,\n            elevationFeatures: void 0\n          },\n          p = [],\n          g = s.familiesBySource[this.source];\n        for (const s in g) {\n          const n = t.layers[s];\n          if (!n) continue;\n          let r = !1,\n            a = !1,\n            d = !1;\n          for (const e of g[s]) \"symbol\" === e[0].type ? r = !0 : a = !0, e[0].is3D() && \"model\" !== e[0].type && (d = !0);\n          if (this.extraShadowCaster && !d) continue;\n          if (!0 === this.isSymbolTile && !r) continue;\n          if (!1 === this.isSymbolTile && !a) continue;\n          1 === n.version && e.w(\"Vector tile source \\\"\".concat(this.source, \"\\\" layer \\\"\").concat(s, \"\\\" does not use vector tile spec v2 and therefore may have some rendering errors.\"));\n          const m = c.encode(s),\n            y = [];\n          let w = !1;\n          for (let t = 0, i = 0; t < n.length; t++) {\n            const o = n.feature(t),\n              r = h.getId(o, s);\n            if (this.localizableLayerIds && this.localizableLayerIds.has(s)) {\n              const e = o.properties ? o.properties.worldview : null;\n              if (this.worldview && \"string\" == typeof e) if (\"all\" === e) o.properties.$localized = !0;else {\n                if (!e.split(\",\").includes(this.worldview)) continue;\n                o.properties.$localized = !0, o.properties.worldview = this.worldview;\n              }\n            }\n            !w && o.properties && o.properties.hasOwnProperty(e.fg) && (w = !0), y.push({\n              feature: o,\n              id: r,\n              index: i,\n              sourceLayerIndex: m\n            }), i++;\n          }\n          w && !f.elevationFeatures && t.layers.hasOwnProperty(e.fh) && (f.elevationFeatures = e.fi.parseFrom(t.layers[e.fh], this.canonical));\n          for (const t of g[s]) {\n            const s = t[0];\n            if (this.extraShadowCaster && (!s.is3D() || \"model\" === s.type)) continue;\n            if (void 0 !== this.isSymbolTile && \"symbol\" === s.type !== this.isSymbolTile) continue;\n            if (s.minzoom && this.zoom < Math.floor(s.minzoom)) continue;\n            if (s.maxzoom && this.zoom >= s.maxzoom) continue;\n            if (\"none\" === s.visibility) continue;\n            l(t, this.zoom, f.brightness, i, this.worldview);\n            const n = u[s.id] = s.createBucket({\n              index: h.bucketLayerIDs.length,\n              layers: t,\n              zoom: this.zoom,\n              lut: this.lut,\n              canonical: this.canonical,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: m,\n              sourceID: this.source,\n              projection: this.projection.spec,\n              tessellationStep: this.tessellationStep,\n              styleDefinedModelURLs: o,\n              worldview: this.worldview\n            });\n            h.bucketLayerIDs.push(t.map(t => e.B(t.id, t.scope)));\n            let r = n.prepare ? n.prepare() : null;\n            null != r ? (r = r.then(() => n.populate(y, f, this.tileID.canonical, this.tileTransform)), p.push(r)) : n.populate(y, f, this.tileID.canonical, this.tileTransform);\n          }\n        }\n        const m = () => {\n          let s, o, p, g, m, y;\n          d.trim();\n          const w = {\n              type: \"maybePrepare\",\n              isSymbolTile: this.isSymbolTile,\n              zoom: this.zoom\n            },\n            b = () => {\n              if (s) return this.status = \"done\", a(s);\n              if (this.extraShadowCaster) this.status = \"done\", a(null, {\n                buckets: Object.values(u).filter(e => !e.isEmpty()),\n                featureIndex: h,\n                collisionBoxArray: null,\n                glyphAtlasImage: null,\n                lineAtlas: null,\n                imageAtlas: null,\n                brightness: f.brightness,\n                glyphMap: null,\n                iconMap: null,\n                glyphPositions: null\n              });else if (o && p && g) {\n                const t = new r(o),\n                  s = new Map();\n                for (const [t, i] of p.entries()) {\n                  const {\n                    imagePosition: o\n                  } = e.fl(t, i, e.fm);\n                  s.set(t, o);\n                }\n                const a = {};\n                for (const n in u) {\n                  const r = u[n];\n                  r instanceof e.b4 && (l(r.layers, this.zoom, f.brightness, i, this.worldview), a[n] = e.fn(r, o, t.positions, p, s, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, m, this.worldview));\n                }\n                const c = {\n                  iconsPending: !0,\n                  patternsPending: !0\n                };\n                this.rasterizeIfNeeded(n, p, m, () => {\n                  c.iconsPending = !1, x(a, t, c);\n                }), this.rasterizeIfNeeded(n, g, y, () => {\n                  c.patternsPending = !1, x(a, t, c);\n                });\n              }\n            },\n            x = (t, s, o, n) => {\n              if (o.iconsPending || o.patternsPending) return;\n              const r = new e.fo(p, g, this.lut);\n              for (const s in u) {\n                const o = u[s];\n                if (s in t) e.fp(o, t[s], this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, p, r);else if (o.hasPattern && (o instanceof e.ba || o instanceof e.bb || o instanceof e.e7)) {\n                  l(o.layers, this.zoom, f.brightness, i, this.worldview);\n                  const e = Object.fromEntries(r.patternPositions);\n                  o.addFeatures(f, this.tileID.canonical, e, i, this.tileTransform, this.brightness);\n                }\n              }\n              this.status = \"done\", a(null, {\n                buckets: Object.values(u).filter(e => !e.isEmpty()),\n                featureIndex: h,\n                collisionBoxArray: this.collisionBoxArray,\n                glyphAtlasImage: s.image,\n                lineAtlas: d,\n                imageAtlas: r,\n                brightness: f.brightness\n              });\n            };\n          if (!this.extraShadowCaster) {\n            const t = e.fj(f.glyphDependencies, e => Object.keys(e).map(Number));\n            Object.keys(t).length ? n.send(\"getGlyphs\", {\n              uid: this.uid,\n              stacks: t\n            }, (e, t) => {\n              s || (s = e, o = t, b());\n            }, void 0, !1, w) : o = {};\n            const i = Array.from(f.iconDependencies.keys()).map(t => e.I.parse(t));\n            i.length ? n.send(\"getImages\", {\n              images: i,\n              source: this.source,\n              scope: this.scope,\n              tileID: this.tileID,\n              type: \"icons\"\n            }, (e, t) => {\n              s || (s = e, p = new Map(), m = this.updateImageMapAndGetImageTaskQueue(p, t, f.iconDependencies), b());\n            }, void 0, !1, w) : (p = new Map(), m = new Map());\n            const r = Array.from(f.patternDependencies.keys()).map(t => e.I.parse(t));\n            r.length ? n.send(\"getImages\", {\n              images: r,\n              source: this.source,\n              scope: this.scope,\n              tileID: this.tileID,\n              type: \"patterns\"\n            }, (e, t) => {\n              s || (s = e, g = new Map(), y = this.updateImageMapAndGetImageTaskQueue(g, t, f.patternDependencies), b());\n            }, void 0, !1, w) : (g = new Map(), y = new Map());\n          }\n          if (f.elevationFeatures && f.elevationFeatures.length > 0) {\n            const s = [];\n            for (const t of Object.values(u)) if (t instanceof e.bb) {\n              const e = t.getUnevaluatedPortalGraph();\n              e && s.push(e);\n            }\n            const i = e.fk.evaluate(s);\n            for (const s of Object.values(u)) if (s instanceof e.bb) {\n              const e = t.layers[c.decode(s.sourceLayerIndex)];\n              s.setEvaluatedPortalGraph(i, e, this.tileID.canonical, f.availableImages, f.brightness);\n            }\n          }\n          b();\n        };\n        p.length > 0 ? Promise.allSettled(p).then(m).catch(a) : m();\n      }\n      rasterizeIfNeeded(e, t, s, i) {\n        Array.from(t.values()).some(e => e.usvg) ? this.rasterize(e, t, s, i) : i();\n      }\n      updateImageMapAndGetImageTaskQueue(e, t, s) {\n        const i = new Map();\n        for (const o of t.keys()) {\n          const n = s.get(o) || [];\n          for (const s of n) {\n            const o = s.toString(),\n              n = t.get(s.id.toString());\n            n.usvg ? i.has(o) || (i.set(o, s), e.set(o, Object.assign({}, n))) : e.set(o, n);\n          }\n        }\n        return i;\n      }\n      rasterize(e, t, s, i) {\n        this.rasterizeTask = e.send(\"rasterizeImages\", {\n          scope: this.scope,\n          tasks: s\n        }, (e, s) => {\n          if (!e) for (const [e, i] of s.entries()) {\n            const s = Object.assign(t.get(e), {\n              data: i\n            });\n            t.set(e, s);\n          }\n          i();\n        });\n      }\n      cancelRasterize() {\n        this.rasterizeTask && this.rasterizeTask.cancel();\n      }\n    }\n    function l(t, s, i, o, n) {\n      const r = new e.ac(s, {\n        brightness: i,\n        worldview: n\n      });\n      for (const e of t) e.recalculate(r, o);\n    }\n    class c extends e.E {\n      constructor(t, s, i, o, n, r, a) {\n        super(), this.actor = t, this.layerIndex = s, this.availableImages = i, this.availableModels = o, this.loadVectorData = r || e.aL, this.loading = {}, this.loaded = {}, this.deduped = new e.aK(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler, this.brightness = a;\n      }\n      loadTile(s, i) {\n        const o = s.uid,\n          n = s && s.request,\n          r = n && n.collectResourceTiming,\n          l = this.loading[o] = new a(s);\n        l.abort = this.loadVectorData(s, (a, c) => {\n          const h = !this.loading[o];\n          if (delete this.loading[o], l.cancelRasterize(), h || a || !c) return l.status = \"done\", h || (this.loaded[o] = l), i(a);\n          const u = c.rawData,\n            d = {};\n          c.expires && (d.expires = c.expires), c.cacheControl && (d.cacheControl = c.cacheControl), l.vectorTile = c.vectorTile || new e.fq(new e.bt(u));\n          const f = () => {\n            l.parse(l.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (e, s) => {\n              if (e || !s) return i(e);\n              const o = {};\n              if (r) {\n                const e = t(n);\n                e.length > 0 && (o.resourceTiming = JSON.parse(JSON.stringify(e)));\n              }\n              i(null, Object.assign({\n                rawTileData: u.slice(0)\n              }, s, d, o));\n            });\n          };\n          this.isSpriteLoaded ? f() : this.once(\"isSpriteLoaded\", () => {\n            this.scheduler ? this.scheduler.add(f, {\n              type: \"parseTile\",\n              isSymbolTile: s.isSymbolTile,\n              zoom: s.tileZoom\n            }) : f();\n          }), this.loaded = this.loaded || {}, this.loaded[o] = l;\n        });\n      }\n      reloadTile(t, s) {\n        const i = this.loaded,\n          o = t.uid;\n        if (i && i[o]) {\n          const n = i[o];\n          n.scaleFactor = t.scaleFactor, n.showCollisionBoxes = t.showCollisionBoxes, n.projection = t.projection, n.brightness = t.brightness, n.tileTransform = e.aZ(t.tileID.canonical, t.projection), n.extraShadowCaster = t.extraShadowCaster, n.lut = t.lut, n.worldview = t.worldview;\n          const r = (e, t) => {\n            const i = n.reloadCallback;\n            i && (delete n.reloadCallback, n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i)), s(e, t);\n          };\n          \"parsing\" === n.status ? n.reloadCallback = r : \"done\" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, r) : r());\n        } else s(null, void 0);\n      }\n      abortTile(e, t) {\n        const s = e.uid,\n          i = this.loading[s];\n        i && (i.abort && i.abort(), delete this.loading[s]), t();\n      }\n      removeTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        s && s[i] && delete s[i], t();\n      }\n    }\n    class h {\n      loadTile(t, s) {\n        const {\n            uid: i,\n            encoding: o,\n            rawImageData: n,\n            padding: r\n          } = t,\n          a = ImageBitmap && n instanceof ImageBitmap ? this.getImageData(n, r) : n;\n        s(null, new e.fr(i, a, o, r < 1));\n      }\n      reloadTile(e, t) {\n        t(null, null);\n      }\n      abortTile(e, t) {\n        t();\n      }\n      removeTile(e, t) {\n        t();\n      }\n      getImageData(e, t) {\n        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\", {\n          willReadFrequently: !0\n        })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);\n        const s = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);\n        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;\n      }\n    }\n    e.bs.setPbf(e.bt);\n    class u {\n      constructor(t) {\n        this._mrt = new e.bs(t.partial ? 30 : 1 / 0), this._isHeaderLoaded = !1, this.uid = t.uid, this.tileID = t.tileID, this.source = t.source;\n      }\n      parse(t, s) {\n        const i = this._mrt;\n        this.status = \"parsing\", this._entireBuffer = t;\n        try {\n          i.parseHeader(t), this._isHeaderLoaded = !0;\n          const o = [];\n          for (const s in i.layers) {\n            const n = i.getLayer(s),\n              r = n.getDataRange(n.getBandList()),\n              a = i.createDecodingTask(r),\n              l = t.slice(r.firstByte, r.lastByte + 1),\n              c = e.bs.performDecoding(l, a).then(e => a.complete(null, e)).catch(e => a.complete(e, null));\n            o.push(c);\n          }\n          Promise.allSettled(o).then(() => s(null, i)).catch(e => s(e));\n        } catch (e) {\n          s(e);\n        }\n      }\n    }\n    class d {\n      constructor(e) {\n        this.actor = e, this.loading = {}, this.loaded = {};\n      }\n      loadTile(t, s) {\n        const i = t.uid,\n          o = t.request,\n          n = this.loading[i] = new u(t),\n          {\n            cancel: r\n          } = e.bu(o, (e, t, o, r) => {\n            const a = !this.loading[i];\n            if (delete this.loading[i], a || e || !t) return n.status = \"done\", a || (this.loaded[i] = n), s(e);\n            n.parse(t, (e, t) => {\n              if (e || !t) return s(e);\n              s(null, t, o, r);\n            }), this.loaded[i] = n;\n          });\n        n.abort = r;\n      }\n      reloadTile(e, t) {\n        t(null, void 0);\n      }\n      abortTile(e, t) {\n        const s = e.uid,\n          i = this.loading[s];\n        i && (i.abort && i.abort(), delete this.loading[s]), t();\n      }\n      removeTile(e, t) {\n        const s = e.uid;\n        this.loaded[s] && delete this.loaded[s], t();\n      }\n      decodeRasterArray(t, s) {\n        e.bs.performDecoding(t.buffer, t.task).then(e => s(null, e)).catch(e => s(e));\n      }\n    }\n    const f = e.fs.prototype.toGeoJSON;\n    class p {\n      constructor(t) {\n        this._feature = t, this.extent = e.al, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n      }\n      loadGeometry() {\n        if (1 === this._feature.type) {\n          const t = [];\n          for (const s of this._feature.geometry) t.push([new e.P(s[0], s[1])]);\n          return t;\n        }\n        {\n          const t = [];\n          for (const s of this._feature.geometry) {\n            const i = [];\n            for (const t of s) i.push(new e.P(t[0], t[1]));\n            t.push(i);\n          }\n          return t;\n        }\n      }\n      toGeoJSON(e, t, s) {\n        return f.call(this, e, t, s);\n      }\n    }\n    class g {\n      constructor(t, s) {\n        this.name = t, this.extent = e.al, this.length = s.length, this._jsonFeatures = s;\n      }\n      feature(e) {\n        return new p(this._jsonFeatures[e]);\n      }\n    }\n    class m {\n      constructor(t) {\n        this.layers = {}, this.extent = e.al;\n        for (const e of Object.keys(t)) this.layers[e] = new g(e, t[e]);\n      }\n    }\n    const y = 64 / 4096,\n      w = 128;\n    class b {\n      constructor() {\n        this.features = new Map();\n      }\n      clear() {\n        this.features.clear();\n      }\n      load() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let t = arguments.length > 1 ? arguments[1] : undefined;\n        for (const s of e) {\n          const e = s.id;\n          if (null == e) continue;\n          let i = this.features.get(e);\n          i && this.updateCache(i, t), s.geometry ? (i = v(s), this.updateCache(i, t), this.features.set(e, i)) : this.features.delete(e), this.updateCache(i, t);\n        }\n      }\n      updateCache(e, t) {\n        for (const {\n          canonical: s,\n          uid: i\n        } of Object.values(t)) {\n          const {\n            z: o,\n            x: n,\n            y: r\n          } = s;\n          x(e, Math.pow(2, o), n, r) && delete t[i];\n        }\n      }\n      getTile(e, t, s) {\n        const i = Math.pow(2, e),\n          o = [];\n        for (const e of this.features.values()) x(e, i, t, s) && o.push(P(e, i, t, s));\n        return {\n          features: o\n        };\n      }\n      getFeatures() {\n        return [...this.features.values()];\n      }\n    }\n    function x(_ref73, o, n, r) {\n      let {\n        minX: e,\n        minY: t,\n        maxX: s,\n        maxY: i\n      } = _ref73;\n      return e < (n + 1 + y) / o && t < (r + 1 + y) / o && s > (n - y) / o && i > (r - y) / o;\n    }\n    function v(e) {\n      const {\n        id: t,\n        geometry: s,\n        properties: i\n      } = e;\n      if (!s) return;\n      if (\"GeometryCollection\" === s.type) throw new Error(\"GeometryCollection not supported in dynamic mode.\");\n      const {\n          type: o,\n          coordinates: n\n        } = s,\n        r = {\n          id: t,\n          type: 1,\n          geometry: [],\n          tags: i,\n          minX: 1 / 0,\n          minY: 1 / 0,\n          maxX: -1 / 0,\n          maxY: -1 / 0\n        },\n        a = r.geometry;\n      if (\"Point\" === o) I(n, a, r);else if (\"MultiPoint\" === o) for (const e of n) I(e, a, r);else if (\"LineString\" === o) r.type = 2, S(n, a, r);else if (\"MultiLineString\" === o) r.type = 2, M(n, a, r);else if (\"Polygon\" === o) r.type = 3, M(n, a, r, !0);else {\n        if (\"MultiPolygon\" !== o) throw new Error(\"Input data is not a valid GeoJSON object.\");\n        r.type = 3;\n        for (const e of n) M(e, a, r, !0);\n      }\n      return r;\n    }\n    function I(_ref74, i, o) {\n      let [t, s] = _ref74;\n      const n = e.aF(t);\n      let r = e.aJ(s);\n      r = r < 0 ? 0 : r > 1 ? 1 : r, i.push(n, r), o.minX = Math.min(o.minX, n), o.minY = Math.min(o.minY, r), o.maxX = Math.max(o.maxX, n), o.maxY = Math.max(o.maxY, r);\n    }\n    function S(e, t, s) {\n      let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n      let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n      const n = [];\n      for (const t of e) I(t, n, s);\n      t.push(n), i && function (e, t) {\n        let s = 0;\n        for (let t = 0, i = e.length, o = i - 2; t < i; o = t, t += 2) s += (e[t] - e[o]) * (e[t + 1] + e[o + 1]);\n        if (s > 0 === t) for (let t = 0, s = e.length; t < s / 2; t += 2) {\n          const i = e[t],\n            o = e[t + 1];\n          e[t] = e[s - 2 - t], e[t + 1] = e[s - 1 - t], e[s - 2 - t] = i, e[s - 1 - t] = o;\n        }\n      }(n, o);\n    }\n    function M(e, t, s) {\n      let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n      for (let o = 0; o < e.length; o++) S(e[o], t, s, i, 0 === o);\n    }\n    function P(t, s, i, o) {\n      const {\n          id: n,\n          type: r,\n          geometry: a,\n          tags: l\n        } = t,\n        c = [];\n      if (1 === r) !function (t, s, i, o, n) {\n        for (let r = 0; r < t.length; r += 2) {\n          const a = Math.round(e.al * (t[r + 0] * s - i)),\n            l = Math.round(e.al * (t[r + 1] * s - o));\n          n.push([a, l]);\n        }\n      }(a, s, i, o, c);else for (const e of a) T(e, s, i, o, c);\n      return {\n        id: n,\n        type: r,\n        geometry: c,\n        tags: l\n      };\n    }\n    function T(t, s, i, o, n) {\n      const r = -w,\n        a = e.al + w;\n      let l;\n      for (let c = 0; c < t.length - 2; c += 2) {\n        let h = Math.round(e.al * (t[c + 0] * s - i)),\n          u = Math.round(e.al * (t[c + 1] * s - o)),\n          d = Math.round(e.al * (t[c + 2] * s - i)),\n          f = Math.round(e.al * (t[c + 3] * s - o));\n        const p = d - h,\n          g = f - u;\n        h < r && d < r || (h < r ? (u += Math.round(g * ((r - h) / p)), h = r) : d < r && (f = u + Math.round(g * ((r - h) / p)), d = r), u < r && f < r || (u < r ? (h += Math.round(p * ((r - u) / g)), u = r) : f < r && (d = h + Math.round(p * ((r - u) / g)), f = r), h >= a && d >= a || (h >= a ? (u += Math.round(g * ((a - h) / p)), h = a) : d >= a && (f = u + Math.round(g * ((a - h) / p)), d = a), u >= a && f >= a || (u >= a ? (h += Math.round(p * ((a - u) / g)), u = a) : f >= a && (d = h + Math.round(p * ((a - u) / g)), f = a), l && h === l[l.length - 1][0] && u === l[l.length - 1][1] || (l = [[h, u]], n.push(l)), l.push([d, f])))));\n      }\n    }\n    function k(_ref75, i) {\n      let {\n        name: t,\n        features: s\n      } = _ref75;\n      i.writeStringField(1, t), i.writeVarintField(5, e.al);\n      const o = new Map(),\n        n = new Map(),\n        r = {\n          keys: o,\n          values: n,\n          feature: null\n        };\n      for (const e of s) r.feature = e, i.writeMessage(2, L, r);\n      for (const e of o.keys()) i.writeStringField(3, e);\n      for (const e of n.keys()) i.writeMessage(4, j, e);\n    }\n    function L(e, t) {\n      const s = e.feature;\n      void 0 !== s.id && Number.isSafeInteger(+s.id) && t.writeVarintField(1, +s.id), s.tags && t.writeMessage(2, _, e), t.writeVarintField(3, s.type), t.writeMessage(4, D, s);\n    }\n    function _(_ref76, i) {\n      let {\n        keys: e,\n        values: t,\n        feature: s\n      } = _ref76;\n      for (const o of Object.keys(s.tags)) {\n        let n = s.tags[o];\n        if (null === n) continue;\n        let r = e.get(o);\n        void 0 === r && (r = e.size, e.set(o, r)), i.writeVarint(r);\n        const a = typeof n;\n        \"string\" !== a && \"boolean\" !== a && \"number\" !== a && (n = JSON.stringify(n));\n        let l = t.get(n);\n        void 0 === l && (l = t.size, t.set(n, l)), i.writeVarint(l);\n      }\n    }\n    function C(e, t) {\n      return (t << 3) + (7 & e);\n    }\n    function z(e) {\n      return e << 1 ^ e >> 31;\n    }\n    function D(e, t) {\n      const {\n        geometry: s,\n        type: i\n      } = e;\n      let o = 0,\n        n = 0;\n      if (1 === i) {\n        t.writeVarint(C(1, s.length));\n        for (const e of s) {\n          const s = e[0] - o,\n            i = e[1] - n;\n          t.writeVarint(z(s)), t.writeVarint(z(i)), o += s, n += i;\n        }\n      } else for (const e of s) {\n        t.writeVarint(C(1, 1));\n        const s = e.length - (3 === i ? 1 : 0);\n        for (let i = 0; i < s; i++) {\n          1 === i && t.writeVarint(C(2, s - 1));\n          const r = e[i][0] - o,\n            a = e[i][1] - n;\n          t.writeVarint(z(r)), t.writeVarint(z(a)), o += r, n += a;\n        }\n        3 === i && t.writeVarint(C(7, 1));\n      }\n    }\n    function j(e, t) {\n      const s = typeof e;\n      \"string\" === s ? t.writeStringField(1, e) : \"boolean\" === s ? t.writeBooleanField(7, e) : \"number\" === s && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n    const O = {\n        minZoom: 0,\n        maxZoom: 16,\n        minPoints: 2,\n        radius: 40,\n        extent: 512,\n        nodeSize: 64,\n        log: !1,\n        generateId: !1,\n        reduce: null,\n        map: e => e\n      },\n      F = Math.fround || (A = new Float32Array(1), e => (A[0] = +e, A[0]));\n    var A;\n    const Z = 3,\n      B = 5,\n      N = 6;\n    class R {\n      constructor(e) {\n        this.options = Object.assign(Object.create(O), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];\n      }\n      load(e) {\n        const {\n          log: t,\n          minZoom: s,\n          maxZoom: i\n        } = this.options;\n        t && console.time(\"total time\");\n        const o = \"prepare \".concat(e.length, \" points\");\n        t && console.time(o), this.points = e;\n        const n = [];\n        for (let t = 0; t < e.length; t++) {\n          const s = e[t];\n          if (!s.geometry) continue;\n          const [i, o] = s.geometry.coordinates,\n            r = F(X(i)),\n            a = F(J(o));\n          n.push(r, a, 1 / 0, t, -1, 1), this.options.reduce && n.push(0);\n        }\n        let r = this.trees[i + 1] = this._createTree(n);\n        t && console.timeEnd(o);\n        for (let e = i; e >= s; e--) {\n          const s = +Date.now();\n          r = this.trees[e] = this._createTree(this._cluster(r, e)), t && console.log(\"z%d: %d clusters in %dms\", e, r.numItems, +Date.now() - s);\n        }\n        return t && console.timeEnd(\"total time\"), this;\n      }\n      getClusters(e, t) {\n        let s = ((e[0] + 180) % 360 + 360) % 360 - 180;\n        const i = Math.max(-90, Math.min(90, e[1]));\n        let o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;\n        const n = Math.max(-90, Math.min(90, e[3]));\n        if (e[2] - e[0] >= 360) s = -180, o = 180;else if (s > o) {\n          const e = this.getClusters([s, i, 180, n], t),\n            r = this.getClusters([-180, i, o, n], t);\n          return e.concat(r);\n        }\n        const r = this.trees[this._limitZoom(t)],\n          a = r.range(X(s), J(n), X(o), J(i)),\n          l = r.data,\n          c = [];\n        for (const e of a) {\n          const t = this.stride * e;\n          c.push(l[t + B] > 1 ? E(l, t, this.clusterProps) : this.points[l[t + Z]]);\n        }\n        return c;\n      }\n      getChildren(e) {\n        const t = this._getOriginId(e),\n          s = this._getOriginZoom(e),\n          i = \"No cluster with the specified id.\",\n          o = this.trees[s];\n        if (!o) throw new Error(i);\n        const n = o.data;\n        if (t * this.stride >= n.length) throw new Error(i);\n        const r = this.options.radius / (this.options.extent * Math.pow(2, s - 1)),\n          a = o.within(n[t * this.stride], n[t * this.stride + 1], r),\n          l = [];\n        for (const t of a) {\n          const s = t * this.stride;\n          n[s + 4] === e && l.push(n[s + B] > 1 ? E(n, s, this.clusterProps) : this.points[n[s + Z]]);\n        }\n        if (0 === l.length) throw new Error(i);\n        return l;\n      }\n      getLeaves(e, t, s) {\n        const i = [];\n        return this._appendLeaves(i, e, t = t || 10, s = s || 0, 0), i;\n      }\n      getTile(e, t, s) {\n        const i = this.trees[this._limitZoom(e)],\n          o = Math.pow(2, e),\n          {\n            extent: n,\n            radius: r\n          } = this.options,\n          a = r / n,\n          l = (s - a) / o,\n          c = (s + 1 + a) / o,\n          h = {\n            features: []\n          };\n        return this._addTileFeatures(i.range((t - a) / o, l, (t + 1 + a) / o, c), i.data, t, s, o, h), 0 === t && this._addTileFeatures(i.range(1 - a / o, l, 1, c), i.data, o, s, o, h), t === o - 1 && this._addTileFeatures(i.range(0, l, a / o, c), i.data, -1, s, o, h), h.features.length ? h : null;\n      }\n      getClusterExpansionZoom(e) {\n        let t = this._getOriginZoom(e) - 1;\n        for (; t <= this.options.maxZoom;) {\n          const s = this.getChildren(e);\n          if (t++, 1 !== s.length) break;\n          e = s[0].properties.cluster_id;\n        }\n        return t;\n      }\n      _appendLeaves(e, t, s, i, o) {\n        const n = this.getChildren(t);\n        for (const t of n) {\n          const n = t.properties;\n          if (n && n.cluster ? o + n.point_count <= i ? o += n.point_count : o = this._appendLeaves(e, n.cluster_id, s, i, o) : o < i ? o++ : e.push(t), e.length === s) break;\n        }\n        return o;\n      }\n      _createTree(t) {\n        const s = new e.c3(t.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let e = 0; e < t.length; e += this.stride) s.add(t[e], t[e + 1]);\n        return s.finish(), s.data = t, s;\n      }\n      _addTileFeatures(e, t, s, i, o, n) {\n        for (const r of e) {\n          const e = r * this.stride,\n            a = t[e + B] > 1;\n          let l, c, h;\n          if (a) l = Y(t, e, this.clusterProps), c = t[e], h = t[e + 1];else {\n            const s = this.points[t[e + Z]];\n            l = s.properties;\n            const [i, o] = s.geometry.coordinates;\n            c = X(i), h = J(o);\n          }\n          const u = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (c * o - s)), Math.round(this.options.extent * (h * o - i))]],\n            tags: l\n          };\n          let d;\n          d = a || this.options.generateId ? t[e + Z] : this.points[t[e + Z]].id, void 0 !== d && (u.id = d), n.features.push(u);\n        }\n      }\n      _limitZoom(e) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));\n      }\n      _cluster(e, t) {\n        const {\n            radius: s,\n            extent: i,\n            reduce: o,\n            minPoints: n\n          } = this.options,\n          r = s / (i * Math.pow(2, t)),\n          a = e.data,\n          l = [],\n          c = this.stride;\n        for (let s = 0; s < a.length; s += c) {\n          if (a[s + 2] <= t) continue;\n          a[s + 2] = t;\n          const i = a[s],\n            h = a[s + 1],\n            u = e.within(a[s], a[s + 1], r),\n            d = a[s + B];\n          let f = d;\n          for (const e of u) {\n            const s = e * c;\n            a[s + 2] > t && (f += a[s + B]);\n          }\n          if (f > d && f >= n) {\n            let e,\n              n = i * d,\n              r = h * d,\n              p = -1;\n            const g = (s / c << 5) + (t + 1) + this.points.length;\n            for (const i of u) {\n              const l = i * c;\n              if (a[l + 2] <= t) continue;\n              a[l + 2] = t;\n              const h = a[l + B];\n              n += a[l] * h, r += a[l + 1] * h, a[l + 4] = g, o && (e || (e = this._map(a, s, !0), p = this.clusterProps.length, this.clusterProps.push(e)), o(e, this._map(a, l)));\n            }\n            a[s + 4] = g, l.push(n / f, r / f, 1 / 0, g, -1, f), o && l.push(p);\n          } else {\n            for (let e = 0; e < c; e++) l.push(a[s + e]);\n            if (f > 1) for (const e of u) {\n              const s = e * c;\n              if (!(a[s + 2] <= t)) {\n                a[s + 2] = t;\n                for (let e = 0; e < c; e++) l.push(a[s + e]);\n              }\n            }\n          }\n        }\n        return l;\n      }\n      _getOriginId(e) {\n        return e - this.points.length >> 5;\n      }\n      _getOriginZoom(e) {\n        return (e - this.points.length) % 32;\n      }\n      _map(e, t, s) {\n        if (e[t + B] > 1) {\n          const i = this.clusterProps[e[t + N]];\n          return s ? Object.assign({}, i) : i;\n        }\n        const i = this.points[e[t + Z]].properties,\n          o = this.options.map(i);\n        return s && o === i ? Object.assign({}, o) : o;\n      }\n    }\n    function E(e, t, s) {\n      return {\n        type: \"Feature\",\n        id: e[t + Z],\n        properties: Y(e, t, s),\n        geometry: {\n          type: \"Point\",\n          coordinates: [(i = e[t], 360 * (i - .5)), G(e[t + 1])]\n        }\n      };\n      var i;\n    }\n    function Y(e, t, s) {\n      const i = e[t + B],\n        o = i >= 1e4 ? \"\".concat(Math.round(i / 1e3), \"k\") : i >= 1e3 ? Math.round(i / 100) / 10 + \"k\" : i,\n        n = e[t + N],\n        r = -1 === n ? {} : Object.assign({}, s[n]);\n      return Object.assign(r, {\n        cluster: !0,\n        cluster_id: e[t + Z],\n        point_count: i,\n        point_count_abbreviated: o\n      });\n    }\n    function X(e) {\n      return e / 360 + .5;\n    }\n    function J(e) {\n      const t = Math.sin(e * Math.PI / 180),\n        s = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return s < 0 ? 0 : s > 1 ? 1 : s;\n    }\n    function G(e) {\n      const t = (180 - 360 * e) * Math.PI / 180;\n      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;\n    }\n    function V(e, t, s, i) {\n      let o = i;\n      const n = t + (s - t >> 1);\n      let r,\n        a = s - t;\n      const l = e[t],\n        c = e[t + 1],\n        h = e[s],\n        u = e[s + 1];\n      for (let i = t + 3; i < s; i += 3) {\n        const t = $(e[i], e[i + 1], l, c, h, u);\n        if (t > o) r = i, o = t;else if (t === o) {\n          const e = Math.abs(i - n);\n          e < a && (r = i, a = e);\n        }\n      }\n      o > i && (r - t > 3 && V(e, t, r, i), e[r + 2] = o, s - r > 3 && V(e, r, s, i));\n    }\n    function $(e, t, s, i, o, n) {\n      let r = o - s,\n        a = n - i;\n      if (0 !== r || 0 !== a) {\n        const l = ((e - s) * r + (t - i) * a) / (r * r + a * a);\n        l > 1 ? (s = o, i = n) : l > 0 && (s += r * l, i += a * l);\n      }\n      return r = e - s, a = t - i, r * r + a * a;\n    }\n    function U(e, t, s, i) {\n      const o = {\n        id: e !== null && e !== void 0 ? e : null,\n        type: t,\n        geometry: s,\n        tags: i,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      if (\"Point\" === t || \"MultiPoint\" === t || \"LineString\" === t) q(o, s);else if (\"Polygon\" === t) q(o, s[0]);else if (\"MultiLineString\" === t) for (const e of s) q(o, e);else if (\"MultiPolygon\" === t) for (const e of s) q(o, e[0]);\n      return o;\n    }\n    function q(e, t) {\n      for (let s = 0; s < t.length; s += 3) e.minX = Math.min(e.minX, t[s]), e.minY = Math.min(e.minY, t[s + 1]), e.maxX = Math.max(e.maxX, t[s]), e.maxY = Math.max(e.maxY, t[s + 1]);\n    }\n    function W(e, t, s, i) {\n      if (!t.geometry) return;\n      const o = t.geometry.coordinates;\n      if (o && 0 === o.length) return;\n      const n = t.geometry.type,\n        r = Math.pow(s.tolerance / ((1 << s.maxZoom) * s.extent), 2);\n      let a = [],\n        l = t.id;\n      if (s.promoteId ? l = t.properties[s.promoteId] : s.generateId && (l = i || 0), \"Point\" === n) H(o, a);else if (\"MultiPoint\" === n) for (const e of o) H(e, a);else if (\"LineString\" === n) Q(o, a, r, !1);else if (\"MultiLineString\" === n) {\n        if (s.lineMetrics) {\n          for (const s of o) a = [], Q(s, a, r, !1), e.push(U(l, \"LineString\", a, t.properties));\n          return;\n        }\n        K(o, a, r, !1);\n      } else if (\"Polygon\" === n) K(o, a, r, !0);else {\n        if (\"MultiPolygon\" !== n) {\n          if (\"GeometryCollection\" === n) {\n            for (const o of t.geometry.geometries) W(e, {\n              id: l,\n              geometry: o,\n              properties: t.properties\n            }, s, i);\n            return;\n          }\n          throw new Error(\"Input data is not a valid GeoJSON object.\");\n        }\n        for (const e of o) {\n          const t = [];\n          K(e, t, r, !0), a.push(t);\n        }\n      }\n      e.push(U(l, n, a, t.properties));\n    }\n    function H(e, t) {\n      t.push(ee(e[0]), te(e[1]), 0);\n    }\n    function Q(e, t, s, i) {\n      let o,\n        n,\n        r = 0;\n      for (let s = 0; s < e.length; s++) {\n        const a = ee(e[s][0]),\n          l = te(e[s][1]);\n        t.push(a, l, 0), s > 0 && (r += i ? (o * l - a * n) / 2 : Math.sqrt(Math.pow(a - o, 2) + Math.pow(l - n, 2))), o = a, n = l;\n      }\n      const a = t.length - 3;\n      t[2] = 1, V(t, 0, a, s), t[a + 2] = 1, t.size = Math.abs(r), t.start = 0, t.end = t.size;\n    }\n    function K(e, t, s, i) {\n      for (let o = 0; o < e.length; o++) {\n        const n = [];\n        Q(e[o], n, s, i), t.push(n);\n      }\n    }\n    function ee(e) {\n      return e / 360 + .5;\n    }\n    function te(e) {\n      const t = Math.sin(e * Math.PI / 180),\n        s = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return s < 0 ? 0 : s > 1 ? 1 : s;\n    }\n    function se(e, t, s, i, o, n, r, a) {\n      if (i /= t, n >= (s /= t) && r < i) return e;\n      if (r < s || n >= i) return null;\n      const l = [];\n      for (const t of e) {\n        const e = t.geometry;\n        let n = t.type;\n        const r = 0 === o ? t.minX : t.minY,\n          c = 0 === o ? t.maxX : t.maxY;\n        if (r >= s && c < i) {\n          l.push(t);\n          continue;\n        }\n        if (c < s || r >= i) continue;\n        let h = [];\n        if (\"Point\" === n || \"MultiPoint\" === n) ie(e, h, s, i, o);else if (\"LineString\" === n) oe(e, h, s, i, o, !1, a.lineMetrics);else if (\"MultiLineString\" === n) re(e, h, s, i, o, !1);else if (\"Polygon\" === n) re(e, h, s, i, o, !0);else if (\"MultiPolygon\" === n) for (const t of e) {\n          const e = [];\n          re(t, e, s, i, o, !0), e.length && h.push(e);\n        }\n        if (h.length) {\n          if (a.lineMetrics && \"LineString\" === n) {\n            for (const e of h) l.push(U(t.id, n, e, t.tags));\n            continue;\n          }\n          \"LineString\" !== n && \"MultiLineString\" !== n || (1 === h.length ? (n = \"LineString\", h = h[0]) : n = \"MultiLineString\"), \"Point\" !== n && \"MultiPoint\" !== n || (n = 3 === h.length ? \"Point\" : \"MultiPoint\"), l.push(U(t.id, n, h, t.tags));\n        }\n      }\n      return l.length ? l : null;\n    }\n    function ie(e, t, s, i, o) {\n      for (let n = 0; n < e.length; n += 3) {\n        const r = e[n + o];\n        r >= s && r <= i && ae(t, e[n], e[n + 1], e[n + 2]);\n      }\n    }\n    function oe(e, t, s, i, o, n, r) {\n      let a = ne(e);\n      const l = 0 === o ? le : ce;\n      let c,\n        h,\n        u = e.start;\n      for (let d = 0; d < e.length - 3; d += 3) {\n        const f = e[d],\n          p = e[d + 1],\n          g = e[d + 2],\n          m = e[d + 3],\n          y = e[d + 4],\n          w = 0 === o ? f : p,\n          b = 0 === o ? m : y;\n        let x = !1;\n        r && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(p - y, 2))), w < s ? b > s && (h = l(a, f, p, m, y, s), r && (a.start = u + c * h)) : w > i ? b < i && (h = l(a, f, p, m, y, i), r && (a.start = u + c * h)) : ae(a, f, p, g), b < s && w >= s && (h = l(a, f, p, m, y, s), x = !0), b > i && w <= i && (h = l(a, f, p, m, y, i), x = !0), !n && x && (r && (a.end = u + c * h), t.push(a), a = ne(e)), r && (u += c);\n      }\n      let d = e.length - 3;\n      const f = e[d],\n        p = e[d + 1],\n        g = 0 === o ? f : p;\n      g >= s && g <= i && ae(a, f, p, e[d + 2]), d = a.length - 3, n && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && ae(a, a[0], a[1], a[2]), a.length && t.push(a);\n    }\n    function ne(e) {\n      const t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n    function re(e, t, s, i, o, n) {\n      for (const r of e) oe(r, t, s, i, o, n, !1);\n    }\n    function ae(e, t, s, i) {\n      e.push(t, s, i);\n    }\n    function le(e, t, s, i, o, n) {\n      const r = (n - t) / (i - t);\n      return ae(e, n, s + (o - s) * r, 1), r;\n    }\n    function ce(e, t, s, i, o, n) {\n      const r = (n - s) / (o - s);\n      return ae(e, t + (i - t) * r, n, 1), r;\n    }\n    function he(e, t) {\n      const s = [];\n      for (let i = 0; i < e.length; i++) {\n        const o = e[i],\n          n = o.type;\n        let r;\n        if (\"Point\" === n || \"MultiPoint\" === n || \"LineString\" === n) r = ue(o.geometry, t);else if (\"MultiLineString\" === n || \"Polygon\" === n) {\n          r = [];\n          for (const e of o.geometry) r.push(ue(e, t));\n        } else if (\"MultiPolygon\" === n) {\n          r = [];\n          for (const e of o.geometry) {\n            const s = [];\n            for (const i of e) s.push(ue(i, t));\n            r.push(s);\n          }\n        }\n        s.push(U(o.id, n, r, o.tags));\n      }\n      return s;\n    }\n    function ue(e, t) {\n      const s = [];\n      s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);\n      for (let i = 0; i < e.length; i += 3) s.push(e[i] + t, e[i + 1], e[i + 2]);\n      return s;\n    }\n    function de(e, t) {\n      if (e.transformed) return e;\n      const s = 1 << e.z,\n        i = e.x,\n        o = e.y;\n      for (const n of e.features) {\n        const e = n.geometry,\n          r = n.type;\n        if (n.geometry = [], 1 === r) for (let r = 0; r < e.length; r += 2) n.geometry.push(fe(e[r], e[r + 1], t, s, i, o));else for (let r = 0; r < e.length; r++) {\n          const a = [];\n          for (let n = 0; n < e[r].length; n += 2) a.push(fe(e[r][n], e[r][n + 1], t, s, i, o));\n          n.geometry.push(a);\n        }\n      }\n      return e.transformed = !0, e;\n    }\n    function fe(e, t, s, i, o, n) {\n      return [Math.round(s * (e * i - o)), Math.round(s * (t * i - n))];\n    }\n    function pe(e, t, s, i, o) {\n      const n = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent),\n        r = {\n          features: [],\n          numPoints: 0,\n          numSimplified: 0,\n          numFeatures: e.length,\n          source: null,\n          x: s,\n          y: i,\n          z: t,\n          transformed: !1,\n          minX: 2,\n          minY: 1,\n          maxX: -1,\n          maxY: 0\n        };\n      for (const t of e) ge(r, t, n, o);\n      return r;\n    }\n    function ge(e, t, s, i) {\n      const o = t.geometry,\n        n = t.type,\n        r = [];\n      if (e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), \"Point\" === n || \"MultiPoint\" === n) for (let t = 0; t < o.length; t += 3) r.push(o[t], o[t + 1]), e.numPoints++, e.numSimplified++;else if (\"LineString\" === n) me(r, o, e, s, !1, !1);else if (\"MultiLineString\" === n || \"Polygon\" === n) for (let t = 0; t < o.length; t++) me(r, o[t], e, s, \"Polygon\" === n, 0 === t);else if (\"MultiPolygon\" === n) for (let t = 0; t < o.length; t++) {\n        const i = o[t];\n        for (let t = 0; t < i.length; t++) me(r, i[t], e, s, !0, 0 === t);\n      }\n      if (r.length) {\n        let s = t.tags || null;\n        if (\"LineString\" === n && i.lineMetrics) {\n          s = {};\n          for (const e in t.tags) s[e] = t.tags[e];\n          s.mapbox_clip_start = o.start / o.size, s.mapbox_clip_end = o.end / o.size;\n        }\n        const a = {\n          geometry: r,\n          type: \"Polygon\" === n || \"MultiPolygon\" === n ? 3 : \"LineString\" === n || \"MultiLineString\" === n ? 2 : 1,\n          tags: s\n        };\n        null !== t.id && (a.id = t.id), e.features.push(a);\n      }\n    }\n    function me(e, t, s, i, o, n) {\n      const r = i * i;\n      if (i > 0 && t.size < (o ? r : i)) return void (s.numPoints += t.length / 3);\n      const a = [];\n      for (let e = 0; e < t.length; e += 3) (0 === i || t[e + 2] > r) && (s.numSimplified++, a.push(t[e], t[e + 1])), s.numPoints++;\n      o && function (e, t) {\n        let s = 0;\n        for (let t = 0, i = e.length, o = i - 2; t < i; o = t, t += 2) s += (e[t] - e[o]) * (e[t + 1] + e[o + 1]);\n        if (s > 0 === t) for (let t = 0, s = e.length; t < s / 2; t += 2) {\n          const i = e[t],\n            o = e[t + 1];\n          e[t] = e[s - 2 - t], e[t + 1] = e[s - 1 - t], e[s - 2 - t] = i, e[s - 1 - t] = o;\n        }\n      }(a, n), e.push(a);\n    }\n    const ye = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    };\n    class we {\n      constructor(e, t) {\n        const s = (t = this.options = function (e, t) {\n          for (const s in t) e[s] = t[s];\n          return e;\n        }(Object.create(ye), t)).debug;\n        if (s && console.time(\"preprocess data\"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n        if (t.promoteId && t.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n        let i = function (e, t) {\n          const s = [];\n          if (\"FeatureCollection\" === e.type) for (let i = 0; i < e.features.length; i++) W(s, e.features[i], t, i);else W(s, \"Feature\" === e.type ? e : {\n            geometry: e\n          }, t);\n          return s;\n        }(e, t);\n        this.tiles = {}, this.tileCoords = [], s && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", t.indexMaxZoom, t.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), i = function (e, t) {\n          const s = t.buffer / t.extent;\n          let i = e;\n          const o = se(e, 1, -1 - s, s, 0, -1, 2, t),\n            n = se(e, 1, 1 - s, 2 + s, 0, -1, 2, t);\n          return (o || n) && (i = se(e, 1, -s, 1 + s, 0, -1, 2, t) || [], o && (i = he(o, 1).concat(i)), n && (i = i.concat(he(n, -1)))), i;\n        }(i, t), i.length && this.splitTile(i, 0, 0, 0), s && (i.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n      }\n      splitTile(e, t, s, i, o, n, r) {\n        const a = [e, t, s, i],\n          l = this.options,\n          c = l.debug;\n        for (; a.length;) {\n          i = a.pop(), s = a.pop(), t = a.pop(), e = a.pop();\n          const h = 1 << t,\n            u = be(t, s, i);\n          let d = this.tiles[u];\n          if (!d && (c > 1 && console.time(\"creation\"), d = this.tiles[u] = pe(e, t, s, i, l), this.tileCoords.push({\n            z: t,\n            x: s,\n            y: i\n          }), c)) {\n            c > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", t, s, i, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd(\"creation\"));\n            const e = \"z\".concat(t);\n            this.stats[e] = (this.stats[e] || 0) + 1, this.total++;\n          }\n          if (d.source = e, null == o) {\n            if (t === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue;\n          } else {\n            if (t === l.maxZoom || t === o) continue;\n            if (null != o) {\n              const e = o - t;\n              if (s !== n >> e || i !== r >> e) continue;\n            }\n          }\n          if (d.source = null, 0 === e.length) continue;\n          c > 1 && console.time(\"clipping\");\n          const f = .5 * l.buffer / l.extent,\n            p = .5 - f,\n            g = .5 + f,\n            m = 1 + f;\n          let y = null,\n            w = null,\n            b = null,\n            x = null,\n            v = se(e, h, s - f, s + g, 0, d.minX, d.maxX, l),\n            I = se(e, h, s + p, s + m, 0, d.minX, d.maxX, l);\n          e = null, v && (y = se(v, h, i - f, i + g, 1, d.minY, d.maxY, l), w = se(v, h, i + p, i + m, 1, d.minY, d.maxY, l), v = null), I && (b = se(I, h, i - f, i + g, 1, d.minY, d.maxY, l), x = se(I, h, i + p, i + m, 1, d.minY, d.maxY, l), I = null), c > 1 && console.timeEnd(\"clipping\"), a.push(y || [], t + 1, 2 * s, 2 * i), a.push(w || [], t + 1, 2 * s, 2 * i + 1), a.push(b || [], t + 1, 2 * s + 1, 2 * i), a.push(x || [], t + 1, 2 * s + 1, 2 * i + 1);\n        }\n      }\n      getTile(e, t, s) {\n        e = +e, t = +t, s = +s;\n        const i = this.options,\n          {\n            extent: o,\n            debug: n\n          } = i;\n        if (e < 0 || e > 24) return null;\n        const r = 1 << e,\n          a = be(e, t = t + r & r - 1, s);\n        if (this.tiles[a]) return de(this.tiles[a], o);\n        n > 1 && console.log(\"drilling down to z%d-%d-%d\", e, t, s);\n        let l,\n          c = e,\n          h = t,\n          u = s;\n        for (; !l && c > 0;) c--, h >>= 1, u >>= 1, l = this.tiles[be(c, h, u)];\n        return l && l.source ? (n > 1 && (console.log(\"found parent tile z%d-%d-%d\", c, h, u), console.time(\"drilling down\")), this.splitTile(l.source, c, h, u, e, t, s), n > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? de(this.tiles[a], o) : null) : null;\n      }\n    }\n    function be(e, t, s) {\n      return 32 * ((1 << e) * s + t) + e;\n    }\n    function xe(t, s) {\n      const i = t.tileID.canonical;\n      if (!this._geoJSONIndex) return void s(null, null);\n      const o = this._geoJSONIndex.getTile(i.z, i.x, i.y);\n      if (!o) return void s(null, null);\n      const n = e => e.tags && \"3d_elevation_id\" in e.tags && \"source\" in e.tags && \"elevation\" === e.tags.source,\n        r = o.features.filter(e => n(e));\n      let a = {\n        _geojsonTileLayer: o.features\n      };\n      r.length > 0 && (a = {\n        _geojsonTileLayer: o.features.filter(e => !n(e)),\n        hd_road_elevation: r\n      });\n      const l = new m(a),\n        c = function (t) {\n          const s = new e.bt();\n          for (const e of Object.keys(t)) s.writeMessage(3, k, {\n            name: e,\n            features: t[e]\n          });\n          return s.finish();\n        }(a).buffer;\n      s(null, {\n        vectorTile: l,\n        rawData: c\n      });\n    }\n    class ve extends c {\n      constructor(e, t, s, i, o, n, r) {\n        super(e, t, s, i, o, xe, r), n && (this.loadGeoJSON = n), this._dynamicIndex = new b();\n      }\n      loadData(s, i) {\n        const o = s && s.request,\n          n = o && o.collectResourceTiming;\n        this._geoJSONIndex = null, this.loadGeoJSON(s, (r, a) => {\n          if (r || !a) return i(r);\n          if (\"object\" != typeof a) return i(new Error(\"Input data given to '\".concat(s.source, \"' is not a valid GeoJSON object.\")));\n          {\n            try {\n              if (s.filter) {\n                const t = e.U(s.filter, {\n                  type: \"boolean\",\n                  \"property-type\": \"data-driven\",\n                  overridable: !1,\n                  transition: !1\n                });\n                if (\"error\" === t.result) throw new Error(t.value.map(e => \"\".concat(e.key, \": \").concat(e.message)).join(\", \"));\n                a.features = a.features.filter(e => t.value.evaluate({\n                  zoom: 0\n                }, e));\n              }\n              s.dynamic ? (\"Feature\" === a.type && (a = {\n                type: \"FeatureCollection\",\n                features: [a]\n              }), s.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a.features, this.loaded), s.cluster && (a.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s.cluster ? new R(function (_ref77) {\n                let {\n                  superclusterOptions: t,\n                  clusterProperties: s\n                } = _ref77;\n                if (!s || !t) return t;\n                const i = {},\n                  o = {},\n                  n = {\n                    accumulated: null,\n                    zoom: 0\n                  },\n                  r = {\n                    properties: null\n                  },\n                  a = Object.keys(s);\n                for (const t of a) {\n                  const [n, r] = s[t],\n                    a = e.U(r),\n                    l = e.U(\"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n);\n                  i[t] = a.value, o[t] = l.value;\n                }\n                return t.map = e => {\n                  r.properties = e;\n                  const t = {};\n                  for (const e of a) t[e] = i[e].evaluate(n, r);\n                  return t;\n                }, t.reduce = (e, t) => {\n                  r.properties = t;\n                  for (const t of a) n.accumulated = e[t], e[t] = o[t].evaluate(n, r);\n                }, t;\n              }(s)).load(a.features) : s.dynamic ? this._dynamicIndex : function (e, t) {\n                return new we(e, t);\n              }(a, s.geojsonVtOptions);\n            } catch (e) {\n              return i(e);\n            }\n            const r = {};\n            if (n) {\n              const e = t(o);\n              e && (r.resourceTiming = {}, r.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));\n            }\n            i(null, r);\n          }\n        });\n      }\n      reloadTile(e, t) {\n        const s = this.loaded;\n        return s && s[e.uid] ? e.partial ? t(null, void 0) : super.reloadTile(e, t) : this.loadTile(e, t);\n      }\n      loadGeoJSON(t, s) {\n        if (t.request) e.m(t.request, s);else {\n          if (\"string\" != typeof t.data) return s(new Error(\"Input data given to '\".concat(t.source, \"' is not a valid GeoJSON object.\")));\n          setTimeout(() => {\n            try {\n              return s(null, JSON.parse(t.data));\n            } catch (e) {\n              return s(new Error(\"Input data given to '\".concat(t.source, \"' is not a valid GeoJSON object.\")));\n            }\n          }, 0);\n        }\n      }\n      getClusterExpansionZoom(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterChildren(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterLeaves(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }\n    }\n    class Ie {\n      constructor(t, s, i) {\n        this.tileID = new e.aO(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t.projection, this.brightness = s, this.worldview = i;\n      }\n      parse(t, s, i, o) {\n        this.status = \"parsing\";\n        const n = new e.aO(i.tileID.overscaledZ, i.tileID.wrap, i.tileID.canonical.z, i.tileID.canonical.x, i.tileID.canonical.y),\n          r = [],\n          a = s.familiesBySource[i.source],\n          l = new e.fe(n, i.promoteId);\n        l.bucketLayerIDs = [], l.is3DTile = !0, e.ft(t).then(t => {\n          if (!t) return o(new Error(\"Could not parse tile\"));\n          const s = t.json.extensionsUsed && t.json.extensionsUsed.includes(\"MAPBOX_mesh_features\") || t.json.asset.extras && t.json.asset.extras.MAPBOX_mesh_features,\n            c = t.json.extensionsUsed && t.json.extensionsUsed.includes(\"EXT_meshopt_compression\"),\n            h = new e.ac(this.zoom, {\n              brightness: this.brightness,\n              worldview: this.worldview\n            });\n          for (const o in a) for (const u of a[o]) {\n            const o = u[0];\n            l.bucketLayerIDs.push(u.map(t => e.B(t.id, t.scope))), o.recalculate(h, []);\n            const a = e.fu(t, 1 / e.d6(i.tileID.canonical)),\n              d = new e.fv(u, a, n, s, c, this.brightness, l, this.worldview);\n            s || (d.needsUpload = !0), r.push(d), d.evaluate(o);\n          }\n          this.status = \"done\", o(null, {\n            buckets: r,\n            featureIndex: l,\n            collisionBoxArray: null,\n            glyphAtlasImage: null,\n            lineAtlas: null,\n            imageAtlas: null,\n            brightness: null\n          });\n        }).catch(e => o(new Error(e.message)));\n      }\n    }\n    class Se {\n      constructor(e, t, s, i, o, n, r, a) {\n        this.actor = e, this.layerIndex = t, this.availableImages = s, this.availableModels = i, this.brightness = r, this.loading = {}, this.loaded = {}, this.worldview = a;\n      }\n      loadTile(t, s) {\n        const i = t.uid,\n          o = this.loading[i] = new Ie(t, this.brightness, this.worldview);\n        e.bu(t.request, (e, n) => {\n          const r = !this.loading[i];\n          return delete this.loading[i], r || e ? (o.status = \"done\", r || (this.loaded[i] = o), s(e)) : n && 0 !== n.byteLength ? void o.parse(n, this.layerIndex, t, (e, t) => {\n            o.status = \"done\", this.loaded = this.loaded || {}, this.loaded[i] = o, e || !t ? s(e) : s(null, t);\n          }) : (o.status = \"done\", this.loaded[i] = o, s());\n        });\n      }\n      reloadTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        if (s && s[i]) {\n          const o = s[i];\n          o.projection = e.projection, o.brightness = e.brightness;\n          const n = (s, i) => {\n            o.reloadCallback && (delete o.reloadCallback, this.loadTile(e, t)), t(s, i);\n          };\n          \"parsing\" === o.status ? o.reloadCallback = n : \"done\" === o.status && this.loadTile(e, t);\n        }\n      }\n      abortTile(e, t) {\n        const s = e.uid;\n        this.loading[s] && delete this.loading[s], t();\n      }\n      removeTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        s && s[i] && delete s[i], t();\n      }\n    }\n    class Me {\n      constructor(t) {\n        this.self = t, this.actor = new e.fx(t, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.x(), this.rtlPluginParsingListeners = [], this.projections = {}, this.defaultProjection = e.cl({\n          name: \"mercator\"\n        }), this.workerSourceTypes = {\n          vector: c,\n          geojson: ve,\n          \"raster-dem\": h,\n          \"raster-array\": d,\n          \"batched-model\": Se\n        }, this.workerSources = {}, this.self.registerWorkerSource = (e, t) => {\n          if (this.workerSourceTypes[e]) throw new Error(\"Worker source with name \\\"\".concat(e, \"\\\" already registered.\"));\n          this.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = t => {\n          if (e.fy.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n          e.fy.setState({\n            pluginStatus: e.fz.parsed,\n            pluginURL: e.fy.getPluginURL()\n          }), e.fy.applyArabicShaping = t.applyArabicShaping, e.fy.processBidirectionalText = t.processBidirectionalText, e.fy.processStyledBidirectionalText = t.processStyledBidirectionalText;\n          for (const e of this.rtlPluginParsingListeners) e(null, !0);\n          this.rtlPluginParsingListeners = [];\n        };\n      }\n      clearCaches(e, t, s) {\n        delete this.layerIndexes[e], delete this.availableImages[e], delete this.availableModels[e], delete this.workerSources[e], s();\n      }\n      checkIfReady(e, t, s) {\n        s();\n      }\n      setReferrer(e, t) {\n        this.referrer = t;\n      }\n      spriteLoaded(t, s) {\n        this.isSpriteLoaded[t] || (this.isSpriteLoaded[t] = {});\n        const {\n          scope: i,\n          isLoaded: o\n        } = s;\n        if (this.isSpriteLoaded[t][i] = o, this.workerSources[t] && this.workerSources[t][i]) for (const s in this.workerSources[t][i]) {\n          const n = this.workerSources[t][i][s];\n          for (const t in n) {\n            const s = n[t];\n            s instanceof c && (s.isSpriteLoaded = o, s.fire(new e.z(\"isSpriteLoaded\")));\n          }\n        }\n      }\n      setImages(e, t, s) {\n        this.availableImages[e] || (this.availableImages[e] = {});\n        const {\n          scope: i,\n          images: o\n        } = t;\n        if (this.availableImages[e][i] = o, this.workerSources[e] && this.workerSources[e][i]) {\n          for (const t in this.workerSources[e][i]) {\n            const s = this.workerSources[e][i][t];\n            for (const e in s) s[e].availableImages = o;\n          }\n          s();\n        } else s();\n      }\n      setModels(e, _ref78, i) {\n        let {\n          scope: t,\n          models: s\n        } = _ref78;\n        if (this.availableModels[e] || (this.availableModels[e] = {}), this.availableModels[e][t] = s, this.workerSources[e] && this.workerSources[e][t]) {\n          for (const i in this.workerSources[e][t]) {\n            const o = this.workerSources[e][t][i];\n            for (const e in o) o[e].availableModels = s;\n          }\n          i();\n        } else i();\n      }\n      setProjection(t, s) {\n        this.projections[t] = e.cl(s);\n      }\n      setBrightness(e, t, s) {\n        this.brightness = t, s();\n      }\n      setWorldview(e, t, s) {\n        this.worldview = t, s();\n      }\n      setLayers(e, t, s) {\n        this.getLayerIndex(e, t.scope).replace(t.layers, t.options), s();\n      }\n      updateLayers(e, t, s) {\n        this.getLayerIndex(e, t.scope).update(t.layers, t.removedIds, t.options), s();\n      }\n      loadTile(e, t, s) {\n        t.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t.type, t.source, t.scope).loadTile(t, s);\n      }\n      decodeRasterArray(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).decodeRasterArray(t, s);\n      }\n      reloadTile(e, t, s) {\n        t.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t.type, t.source, t.scope).reloadTile(t, s);\n      }\n      abortTile(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).abortTile(t, s);\n      }\n      removeTile(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).removeTile(t, s);\n      }\n      removeSource(e, t, s) {\n        if (!(this.workerSources[e] && this.workerSources[e][t.scope] && this.workerSources[e][t.scope][t.type] && this.workerSources[e][t.scope][t.type][t.source])) return;\n        const i = this.workerSources[e][t.scope][t.type][t.source];\n        delete this.workerSources[e][t.scope][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, s) : s();\n      }\n      loadWorkerSource(e, t, s) {\n        try {\n          this.self.importScripts(t.url), s();\n        } catch (e) {\n          s(e.toString());\n        }\n      }\n      syncRTLPluginState(t, s, i) {\n        if (e.fy.isParsed()) i(null, !0);else if (e.fy.isParsing()) this.rtlPluginParsingListeners.push(i);else try {\n          e.fy.setState(s);\n          const t = e.fy.getPluginURL();\n          !e.fy.isLoaded() || e.fy.isParsed() || e.fy.isParsing() || null == t || (e.fy.setState({\n            pluginStatus: e.fz.parsing,\n            pluginURL: e.fy.getPluginURL()\n          }), this.self.importScripts(t), e.fy.isParsed() ? i(null, !0) : this.rtlPluginParsingListeners.push(i));\n        } catch (e) {\n          i(e.toString());\n        }\n      }\n      setDracoUrl(e, t) {\n        this.dracoUrl = t;\n      }\n      getAvailableImages(e, t) {\n        this.availableImages[e] || (this.availableImages[e] = {});\n        let s = this.availableImages[e][t];\n        return s || (s = []), s;\n      }\n      getAvailableModels(e, t) {\n        this.availableModels[e] || (this.availableModels[e] = {});\n        let s = this.availableModels[e][t];\n        return s || (s = {}), s;\n      }\n      getLayerIndex(e, t) {\n        this.layerIndexes[e] || (this.layerIndexes[e] = {});\n        let s = this.layerIndexes[e][t];\n        return s || (s = this.layerIndexes[e][t] = new o(), s.scope = t), s;\n      }\n      getWorkerSource(e, t, s, i) {\n        const o = this.workerSources;\n        return o[e] || (o[e] = {}), o[e][i] || (o[e][i] = {}), o[e][i][t] || (o[e][i][t] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), o[e][i][t][s] || (o[e][i][t][s] = new this.workerSourceTypes[t]({\n          send: (t, s, i, o, n, r) => this.actor.send(t, s, i, e, n, r),\n          scheduler: this.actor.scheduler\n        }, this.getLayerIndex(e, i), this.getAvailableImages(e, i), this.getAvailableModels(e, i), this.isSpriteLoaded[e][i], void 0, this.brightness, this.worldview)), o[e][i][t][s];\n      }\n      rasterizeImagesWorker(e, t, s) {\n        const i = new Map();\n        for (const [s, {\n          image: o,\n          imageVariant: n\n        }] of t.tasks.entries()) {\n          const r = this.imageRasterizer.rasterize(n, o, t.scope, e);\n          i.set(s, r);\n        }\n        s(void 0, i);\n      }\n      removeRasterizedImages(e, t, s) {\n        this.imageRasterizer.removeImagesFromCacheByIds(t.imageIds, t.scope, e), s();\n      }\n      enforceCacheSizeLimit(t, s) {\n        e.fA(s);\n      }\n      getWorkerPerformanceMetrics(e, t, s) {\n        s(void 0, void 0);\n      }\n    }\n    return e.fw(self) && (self.worker = new Me(self)), Me;\n  });\n  define([\"./shared\"], function (e) {\n    var t = \"3.15.0\";\n    const i = {\n        create: \"create\",\n        load: \"load\",\n        fullLoad: \"fullLoad\"\n      },\n      o = {\n        mark(e) {\n          performance.mark(e);\n        },\n        measure(e, t, i) {\n          performance.measure(e, t, i);\n        }\n      };\n    function s(t) {\n      const i = t.name.split(\"?\")[0];\n      return e.a(i) && i.includes(\"mapbox-gl.js\") ? \"javascript\" : e.a(i) && i.includes(\"mapbox-gl.css\") ? \"css\" : e.b(i) ? \"fontRange\" : e.c(i) ? \"sprite\" : e.i(i) ? \"style\" : e.d(i) ? \"tilejson\" : \"other\";\n    }\n    var r,\n      n = {},\n      a = function () {\n        if (r) return n;\n        function e(e) {\n          return !t(e);\n        }\n        function t(t) {\n          return \"undefined\" == typeof window || \"undefined\" == typeof document ? \"not a browser\" : function () {\n            if (!(\"Worker\" in window && \"Blob\" in window && \"URL\" in window)) return !1;\n            var e,\n              t,\n              i = new Blob([\"\"], {\n                type: \"text/javascript\"\n              }),\n              o = URL.createObjectURL(i);\n            try {\n              t = new Worker(o), e = !0;\n            } catch (t) {\n              e = !1;\n            }\n            return t && t.terminate(), URL.revokeObjectURL(o), e;\n          }() ? function () {\n            var e = document.createElement(\"canvas\");\n            e.width = e.height = 1;\n            var t = e.getContext(\"2d\");\n            if (!t) return !1;\n            var i = t.getImageData(0, 0, 1, 1);\n            return i && i.width === e.width;\n          }() ? (void 0 === i[o = t && t.failIfMajorPerformanceCaveat] && (i[o] = function (t) {\n            var i,\n              o = function (t) {\n                var i = document.createElement(\"canvas\"),\n                  o = Object.create(e.webGLContextAttributes);\n                return o.failIfMajorPerformanceCaveat = t, i.getContext(\"webgl2\", o);\n              }(t);\n            if (!o) return !1;\n            try {\n              i = o.createShader(o.VERTEX_SHADER);\n            } catch (e) {\n              return !1;\n            }\n            return !(!i || o.isContextLost()) && (o.shaderSource(i, \"void main() {}\"), o.compileShader(i), !0 === o.getShaderParameter(i, o.COMPILE_STATUS));\n          }(o)), i[o] ? document.documentMode ? \"insufficient ECMAScript 6 support\" : void 0 : \"insufficient WebGL2 support\") : \"insufficient Canvas/getImageData support\" : \"insufficient worker support\";\n          var o;\n        }\n        r = 1, n.supported = e, n.notSupportedReason = t;\n        var i = {};\n        return e.webGLContextAttributes = {\n          antialias: !1,\n          alpha: !0,\n          stencil: !0,\n          depth: !0\n        }, n;\n      }();\n    function l(e, t, i) {\n      const o = document.createElement(e);\n      return null != t && (o.className = t), i && i.appendChild(o), o;\n    }\n    function c(e, t, i) {\n      const o = document.createElementNS(\"http://www.w3.org/2000/svg\", e);\n      for (const e of Object.keys(t)) o.setAttributeNS(null, e, String(t[e]));\n      return i && i.appendChild(o), o;\n    }\n    const h = \"undefined\" != typeof document ? document.documentElement && document.documentElement.style : null,\n      d = h && void 0 !== h.userSelect ? \"userSelect\" : \"WebkitUserSelect\";\n    let u;\n    function _() {\n      h && d && (u = h[d], h[d] = \"none\");\n    }\n    function p() {\n      h && d && (h[d] = u);\n    }\n    function f(e) {\n      e.preventDefault(), e.stopPropagation(), window.removeEventListener(\"click\", f, !0);\n    }\n    function m() {\n      window.addEventListener(\"click\", f, !0), window.setTimeout(() => {\n        window.removeEventListener(\"click\", f, !0);\n      }, 0);\n    }\n    function g(e, t) {\n      const i = e.getBoundingClientRect();\n      return x(e, i, t);\n    }\n    function v(e, t) {\n      const i = e.getBoundingClientRect(),\n        o = [];\n      for (let s = 0; s < t.length; s++) o.push(x(e, i, t[s]));\n      return o;\n    }\n    function y(e) {\n      return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e.button && e.ctrlKey ? 0 : e.button;\n    }\n    function x(t, i, o) {\n      const s = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;\n      return new e.P((o.clientX - i.left) * s, (o.clientY - i.top) * s);\n    }\n    const b = \"01\",\n      w = \"NO_ACCESS_TOKEN\";\n    class T {\n      constructor(e, t, i) {\n        this._transformRequestFn = e, this._customAccessToken = t, this._silenceAuthErrors = !!i, this._createSkuToken();\n      }\n      _createSkuToken() {\n        const e = function () {\n          let e = \"\";\n          for (let t = 0; t < 10; t++) e += \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"[Math.floor(62 * Math.random())];\n          return {\n            token: [\"1\", b, e].join(\"\"),\n            tokenExpiresAt: Date.now() + 432e5\n          };\n        }();\n        this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt;\n      }\n      _isSkuTokenExpired() {\n        return Date.now() > this._skuTokenExpiresAt;\n      }\n      transformRequest(e, t) {\n        return this._transformRequestFn && this._transformRequestFn(e, t) || {\n          url: e\n        };\n      }\n      normalizeStyleURL(i, o) {\n        if (!e.h(i)) return i;\n        const s = S(i);\n        return s.params.push(\"sdk=js-\".concat(t)), s.path = \"/styles/v1\".concat(s.path), this._makeAPIURL(s, this._customAccessToken || o);\n      }\n      normalizeGlyphsURL(t, i) {\n        if (!e.h(t)) return t;\n        const o = S(t);\n        return o.path = \"/fonts/v1\".concat(o.path), this._makeAPIURL(o, this._customAccessToken || i);\n      }\n      normalizeModelURL(t, i) {\n        if (!e.h(t)) return t;\n        const o = S(t);\n        return o.path = \"/models/v1\".concat(o.path), this._makeAPIURL(o, this._customAccessToken || i);\n      }\n      normalizeSourceURL(t, i, o, s) {\n        if (!e.h(t)) return t;\n        const r = S(t);\n        return r.path = \"/v4/\".concat(r.authority, \".json\"), r.params.push(\"secure\"), o && r.params.push(\"language=\".concat(o)), s && r.params.push(\"worldview=\".concat(s)), this._makeAPIURL(r, this._customAccessToken || i);\n      }\n      normalizeIconsetURL(t, i) {\n        const o = S(t);\n        return e.h(t) ? (o.path = \"/styles/v1\".concat(o.path, \"/iconset.pbf\"), this._makeAPIURL(o, this._customAccessToken || i)) : I(o);\n      }\n      normalizeSpriteURL(t, i, o, s) {\n        const r = S(t);\n        return e.h(t) ? (r.path = \"/styles/v1\".concat(r.path, \"/sprite\").concat(i).concat(o), this._makeAPIURL(r, this._customAccessToken || s)) : (r.path += \"\".concat(i).concat(o), I(r));\n      }\n      normalizeTileURL(t, i, o) {\n        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !e.h(t)) return t;\n        const s = S(t);\n        s.path = s.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, \"\".concat(i || o && \"raster\" !== s.authority && 512 === o ? \"@2x\" : \"\").concat(e.k.supported ? \".webp\" : \"$1\")), \"raster\" === s.authority ? s.path = \"/\".concat(e.e.RASTER_URL_PREFIX).concat(s.path) : \"rasterarrays\" === s.authority ? s.path = \"/\".concat(e.e.RASTERARRAYS_URL_PREFIX).concat(s.path) : \"3dtiles\" === s.authority ? s.path = \"/\".concat(e.e.TILES3D_URL_PREFIX).concat(s.path) : (s.path = s.path.replace(/^.+\\/v4\\//, \"/\"), s.path = \"/\".concat(e.e.TILE_URL_VERSION).concat(s.path));\n        const r = this._customAccessToken || function (e) {\n          for (const t of e) {\n            const e = t.match(/^access_token=(.*)$/);\n            if (e) return e[1];\n          }\n          return null;\n        }(s.params) || e.e.ACCESS_TOKEN;\n        return e.e.REQUIRE_ACCESS_TOKEN && r && this._skuToken && s.params.push(\"sku=\".concat(this._skuToken)), this._makeAPIURL(s, r);\n      }\n      canonicalizeTileURL(t, i) {\n        const o = S(t);\n        if (!o.path.match(/^(\\/v4\\/|\\/(raster|rasterarrays)\\/v1\\/)/) || !o.path.match(/\\.[\\w]+$/)) return t;\n        let s = \"mapbox://\";\n        o.path.match(/^\\/raster\\/v1\\//) ? s += \"raster/\".concat(o.path.replace(\"/\".concat(e.e.RASTER_URL_PREFIX, \"/\"), \"\")) : o.path.match(/^\\/rasterarrays\\/v1\\//) ? s += \"rasterarrays/\".concat(o.path.replace(\"/\".concat(e.e.RASTERARRAYS_URL_PREFIX, \"/\"), \"\")) : s += \"tiles/\".concat(o.path.replace(\"/\".concat(e.e.TILE_URL_VERSION, \"/\"), \"\"));\n        let r = o.params;\n        return i && (r = r.filter(e => !e.match(/^access_token=/))), r.length && (s += \"?\".concat(r.join(\"&\"))), s;\n      }\n      canonicalizeTileset(t, i) {\n        const o = !!i && e.h(i),\n          s = [];\n        for (const i of t.tiles || []) e.j(i) ? s.push(this.canonicalizeTileURL(i, o)) : s.push(i);\n        return s;\n      }\n      _makeAPIURL(t, i) {\n        const o = \"See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\",\n          s = S(e.e.API_URL);\n        if (t.protocol = s.protocol, t.authority = s.authority, \"http\" === t.protocol) {\n          const e = t.params.indexOf(\"secure\");\n          e >= 0 && t.params.splice(e, 1);\n        }\n        if (\"/\" !== s.path && (t.path = \"\".concat(s.path).concat(t.path)), !e.e.REQUIRE_ACCESS_TOKEN) return I(t);\n        if (i = i || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {\n          if (!i) throw new Error(\"An API access token is required to use Mapbox GL. \".concat(o));\n          if (\"s\" === i[0]) throw new Error(\"Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). \".concat(o));\n        }\n        return t.params = t.params.filter(e => -1 === e.indexOf(\"access_token\")), t.params.push(\"access_token=\".concat(i || \"\")), I(t);\n      }\n    }\n    const E = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n    function S(e) {\n      const t = e.match(E);\n      if (!t) throw new Error(\"Unable to parse URL object\");\n      return {\n        protocol: t[1],\n        authority: t[2],\n        path: t[3] || \"/\",\n        params: t[4] ? t[4].split(\"&\") : []\n      };\n    }\n    function I(e) {\n      const t = e.params.length ? \"?\".concat(e.params.join(\"&\")) : \"\";\n      return \"\".concat(e.protocol, \"://\").concat(e.authority).concat(e.path).concat(t);\n    }\n    const C = \"mapbox.eventData\";\n    function R(t) {\n      if (!t) return null;\n      const i = t.split(\".\");\n      if (!i || 3 !== i.length) return null;\n      try {\n        return JSON.parse(e.l(i[1]));\n      } catch (e) {\n        return null;\n      }\n    }\n    class A {\n      constructor(e) {\n        this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n      }\n      getStorageKey(t) {\n        const i = R(e.e.ACCESS_TOKEN);\n        let o = \"\";\n        return o = i && i.u ? e.f(i.u) : e.e.ACCESS_TOKEN || \"\", t ? \"\".concat(C, \".\").concat(t, \":\").concat(o) : \"\".concat(C, \":\").concat(o);\n      }\n      fetchEventData() {\n        const t = e.s(\"localStorage\"),\n          i = this.getStorageKey(),\n          o = this.getStorageKey(\"uuid\");\n        if (t) try {\n          const e = localStorage.getItem(i);\n          e && (this.eventData = JSON.parse(e));\n          const t = localStorage.getItem(o);\n          t && (this.anonId = t);\n        } catch (t) {\n          e.w(\"Unable to read from LocalStorage\");\n        }\n      }\n      saveEventData() {\n        const t = e.s(\"localStorage\"),\n          i = this.getStorageKey(),\n          o = this.getStorageKey(\"uuid\"),\n          s = this.anonId;\n        if (t && s) try {\n          localStorage.setItem(o, s), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i, JSON.stringify(this.eventData));\n        } catch (t) {\n          e.w(\"Unable to write to LocalStorage\");\n        }\n      }\n      processRequests(e) {}\n      postEvent(t, i, o, s) {\n        if (!e.e.EVENTS_URL) return;\n        const r = S(e.e.EVENTS_URL);\n        r.params.push(\"access_token=\".concat(s || e.e.ACCESS_TOKEN || \"\"));\n        const n = {\n            event: this.type,\n            created: new Date(t).toISOString()\n          },\n          a = i ? Object.assign(n, i) : n,\n          l = {\n            url: I(r),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            },\n            body: JSON.stringify([a])\n          };\n        this.pendingRequest = e.p(l, e => {\n          this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);\n        });\n      }\n      queueRequest(e, t) {\n        this.queue.push(e), this.processRequests(t);\n      }\n    }\n    const D = new class extends A {\n        constructor(e) {\n          super(\"appUserTurnstile\"), this._customAccessToken = e;\n        }\n        postTurnstileEvent(t, i) {\n          e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t) && t.some(t => e.h(t) || e.j(t)) && this.queueRequest(Date.now(), i);\n        }\n        processRequests(i) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n          const o = R(e.e.ACCESS_TOKEN),\n            s = o ? o.u : e.e.ACCESS_TOKEN;\n          let r = s !== this.eventData.tokenU;\n          e.v(this.anonId) || (this.anonId = e.u(), r = !0);\n          const n = this.queue.shift();\n          if (this.eventData.lastSuccess) {\n            const e = new Date(this.eventData.lastSuccess),\n              t = new Date(n),\n              i = (n - this.eventData.lastSuccess) / 864e5;\n            r = r || i >= 1 || i < -1 || e.getDate() !== t.getDate();\n          } else r = !0;\n          r ? this.postEvent(n, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: t,\n            skuId: b,\n            \"enabled.telemetry\": !1,\n            userId: this.anonId\n          }, e => {\n            e || (this.eventData.lastSuccess = n, this.eventData.tokenU = s);\n          }, i) : this.processRequests();\n        }\n      }(),\n      L = D.postTurnstileEvent.bind(D),\n      P = new class extends A {\n        constructor() {\n          super(\"map.load\"), this.success = {}, this.skuToken = \"\";\n        }\n        postMapLoadEvent(t, i, o, s) {\n          this.skuToken = i, this.errorCb = s, e.e.EVENTS_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, o) : this.errorCb(new Error(w)));\n        }\n        processRequests(i) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: o,\n            timestamp: s\n          } = this.queue.shift();\n          o && this.success[o] || (this.anonId || this.fetchEventData(), e.v(this.anonId) || (this.anonId = e.u()), this.postEvent(s, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: t,\n            skuId: b,\n            skuToken: this.skuToken,\n            userId: this.anonId\n          }, e => {\n            e ? this.errorCb(e) : o && (this.success[o] = !0);\n          }, i));\n        }\n        remove() {\n          this.errorCb = null;\n        }\n      }(),\n      z = P.postMapLoadEvent.bind(P),\n      O = new class extends A {\n        constructor() {\n          super(\"style.load\"), this.eventIdPerMapInstanceMap = new Map(), this.mapInstanceIdMap = new WeakMap();\n        }\n        getMapInstanceId(t) {\n          let i = this.mapInstanceIdMap.get(t);\n          return i || (i = e.u(), this.mapInstanceIdMap.set(t, i)), i;\n        }\n        getEventId(e) {\n          const t = this.eventIdPerMapInstanceMap.get(e) || 0;\n          return this.eventIdPerMapInstanceMap.set(e, t + 1), t;\n        }\n        postStyleLoadEvent(t, i) {\n          const {\n            map: o,\n            style: s,\n            importedStyles: r\n          } = i;\n          if (!e.e.EVENTS_URL || !t && !e.e.ACCESS_TOKEN) return;\n          const n = this.getMapInstanceId(o),\n            a = {\n              mapInstanceId: n,\n              eventId: this.getEventId(n),\n              style: s\n            };\n          r.length && (a.importedStyles = r), this.queueRequest({\n            timestamp: Date.now(),\n            payload: a\n          }, t);\n        }\n        processRequests(e) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            timestamp: t,\n            payload: i\n          } = this.queue.shift();\n          this.postEvent(t, i, () => {}, e);\n        }\n      }(),\n      M = O.postStyleLoadEvent.bind(O),\n      F = new class extends A {\n        constructor() {\n          super(\"gljs.performance\");\n        }\n        postPerformanceEvent(t, i) {\n          e.e.EVENTS_URL && (t || e.e.ACCESS_TOKEN) && this.queueRequest({\n            timestamp: Date.now(),\n            performanceData: i\n          }, t);\n        }\n        processRequests(o) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n              timestamp: r,\n              performanceData: n\n            } = this.queue.shift(),\n            a = function (o) {\n              const r = performance.getEntriesByType(\"resource\"),\n                n = performance.getEntriesByType(\"mark\"),\n                a = function (e) {\n                  const t = {};\n                  if (e) for (const i in e) if (\"other\" !== i) for (const o of e[i]) {\n                    const e = \"\".concat(i, \"ResolveRangeMin\"),\n                      s = \"\".concat(i, \"ResolveRangeMax\"),\n                      r = \"\".concat(i, \"RequestCount\"),\n                      n = \"\".concat(i, \"RequestCachedCount\");\n                    t[e] = Math.min(t[e] || 1 / 0, o.startTime), t[s] = Math.max(t[s] || -1 / 0, o.responseEnd);\n                    const a = e => {\n                      void 0 === t[e] && (t[e] = 0), ++t[e];\n                    };\n                    void 0 !== o.transferSize && 0 === o.transferSize && a(n), a(r);\n                  }\n                  return t;\n                }(function (e, t) {\n                  const i = {};\n                  if (e) for (const o of e) {\n                    const e = t(o);\n                    void 0 === i[e] && (i[e] = []), i[e].push(o);\n                  }\n                  return i;\n                }(r, s)),\n                l = window.devicePixelRatio,\n                c = navigator.connection || navigator.mozConnection || navigator.webkitConnection,\n                h = c ? c.effectiveType : void 0,\n                d = {\n                  counters: [],\n                  metadata: [],\n                  attributes: []\n                },\n                u = (e, t, i) => {\n                  null != i && e.push({\n                    name: t,\n                    value: i.toString()\n                  });\n                };\n              for (const e in a) u(d.counters, e, a[e]);\n              if (o.interactionRange[0] !== 1 / 0 && o.interactionRange[1] !== -1 / 0 && (u(d.counters, \"interactionRangeMin\", o.interactionRange[0]), u(d.counters, \"interactionRangeMax\", o.interactionRange[1])), n) for (const e of Object.keys(i)) {\n                const t = i[e],\n                  o = n.find(e => e.name === t);\n                o && u(d.counters, t, o.startTime);\n              }\n              return u(d.counters, \"visibilityHidden\", o.visibilityHidden), u(d.attributes, \"style\", function (t) {\n                if (t) for (const i of t) {\n                  const t = i.name.split(\"?\")[0];\n                  if (e.i(t)) {\n                    const e = t.split(\"/\").slice(-2);\n                    if (2 === e.length) return \"mapbox://styles/\".concat(e[0], \"/\").concat(e[1]);\n                  }\n                }\n              }(r)), u(d.attributes, \"terrainEnabled\", o.terrainEnabled ? \"true\" : \"false\"), u(d.attributes, \"fogEnabled\", o.fogEnabled ? \"true\" : \"false\"), u(d.attributes, \"projection\", o.projection), u(d.attributes, \"zoom\", o.zoom), u(d.metadata, \"devicePixelRatio\", l), u(d.metadata, \"connectionEffectiveType\", h), u(d.metadata, \"navigatorUserAgent\", navigator.userAgent), u(d.metadata, \"screenWidth\", window.screen.width), u(d.metadata, \"screenHeight\", window.screen.height), u(d.metadata, \"windowWidth\", window.innerWidth), u(d.metadata, \"windowHeight\", window.innerHeight), u(d.metadata, \"mapWidth\", o.width / l), u(d.metadata, \"mapHeight\", o.height / l), u(d.metadata, \"webglRenderer\", o.renderer), u(d.metadata, \"webglVendor\", o.vendor), u(d.metadata, \"sdkVersion\", t), u(d.metadata, \"sdkIdentifier\", \"mapbox-gl-js\"), d;\n            }(n);\n          for (const e of a.metadata);\n          for (const e of a.counters);\n          for (const e of a.attributes);\n          this.postEvent(r, a, () => {}, o);\n        }\n      }(),\n      B = F.postPerformanceEvent.bind(F),\n      k = new class extends A {\n        constructor() {\n          super(\"map.auth\"), this.success = {}, this.skuToken = \"\";\n        }\n        getSession(t, i, o, s) {\n          if (!e.e.API_URL || !e.e.SESSION_PATH) return;\n          const r = S(e.e.API_URL + e.e.SESSION_PATH);\n          r.params.push(\"sku=\".concat(i || \"\")), r.params.push(\"access_token=\".concat(s || e.e.ACCESS_TOKEN || \"\"));\n          const n = {\n            url: I(r),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          };\n          this.pendingRequest = e.g(n, e => {\n            this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);\n          });\n        }\n        getSessionAPI(t, i, o, s) {\n          this.skuToken = i, this.errorCb = s, e.e.SESSION_PATH && e.e.API_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, o) : this.errorCb(new Error(w)));\n        }\n        processRequests(e) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: t,\n            timestamp: i\n          } = this.queue.shift();\n          t && this.success[t] || this.getSession(i, this.skuToken, e => {\n            e ? this.errorCb(e) : t && (this.success[t] = !0);\n          }, e);\n        }\n        remove() {\n          this.errorCb = null;\n        }\n      }(),\n      N = k.getSessionAPI.bind(k),\n      U = new Set();\n    function j(e, t) {\n      t ? U.add(e) : U.delete(e);\n    }\n    class V {\n      constructor() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set(), this._updatedImages = {};\n      }\n      isDirty() {\n        return this._changed;\n      }\n      setDirty() {\n        this._changed = !0;\n      }\n      getUpdatedSourceCaches() {\n        return this._updatedSourceCaches;\n      }\n      updateSourceCache(e, t) {\n        this._updatedSourceCaches[e] = t, this.setDirty();\n      }\n      discardSourceCacheUpdate(e) {\n        delete this._updatedSourceCaches[e];\n      }\n      updateLayer(e) {\n        const t = e.scope;\n        this._updatedLayers[t] = this._updatedLayers[t] || new Set(), this._updatedLayers[t].add(e.id), this.setDirty();\n      }\n      removeLayer(e) {\n        const t = e.scope;\n        this._removedLayers[t] = this._removedLayers[t] || {}, this._updatedLayers[t] = this._updatedLayers[t] || new Set(), this._removedLayers[t][e.id] = e, this._updatedLayers[t].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();\n      }\n      getRemovedLayer(e) {\n        return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;\n      }\n      discardLayerRemoval(e) {\n        this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];\n      }\n      getLayerUpdatesByScope() {\n        const e = {};\n        for (const t in this._updatedLayers) e[t] = e[t] || {}, e[t].updatedIds = Array.from(this._updatedLayers[t].values());\n        for (const t in this._removedLayers) e[t] = e[t] || {}, e[t].removedIds = Object.keys(this._removedLayers[t]);\n        return e;\n      }\n      getUpdatedPaintProperties() {\n        return this._updatedPaintProps;\n      }\n      updatePaintProperties(e) {\n        this._updatedPaintProps.add(e.fqid), this.setDirty();\n      }\n      getUpdatedImages(e) {\n        return this._updatedImages[e] ? Array.from(this._updatedImages[e].values()) : [];\n      }\n      updateImage(t, i) {\n        this._updatedImages[i] = this._updatedImages[i] || new Set(), this._updatedImages[i].add(e.I.toString(t)), this.setDirty();\n      }\n      resetUpdatedImages(e) {\n        this._updatedImages[e] && this._updatedImages[e].clear();\n      }\n      reset() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};\n      }\n    }\n    function G(e) {\n      const {\n        userImage: t\n      } = e;\n      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);\n    }\n    class H extends e.E {\n      constructor(t) {\n        super(), this.imageProviders = new Map(), this.images = new Map(), this.updatedImages = new Map(), this.callbackDispatchedThisFrame = new Map(), this.loaded = new Map(), this.requestors = [], this.patterns = new Map(), this.patternsInFlight = new Set(), this.atlasImage = new Map(), this.atlasTexture = new Map(), this.dirty = !0, this.spriteFormat = t, \"raster\" !== t && e.r() && (this.imageRasterizerDispatcher = new e.D(e.t(), this, \"Image Rasterizer Worker\", 1));\n      }\n      addScope(t) {\n        this.loaded.set(t, !1), this.imageProviders.set(t, new Map()), this.images.set(t, new Map()), this.updatedImages.set(t, new Set()), this.callbackDispatchedThisFrame.set(t, new Set()), this.patterns.set(t, new Map()), this.atlasImage.set(t, new e.q({\n          width: 1,\n          height: 1\n        }));\n      }\n      removeScope(e) {\n        this.loaded.delete(e), this.imageProviders.delete(e), this.images.delete(e), this.updatedImages.delete(e), this.callbackDispatchedThisFrame.delete(e), this.patterns.delete(e), this.atlasImage.delete(e);\n        const t = this.atlasTexture.get(e);\n        t && (t.destroy(), this.atlasTexture.delete(e));\n      }\n      addImageProvider(e, t) {\n        this.imageProviders.has(t) || this.imageProviders.set(t, new Map()), this.imageProviders.get(t).set(e.id, e);\n      }\n      removeImageProvider(e, t) {\n        this.imageProviders.has(t) && this.imageProviders.get(t).delete(e);\n      }\n      getPendingImageProviders() {\n        const e = [];\n        for (const t of this.imageProviders.values()) for (const i of t.values()) i.hasPendingRequests() && e.push(i);\n        return e;\n      }\n      get imageRasterizer() {\n        return this._imageRasterizer || (this._imageRasterizer = new e.x()), this._imageRasterizer;\n      }\n      isLoaded() {\n        for (const e of this.loaded.keys()) if (!this.loaded.get(e)) return !1;\n        return !0;\n      }\n      setLoaded(e, t) {\n        if (this.loaded.get(t) !== e && (this.loaded.set(t, e), e)) {\n          for (const {\n            ids: e,\n            callback: i\n          } of this.requestors) this._notify(e, t, i);\n          this.requestors = [];\n        }\n      }\n      hasImage(e, t) {\n        return !!this.getImage(e, t);\n      }\n      getImage(e, t) {\n        return this.images.get(t).get(e.toString());\n      }\n      addImage(e, t, i) {\n        this._validate(e, i) && this.images.get(t).set(e.toString(), i);\n      }\n      _validate(t, i) {\n        let o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.y(new Error(\"Image \\\"\".concat(t.name, \"\\\" has invalid \\\"stretchX\\\" value\")))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.y(new Error(\"Image \\\"\".concat(t.name, \"\\\" has invalid \\\"stretchY\\\" value\")))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.y(new Error(\"Image \\\"\".concat(t.name, \"\\\" has invalid \\\"content\\\" value\")))), o = !1), o;\n      }\n      _validateStretch(e, t) {\n        if (!e) return !0;\n        let i = 0;\n        for (const o of e) {\n          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;\n          i = o[1];\n        }\n        return !0;\n      }\n      _validateContent(e, t) {\n        if (!e) return !0;\n        if (4 !== e.length) return !1;\n        if (!t.usvg) {\n          if (e[0] < 0 || t.data.width < e[0]) return !1;\n          if (e[1] < 0 || t.data.height < e[1]) return !1;\n          if (e[2] < 0 || t.data.width < e[2]) return !1;\n          if (e[3] < 0 || t.data.height < e[3]) return !1;\n        }\n        return !(e[2] < e[0] || e[3] < e[1]);\n      }\n      updateImage(e, t, i) {\n        const o = this.images.get(t).get(e.toString());\n        i.version = o.version + 1, this.images.get(t).set(e.toString(), i), this.updatedImages.get(t).add(e), this.removeFromImageRasterizerCache(e, t);\n      }\n      clearUpdatedImages(e) {\n        this.updatedImages.get(e).clear();\n      }\n      removeFromImageRasterizerCache(t, i) {\n        \"raster\" !== this.spriteFormat && (e.r() ? this.imageRasterizerDispatcher.getActor().send(\"removeRasterizedImages\", {\n          imageIds: [t],\n          scope: i\n        }) : this.imageRasterizer.removeImagesFromCacheByIds([t], i));\n      }\n      removeImage(e, t) {\n        const i = this.images.get(t),\n          o = i.get(e.toString());\n        i.delete(e.toString()), this.patterns.get(t).delete(e.toString()), this.removeFromImageRasterizerCache(e, t), o.userImage && o.userImage.onRemove && o.userImage.onRemove();\n      }\n      listImages(t) {\n        return Array.from(this.images.get(t).keys()).map(t => e.I.from(t));\n      }\n      getImages(e, t, i) {\n        const o = [],\n          s = [],\n          r = this.imageProviders.get(t);\n        for (const i of e) {\n          if (!i.iconsetId) {\n            o.push(i);\n            continue;\n          }\n          const e = r.get(i.iconsetId);\n          e && (this.getImage(i, t) ? s.push(i) : e.addPendingRequest(i));\n        }\n        if (0 === o.length) return void this._notify(s, t, i);\n        let n = !0;\n        const a = !!this.loaded.get(t),\n          l = this.images.get(t);\n        if (!a) for (const e of o) l.has(e.toString()) || (n = !1);\n        a || n ? this._notify(o, t, i) : this.requestors.push({\n          ids: o,\n          scope: t,\n          callback: i\n        });\n      }\n      rasterizeImages(e, t) {\n        const i = new Map(),\n          {\n            tasks: o,\n            scope: s\n          } = e;\n        for (const [e, t] of o.entries()) {\n          const o = this.getImage(t.id, s);\n          o && i.set(e, {\n            image: o,\n            imageVariant: t\n          });\n        }\n        this._rasterizeImages(s, i, t);\n      }\n      _rasterizeImages(t, i, o) {\n        if (e.r()) this.imageRasterizerDispatcher.getActor().send(\"rasterizeImagesWorker\", {\n          tasks: i,\n          scope: t\n        }, o);else {\n          const e = new Map();\n          for (const [o, {\n            image: s,\n            imageVariant: r\n          }] of i.entries()) e.set(o, this.imageRasterizer.rasterize(r, s, t, 0));\n          o(void 0, e);\n        }\n      }\n      getUpdatedImages(e) {\n        return this.updatedImages.get(e) || new Set();\n      }\n      _notify(t, i, o) {\n        const s = this.images.get(i),\n          r = new Map();\n        for (const i of t) {\n          if (!s.get(i.toString())) {\n            if (i.iconsetId) continue;\n            this.fire(new e.z(\"styleimagemissing\", {\n              id: i.name\n            }));\n          }\n          const t = s.get(i.toString());\n          if (!t) {\n            e.w(\"Image \\\"\".concat(i.name, \"\\\" could not be loaded. Please make sure you have added the image with map.addImage() or a \\\"sprite\\\" property in your style. You can provide missing images by listening for the \\\"styleimagemissing\\\" map event.\"));\n            continue;\n          }\n          const o = {\n            data: t.usvg ? null : t.data.clone(),\n            pixelRatio: t.pixelRatio,\n            sdf: t.sdf,\n            usvg: t.usvg,\n            version: t.version,\n            stretchX: t.stretchX,\n            stretchY: t.stretchY,\n            content: t.content,\n            hasRenderCallback: Boolean(t.userImage && t.userImage.render)\n          };\n          t.usvg && Object.assign(o, {\n            width: t.icon.usvg_tree.width,\n            height: t.icon.usvg_tree.height\n          }), r.set(e.I.toString(i), o);\n        }\n        o(null, r);\n      }\n      getPixelSize(e) {\n        const {\n          width: t,\n          height: i\n        } = this.atlasImage.get(e);\n        return {\n          width: t,\n          height: i\n        };\n      }\n      getPattern(t, i, o) {\n        const s = t.toString(),\n          r = this.patterns.get(i),\n          n = r.get(s),\n          a = this.getImage(t, i);\n        if (!a) return null;\n        if (n) {\n          if (n.position.version === a.version) return n.position;\n          n.position.version = a.version;\n        } else {\n          if (a.usvg && !a.data) {\n            const r = this.getPatternInFlightId(s, i);\n            if (this.patternsInFlight.has(r)) return null;\n            this.patternsInFlight.add(r);\n            const n = new e.A(t).scaleSelf(e.o.devicePixelRatio),\n              l = new Map([[n.toString(), {\n                image: a,\n                imageVariant: n\n              }]]);\n            return this._rasterizeImages(i, l, (e, t) => this.storePatternImage(n, i, a, o, t)), null;\n          }\n          this.storePattern(t, i, a);\n        }\n        return this._updatePatternAtlas(i, o), r.get(s).position;\n      }\n      getPatternInFlightId(t, i) {\n        return e.B(t, i);\n      }\n      hasPatternsInFlight() {\n        return 0 !== this.patternsInFlight.size;\n      }\n      storePatternImage(e, t, i, o, s) {\n        const r = e.toString(),\n          n = s ? s.get(r) : void 0;\n        n && (i.data = n, this.storePattern(e.id, t, i), this._updatePatternAtlas(t, o), this.patternsInFlight.delete(this.getPatternInFlightId(e.id.toString(), t)));\n      }\n      storePattern(t, i, o) {\n        const s = {\n            w: o.data.width + 2 * e.C,\n            h: o.data.height + 2 * e.C,\n            x: 0,\n            y: 0\n          },\n          r = new e.F(s, o, e.C);\n        this.patterns.get(i).set(t.toString(), {\n          bin: s,\n          position: r\n        });\n      }\n      destroyAtlasTextures() {\n        for (const e of this.atlasTexture.values()) e && e.destroy();\n        this.atlasTexture.clear();\n      }\n      bind(t, i) {\n        const o = t.gl;\n        let s = this.atlasTexture.get(i);\n        s ? this.dirty && (s.update(this.atlasImage.get(i)), this.dirty = !1) : (s = new e.T(t, this.atlasImage.get(i), o.RGBA8), this.atlasTexture.set(i, s)), s.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }\n      _updatePatternAtlas(t, i) {\n        const o = this.patterns.get(t),\n          s = Array.from(o.values()).map(_ref79 => {\n            let {\n              bin: e\n            } = _ref79;\n            return e;\n          }),\n          {\n            w: r,\n            h: n\n          } = e.G(s),\n          a = this.atlasImage.get(t);\n        a.resize({\n          width: r || 1,\n          height: n || 1\n        });\n        const l = this.images.get(t);\n        for (const [t, {\n          bin: s,\n          position: r\n        }] of o.entries()) {\n          let o = r.padding;\n          const n = s.x + o,\n            c = s.y + o,\n            h = l.get(t).data,\n            d = h.width,\n            u = h.height;\n          o = o > 1 ? o - 1 : o, e.q.copy(h, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: n,\n            y: c\n          }, {\n            width: d,\n            height: u\n          }, i), e.q.copy(h, a, {\n            x: 0,\n            y: u - o\n          }, {\n            x: n,\n            y: c - o\n          }, {\n            width: d,\n            height: o\n          }, i), e.q.copy(h, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: n,\n            y: c + u\n          }, {\n            width: d,\n            height: o\n          }, i), e.q.copy(h, a, {\n            x: d - o,\n            y: 0\n          }, {\n            x: n - o,\n            y: c\n          }, {\n            width: o,\n            height: u\n          }, i), e.q.copy(h, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: n + d,\n            y: c\n          }, {\n            width: o,\n            height: u\n          }, i), e.q.copy(h, a, {\n            x: d - o,\n            y: u - o\n          }, {\n            x: n - o,\n            y: c - o\n          }, {\n            width: o,\n            height: o\n          }, i), e.q.copy(h, a, {\n            x: 0,\n            y: u - o\n          }, {\n            x: n + d,\n            y: c - o\n          }, {\n            width: o,\n            height: o\n          }, i), e.q.copy(h, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: n + d,\n            y: c + u\n          }, {\n            width: o,\n            height: o\n          }, i), e.q.copy(h, a, {\n            x: d - o,\n            y: 0\n          }, {\n            x: n - o,\n            y: c + u\n          }, {\n            width: o,\n            height: o\n          }, i);\n        }\n        this.dirty = !0;\n      }\n      beginFrame() {\n        for (const e of this.images.keys()) this.callbackDispatchedThisFrame.set(e, new Set());\n      }\n      dispatchRenderCallbacks(e, t) {\n        const i = this.images.get(t);\n        for (const o of e) {\n          if (this.callbackDispatchedThisFrame.get(t).has(o.toString())) continue;\n          this.callbackDispatchedThisFrame.get(t).add(o.toString());\n          const e = i.get(o.toString());\n          G(e) && this.updateImage(o, t, e);\n        }\n      }\n      destroy() {\n        this.imageRasterizerDispatcher && this.imageRasterizerDispatcher.remove();\n      }\n    }\n    function q(t) {\n      const i = t.value,\n        o = t.valueSpec,\n        s = t.style,\n        r = t.styleSpec,\n        n = t.key,\n        a = t.arrayElementValidator || _e;\n      if (!Array.isArray(i)) return [new e.V(n, i, \"array expected, \".concat(e.K(i), \" found\"))];\n      if (o.length && i.length !== o.length) return [new e.V(n, i, \"array length \".concat(o.length, \" expected, length \").concat(i.length, \" found\"))];\n      if (o[\"min-length\"] && i.length < o[\"min-length\"]) return [new e.V(n, i, \"array length at least \".concat(o[\"min-length\"], \" expected, length \").concat(i.length, \" found\"))];\n      let l = {\n        type: o.value,\n        values: o.values,\n        minimum: o.minimum,\n        maximum: o.maximum,\n        function: void 0\n      };\n      r.$version < 7 && (l.function = o.function), e.H(o.value) && (l = o.value);\n      let c = [];\n      for (let e = 0; e < i.length; e++) c = c.concat(a({\n        array: i,\n        arrayIndex: e,\n        value: i[e],\n        valueSpec: l,\n        style: s,\n        styleSpec: r,\n        key: \"\".concat(n, \"[\").concat(e, \"]\")\n      }, !0));\n      return c;\n    }\n    function Z(t) {\n      const i = t.key,\n        o = t.value,\n        s = t.valueSpec;\n      if (!e.L(o)) return [new e.V(i, o, \"number expected, \".concat(e.K(o), \" found\"))];\n      if (o != o) return [new e.V(i, o, \"number expected, NaN found\")];\n      if (\"minimum\" in s) {\n        let r = s.minimum;\n        if (Array.isArray(s.minimum) && (r = s.minimum[t.arrayIndex]), o < r) return [new e.V(i, o, \"\".concat(o, \" is less than the minimum value \").concat(r))];\n      }\n      if (\"maximum\" in s) {\n        let r = s.maximum;\n        if (Array.isArray(s.maximum) && (r = s.maximum[t.arrayIndex]), o > r) return [new e.V(i, o, \"\".concat(o, \" is greater than the maximum value \").concat(r))];\n      }\n      return [];\n    }\n    function W(t) {\n      const i = t.key,\n        o = t.value;\n      if (!e.H(o)) return [new e.V(i, o, \"object expected, \".concat(e.K(o), \" found\"))];\n      const s = t.valueSpec,\n        r = e.J(o.type);\n      let n,\n        a,\n        l,\n        c = {};\n      const h = \"categorical\" !== r && void 0 === o.property,\n        d = !h,\n        u = function (t) {\n          const i = t.stops;\n          return Array.isArray(i) && Array.isArray(i[0]) && e.H(i[0][0]);\n        }(o),\n        _ = pe({\n          key: t.key,\n          value: t.value,\n          valueSpec: t.styleSpec.function,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            stops: function (t) {\n              if (\"identity\" === r) return [new e.V(t.key, t.value, 'identity function may not have a \"stops\" property')];\n              let i = [];\n              const o = t.value;\n              return i = i.concat(q({\n                key: t.key,\n                value: o,\n                valueSpec: t.valueSpec,\n                style: t.style,\n                styleSpec: t.styleSpec,\n                arrayElementValidator: p\n              })), Array.isArray(o) && 0 === o.length && i.push(new e.V(t.key, o, \"array must have at least one stop\")), i;\n            },\n            default: function (e) {\n              return _e({\n                key: e.key,\n                value: e.value,\n                valueSpec: s,\n                style: e.style,\n                styleSpec: e.styleSpec\n              });\n            }\n          }\n        });\n      return \"identity\" === r && h && _.push(new e.V(t.key, t.value, 'missing required property \"property\"')), \"identity\" === r || o.stops || _.push(new e.V(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === r && s.expression && !e.M(s) && _.push(new e.V(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (d && !e.N(s) ? _.push(new e.V(t.key, t.value, \"property functions not supported\")) : h && !e.O(s) && _.push(new e.V(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== r && !u || void 0 !== o.property || _.push(new e.V(t.key, t.value, '\"property\" property is required')), _;\n      function p(t) {\n        let i = [];\n        const o = t.value,\n          r = t.key;\n        if (!Array.isArray(o)) return [new e.V(r, o, \"array expected, \".concat(e.K(o), \" found\"))];\n        if (2 !== o.length) return [new e.V(r, o, \"array length 2 expected, length \".concat(o.length, \" found\"))];\n        if (u) {\n          if (!e.H(o[0])) return [new e.V(r, o, \"object expected, \".concat(e.K(o[0]), \" found\"))];\n          const s = o[0];\n          if (void 0 === s.zoom) return [new e.V(r, o, \"object stop key must have zoom\")];\n          if (void 0 === s.value) return [new e.V(r, o, \"object stop key must have value\")];\n          const n = e.J(s.zoom);\n          if (\"number\" != typeof n) return [new e.V(r, s.zoom, \"stop zoom values must be numbers\")];\n          if (l && l > n) return [new e.V(r, s.zoom, \"stop zoom values must appear in ascending order\")];\n          n !== l && (l = n, a = void 0, c = {}), i = i.concat(pe({\n            key: \"\".concat(r, \"[0]\"),\n            value: o[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: Z,\n              value: f\n            }\n          }));\n        } else i = i.concat(f({\n          key: \"\".concat(r, \"[0]\"),\n          value: o[0],\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, o));\n        return e.Q(e.S(o[1])) ? i.concat([new e.V(\"\".concat(r, \"[1]\"), o[1], \"expressions are not allowed in function stops.\")]) : i.concat(_e({\n          key: \"\".concat(r, \"[1]\"),\n          value: o[1],\n          valueSpec: s,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n      function f(t, i) {\n        const o = e.K(t.value),\n          l = e.J(t.value),\n          h = null !== t.value ? t.value : i;\n        if (n) {\n          if (o !== n) return [new e.V(t.key, h, \"\".concat(o, \" stop domain type must match previous stop domain type \").concat(n))];\n        } else n = o;\n        if (\"number\" !== o && \"string\" !== o && \"boolean\" !== o && \"number\" != typeof l && \"string\" != typeof l && \"boolean\" != typeof l) return [new e.V(t.key, h, \"stop domain value must be a number, string, or boolean\")];\n        if (\"number\" !== o && \"categorical\" !== r) {\n          let i = \"number expected, \".concat(o, \" found\");\n          return e.N(s) && void 0 === r && (i += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new e.V(t.key, h, i)];\n        }\n        return \"categorical\" !== r || \"number\" !== o || \"number\" == typeof l && isFinite(l) && Math.floor(l) === l ? \"categorical\" !== r && \"number\" === o && \"number\" == typeof l && \"number\" == typeof a && void 0 !== a && l < a ? [new e.V(t.key, h, \"stop domain values must appear in ascending order\")] : (a = l, \"categorical\" === r && l in c ? [new e.V(t.key, h, \"stop domain values must be unique\")] : (c[l] = !0, [])) : [new e.V(t.key, h, \"integer expected, found \".concat(String(l)))];\n      }\n    }\n    function $(t) {\n      const i = (\"property\" === t.expressionContext ? e.W : e.U)(e.S(t.value), t.valueSpec);\n      if (\"error\" === i.result) return i.value.map(i => new e.V(\"\".concat(t.key).concat(i.key), t.value, i.message));\n      const o = i.value.expression || i.value._styleExpression.expression;\n      if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !o.outputDefined()) return [new e.V(t.key, t.value, \"Invalid data expression for \\\"\".concat(t.propertyKey, \"\\\". Output values must be contained as literals within the expression.\"))];\n      if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !e.Z(o)) return [new e.V(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n      if (\"filter\" === t.expressionContext) return X(o, t);\n      if (\"appearance\" === t.expressionContext) return Y(o, t);\n      if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n        if (!e.X(o, [\"zoom\", \"feature-state\"])) return [new e.V(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        if (\"cluster-initial\" === t.expressionContext && !e.Y(o)) return [new e.V(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n      }\n      return [];\n    }\n    function X(t, i) {\n      const o = new Set([\"zoom\", \"feature-state\", \"pitch\", \"distance-from-center\"]);\n      if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters) o.delete(e);\n      if (0 === o.size) return [];\n      const s = [];\n      return t instanceof e._ && o.has(t.name) ? [new e.V(i.key, i.value, \"[\\\"\".concat(t.name, \"\\\"] expression is not supported in a filter for a \").concat(i.object.type, \" layer with id: \").concat(i.object.id))] : (t.eachChild(e => {\n        s.push(...X(e, i));\n      }), s);\n    }\n    function Y(t, i) {\n      const o = new Set();\n      if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters) o.add(e);\n      if (0 === o.size) return [];\n      const s = [];\n      return t instanceof e._ && !o.has(t.name) ? [new e.V(i.key, i.value, \"[\\\"\".concat(t.name, \"\\\"] is not an allowed parameter\"))] : (t.eachChild(e => {\n        s.push(...Y(e, i));\n      }), s);\n    }\n    function K(t) {\n      const i = t.key,\n        o = t.value,\n        s = t.valueSpec,\n        r = [];\n      return Array.isArray(s.values) ? -1 === s.values.indexOf(e.J(o)) && r.push(new e.V(i, o, \"expected one of [\".concat(s.values.join(\", \"), \"], \").concat(JSON.stringify(o), \" found\"))) : -1 === Object.keys(s.values).indexOf(e.J(o)) && r.push(new e.V(i, o, \"expected one of [\".concat(Object.keys(s.values).join(\", \"), \"], \").concat(JSON.stringify(o), \" found\"))), r;\n    }\n    function J(t) {\n      return e.a2(e.S(t.value)) ? $(Object.assign({}, t, {\n        expressionContext: \"filter\",\n        valueSpec: t.styleSpec[\"filter_\".concat(t.layerType || \"fill\")]\n      })) : Q(t);\n    }\n    function Q(t) {\n      const i = t.value,\n        o = t.key;\n      if (!Array.isArray(i)) return [new e.V(o, i, \"array expected, \".concat(e.K(i), \" found\"))];\n      if (i.length < 1) return [new e.V(o, i, \"filter array must have at least 1 element\")];\n      const s = t.styleSpec;\n      let r = K({\n        key: \"\".concat(o, \"[0]\"),\n        value: i[0],\n        valueSpec: s.filter_operator\n      });\n      switch (e.J(i[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          i.length >= 2 && \"$type\" === e.J(i[1]) && r.push(new e.V(o, i, \"\\\"$type\\\" cannot be use with operator \\\"\".concat(i[0], \"\\\"\")));\n        case \"==\":\n        case \"!=\":\n          3 !== i.length && r.push(new e.V(o, i, \"filter array for operator \\\"\".concat(i[0], \"\\\" must have 3 elements\")));\n        case \"in\":\n        case \"!in\":\n          i.length >= 2 && (e.a0(i[1]) || r.push(new e.V(\"\".concat(o, \"[1]\"), i[1], \"string expected, \".concat(e.K(i[1]), \" found\"))));\n          for (let t = 2; t < i.length; t++) \"$type\" === e.J(i[1]) ? r = r.concat(K({\n            key: \"\".concat(o, \"[\").concat(t, \"]\"),\n            value: i[t],\n            valueSpec: s.geometry_type\n          })) : e.a0(i[t]) || e.L(i[t]) || e.$(i[t]) || r.push(new e.V(\"\".concat(o, \"[\").concat(t, \"]\"), i[t], \"string, number, or boolean expected, \".concat(e.K(i[t]), \" found.\")));\n          break;\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let e = 1; e < i.length; e++) r = r.concat(Q({\n            key: \"\".concat(o, \"[\").concat(e, \"]\"),\n            value: i[e],\n            style: t.style,\n            styleSpec: t.styleSpec\n          }));\n          break;\n        case \"has\":\n        case \"!has\":\n          2 !== i.length ? r.push(new e.V(o, i, \"filter array for \\\"\".concat(i[0], \"\\\" operator must have 2 elements\"))) : e.a0(i[1]) || r.push(new e.V(\"\".concat(o, \"[1]\"), i[1], \"string expected, \".concat(e.K(i[1]), \" found\")));\n      }\n      return r;\n    }\n    function ee(t, i) {\n      const o = t.key,\n        s = t.style,\n        r = t.layer,\n        n = t.styleSpec,\n        a = t.value,\n        l = t.objectKey,\n        c = n[\"\".concat(i, \"_\").concat(t.layerType)];\n      if (!c) return [];\n      const h = l.match(/^(.*)-use-theme$/);\n      if (h && c[h[1]]) return e.Q(a) ? [].concat(_e({\n        key: t.key,\n        value: a,\n        valueSpec: {\n          type: \"string\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        style: s,\n        styleSpec: n,\n        expressionContext: \"property\",\n        propertyType: i,\n        propertyKey: l\n      })) : _e({\n        key: o,\n        value: a,\n        valueSpec: {\n          type: \"string\"\n        },\n        style: s,\n        styleSpec: n\n      });\n      const d = l.match(/^(.*)-transition$/);\n      if (\"paint\" === i && d && c[d[1]] && c[d[1]].transition) return _e({\n        key: o,\n        value: a,\n        valueSpec: n.transition,\n        style: s,\n        styleSpec: n\n      });\n      const u = t.valueSpec || c[l];\n      if (!u) return [new e.a3(o, a, \"unknown property \\\"\".concat(l, \"\\\"\"))];\n      let _;\n      if (e.a0(a) && e.N(u) && !u.tokens && (_ = /^{([^}]+)}$/.exec(a))) {\n        const t = \"`{ \\\"type\\\": \\\"identity\\\", \\\"property\\\": \".concat(_ ? JSON.stringify(_[1]) : '\"_\"', \" }`\");\n        return [new e.V(o, a, \"\\\"\".concat(l, \"\\\" does not support interpolation syntax\\nUse an identity property function instead: \").concat(t, \".\"))];\n      }\n      const p = [];\n      if (\"symbol\" === t.layerType) \"text-field\" !== l || !s || s.glyphs || s.imports || p.push(new e.V(o, a, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === l && e.a4(e.S(a)) && \"identity\" === e.J(a.type) && p.push(new e.V(o, a, '\"text-font\" does not support identity functions'));else if (\"model\" === t.layerType && \"paint\" === i && r && r.layout && r.layout.hasOwnProperty(\"model-id\") && e.N(u) && (e.a5(u) || e.O(u))) {\n        const t = e.W(e.S(a), u),\n          i = t.value.expression || t.value._styleExpression.expression;\n        i && !e.X(i, [\"measure-light\"]) && (\"model-emissive-strength\" === l && e.Y(i) && e.Z(i) || p.push(new e.V(o, a, \"\".concat(l, \" does not support measure-light expressions when the model layer source is vector tile or GeoJSON.\"))));\n      }\n      return p.concat(_e({\n        key: t.key,\n        value: a,\n        valueSpec: u,\n        style: s,\n        styleSpec: n,\n        expressionContext: \"property\",\n        propertyType: i,\n        propertyKey: l\n      }));\n    }\n    function te(e) {\n      return ee(e, \"paint\");\n    }\n    function ie(e) {\n      return ee(e, \"layout\");\n    }\n    function oe(t) {\n      let i = [];\n      const o = t.value,\n        s = t.key,\n        r = t.style,\n        n = t.styleSpec;\n      if (!e.H(o)) return [new e.V(s, o, \"object expected\")];\n      o.type || o.ref || i.push(new e.V(s, o, 'either \"type\" or \"ref\" is required'));\n      let a = e.J(o.type);\n      const l = e.J(o.ref);\n      if (o.id) {\n        const n = e.J(o.id);\n        for (let a = 0; a < t.arrayIndex; a++) {\n          const t = r.layers[a];\n          e.J(t.id) === n && i.push(new e.V(s, o.id, \"duplicate layer id \\\"\".concat(n, \"\\\", previously used at line \").concat(t.id.__line__)));\n        }\n      }\n      if (\"ref\" in o) {\n        let t;\n        [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(t => {\n          t in o && i.push(new e.V(s, o[t], \"\\\"\".concat(t, \"\\\" is prohibited for ref layers\")));\n        }), r.layers.forEach(i => {\n          e.J(i.id) === l && (t = i);\n        }), t ? t.ref ? i.push(new e.V(s, o.ref, \"ref cannot reference another ref layer\")) : a = e.J(t.type) : \"string\" == typeof l && i.push(new e.V(s, o.ref, \"ref layer \\\"\".concat(l, \"\\\" not found\")));\n      } else if (\"background\" !== a && \"sky\" !== a && \"slot\" !== a) if (o.source) {\n        if (e.a0(o.source)) {\n          const t = r.sources && r.sources[o.source],\n            n = t && e.J(t.type);\n          t ? \"vector\" === n && \"raster\" === a ? i.push(new e.V(s, o.source, \"layer \\\"\".concat(o.id, \"\\\" requires a raster source\"))) : \"raster\" === n && \"raster\" !== a ? i.push(new e.V(s, o.source, \"layer \\\"\".concat(o.id, \"\\\" requires a vector source\"))) : \"vector\" !== n || o[\"source-layer\"] ? \"raster-dem\" === n && \"hillshade\" !== a ? i.push(new e.V(s, o.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"raster-array\" !== n || [\"raster\", \"raster-particle\"].includes(a) ? \"line\" === a && o.paint && (o.paint[\"line-gradient\"] || o.paint[\"line-trim-offset\"]) && \"geojson\" === n && !t.lineMetrics ? i.push(new e.V(s, o, \"layer \\\"\".concat(o.id, \"\\\" specifies a line-gradient, which requires the GeoJSON source to have `lineMetrics` enabled.\"))) : \"raster-particle\" === a && \"raster-array\" !== n && i.push(new e.V(s, o.source, \"layer \\\"\".concat(o.id, \"\\\" requires a 'raster-array' source.\"))) : i.push(new e.V(s, o.source, \"raster-array source can only be used with layer type 'raster'.\")) : i.push(new e.V(s, o, \"layer \\\"\".concat(o.id, \"\\\" must specify a \\\"source-layer\\\"\"))) : i.push(new e.V(s, o.source, \"source \\\"\".concat(o.source, \"\\\" not found\")));\n        } else i.push(new e.V(\"\".concat(s, \".source\"), o.source, '\"source\" must be a string'));\n      } else i.push(new e.V(s, o, 'missing required property \"source\"'));\n      return i = i.concat(pe({\n        key: s,\n        value: o,\n        valueSpec: n.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          \"*\": () => [],\n          type: () => _e({\n            key: \"\".concat(s, \".type\"),\n            value: o.type,\n            valueSpec: n.layer.type,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            object: o,\n            objectKey: \"type\"\n          }),\n          filter: e => J(Object.assign({\n            layerType: a\n          }, e)),\n          layout: e => pe({\n            layer: o,\n            key: e.key,\n            value: e.value,\n            valueSpec: {},\n            style: e.style,\n            styleSpec: e.styleSpec,\n            objectElementValidators: {\n              \"*\": e => ie(Object.assign({\n                layerType: a\n              }, e))\n            }\n          }),\n          paint: e => pe({\n            layer: o,\n            key: e.key,\n            value: e.value,\n            valueSpec: {},\n            style: e.style,\n            styleSpec: e.styleSpec,\n            objectElementValidators: {\n              \"*\": e => te(Object.assign({\n                layerType: a,\n                layer: o\n              }, e))\n            }\n          }),\n          appearances(t) {\n            const i = q({\n                key: t.key,\n                value: t.value,\n                valueSpec: t.valueSpec,\n                style: t.style,\n                styleSpec: t.styleSpec,\n                arrayElementValidator: t => function (t) {\n                  const {\n                      key: i,\n                      layer: o,\n                      layerType: s\n                    } = t,\n                    r = e.J(t.value),\n                    n = e.J(r.name),\n                    a = e.J(r.condition),\n                    l = pe({\n                      key: i,\n                      value: r,\n                      valueSpec: t.styleSpec.appearance,\n                      style: t.style,\n                      styleSpec: t.styleSpec,\n                      objectElementValidators: {\n                        condition: t => function (t) {\n                          const i = [];\n                          return i.push(...$({\n                            key: t.key,\n                            value: t.object.condition,\n                            valueSpec: e.a6.appearance.condition,\n                            expressionContext: \"appearance\"\n                          })), i;\n                        }(Object.assign({\n                          layer: o,\n                          layerType: s\n                        }, t)),\n                        properties: t => function (t) {\n                          const i = [],\n                            {\n                              styleSpec: o,\n                              layer: s,\n                              layerType: r\n                            } = t,\n                            n = o[\"paint_\".concat(r)],\n                            a = o[\"layout_\".concat(r)],\n                            l = t.object[t.objectKey];\n                          for (const o in l) {\n                            const c = o in n ? \"paint\" : o in a ? \"layout\" : void 0;\n                            if (!c) {\n                              i.push(new e.V(t.key, o, \"unknown property \\\"\".concat(o, \"\\\" for layer type \\\"\").concat(r, \"\\\"\")));\n                              continue;\n                            }\n                            const h = Object.assign({}, t, {\n                              key: \"\".concat(t.key, \".\").concat(o),\n                              object: l,\n                              objectKey: o,\n                              layer: s,\n                              layerType: r,\n                              value: l[o],\n                              valueSpec: \"paint\" === c ? n[o] : a[o]\n                            });\n                            i.push(...ee(h, c));\n                          }\n                          return i;\n                        }(Object.assign({\n                          layer: o,\n                          layerType: s\n                        }, t))\n                      }\n                    });\n                  return \"hidden\" === n || a || l.push(new e.V(t.key, \"name\", 'Appearance with name different than \"hidden\" must have a condition')), l;\n                }(Object.assign({\n                  layerType: a,\n                  layer: o\n                }, t))\n              }),\n              s = Array.isArray(t.value) ? t.value : [],\n              r = new Set();\n            return s.forEach((s, n) => {\n              const a = e.J(s.name);\n              if (a) if (r.has(a)) {\n                const s = e.J(o.id);\n                i.push(new e.V(t.key, a, \"Duplicated appearance name \\\"\".concat(a, \"\\\" for layer \\\"\").concat(s, \"\\\"\")));\n              } else r.add(a);\n            }), i;\n          }\n        }\n      })), i;\n    }\n    function se(_ref80) {\n      let {\n        key: t,\n        value: i\n      } = _ref80;\n      return e.a0(i) ? [] : [new e.V(t, i, \"string expected, \".concat(e.K(i), \" found\"))];\n    }\n    const re = {\n      promoteId: function t(_ref81) {\n        let {\n          key: i,\n          value: o\n        } = _ref81;\n        if (e.a0(o)) return se({\n          key: i,\n          value: o\n        });\n        if (Array.isArray(o)) {\n          const t = [],\n            s = e.S(o),\n            r = e.U(s);\n          return \"error\" === r.result && r.value.forEach(o => {\n            t.push(new e.V(\"\".concat(i).concat(o.key), null, \"\".concat(o.message)));\n          }), e.X(r.value.expression, [\"zoom\", \"heatmap-density\", \"line-progress\", \"raster-value\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\", \"measure-light\", \"raster-particle-speed\"]) || t.push(new e.V(\"\".concat(i), null, \"promoteId expression should be only feature dependent\")), t;\n        }\n        if (!e.H(o)) return [new e.V(i, o, \"string, expression or object expected, \\\"\".concat(e.K(o), \"\\\" found\"))];\n        const s = [];\n        for (const e in o) s.push(...t({\n          key: \"\".concat(i, \".\").concat(e),\n          value: o[e]\n        }));\n        return s;\n      }\n    };\n    function ne(t) {\n      const i = t.value,\n        o = t.key,\n        s = t.styleSpec,\n        r = t.style;\n      if (!e.H(i)) return [new e.V(o, i, \"object expected, \".concat(e.K(i), \" found\"))];\n      if (!(\"type\" in i)) return [new e.V(o, i, '\"type\" is required')];\n      const n = e.J(i.type);\n      let a = [];\n      switch ([\"vector\", \"raster\", \"raster-dem\", \"raster-array\"].includes(n) && (\"url\" in i || \"tiles\" in i || a.push(new e.a3(o, i, 'Either \"url\" or \"tiles\" is required.'))), n) {\n        case \"vector\":\n        case \"raster\":\n        case \"raster-dem\":\n        case \"raster-array\":\n          return a = a.concat(pe({\n            key: o,\n            value: i,\n            valueSpec: s[\"source_\".concat(n.replace(\"-\", \"_\"))],\n            style: t.style,\n            styleSpec: s,\n            objectElementValidators: re\n          })), a;\n        case \"geojson\":\n          if (a = pe({\n            key: o,\n            value: i,\n            valueSpec: s.source_geojson,\n            style: r,\n            styleSpec: s,\n            objectElementValidators: re\n          }), \"cluster\" in i && \"clusterProperties\" in i) {\n            if (!e.H(i.clusterProperties)) return [new e.V(\"\".concat(o, \".clusterProperties\"), i, \"object expected, \".concat(e.K(i), \" found\"))];\n            for (const t in i.clusterProperties) {\n              const s = i.clusterProperties[t];\n              if (!Array.isArray(s)) return [new e.V(\"\".concat(o, \".clusterProperties.\").concat(t), s, \"array expected\")];\n              const [r, n] = s,\n                l = \"string\" == typeof r ? [r, [\"accumulated\"], [\"get\", t]] : r;\n              a.push(...$({\n                key: \"\".concat(o, \".\").concat(t, \".map\"),\n                value: n,\n                expressionContext: \"cluster-map\"\n              })), a.push(...$({\n                key: \"\".concat(o, \".\").concat(t, \".reduce\"),\n                value: l,\n                expressionContext: \"cluster-reduce\"\n              }));\n            }\n          }\n          return a;\n        case \"video\":\n          return pe({\n            key: o,\n            value: i,\n            valueSpec: s.source_video,\n            style: r,\n            styleSpec: s\n          });\n        case \"image\":\n          return pe({\n            key: o,\n            value: i,\n            valueSpec: s.source_image,\n            style: r,\n            styleSpec: s\n          });\n        case \"canvas\":\n          return [new e.V(o, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n        default:\n          return K({\n            key: \"\".concat(o, \".type\"),\n            value: i.type,\n            valueSpec: {\n              values: ae(s)\n            }\n          });\n      }\n    }\n    function ae(e) {\n      return e.source.reduce((t, i) => {\n        const o = e[i];\n        return \"enum\" === o.type.type && (t = t.concat(Object.keys(o.type.values))), t;\n      }, []);\n    }\n    function le(t) {\n      const i = t.value,\n        o = t.styleSpec,\n        s = o.light,\n        r = t.style;\n      if (void 0 === i) return [];\n      if (!e.H(i)) return [new e.V(\"light\", i, \"object expected, \".concat(e.K(i), \" found\"))];\n      let n = [];\n      for (const t in i) {\n        const a = t.match(/^(.*)-transition$/),\n          l = t.match(/^(.*)-use-theme$/);\n        n = n.concat(l && s[l[1]] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: r,\n          styleSpec: o\n        }) : a && s[a[1]] && s[a[1]].transition ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: o.transition,\n          style: r,\n          styleSpec: o\n        }) : s[t] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: s[t],\n          style: r,\n          styleSpec: o\n        }) : [new e.V(t, i[t], \"unknown property \\\"\".concat(t, \"\\\"\"))]);\n      }\n      return n;\n    }\n    function ce(t) {\n      const i = t.value;\n      if (!i) return [];\n      const o = t.key;\n      if (!e.H(i)) return [new e.V(o, i, \"object expected, \".concat(e.K(i), \" found\"))];\n      let s = [];\n      const r = t.styleSpec,\n        n = r[\"light-3d\"],\n        a = t.style,\n        l = t.style.lights;\n      for (const t of [\"type\", \"id\"]) if (!(t in i)) return s = s.concat([new e.V(o, i, \"missing property \\\"\".concat(t, \"\\\"\"))]), s;\n      if (!e.a0(i.type)) return s = s.concat([new e.V(\"\".concat(o, \".type\"), i.type, \"string expected\")]), s;\n      if (l) for (let r = 0; r < t.arrayIndex; r++) {\n        const t = e.J(i.type),\n          n = l[r];\n        e.J(n.type) === t && s.push(new e.V(o, i.id, \"duplicate light type \\\"\".concat(i.type, \"\\\", previously defined at line \").concat(n.id.__line__)));\n      }\n      const c = \"properties_light_\".concat(i.type);\n      if (!(c in r)) return s = s.concat([new e.V(\"\".concat(o, \".type\"), i, \"Invalid light type \".concat(i.type))]), s;\n      const h = r[c];\n      for (const o in i) if (\"properties\" === o) {\n        const n = i[o];\n        if (!e.H(n)) return s = s.concat([new e.V(\"properties\", n, \"object expected, \".concat(e.K(n), \" found\"))]), s;\n        for (const l in n) {\n          const c = l.match(/^(.*)-transition$/),\n            d = l.match(/^(.*)-use-theme$/);\n          s = s.concat(d && h[d[1]] ? _e({\n            key: o,\n            value: n[l],\n            valueSpec: {\n              type: \"string\"\n            },\n            style: a,\n            styleSpec: r\n          }) : c && h[c[1]] && h[c[1]].transition ? _e({\n            key: o,\n            value: i[o],\n            valueSpec: r.transition,\n            style: a,\n            styleSpec: r\n          }) : h[l] ? _e({\n            key: l,\n            value: n[l],\n            valueSpec: h[l],\n            style: a,\n            styleSpec: r\n          }) : [new e.a3(t.key, n[l], \"unknown property \\\"\".concat(l, \"\\\"\"))]);\n        }\n      } else s = s.concat(n[o] ? _e({\n        key: o,\n        value: i[o],\n        valueSpec: n[o],\n        style: a,\n        styleSpec: r\n      }) : [new e.a3(o, i[o], \"unknown property \\\"\".concat(o, \"\\\"\"))]);\n      return s;\n    }\n    function he(t) {\n      const i = t.value,\n        o = t.key,\n        s = t.style,\n        r = t.styleSpec,\n        n = r.terrain;\n      if (null == i) return [];\n      if (!e.H(i)) return [new e.V(\"terrain\", i, \"object expected, \".concat(e.K(i), \" found\"))];\n      let a = [];\n      for (const t in i) {\n        const o = t.match(/^(.*)-transition$/),\n          l = t.match(/^(.*)-use-theme$/);\n        a = a.concat(l && n[l[1]] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: s,\n          styleSpec: r\n        }) : o && n[o[1]] && n[o[1]].transition ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: r.transition,\n          style: s,\n          styleSpec: r\n        }) : n[t] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: n[t],\n          style: s,\n          styleSpec: r\n        }) : [new e.a3(t, i[t], \"unknown property \\\"\".concat(t, \"\\\"\"))]);\n      }\n      if (i.source) {\n        if (e.a0(i.source)) {\n          const t = s.sources && s.sources[i.source],\n            r = t && e.J(t.type);\n          t ? \"raster-dem\" !== r && a.push(new e.V(\"\".concat(o, \".source\"), i.source, \"terrain cannot be used with a source of type \".concat(r, \", it only be used with a \\\"raster-dem\\\" source type\"))) : a.push(new e.V(\"\".concat(o, \".source\"), i.source, \"source \\\"\".concat(i.source, \"\\\" not found\")));\n        } else a.push(new e.V(\"\".concat(o, \".source\"), i.source, \"source must be a string\"));\n      } else a.push(new e.V(o, i, 'terrain is missing required property \"source\"'));\n      return a;\n    }\n    function de(t) {\n      const i = t.value,\n        o = t.style,\n        s = t.styleSpec,\n        r = s.fog;\n      if (void 0 === i) return [];\n      if (!e.H(i)) return [new e.V(\"fog\", i, \"object expected, \".concat(e.K(i), \" found\"))];\n      let n = [];\n      for (const t in i) {\n        const a = t.match(/^(.*)-transition$/),\n          l = t.match(/^(.*)-use-theme$/);\n        n = n.concat(l && r[l[1]] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: o,\n          styleSpec: s\n        }) : a && r[a[1]] && r[a[1]].transition ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: s.transition,\n          style: o,\n          styleSpec: s\n        }) : r[t] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: r[t],\n          style: o,\n          styleSpec: s\n        }) : [new e.a3(t, i[t], \"unknown property \\\"\".concat(t, \"\\\"\"))]);\n      }\n      return n;\n    }\n    const ue = {\n      \"*\": () => [],\n      array: q,\n      boolean: function (t) {\n        const i = t.value,\n          o = t.key;\n        return e.$(i) ? [] : [new e.V(o, i, \"boolean expected, \".concat(e.K(i), \" found\"))];\n      },\n      number: Z,\n      color: function (_ref82) {\n        let {\n          key: t,\n          value: i\n        } = _ref82;\n        return e.a0(i) ? null === e.a1.parseCSSColor(i) ? [new e.V(t, i, \"color expected, \\\"\".concat(i, \"\\\" found\"))] : [] : [new e.V(t, i, \"color expected, \".concat(e.K(i), \" found\"))];\n      },\n      enum: K,\n      filter: J,\n      function: W,\n      layer: oe,\n      object: pe,\n      source: ne,\n      model: e.a7,\n      light: le,\n      \"light-3d\": ce,\n      terrain: he,\n      fog: de,\n      string: se,\n      formatted: function (e) {\n        return 0 === se(e).length ? [] : $(e);\n      },\n      resolvedImage: function (e) {\n        return 0 === se(e).length ? [] : $(e);\n      },\n      projection: function (t) {\n        const i = t.value,\n          o = t.styleSpec,\n          s = o.projection,\n          r = t.style;\n        if (e.H(i)) {\n          let e = [];\n          for (const t in i) e = e.concat(_e({\n            key: t,\n            value: i[t],\n            valueSpec: s[t],\n            style: r,\n            styleSpec: o\n          }));\n          return e;\n        }\n        return e.a0(i) ? [] : [new e.V(\"projection\", i, \"object or string expected, \".concat(e.K(i), \" found\"))];\n      },\n      import: function (t) {\n        const i = t.key,\n          {\n            value: o,\n            styleSpec: s\n          } = t;\n        if (!e.H(o)) return [new e.V(i, o, \"import must be an object\")];\n        const {\n            data: r\n          } = o,\n          n = _objectWithoutProperties(o, _excluded);\n        Object.defineProperty(n, \"__line__\", {\n          value: o.__line__,\n          enumerable: !1\n        });\n        let a = pe(Object.assign({}, t, {\n          value: n,\n          valueSpec: s.import\n        }));\n        return \"\" === e.J(n.id) && a.push(new e.V(\"\".concat(t.key, \".id\"), n, \"import id can't be an empty string\")), r && (a = a.concat(me(r, s, {\n          key: \"\".concat(t.key, \".data\")\n        }))), a;\n      },\n      iconset: function (t) {\n        const i = t.value,\n          o = t.key,\n          s = t.styleSpec,\n          r = t.style;\n        if (!e.H(i)) return [new e.V(o, i, \"object expected\")];\n        if (!i.type) return [new e.V(o, i, '\"type\" is required')];\n        const n = e.J(i.type);\n        let a = [];\n        if (a = a.concat(pe({\n          key: o,\n          value: i,\n          valueSpec: s[\"iconset_\".concat(n)],\n          style: r,\n          styleSpec: s\n        })), function (e, t) {\n          return !(\"source\" !== e || !t.source);\n        }(n, i)) {\n          const t = r.sources && r.sources[i.source],\n            s = t && e.J(t.type);\n          t ? \"raster-array\" !== s && a.push(new e.V(o, i.source, \"iconset cannot be used with a source of type \".concat(String(s), \", it only be used with a \\\"raster-array\\\" source type\"))) : a.push(new e.V(o, i.source, \"source \\\"\".concat(i.source, \"\\\" not found\")));\n        }\n        return a;\n      }\n    };\n    function _e(t) {\n      let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n      const o = t.value,\n        s = t.valueSpec,\n        r = t.styleSpec;\n      if (s.expression) {\n        if (e.a4(e.J(o))) return W(t);\n        if (e.Q(e.S(o))) return $(t);\n      }\n      if (s.type && ue[s.type]) {\n        const e = ue[s.type](t);\n        return !0 === i && e.length > 0 && Array.isArray(t.value) ? $(t) : e;\n      }\n      return pe(Object.assign({}, t, {\n        valueSpec: s.type ? r[s.type] : s\n      }));\n    }\n    function pe(t) {\n      const i = t.key,\n        o = t.value,\n        s = t.valueSpec || {},\n        r = t.objectElementValidators || {},\n        n = t.style,\n        a = t.styleSpec;\n      if (!e.H(o)) return [new e.V(i, o, \"object expected, \".concat(e.K(o), \" found\"))];\n      let l = [];\n      for (const t in o) {\n        const c = t.split(\".\")[0];\n        let h;\n        r[c] ? h = r[c] : s[c] ? h = _e : r[\"*\"] ? h = r[\"*\"] : s[\"*\"] && (h = _e), h ? l = l.concat(h({\n          key: (i ? \"\".concat(i, \".\") : i) + t,\n          value: o[t],\n          valueSpec: s[c] || s[\"*\"],\n          style: n,\n          styleSpec: a,\n          object: o,\n          objectKey: t\n        }, o)) : l.push(new e.a3(i, o[t], \"unknown property \\\"\".concat(t, \"\\\"\")));\n      }\n      for (const t in s) r[t] || s[t].required && void 0 === s[t].default && void 0 === o[t] && l.push(new e.V(i, o, \"missing required property \\\"\".concat(t, \"\\\"\")));\n      return l;\n    }\n    function fe(_ref83) {\n      let {\n        key: t,\n        value: i\n      } = _ref83;\n      const o = se({\n        key: t,\n        value: i\n      });\n      if (o.length) return o;\n      const s = i;\n      return -1 === s.indexOf(\"{fontstack}\") && o.push(new e.V(t, i, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === s.indexOf(\"{range}\") && o.push(new e.V(t, i, '\"glyphs\" url must include a \"{range}\" token')), o;\n    }\n    function me(t) {\n      let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.a6;\n      let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return pe({\n        key: o.key || \"\",\n        value: t,\n        valueSpec: Object.assign(i.$root, {\n          \"*\": {\n            type: \"*\"\n          }\n        }),\n        styleSpec: i,\n        style: t,\n        objectElementValidators: {\n          glyphs: fe\n        }\n      });\n    }\n    function ge(t) {\n      let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e.a6;\n      return De(me(t, i));\n    }\n    const ve = e => De(ne(e)),\n      ye = e => De(le(e)),\n      xe = e => De(ce(e)),\n      be = e => De(he(e)),\n      we = e => De(de(e)),\n      Te = t => De(function (t) {\n        const i = t.value,\n          o = t.style,\n          s = t.styleSpec,\n          r = s.snow;\n        if (void 0 === i) return [];\n        if (!e.H(i)) return [new e.V(\"snow\", i, \"object expected, \".concat(e.K(i), \" found\"))];\n        let n = [];\n        for (const t in i) {\n          const a = t.match(/^(.*)-transition$/);\n          n = n.concat(a && r[a[1]] && r[a[1]].transition ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: s.transition,\n            style: o,\n            styleSpec: s\n          }) : r[t] ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: r[t],\n            style: o,\n            styleSpec: s\n          }) : [new e.a3(t, i[t], \"unknown property \\\"\".concat(t, \"\\\"\"))]);\n        }\n        return n;\n      }(t)),\n      Ee = t => De(function (t) {\n        const i = t.value,\n          o = t.style,\n          s = t.styleSpec,\n          r = s.rain;\n        if (void 0 === i) return [];\n        if (!e.H(i)) return [new e.V(\"rain\", i, \"object expected, \".concat(e.K(i), \" found\"))];\n        let n = [];\n        for (const t in i) {\n          const a = t.match(/^(.*)-transition$/);\n          n = n.concat(a && r[a[1]] && r[a[1]].transition ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: s.transition,\n            style: o,\n            styleSpec: s\n          }) : r[t] ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: r[t],\n            style: o,\n            styleSpec: s\n          }) : [new e.a3(t, i[t], \"unknown property \\\"\".concat(t, \"\\\"\"))]);\n        }\n        return n;\n      }(t)),\n      Se = e => De(oe(e)),\n      Ie = e => De(J(e)),\n      Ce = e => De(te(e)),\n      Re = e => De(ie(e)),\n      Ae = t => De(e.a7(t));\n    function De(e) {\n      return e.slice().sort((e, t) => e.line && t.line ? e.line - t.line : 0);\n    }\n    function Le(t, i) {\n      let o = !1;\n      if (i && i.length) for (const s of i) s instanceof e.a3 ? e.w(s.message) : (t.fire(new e.y(new Error(s.message))), o = !0);\n      return o;\n    }\n    let Pe;\n    class ze extends e.E {\n      constructor(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"flat\";\n        super(), this._transitionable = new e.a8(Pe || (Pe = new e.a9({\n          anchor: new e.aa(e.a6.light.anchor),\n          position: new e.ab(e.a6.light.position),\n          color: new e.aa(e.a6.light.color),\n          intensity: new e.aa(e.a6.light.intensity)\n        }))), this.setLight(t, i), this._transitioning = this._transitionable.untransitioned();\n      }\n      getLight() {\n        return this._transitionable.serialize();\n      }\n      setLight(e, t) {\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this._validate(ye, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t);\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && Le(this, t.call(ge, Object.assign({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.a6\n        })));\n      }\n    }\n    let Oe = class extends e.E {\n      constructor(t, i, o, s, r) {\n        super(), this.scope = o, this._transitionable = new e.a8(new e.a9({\n          source: new e.aa(e.a6.terrain.source),\n          exaggeration: new e.aa(e.a6.terrain.exaggeration)\n        }), o, s), this._transitionable.setTransitionOrValue(t, s), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i, this.worldview = r;\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(e, t) {\n        this._transitionable.setTransitionOrValue(e, t);\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      getExaggeration(t) {\n        return this._transitioning.possiblyEvaluate(new e.ac(t, {\n          worldview: this.worldview\n        })).get(\"exaggeration\");\n      }\n      getAttenuationRange() {\n        if (!this.isZoomDependent()) return null;\n        const t = this._transitionable._values.exaggeration;\n        if (!t) return null;\n        const i = t.value.expression;\n        if (!i) return null;\n        let o = -1,\n          s = -1,\n          r = 1;\n        for (const t of i.zoomStops) r = i.evaluate(new e.ac(t, {\n          worldview: this.worldview\n        })), r > .01 ? (o = t, s = -1) : s = t;\n        return r < .01 && o > 0 && s > o ? [o, s] : null;\n      }\n      isZoomDependent() {\n        const t = this._transitionable._values.exaggeration;\n        return null != t && null != t.value && null != t.value.expression && t.value.expression instanceof e.ad;\n      }\n    };\n    const Me = 45,\n      Fe = 65,\n      Be = .05;\n    function ke(t, i, o, s) {\n      const r = e.ah(Me, Fe, o),\n        [n, a] = Ne(t, s);\n      let l = 1 - Math.min(1, Math.exp((i - n) / (a - n) * -6));\n      return l *= l * l, l = Math.min(1, 1.00747 * l), l * r * t.alpha;\n    }\n    function Ne(e, t) {\n      const i = .5 / Math.tan(.5 * t);\n      return [e.range[0] + i, e.range[1] + i];\n    }\n    function Ue(t, i, o, s, r) {\n      const n = e.af([], [i, o, s], r.mercatorFogMatrix);\n      return ke(t, e.ag(n), r.pitch, r._fov);\n    }\n    function je(t, i, o, s, r, n, a) {\n      const l = [[o, s, 0], [r, s, 0], [r, n, 0], [o, n, 0]];\n      let c = Number.MAX_VALUE,\n        h = -Number.MAX_VALUE;\n      for (const t of l) {\n        const o = e.af([], t, i),\n          s = e.ag(o);\n        c = Math.min(c, s), h = Math.max(h, s);\n      }\n      return [ke(t, c, a.pitch, a._fov), ke(t, h, a.pitch, a._fov)];\n    }\n    class Ve extends e.E {\n      constructor(t, i, o, s) {\n        super();\n        const r = new e.a9({\n          range: new e.aa(e.a6.fog.range),\n          color: new e.aa(e.a6.fog.color),\n          \"color-use-theme\": new e.aa({\n            type: \"string\",\n            \"property-type\": \"data-constant\",\n            default: \"default\"\n          }),\n          \"high-color\": new e.aa(e.a6.fog[\"high-color\"]),\n          \"high-color-use-theme\": new e.aa({\n            type: \"string\",\n            \"property-type\": \"data-constant\",\n            default: \"default\"\n          }),\n          \"space-color\": new e.aa(e.a6.fog[\"space-color\"]),\n          \"space-color-use-theme\": new e.aa({\n            type: \"string\",\n            \"property-type\": \"data-constant\",\n            default: \"default\"\n          }),\n          \"horizon-blend\": new e.aa(e.a6.fog[\"horizon-blend\"]),\n          \"star-intensity\": new e.aa(e.a6.fog[\"star-intensity\"]),\n          \"vertical-range\": new e.aa(e.a6.fog[\"vertical-range\"])\n        });\n        this._transitionable = new e.a8(r, o, new Map(s)), this.set(t, s), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.ai(r), this.scope = o;\n      }\n      get state() {\n        const t = this._transform,\n          i = \"globe\" === t.projection.name,\n          o = e.aj(t.zoom),\n          s = this.properties.get(\"range\"),\n          r = [.5, 3];\n        return {\n          range: i ? [e.ak(r[0], s[0], o), e.ak(r[1], s[1], o)] : s,\n          horizonBlend: this.properties.get(\"horizon-blend\"),\n          alpha: this.properties.get(\"color\").a\n        };\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (this._validate(we, t, o)) return;\n        const s = Object.assign({}, t);\n        for (const t of Object.keys(e.a6.fog)) void 0 === s[t] && (s[t] = e.a6.fog[t].default);\n        this._options = s, this._transitionable.setTransitionOrValue(this._options, i);\n      }\n      getOpacity(t) {\n        if (!this._transform.projection.supportsFog) return 0;\n        const i = this.properties && this.properties.get(\"color\") || 1;\n        return (\"globe\" === this._transform.projection.name ? 1 : e.ah(Me, Fe, t)) * i.a;\n      }\n      getOpacityAtLatLng(t, i) {\n        return this._transform.projection.supportsFog ? function (t, i, o) {\n          const s = e.ae.fromLngLat(i),\n            r = o.elevation ? o.elevation.getAtPointOrZero(s) : 0;\n          return Ue(t, s.x, s.y, r, o);\n        }(this.state, t, i) : 0;\n      }\n      getOpacityForTile(t) {\n        if (!this._transform.projection.supportsFog) return [1, 1];\n        const i = this._transform.calculateFogTileMatrix(t.toUnwrapped());\n        return je(this.state, i, 0, 0, e.al, e.al, this._transform);\n      }\n      getOpacityForBounds(e, t, i, o, s) {\n        return this._transform.projection.supportsFog ? je(this.state, e, t, i, o, s, this._transform) : [1, 1];\n      }\n      getFovAdjustedRange(e) {\n        return this._transform.projection.supportsFog ? Ne(this.state, e) : [0, 1];\n      }\n      isVisibleOnFrustum(t) {\n        if (!this._transform.projection.supportsFog) return !1;\n        const i = [4, 5, 6, 7];\n        for (const o of i) {\n          const i = t.points[o];\n          let s;\n          if (i[2] >= 0) s = i;else {\n            const r = t.points[o - 4];\n            s = e.am(r, i, r[2] / (r[2] - i[2]));\n          }\n          if (Ue(this.state, s[0], s[1], 0, this._transform) >= Be) return !0;\n        }\n        return !1;\n      }\n      updateConfig(e) {\n        this._transitionable.setTransitionOrValue(this._options, new Map(e));\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && Le(this, t.call(ge, Object.assign({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.a6\n        })));\n      }\n    }\n    let Ge,\n      He,\n      qe,\n      Ze,\n      We = class extends e.E {\n        constructor(t, i, o, s) {\n          super();\n          const r = Ge || (Ge = new e.a9({\n            density: new e.aa(e.a6.snow.density),\n            intensity: new e.aa(e.a6.snow.intensity),\n            color: new e.aa(e.a6.snow.color),\n            opacity: new e.aa(e.a6.snow.opacity),\n            vignette: new e.aa(e.a6.snow.vignette),\n            \"vignette-color\": new e.aa(e.a6.snow[\"vignette-color\"]),\n            \"center-thinning\": new e.aa(e.a6.snow[\"center-thinning\"]),\n            direction: new e.aa(e.a6.snow.direction),\n            \"flake-size\": new e.aa(e.a6.snow[\"flake-size\"])\n          }));\n          this._transitionable = new e.a8(r, o, new Map(s)), this.set(t, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r), this.scope = o;\n        }\n        get state() {\n          const t = this.properties.get(\"opacity\"),\n            i = this.properties.get(\"color\"),\n            o = this.properties.get(\"direction\"),\n            s = e.an(o[0]),\n            r = -Math.max(e.an(o[1]), .01),\n            n = [Math.cos(s) * Math.cos(r), Math.sin(s) * Math.cos(r), Math.sin(r)],\n            a = this.properties.get(\"vignette\"),\n            l = this.properties.get(\"vignette-color\");\n          return l.a = a, {\n            density: this.properties.get(\"density\"),\n            intensity: this.properties.get(\"intensity\"),\n            color: new e.ao(i.r, i.g, i.b, i.a * t),\n            direction: n,\n            centerThinning: this.properties.get(\"center-thinning\"),\n            flakeSize: this.properties.get(\"flake-size\"),\n            vignetteColor: l\n          };\n        }\n        get() {\n          return this._transitionable.serialize();\n        }\n        set(t, i) {\n          let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          if (this._validate(Te, t, o)) return;\n          const s = Object.assign({}, t);\n          for (const t of Object.keys(e.a6.snow)) void 0 === s[t] && (s[t] = e.a6.snow[t].default);\n          this._options = s, this._transitionable.setTransitionOrValue(this._options, i);\n        }\n        updateConfig(e) {\n          this._transitionable.setTransitionOrValue(this._options, new Map(e));\n        }\n        updateTransitions(e) {\n          this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n        }\n        hasTransition() {\n          return this._transitioning.hasTransition();\n        }\n        recalculate(e) {\n          this.properties = this._transitioning.possiblyEvaluate(e);\n        }\n        _validate(t, i, o) {\n          return (!o || !1 !== o.validate) && Le(this, t.call(ge, Object.assign({\n            value: i,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            },\n            styleSpec: e.a6\n          })));\n        }\n      },\n      $e = class extends e.E {\n        constructor(t, i, o, s) {\n          super();\n          const r = He || (He = new e.a9({\n            density: new e.aa(e.a6.rain.density),\n            intensity: new e.aa(e.a6.rain.intensity),\n            color: new e.aa(e.a6.rain.color),\n            opacity: new e.aa(e.a6.rain.opacity),\n            vignette: new e.aa(e.a6.rain.vignette),\n            \"vignette-color\": new e.aa(e.a6.rain[\"vignette-color\"]),\n            \"center-thinning\": new e.aa(e.a6.rain[\"center-thinning\"]),\n            direction: new e.aa(e.a6.rain.direction),\n            \"droplet-size\": new e.aa(e.a6.rain[\"droplet-size\"]),\n            \"distortion-strength\": new e.aa(e.a6.rain[\"distortion-strength\"])\n          }));\n          this._transitionable = new e.a8(r, o, new Map(s)), this.set(t, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ai(r), this.scope = o;\n        }\n        get state() {\n          const t = this.properties.get(\"opacity\"),\n            i = this.properties.get(\"color\"),\n            o = this.properties.get(\"direction\"),\n            s = e.an(o[0]),\n            r = -Math.max(e.an(o[1]), .01),\n            n = [Math.cos(s) * Math.cos(r), Math.sin(s) * Math.cos(r), Math.sin(r)],\n            a = this.properties.get(\"vignette-color\");\n          return a.a = this.properties.get(\"vignette\"), {\n            density: this.properties.get(\"density\"),\n            intensity: this.properties.get(\"intensity\"),\n            color: new e.ao(i.r, i.g, i.b, i.a * t),\n            direction: n,\n            centerThinning: this.properties.get(\"center-thinning\"),\n            dropletSize: this.properties.get(\"droplet-size\"),\n            distortionStrength: this.properties.get(\"distortion-strength\"),\n            vignetteColor: a\n          };\n        }\n        get() {\n          return this._transitionable.serialize();\n        }\n        set(t, i) {\n          let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          if (this._validate(Ee, t, o)) return;\n          const s = Object.assign({}, t);\n          for (const t of Object.keys(e.a6.rain)) void 0 === s[t] && (s[t] = e.a6.rain[t].default);\n          this._options = s, this._transitionable.setTransitionOrValue(this._options, i);\n        }\n        updateConfig(e) {\n          this._transitionable.setTransitionOrValue(this._options, new Map(e));\n        }\n        updateTransitions(e) {\n          this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n        }\n        hasTransition() {\n          return this._transitioning.hasTransition();\n        }\n        recalculate(e) {\n          this.properties = this._transitioning.possiblyEvaluate(e);\n        }\n        _validate(t, i, o) {\n          return (!o || !1 !== o.validate) && Le(this, t.call(ge, Object.assign({\n            value: i,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            },\n            styleSpec: e.a6\n          })));\n        }\n      };\n    class Xe extends e.E {\n      constructor(t, i, o, s) {\n        super(), this.scope = o, this._options = t, this.properties = new e.ai(i), this._transitionable = new e.a8(i, o, new Map(s)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();\n      }\n      updateConfig(e) {\n        this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      get() {\n        return this._options.properties = this._transitionable.serialize(), this._options;\n      }\n      set(e, t) {\n        this._options = e, this._transitionable.setTransitionOrValue(e.properties, t);\n      }\n      shadowsEnabled() {\n        return !!this.properties && !0 === this.properties.get(\"cast-shadows\");\n      }\n    }\n    class Ye {\n      constructor(e, t, i) {\n        this.screenBounds = e, this.cameraPoint = i.getCameraPoint(), this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = t, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, i);\n      }\n      static createFromScreenPoints(t, i) {\n        let o, s;\n        if (t instanceof e.P || \"number\" == typeof t[0]) {\n          const r = e.P.convert(t);\n          o = [r], s = i.isPointAboveHorizon(r);\n        } else {\n          const r = e.P.convert(t[0]),\n            n = e.P.convert(t[1]),\n            a = r.add(n)._div(2);\n          o = [r, n], s = e.aq(r, n).every(e => i.isPointAboveHorizon(e)) && i.isPointAboveHorizon(a);\n        }\n        return new Ye(o, s, i);\n      }\n      isPointQuery() {\n        return 1 === this.screenBounds.length;\n      }\n      bufferedScreenGeometry(t) {\n        return e.aq(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);\n      }\n      bufferedCameraGeometry(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1],\n          s = e.aq(i, o, 0, !1);\n        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? s.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? s[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (s[3] = this.cameraPoint)), e.ar(s, t);\n      }\n      bufferedCameraGeometryGlobe(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1],\n          s = e.aq(i, o, t),\n          r = this.cameraPoint.clone();\n        switch (3 * ((r.y > i.y) + (r.y > o.y)) + ((r.x > i.x) + (r.x > o.x))) {\n          case 0:\n            s[0] = r, s[4] = r.clone();\n            break;\n          case 1:\n            s.splice(1, 0, r);\n            break;\n          case 2:\n            s[1] = r;\n            break;\n          case 3:\n            s.splice(4, 0, r);\n            break;\n          case 5:\n            s.splice(2, 0, r);\n            break;\n          case 6:\n            s[3] = r;\n            break;\n          case 7:\n            s.splice(3, 0, r);\n            break;\n          case 8:\n            s[2] = r;\n        }\n        return s;\n      }\n      containsTile(t, i, o) {\n        let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        const r = t.queryPadding / i._pixelsPerMercatorPixel + 1,\n          n = o ? this._bufferedCameraMercator(r, i) : this._bufferedScreenMercator(r, i);\n        let a = t.tileID.wrap + (n.unwrapped ? s : 0);\n        const l = n.polygon.map(i => e.as(t.tileTransform, i, a));\n        if (!e.at(l, 0, 0, e.al, e.al)) return;\n        a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s : 0);\n        const c = this.screenGeometryMercator.polygon.map(i => e.au(t.tileTransform, i, a)),\n          h = c.map(t => new e.P(t[0], t[1])),\n          d = i.getFreeCameraOptions().position || new e.ae(0, 0, 0),\n          u = e.au(t.tileTransform, d, a),\n          _ = c.map(t => {\n            const i = e.av(t, t, u);\n            return e.aw(i, i), new e.ax(u, i);\n          }),\n          p = e.ay(t, 1, i.zoom) * i._pixelsPerMercatorPixel;\n        return {\n          queryGeometry: this,\n          tilespaceGeometry: h,\n          tilespaceRays: _,\n          bufferedTilespaceGeometry: l,\n          bufferedTilespaceBounds: (f = e.az(l), f.min.x = e.aA(f.min.x, 0, e.al), f.min.y = e.aA(f.min.y, 0, e.al), f.max.x = e.aA(f.max.x, 0, e.al), f.max.y = e.aA(f.max.y, 0, e.al), f),\n          tile: t,\n          tileID: t.tileID,\n          pixelToTileUnitsFactor: p\n        };\n        var f;\n      }\n      _bufferedScreenMercator(e, t) {\n        const i = Qe(e);\n        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : {\n            polygon: this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._screenRaycastCache[i] = o, o;\n        }\n      }\n      _bufferedCameraMercator(e, t) {\n        const i = Qe(e);\n        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : {\n            polygon: this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._cameraRaycastCache[i] = o, o;\n        }\n      }\n      _projectAndResample(t, i) {\n        const o = function (t, i) {\n          const o = e.aB([], i.pixelMatrix, i.globeMatrix),\n            s = [0, -e.aD, 0, 1],\n            r = [0, e.aD, 0, 1],\n            n = [0, 0, 0, 1];\n          e.aC(s, s, o), e.aC(r, r, o), e.aC(n, n, o);\n          const a = new e.P(s[0] / s[3], s[1] / s[3]),\n            l = new e.P(r[0] / r[3], r[1] / r[3]),\n            c = e.aE(t, a) && s[3] < n[3],\n            h = e.aE(t, l) && r[3] < n[3];\n          if (!c && !h) return null;\n          const d = function (e, t, i) {\n            for (let o = 1; o < e.length; o++) {\n              const s = Je(t.pointCoordinate3D(e[o - 1]).x),\n                r = Je(t.pointCoordinate3D(e[o]).x);\n              if (i < 0) {\n                if (s < r) return {\n                  idx: o,\n                  t: -s / (r - 1 - s)\n                };\n              } else if (r < s) return {\n                idx: o,\n                t: (1 - s) / (r + 1 - s)\n              };\n            }\n            return null;\n          }(t, i, c ? -1 : 1);\n          if (!d) return null;\n          const {\n            idx: u,\n            t: _\n          } = d;\n          let p = u > 1 ? Ke(t.slice(0, u), i) : [],\n            f = u < t.length ? Ke(t.slice(u), i) : [];\n          p = p.map(t => new e.P(Je(t.x), t.y)), f = f.map(t => new e.P(Je(t.x), t.y));\n          const m = [...p];\n          0 === m.length && m.push(f[f.length - 1]);\n          const g = e.ak(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, _);\n          let v;\n          return v = c ? [new e.P(0, g), new e.P(0, 0), new e.P(1, 0), new e.P(1, g)] : [new e.P(1, g), new e.P(1, 1), new e.P(0, 1), new e.P(0, g)], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {\n            polygon: m.map(t => new e.ae(t.x, t.y)),\n            unwrapped: !1\n          };\n        }(t, i);\n        if (o) return o;\n        const s = function (t, i) {\n          let o = !1,\n            s = -1 / 0,\n            r = 0;\n          for (let e = 0; e < t.length - 1; e++) t[e].x > s && (s = t[e].x, r = e);\n          for (let e = 0; e < t.length - 1; e++) {\n            const i = (r + e) % (t.length - 1),\n              s = t[i],\n              n = t[i + 1];\n            Math.abs(s.x - n.x) > .5 && (s.x < n.x ? (s.x += 1, 0 === i && (t[t.length - 1].x += 1)) : (n.x += 1, i + 1 === t.length - 1 && (t[0].x += 1)), o = !0);\n          }\n          const n = e.aF(i.center.lng);\n          return o && n < Math.abs(n - 1) && t.forEach(e => {\n            e.x -= 1;\n          }), {\n            polygon: t,\n            unwrapped: o\n          };\n        }(Ke(t, i).map(t => new e.P(Je(t.x), t.y)), i);\n        return {\n          polygon: s.polygon.map(t => new e.ae(t.x, t.y)),\n          unwrapped: s.unwrapped\n        };\n      }\n    }\n    function Ke(t, i) {\n      return e.aG(t, e => {\n        const t = i.pointCoordinate3D(e);\n        e.x = t.x, e.y = t.y;\n      }, 1 / 256);\n    }\n    function Je(e) {\n      return e < 0 ? 1 + e % 1 : e % 1;\n    }\n    function Qe(e) {\n      return 100 * e | 0;\n    }\n    function et(t, i, o, s, r) {\n      const n = function (o, s) {\n          if (o) return r(o);\n          if (s) {\n            if (t.url && s.tiles && t.tiles && delete t.tiles, s.variants) {\n              if (!Array.isArray(s.variants)) return r(new Error(\"variants must be an array\"));\n              for (const e of s.variants) {\n                if (null == e || \"object\" != typeof e || e.constructor !== Object) return r(new Error(\"variant must be an object\"));\n                if (!Array.isArray(e.capabilities)) return r(new Error(\"capabilities must be an array\"));\n                if (1 === e.capabilities.length && \"meshopt\" === e.capabilities[0]) {\n                  s = Object.assign(s, e);\n                  break;\n                }\n              }\n            }\n            const o = e.aH(Object.assign({}, s, t), [\"tilejson\", \"tiles\", \"minzoom\", \"maxzoom\", \"attribution\", \"mapbox_logo\", \"bounds\", \"extra_bounds\", \"scheme\", \"tileSize\", \"encoding\", \"vector_layers\", \"raster_layers\", \"worldview_options\", \"worldview_default\", \"worldview\"]);\n            o.tiles = i.canonicalizeTileset(o, t.url), r(null, o);\n          }\n        },\n        a = function (e, t, i) {\n          if (!e) return null;\n          if (!t && !i) return e;\n          i = i || e.worldview_default;\n          const o = Object.values(e.language || {});\n          if (0 === o.length) return null;\n          const s = Object.values(e.worldview || {});\n          if (0 === s.length) return null;\n          const r = o.every(e => e === t),\n            n = s.every(e => e === i);\n          return r && n ? e : t in (e.language_options || {}) || i in (e.worldview_options || {}) ? null : e.language_options && e.worldview_options ? e : null;\n        }(t.data, o, s);\n      return a ? e.o.frame(() => n(null, a)) : t.url ? e.m(i.transformRequest(i.normalizeSourceURL(t.url, null, o, s), e.R.Source), n) : e.o.frame(() => {\n        const {\n            data: e\n          } = t,\n          i = _objectWithoutProperties(t, _excluded2);\n        n(null, i);\n      });\n    }\n    function tt(t, i) {\n      const o = Math.pow(2, i.z),\n        s = Math.floor(e.aF(t.getWest()) * o),\n        r = Math.floor(e.aJ(t.getNorth()) * o),\n        n = Math.ceil(e.aF(t.getEast()) * o),\n        a = Math.ceil(e.aJ(t.getSouth()) * o);\n      return i.x >= s && i.x < n && i.y >= r && i.y < a;\n    }\n    class it {\n      constructor(t, i, o) {\n        this.bounds = t ? e.aI.convert(this.validateBounds(t)) : null, this.minzoom = i || 0, this.maxzoom = o || 24;\n      }\n      validateBounds(e) {\n        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];\n      }\n      addExtraBounds(t) {\n        if (t) {\n          this.extraBounds || (this.extraBounds = []);\n          for (const i of t) this.extraBounds.push(e.aI.convert(this.validateBounds(i)));\n        }\n      }\n      contains(e) {\n        if (e.z > this.maxzoom || e.z < this.minzoom) return !1;\n        if (this.bounds && !tt(this.bounds, e)) return !1;\n        if (!this.extraBounds) return !0;\n        for (const t of this.extraBounds) if (tt(t, e)) return !0;\n        return !1;\n      }\n      static fromTileJSON(e) {\n        if (!e.bounds && !e.extra_bounds) return null;\n        const t = new it(e.bounds, e.minzoom, e.maxzoom);\n        return t.addExtraBounds(e.extra_bounds), t;\n      }\n    }\n    class ot extends e.E {\n      constructor(t, i, o, s) {\n        if (super(), this.id = t, this.dispatcher = o, this.type = \"vector\", this.minzoom = 0, this.maxzoom = 22, this.scheme = \"xyz\", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, Object.assign(this, e.aH(i, [\"url\", \"scheme\", \"tileSize\", \"promoteId\"])), this._options = Object.assign({\n          type: \"vector\"\n        }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error(\"vector tile sources must have a tileSize of 512\");\n        this.setEventedParent(s), this._tileWorkers = {}, this._deduped = new e.aK();\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.z(\"dataloading\", {\n          dataType: \"source\"\n        }));\n        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n          o = this.map.getWorldview();\n        this._tileJSONRequest = et(this._options, this.map._requestManager, i, o, (s, r) => {\n          if (this._tileJSONRequest = null, this._loaded = !0, s) i && console.warn(\"Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: \".concat(i)), o && console.warn(\"Requested worldview strings must be a valid ISO alpha-2 code. Found: \".concat(o)), this.fire(new e.y(s));else if (r) {\n            if (Object.assign(this, r), this.hasWorldviews = !!r.worldview_options, r.worldview_default && (this.worldviewDefault = r.worldview_default), r.vector_layers) {\n              this.vectorLayers = r.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set();\n              for (const e of r.vector_layers) this.vectorLayerIds.push(e.id), r.worldview && r.worldview[e.source] && this.localizableLayerIds.add(e.id);\n            }\n            this.tileBounds = it.fromTileJSON(r), L(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.z(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n          t && t(s);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest();\n        const t = e.B(this.id, this.scope);\n        this.load(() => this.map.style.clearSource(t));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove(e) {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return Object.assign({}, this._options);\n      }\n      loadTile(t, i) {\n        const o = t.tileID.canonical.url(this.tiles, this.scheme),\n          s = this.map._requestManager.normalizeTileURL(o),\n          r = this.map._requestManager.transformRequest(s, e.R.Tile),\n          n = this.map.style ? this.map.style.getLut(this.scope) : null,\n          a = n ? {\n            image: n.image.clone()\n          } : null,\n          l = {\n            request: r,\n            data: void 0,\n            uid: t.uid,\n            tileID: t.tileID,\n            tileZoom: t.tileZoom,\n            zoom: t.tileID.overscaledZ,\n            maxZoom: this.maxzoom,\n            lut: a,\n            tileSize: this.tileSize * t.tileID.overscaleFactor(),\n            type: this.type,\n            source: this.id,\n            scope: this.scope,\n            pixelRatio: e.o.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId,\n            isSymbolTile: t.isSymbolTile,\n            brightness: this.map.style && this.map.style.getBrightness() || 0,\n            extraShadowCaster: t.isExtraShadowCaster,\n            tessellationStep: this.map._tessellationStep,\n            scaleFactor: this.map.getScaleFactor(),\n            worldview: this.map.getWorldview() || this.worldviewDefault\n          };\n        if (this.hasWorldviews && e.h(o) && (l.localizableLayerIds = this.localizableLayerIds), l.request.collectResourceTiming = this._collectResourceTiming, t.actor && \"expired\" !== t.state) \"loading\" === t.state ? t.reloadCallback = i : t.request = t.actor.send(\"reloadTile\", l, c.bind(this));else if (t.actor = this._tileWorkers[s] = this._tileWorkers[s] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send(\"loadTile\", l, c.bind(this), void 0, !0);else {\n          const i = e.aL.call({\n            deduped: this._deduped\n          }, l, (e, i) => {\n            e || !i ? c.call(this, e) : (l.data = {\n              cacheControl: i.cacheControl,\n              expires: i.expires,\n              rawData: i.rawData.slice(0)\n            }, t.actor && t.actor.send(\"loadTile\", l, c.bind(this), void 0, !0));\n          }, !0);\n          t.request = {\n            cancel: i\n          };\n        }\n        function c(o, s) {\n          return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming), this.map._refreshExpiredTiles && s && t.setExpiryData(s), t.loadVectorData(s, this.map.painter), e.aM(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));\n        }\n      }\n      abortTile(e) {\n        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        });\n      }\n      unloadTile(e, t) {\n        e.actor && e.actor.send(\"removeTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        }), e.destroy();\n      }\n      hasTransition() {\n        return !1;\n      }\n      afterUpdate() {\n        this._tileWorkers = {};\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    class st extends e.E {\n      constructor(t, i, o, s) {\n        super(), this.id = t, this.dispatcher = o, this.setEventedParent(s), this.type = \"raster\", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = \"xyz\", this.tileSize = 512, this._loaded = !1, this._options = Object.assign({\n          type: \"raster\"\n        }, i), Object.assign(this, e.aH(i, [\"url\", \"scheme\", \"tileSize\"]));\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.z(\"dataloading\", {\n          dataType: \"source\"\n        }));\n        const i = this.map.getWorldview();\n        this._tileJSONRequest = et(this._options, this.map._requestManager, null, i, (i, o) => {\n          this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.y(i)) : o && (Object.assign(this, o), o.raster_layers && (this.rasterLayers = o.raster_layers, this.rasterLayerIds = this.rasterLayers.map(e => e.id)), this.tileBounds = it.fromTileJSON(o), L(o.tiles), this.fire(new e.z(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.z(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }))), t && t(i);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest();\n        const t = e.B(this.id, this.scope);\n        this.load(() => this.map.style.clearSource(t));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove(e) {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return Object.assign({}, this._options);\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      loadTile(t, i) {\n        const o = e.o.devicePixelRatio >= 2,\n          s = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);\n        t.request = e.n(this.map._requestManager.transformRequest(s, e.R.Tile), (o, s, r, n) => (delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : o ? (t.state = \"errored\", i(o)) : s ? (this.map._refreshExpiredTiles && t.setExpiryData({\n          cacheControl: r,\n          expires: n\n        }), t.setTexture(s, this.map.painter), t.state = \"loaded\", e.aM(this.dispatcher), void i(null)) : i(null)));\n      }\n      abortTile(e, t) {\n        e.request && (e.request.cancel(), delete e.request), t && t();\n      }\n      unloadTile(t, i) {\n        t.texture && t.texture instanceof e.T ? (t.destroy(!0), t.texture && t.texture instanceof e.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), i && i();\n      }\n      hasTransition() {\n        return !1;\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    function rt(_ref84, o, s) {\n      let [t, i] = _ref84;\n      let {\n        scaled: r = !0\n      } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      const {\n          tileSize: n,\n          buffer: a\n        } = s,\n        {\n          x: l,\n          y: c,\n          z: h\n        } = o;\n      if (!isFinite(l) || !isFinite(c) || !isFinite(h)) throw new Error(\"Invalid MRT header\");\n      const d = 2 ** h,\n        u = d * e.aF(t),\n        _ = d * e.aJ(i);\n      return function (_ref85, i) {\n        let [e, t] = _ref85;\n        let {\n          scaled: o = !0\n        } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!i) throw new Error(\"bandView is undefined\");\n        const {\n          data: s,\n          tileSize: r,\n          buffer: n,\n          offset: a,\n          scale: l,\n          dimension: c\n        } = i;\n        if (e < -n || e > r + n || t < -n || t > r + n) throw new Error(\"Point (\".concat(e, \", \").concat(t, \") out of bounds for tileSize=\").concat(r, \", buffer=\").concat(n));\n        const h = (t + n) * (r + 2 * n) + (e + n);\n        if (4294967295 === new Uint32Array(s.buffer)[h]) return null;\n        let d = [];\n        d = o ? [] : new (0, i.data.constructor)(c);\n        for (let e = 0; e < c; e++) d[e] = Math.round(1e12 * (s[c * h + e] * l + a)) / 1e12;\n        return d;\n      }([Math.min(Math.max(-a, Math.floor((u - l) * n)), n - 1 + a), Math.min(Math.max(-a, Math.floor((_ - c) * n)), n - 1 + a)], s, {\n        scaled: r\n      });\n    }\n    class nt extends st {\n      constructor(e, t, i, o) {\n        super(e, t, i, o), this.type = \"raster-array\", this.maxzoom = 22, this.partial = !0, this._loadTilePending = {}, this._loadTileLoaded = {}, this._options = Object.assign({\n          type: \"raster-array\"\n        }, t);\n      }\n      triggerRepaint(e) {\n        const t = this.map.painter._terrain,\n          i = this.map.style.getSourceCache(this.id);\n        t && t.enabled && i && t._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();\n      }\n      loadTile(t, i) {\n        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize),\n          s = this.map._requestManager.transformRequest(o, e.R.Tile),\n          r = {\n            request: s,\n            uid: t.uid,\n            tileID: t.tileID,\n            type: this.type,\n            source: this.id,\n            scope: this.scope,\n            partial: this.partial\n          };\n        t.source = this.id, t.scope = this.scope, t.requestParams = s, t.actor || (t.actor = this.dispatcher.getActor());\n        const n = (e, o, s, r) => {\n          if (delete t.request, t.aborted) return t.state = \"unloaded\", i(null);\n          if (e) {\n            if (\"AbortError\" === e.name) return;\n            return t.state = \"errored\", i(e);\n          }\n          if (this.map._refreshExpiredTiles && o && t.setExpiryData({\n            cacheControl: s,\n            expires: r\n          }), this.partial && \"expired\" !== t.state) t.state = \"empty\";else if (!this.partial) {\n            if (!o) return i(null);\n            t.state = \"loaded\", t._isHeaderLoaded = !0, t._mrt = o;\n          }\n          i(null);\n        };\n        t.request = this.partial ? t.fetchHeader(void 0, n.bind(this)) : t.actor.send(\"loadTile\", r, n.bind(this), void 0, !0);\n      }\n      abortTile(e) {\n        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        });\n      }\n      unloadTile(e, t) {\n        const i = e.texturePerLayer;\n        if (e.flushAllQueues(), i.size) {\n          e.destroy(!0);\n          for (const e of i.values()) this.map.painter.saveTileTexture(e);\n        } else e.destroy();\n      }\n      prepareTile(t, i, o, s) {\n        t._isHeaderLoaded && (\"empty\" !== t.state && (t.state = \"reloading\"), t.fetchBandForRender(i, o, s, (i, s) => {\n          if (i) return t.state = \"errored\", this.fire(new e.y(i)), void this.triggerRepaint(t);\n          s && (t._isHeaderLoaded = !0, t.setTexturePerLayer(o, s, this.map.painter), t.state = \"loaded\", this.triggerRepaint(t));\n        }));\n      }\n      getInitialBand(e) {\n        if (!this.rasterLayers) return 0;\n        const t = this.rasterLayers.find(_ref86 => {\n            let {\n              id: t\n            } = _ref86;\n            return t === e;\n          }),\n          i = t && t.fields,\n          o = i && i.bands && i.bands;\n        return o ? o[0] : 0;\n      }\n      getTextureDescriptor(t, i, o) {\n        if (!t) return;\n        const s = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];\n        if (!s) return;\n        let r = null;\n        i instanceof e.aP ? r = i.paint.get(\"raster-array-band\") : i instanceof e.aQ && (r = i.paint.get(\"raster-particle-array-band\"));\n        const n = r || this.getInitialBand(s);\n        if (null == n) return;\n        if (!t.textureDescriptorPerLayer.get(i.id)) return void this.prepareTile(t, s, i.id, n);\n        if (t.updateNeeded(i.id, n) && !o) return;\n        const a = t.textureDescriptorPerLayer.get(i.id);\n        return Object.assign({}, a, {\n          texture: t.texturePerLayer.get(i.id)\n        });\n      }\n      getImages(t, i) {\n        const o = new Map();\n        for (const s of t) for (const t of i) {\n          const [i, r] = t.split(\"/\"),\n            n = s.getLayer(i);\n          if (!n) continue;\n          if (!n.hasBand(r) || !n.hasDataForBand(r)) continue;\n          const {\n              bytes: a,\n              tileSize: l,\n              buffer: c\n            } = n.getBandView(r),\n            h = l + 2 * c,\n            d = {\n              data: new e.q({\n                width: h,\n                height: h\n              }, a),\n              pixelRatio: 2,\n              sdf: !1,\n              usvg: !1,\n              version: 0\n            };\n          o.set(t, d);\n        }\n        return o;\n      }\n      queryRasterArrayValueByBandId(t, i, o) {\n        const s = i._mrt;\n        return new Promise(r => {\n          const n = {},\n            a = new Set();\n          for (const [l, c] of Object.entries(s.layers)) {\n            if (o.layerName && l !== o.layerName) continue;\n            const h = {};\n            n[l] = h;\n            for (const {\n              bands: d\n            } of c.dataIndex) for (const u of d) o.bands && !o.bands.includes(u) || (a.add(e.B(l, u)), i.fetchBand(l, null, u, i => {\n              e.o.frame(() => {\n                h[u] = i ? null : rt([t.lng, t.lat], s, c.getBandView(u)), a.delete(e.B(l, u)), 0 === a.size && r(n);\n              });\n            }, !1));\n          }\n          0 === a.size && r(n);\n        });\n      }\n      _loadTileForQuery(t, i) {\n        if (this._loadTileLoaded[t.uid]) return void i(null, t._mrt);\n        if (this._loadTilePending[t.uid]) return void this._loadTilePending[t.uid].push(i);\n        this._loadTilePending[t.uid] = [i];\n        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize),\n          s = this.map._requestManager.transformRequest(o, e.R.Tile);\n        t.actor.send(\"loadTile\", {\n          request: s,\n          uid: t.uid,\n          tileID: t.tileID,\n          type: this.type,\n          source: this.id,\n          scope: this.scope,\n          partial: !1\n        }, (e, i, o, s) => e ? (this._loadTilePending[t.uid].forEach(t => t(e, null)), void delete this._loadTilePending[t.uid]) : i ? (this.map._refreshExpiredTiles && i && t.setExpiryData({\n          cacheControl: o,\n          expires: s\n        }), t._mrt = i, t._isHeaderLoaded = !0, t.state = \"loaded\", this._loadTilePending[t.uid].forEach(e => e(null, i)), this._loadTileLoaded[t.uid] = !0, void delete this._loadTilePending[t.uid]) : (this._loadTilePending[t.uid].forEach(e => e(null, null)), void delete this._loadTilePending[t.uid]), void 0, !0);\n      }\n      queryRasterArrayValueByAllBands(e, t, i) {\n        return new Promise((o, s) => {\n          this._loadTileForQuery(t, (r, n) => {\n            r ? s(r) : o(n ? this.queryRasterArrayValueByBandId(e, t, i) : null);\n          });\n        });\n      }\n      queryRasterArrayValue(t, i) {\n        const o = e.aR.convert(t),\n          s = this.findLoadedParent(o);\n        return s && s._mrt ? i.bands || !this.partial ? this.queryRasterArrayValueByBandId(o, s, i) : this.queryRasterArrayValueByAllBands(o, s, i) : Promise.resolve(null);\n      }\n      findLoadedParent(t) {\n        const i = e.ae.fromLngLat(t, this.map.transform.tileSize),\n          o = this.maxzoom + 1,\n          s = 1 << o,\n          r = Math.floor(i.x),\n          n = Math.floor((i.x - r) * s),\n          a = Math.floor(i.y * s),\n          l = this.map.style.getSourceCache(this.id),\n          c = new e.aO(o, r, o, n, a);\n        return l.findLoadedParent(c, this.minzoom);\n      }\n    }\n    const at = {\n        vector: ot,\n        raster: st,\n        \"raster-dem\": class extends st {\n          constructor(e, t, i, o) {\n            super(e, t, i, o), this.type = \"raster-dem\", this.maxzoom = 22, this._options = Object.assign({\n              type: \"raster-dem\"\n            }, t), this.encoding = t.encoding || \"mapbox\";\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);\n            function s(e, o) {\n              e && (t.state = \"errored\", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = \"loaded\", i(null));\n            }\n            t.request = e.n(this.map._requestManager.transformRequest(o, e.R.Tile), function (o, r, n, a) {\n              if (delete t.request, t.aborted) t.state = \"unloaded\", i(null);else if (o) t.state = \"errored\", i(o);else if (r) {\n                this.map._refreshExpiredTiles && t.setExpiryData({\n                  cacheControl: n,\n                  expires: a\n                });\n                const i = ImageBitmap && r instanceof ImageBitmap && e.r(),\n                  o = 1 - (r.width - e.aN(r.width)) / 2;\n                o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));\n                const l = i ? r : e.o.getImageData(r, o),\n                  c = {\n                    uid: t.uid,\n                    tileID: t.tileID,\n                    source: this.id,\n                    type: this.type,\n                    scope: this.scope,\n                    rawImageData: l,\n                    encoding: this.encoding,\n                    padding: o\n                  };\n                t.actor && \"expired\" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send(\"loadTile\", c, s.bind(this), void 0, !0));\n              }\n            }.bind(this));\n          }\n          _getNeighboringTiles(t) {\n            const i = t.canonical,\n              o = Math.pow(2, i.z),\n              s = (i.x - 1 + o) % o,\n              r = 0 === i.x ? t.wrap - 1 : t.wrap,\n              n = (i.x + 1 + o) % o,\n              a = i.x + 1 === o ? t.wrap + 1 : t.wrap,\n              l = {};\n            return l[new e.aO(t.overscaledZ, r, i.z, s, i.y).key] = {\n              backfilled: !1\n            }, l[new e.aO(t.overscaledZ, a, i.z, n, i.y).key] = {\n              backfilled: !1\n            }, i.y > 0 && (l[new e.aO(t.overscaledZ, r, i.z, s, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.aO(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.aO(t.overscaledZ, a, i.z, n, i.y - 1).key] = {\n              backfilled: !1\n            }), i.y + 1 < o && (l[new e.aO(t.overscaledZ, r, i.z, s, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.aO(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.aO(t.overscaledZ, a, i.z, n, i.y + 1).key] = {\n              backfilled: !1\n            }), l;\n          }\n        },\n        \"raster-array\": nt,\n        geojson: class extends e.E {\n          constructor(t, i, o, s) {\n            super(), this.id = t, this.type = \"geojson\", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(s), this._data = i.data, this._options = Object.assign({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), void 0 !== i.minzoom && (this.minzoom = i.minzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;\n            const r = e.al / this.tileSize;\n            this.workerOptions = Object.assign({\n              source: this.id,\n              scope: this.scope,\n              cluster: i.cluster || !1,\n              geojsonVtOptions: {\n                buffer: (void 0 !== i.buffer ? i.buffer : 128) * r,\n                tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * r,\n                extent: e.al,\n                maxZoom: this.maxzoom,\n                lineMetrics: i.lineMetrics || !1,\n                generateId: i.generateId || !1\n              },\n              superclusterOptions: {\n                maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,\n                minPoints: Math.max(2, i.clusterMinPoints || 2),\n                extent: e.al,\n                radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * r,\n                log: !1,\n                generateId: i.generateId || !1\n              },\n              clusterProperties: i.clusterProperties,\n              filter: i.filter,\n              dynamic: i.dynamic\n            }, i.workerOptions);\n          }\n          onAdd(e) {\n            this.map = e, this.setData(this._data);\n          }\n          setData(e) {\n            return this._data = e, this._updateWorkerData(), this;\n          }\n          updateData(t) {\n            if (!this._options.dynamic) return this.fire(new e.y(new Error(\"Can't call updateData on a GeoJSON source with dynamic set to false.\")));\n            if (\"string\" != typeof t && (\"Feature\" === t.type && (t = {\n              type: \"FeatureCollection\",\n              features: [t]\n            }), \"FeatureCollection\" !== t.type)) return this.fire(new e.y(new Error(\"Data to update should be a feature or a feature collection.\")));\n            if (this._coalesce && \"string\" != typeof t && \"string\" != typeof this._data && \"FeatureCollection\" === this._data.type) {\n              const e = new Map();\n              for (const t of this._data.features) e.set(t.id, t);\n              for (const i of t.features) e.set(i.id, i);\n              this._data.features = [...e.values()];\n            } else this._data = t;\n            return this._updateWorkerData(!0), this;\n          }\n          getClusterExpansionZoom(e, t) {\n            return this.actor.send(\"geojson.getClusterExpansionZoom\", {\n              clusterId: e,\n              source: this.id,\n              scope: this.scope\n            }, t), this;\n          }\n          getClusterChildren(e, t) {\n            return this.actor.send(\"geojson.getClusterChildren\", {\n              clusterId: e,\n              source: this.id,\n              scope: this.scope\n            }, t), this;\n          }\n          getClusterLeaves(e, t, i, o) {\n            return this.actor.send(\"geojson.getClusterLeaves\", {\n              source: this.id,\n              scope: this.scope,\n              clusterId: e,\n              limit: t,\n              offset: i\n            }, o), this;\n          }\n          _updateWorkerData() {\n            let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n            if (this._pendingLoad) return void (this._coalesce = !0);\n            this.fire(new e.z(\"dataloading\", {\n              dataType: \"source\"\n            })), this._loaded = !1;\n            const i = Object.assign({\n              append: t\n            }, this.workerOptions);\n            i.scope = this.scope;\n            const o = this._data;\n            \"string\" == typeof o ? (i.request = this.map._requestManager.transformRequest(e.o.resolveURL(o), e.R.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoad = this.actor.send(\"\".concat(this.type, \".loadData\"), i, (i, o) => {\n              if (this._loaded = !0, this._pendingLoad = null, i) this.fire(new e.y(i));else {\n                const i = {\n                  dataType: \"source\",\n                  sourceDataType: this._metadataFired ? \"content\" : \"metadata\"\n                };\n                this._collectResourceTiming && o && o.resourceTiming && o.resourceTiming[this.id] && (i.resourceTiming = o.resourceTiming[this.id]), t && (this._partialReload = !0), this.fire(new e.z(\"data\", i)), this._partialReload = !1, this._metadataFired = !0;\n              }\n              this._coalesce && (this._updateWorkerData(t), this._coalesce = !1);\n            });\n          }\n          loaded() {\n            return this._loaded;\n          }\n          reload() {\n            const t = e.B(this.id, this.scope);\n            this.map.style.clearSource(t), this._updateWorkerData();\n          }\n          loadTile(t, i) {\n            const o = t.actor ? \"reloadTile\" : \"loadTile\";\n            t.actor = this.actor;\n            const s = this.map.style ? this.map.style.getLut(this.scope) : null,\n              r = s ? {\n                image: s.image.clone()\n              } : null,\n              n = this._partialReload,\n              a = {\n                type: this.type,\n                uid: t.uid,\n                tileID: t.tileID,\n                tileZoom: t.tileZoom,\n                zoom: t.tileID.overscaledZ,\n                maxZoom: this.maxzoom,\n                tileSize: this.tileSize,\n                source: this.id,\n                lut: r,\n                scope: this.scope,\n                pixelRatio: e.o.devicePixelRatio,\n                showCollisionBoxes: this.map.showCollisionBoxes,\n                promoteId: this.promoteId,\n                brightness: this.map.style && this.map.style.getBrightness() || 0,\n                extraShadowCaster: t.isExtraShadowCaster,\n                scaleFactor: this.map.getScaleFactor(),\n                partial: n,\n                worldview: this.map.getWorldview()\n              };\n            t.request = this.actor.send(o, a, (e, s) => n && !s ? (t.state = \"loaded\", i(null)) : (delete t.request, t.destroy(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(s, this.map.painter, \"reloadTile\" === o), i(null))), void 0, \"loadTile\" === o);\n          }\n          abortTile(e) {\n            e.request && (e.request.cancel(), delete e.request), e.aborted = !0;\n          }\n          unloadTile(e, t) {\n            this.actor.send(\"removeTile\", {\n              uid: e.uid,\n              type: this.type,\n              source: this.id,\n              scope: this.scope\n            }), e.destroy();\n          }\n          onRemove(e) {\n            this._pendingLoad && this._pendingLoad.cancel();\n          }\n          serialize() {\n            return Object.assign({}, this._options, {\n              type: this.type,\n              data: this._data\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n        },\n        video: class extends e.aS {\n          constructor(e, t, i, o) {\n            super(e, t, i, o), this.roundZoom = !0, this.type = \"video\", this.options = t;\n          }\n          load() {\n            this._loaded = !1;\n            const t = this.options;\n            this.urls = [];\n            for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);\n            e.aT(this.urls, (t, i) => {\n              this._loaded = !0, t ? this.fire(new e.y(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute(\"playsinline\", \"\"), this.video.addEventListener(\"playing\", () => {\n                this.map.triggerRepaint();\n              }), this.map && this.video.play(), this._finishLoading());\n            });\n          }\n          pause() {\n            this.video && this.video.pause();\n          }\n          play() {\n            this.video && this.video.play();\n          }\n          seek(t) {\n            if (this.video) {\n              const i = this.video.seekable;\n              t < i.start(0) || t > i.end(0) ? this.fire(new e.y(new e.V(\"sources.\".concat(this.id), null, \"Playback for this video can be set only between the \".concat(i.start(0), \" and \").concat(i.end(0), \"-second mark.\")))) : this.video.currentTime = t;\n            }\n          }\n          getVideo() {\n            return this.video;\n          }\n          onAdd(e) {\n            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n          }\n          prepare() {\n            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;\n            const t = this.map.painter.context,\n              i = t.gl;\n            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t, this.video, i.RGBA8), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);\n          }\n          serialize() {\n            return {\n              type: \"video\",\n              urls: this.urls,\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this.video && !this.video.paused;\n          }\n        },\n        image: e.aS,\n        model: class extends e.E {\n          constructor(e, t, i, o) {\n            super(), this.id = e, this.type = \"model\", this.models = [], this._loaded = !1, this._options = t;\n          }\n          load() {\n            const t = [];\n            for (const i in this._options.models) {\n              const o = this._options.models[i],\n                s = e.aV(this.map._requestManager.transformRequest(o.uri, e.R.Model).url).then(t => {\n                  if (!t) return;\n                  const s = e.aW(t),\n                    r = new e.aX(i, o.position, o.orientation, s);\n                  r.computeBoundsAndApplyParent(), this.models.push(r);\n                }).catch(t => {\n                  this.fire(new e.y(new Error(\"Could not load model \".concat(i, \" from \").concat(o.uri, \": \").concat(t.message))));\n                });\n              t.push(s);\n            }\n            Promise.allSettled(t).then(() => {\n              this._loaded = !0, this.fire(new e.z(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"metadata\"\n              }));\n            }).catch(t => {\n              this._loaded = !0, this.fire(new e.y(new Error(\"Could not load models: \".concat(t.message))));\n            });\n          }\n          onAdd(e) {\n            this.map = e, this.load();\n          }\n          hasTransition() {\n            return !1;\n          }\n          loaded() {\n            return this._loaded;\n          }\n          getModels() {\n            return this.models;\n          }\n          loadTile(e, t) {}\n          serialize() {\n            return this._options;\n          }\n        },\n        \"batched-model\": class extends e.E {\n          constructor(e, t, i, o) {\n            super(), this.type = \"batched-model\", this.id = e, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = \"xyz\", this._loaded = !1, this.setEventedParent(o);\n          }\n          onAdd(e) {\n            this.map = e, this.load();\n          }\n          reload() {\n            this.cancelTileJSONRequest();\n            const t = e.B(this.id, this.scope);\n            this.load(() => this.map.style.clearSource(t));\n          }\n          cancelTileJSONRequest() {\n            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n          }\n          load(t) {\n            this._loaded = !1, this.fire(new e.z(\"dataloading\", {\n              dataType: \"source\"\n            }));\n            const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n              o = this.map.getWorldview();\n            this._tileJSONRequest = et(this._options, this.map._requestManager, i, o, (s, r) => {\n              this._tileJSONRequest = null, this._loaded = !0, s ? (i && console.warn(\"Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: \".concat(i)), o && 2 !== o.length && console.warn(\"Requested worldview strings must be a valid ISO alpha-2 code. Found: \".concat(o)), this.fire(new e.y(s))) : r && (Object.assign(this, r), r.bounds && (this.tileBounds = new it(r.bounds, this.minzoom, this.maxzoom)), L(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"metadata\"\n              })), this.fire(new e.z(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"content\"\n              }))), t && t(s);\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n          hasTile(e) {\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loaded() {\n            return this._loaded;\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),\n              s = {\n                request: this.map._requestManager.transformRequest(o, e.R.Tile),\n                data: void 0,\n                uid: t.uid,\n                tileID: t.tileID,\n                tileZoom: t.tileZoom,\n                zoom: t.tileID.overscaledZ,\n                tileSize: this.tileSize * t.tileID.overscaleFactor(),\n                type: this.type,\n                source: this.id,\n                scope: this.scope,\n                showCollisionBoxes: this.map.showCollisionBoxes,\n                isSymbolTile: t.isSymbolTile,\n                brightness: this.map.style && this.map.style.getBrightness() || 0,\n                pixelRatio: e.o.devicePixelRatio,\n                promoteId: this.promoteId\n              };\n            if (t.actor && \"expired\" !== t.state) {\n              if (\"loading\" === t.state) t.reloadCallback = i;else {\n                if (t.buckets) {\n                  const e = Object.values(t.buckets);\n                  for (const t of e) t.dirty = !0;\n                  return void (t.state = \"loaded\");\n                }\n                t.request = t.actor.send(\"reloadTile\", s, r.bind(this));\n              }\n            } else t.actor = this.dispatcher.getActor(), t.request = t.actor.send(\"loadTile\", s, r.bind(this), void 0, !0);\n            function r(e, o) {\n              return t.aborted ? i(null) : e && 404 !== e.status ? i(e) : (this.map._refreshExpiredTiles && o && t.setExpiryData(o), t.loadModelData(o, this.map.painter), t.state = \"loaded\", void i(null));\n            }\n          }\n          serialize() {\n            return Object.assign({}, this._options);\n          }\n        },\n        canvas: class extends e.aS {\n          constructor(t, i, o, s) {\n            super(t, i, o, s), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => \"number\" != typeof e)) || this.fire(new e.y(new e.V(\"sources.\".concat(t), null, '\"coordinates\" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.y(new e.V(\"sources.\".concat(t), null, 'missing required property \"coordinates\"'))), i.animate && \"boolean\" != typeof i.animate && this.fire(new e.y(new e.V(\"sources.\".concat(t), null, 'optional \"animate\" property must be a boolean value'))), i.canvas ? \"string\" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.y(new e.V(\"sources.\".concat(t), null, '\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.y(new e.V(\"sources.\".concat(t), null, 'missing required property \"canvas\"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;\n          }\n          load() {\n            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.y(new Error(\"Canvas dimensions cannot be less than or equal to zero.\"))) : (this.play = function () {\n              this._playing = !0, this.map.triggerRepaint();\n            }, this.pause = function () {\n              this._playing && (this.prepare(), this._playing = !1);\n            }, this._finishLoading());\n          }\n          getCanvas() {\n            return this.canvas;\n          }\n          onAdd(e) {\n            this.map = e, this.load(), this.canvas && this.animate && this.play();\n          }\n          onRemove(e) {\n            this.pause();\n          }\n          prepare() {\n            let t = !1;\n            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;\n            if (0 === Object.keys(this.tiles).length) return;\n            const i = this.map.painter.context;\n            this.texture ? !t && !this._playing || this.texture instanceof e.aU || this.texture.update(this.canvas, {\n              premultiply: !0\n            }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA8, {\n              premultiply: !0\n            }), this._prepareData(i);\n          }\n          serialize() {\n            return {\n              type: \"canvas\",\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this._playing;\n          }\n          _hasInvalidDimensions() {\n            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;\n            return !1;\n          }\n        },\n        custom: class extends e.E {\n          constructor(t, i, o, s) {\n            super(), this.id = t, this.type = \"custom\", this._dataType = \"raster\", this._dispatcher = o, this._implementation = i, this.setEventedParent(s), this.scheme = \"xyz\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.y(new Error(\"Missing implementation for \".concat(this.id, \" custom source\")))), this._implementation.loadTile || this.fire(new e.y(new Error(\"Missing loadTile implementation for \".concat(this.id, \" custom source\")))), this._implementation.bounds && (this.tileBounds = new it(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), Object.assign(this, e.aH(i, [\"dataType\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\", \"minTileCacheSize\", \"maxTileCacheSize\"]));\n          }\n          serialize() {\n            return e.aH(this, [\"type\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\"]);\n          }\n          load() {\n            this._loaded = !0, this.fire(new e.z(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.z(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n          loaded() {\n            return this._loaded;\n          }\n          onAdd(t) {\n            this.map = t, this._loaded = !1, this.fire(new e.z(\"dataloading\", {\n              dataType: \"source\"\n            })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();\n          }\n          onRemove(e) {\n            this._implementation.onRemove && this._implementation.onRemove(e);\n          }\n          hasTile(e) {\n            if (this._implementation.hasTile) {\n              const {\n                x: t,\n                y: i,\n                z: o\n              } = e.canonical;\n              return this._implementation.hasTile({\n                x: t,\n                y: i,\n                z: o\n              });\n            }\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loadTile(e, t) {\n            const {\n                x: i,\n                y: o,\n                z: s\n              } = e.tileID.canonical,\n              r = new AbortController();\n            e.request = Promise.resolve(this._implementation.loadTile({\n              x: i,\n              y: o,\n              z: s\n            }, {\n              signal: r.signal\n            })).then(function (i) {\n              return delete e.request, e.aborted ? (e.state = \"unloaded\", t(null)) : void 0 === i ? (e.state = \"errored\", t(null)) : null === i ? (this.loadTileData(e, {\n                width: this.tileSize,\n                height: this.tileSize,\n                data: null\n              }), e.state = \"loaded\", t(null)) : function (e) {\n                return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;\n              }(i) ? (this.loadTileData(e, i), e.state = \"loaded\", void t(null)) : (e.state = \"errored\", t(new Error(\"Can't infer data type for \".concat(this.id, \", only raster data supported at the moment\"))));\n            }.bind(this)).catch(i => {\n              \"AbortError\" !== i.name && (e.state = \"errored\", t(i));\n            }), e.request.cancel = () => r.abort();\n          }\n          loadTileData(e, t) {\n            e.setTexture(t, this.map.painter);\n          }\n          unloadTile(t, i) {\n            if (t.texture && t.texture instanceof e.T ? (t.destroy(!0), t.texture && t.texture instanceof e.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), this._implementation.unloadTile) {\n              const {\n                x: e,\n                y: i,\n                z: o\n              } = t.tileID.canonical;\n              this._implementation.unloadTile({\n                x: e,\n                y: i,\n                z: o\n              });\n            }\n            i && i();\n          }\n          abortTile(e, t) {\n            e.request && e.request.cancel && (e.request.cancel(), delete e.request), t && t();\n          }\n          hasTransition() {\n            return !1;\n          }\n          _coveringTiles() {\n            return this.map.transform.coveringTiles({\n              tileSize: this.tileSize,\n              minzoom: this.minzoom,\n              maxzoom: this.maxzoom,\n              roundZoom: this.roundZoom\n            }).map(e => ({\n              x: e.canonical.x,\n              y: e.canonical.y,\n              z: e.canonical.z\n            }));\n          }\n          _clearTiles() {\n            const t = e.B(this.id, this.scope);\n            this.map.style.clearSource(t);\n          }\n          _update() {\n            this.fire(new e.z(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n        }\n      },\n      lt = function (t, i, o, s) {\n        const r = new at[i.type](t, i, o, s);\n        if (r.id !== t) throw new Error(\"Expected Source id to be \".concat(t, \" instead of \").concat(r.id));\n        return e.aY([\"load\", \"abort\", \"unload\", \"serialize\", \"prepare\"], r), r;\n      };\n    function ct(e, t) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n      return \"\".concat(i, \":\").concat(t.id || \"\", \":\").concat(t.layer.id, \":\").concat(function (e) {\n        if (\"layerId\" in e) return \"layer:\".concat(e.layerId);\n        {\n          const {\n            featuresetId: t,\n            importId: i\n          } = e;\n          return \"featureset:\".concat(t).concat(i ? \":import:\".concat(i) : \"\");\n        }\n      }(e.target));\n    }\n    function ht(e, t, i) {\n      let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n      if (e.uniqueFeatureID) {\n        const s = ct(e, t, o);\n        if (i.has(s)) return !0;\n        i.add(s);\n      }\n      return !1;\n    }\n    function dt(e, t, i, o) {\n      let s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;\n      const r = t.sourceCache.transform,\n        n = t.sourceCache.tilesIn(e, t.has3DLayers, s);\n      n.sort(pt);\n      const a = [];\n      for (const e of n) {\n        const n = e.tile.queryRenderedFeatures(t, e, i, o, r, s);\n        Object.keys(n).length && a.push({\n          wrappedTileID: e.tile.tileID.wrapped().key,\n          queryResults: n\n        });\n      }\n      return 0 === a.length ? {} : function (e) {\n        const t = {},\n          i = {};\n        for (const o of e) {\n          const e = o.queryResults,\n            s = o.wrappedTileID,\n            r = i[s] = i[s] || {};\n          for (const i in e) {\n            const o = e[i],\n              s = r[i] = r[i] || {},\n              n = t[i] = t[i] || [];\n            for (const e of o) s[e.featureIndex] || (s[e.featureIndex] = !0, n.push(e));\n          }\n        }\n        return t;\n      }(a);\n    }\n    function ut(e, t, i, o, s, r) {\n      const n = {},\n        a = o.queryRenderedSymbols(e),\n        l = [];\n      for (const e of Object.keys(a).map(Number)) l.push(s[e]);\n      l.sort(pt);\n      for (const e of l) {\n        const o = e.featureIndex.lookupSymbolFeatures(a[e.bucketInstanceId], e.bucketIndex, e.sourceLayerIndex, t, i, r);\n        for (const t in o) {\n          const i = n[t] = n[t] || [],\n            s = o[t];\n          s.sort((t, i) => {\n            const o = e.featureSortOrder;\n            if (o) {\n              const e = o.indexOf(t.featureIndex);\n              return o.indexOf(i.featureIndex) - e;\n            }\n            return i.featureIndex - t.featureIndex;\n          });\n          for (const e of s) i.push(e);\n        }\n      }\n      return n;\n    }\n    function _t(e, t) {\n      const i = e.getRenderableIds().map(t => e.getTileByID(t)),\n        o = [],\n        s = {};\n      for (let e = 0; e < i.length; e++) {\n        const r = i[e],\n          n = r.tileID.canonical.key;\n        s[n] || (s[n] = !0, r.querySourceFeatures(o, t));\n      }\n      return o;\n    }\n    function pt(e, t) {\n      const i = e.tileID,\n        o = t.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n    function ft(e, t) {\n      const i = {};\n      if (!t) return i;\n      for (const o of e) {\n        const e = o.layerIds.map(e => t.getLayer(e)).filter(Boolean);\n        if (0 !== e.length) {\n          o.layers = e, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map(t => e.filter(e => e.id === t)[0]));\n          for (const t of e) i[t.fqid] = o;\n        }\n      }\n      return i;\n    }\n    const mt = 32,\n      gt = 33,\n      vt = new Uint16Array(8184);\n    for (let e = 0; e < 2046; e++) {\n      let t = e + 2,\n        i = 0,\n        o = 0,\n        s = 0,\n        r = 0,\n        n = 0,\n        a = 0;\n      for (1 & t ? s = r = n = mt : i = o = a = mt; (t >>= 1) > 1;) {\n        const e = i + s >> 1,\n          l = o + r >> 1;\n        1 & t ? (s = i, r = o, i = n, o = a) : (i = s, o = r, s = n, r = a), n = e, a = l;\n      }\n      const l = 4 * e;\n      vt[l + 0] = i, vt[l + 1] = o, vt[l + 2] = s, vt[l + 3] = r;\n    }\n    const yt = new Uint16Array(2178),\n      xt = new Uint8Array(1089),\n      bt = new Uint16Array(1089);\n    function wt(e) {\n      return 0 === e ? -.03125 : 32 === e ? .03125 : 0;\n    }\n    const Tt = (() => ({\n      type: 2,\n      extent: e.al,\n      loadGeometry: () => [[new e.P(0, 0), new e.P(e.al + 1, 0), new e.P(e.al + 1, e.al + 1), new e.P(0, e.al + 1), new e.P(0, 0)]]\n    }))();\n    class Et {\n      constructor(t, i, o, s, r, n) {\n        this.tileID = t, this.uid = e.b2(), this.uses = 0, this.tileSize = i, this.tileZoom = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = r, s && s.style && (this._lastUpdatedBrightness = s.style.getBrightness()), this.expiredRequestCount = 0, this.state = \"loading\", s && s.transform && (this.projection = s.transform.projection), this.worldview = n;\n      }\n      registerFadeDuration(t) {\n        const i = t + this.timeAdded;\n        i < e.o.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);\n      }\n      wasRequested() {\n        return \"errored\" === this.state || \"loaded\" === this.state || \"reloading\" === this.state;\n      }\n      get tileTransform() {\n        return this._tileTransform || (this._tileTransform = e.aZ(this.tileID.canonical, this.projection)), this._tileTransform;\n      }\n      loadVectorData(t, i, o) {\n        if (this.unloadVectorData(), this.state = \"loaded\", t) {\n          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = ft(t.buckets, i.style), this.hasSymbolBuckets = !1;\n          for (const t in this.buckets) {\n            const i = this.buckets[t];\n            if (i instanceof e.b4) {\n              if (this.hasSymbolBuckets = !0, !o) break;\n              i.justReloaded = !0;\n            }\n          }\n          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {\n            const i = this.buckets[t];\n            if (i instanceof e.b4 && i.hasRTLText) {\n              this.hasRTLText = !0, e.b5();\n              break;\n            }\n          }\n          this.queryPadding = 0;\n          for (const e in this.buckets) {\n            const t = this.buckets[e],\n              o = i.style.getOwnLayer(e);\n            if (!o) continue;\n            const s = o.queryRadius(t);\n            this.queryPadding = Math.max(this.queryPadding, s);\n          }\n          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;\n        } else this.collisionBoxArray = new e.b3();\n      }\n      unloadVectorData() {\n        if (this.hasData()) {\n          for (const e in this.buckets) this.buckets[e].destroy();\n          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = \"unloaded\";\n        }\n      }\n      loadModelData(e, t, i) {\n        e && (e.resourceTiming && (this.resourceTiming = e.resourceTiming), this.buckets = Object.assign({}, this.buckets, ft(e.buckets, t.style)), e.featureIndex && (this.latestFeatureIndex = e.featureIndex));\n      }\n      getBucket(e) {\n        return this.buckets[e.fqid];\n      }\n      upload(t) {\n        for (const e in this.buckets) {\n          const i = this.buckets[e];\n          i.uploadPending() && i.upload(t);\n        }\n        const i = t.gl,\n          o = this.imageAtlas;\n        o && !o.uploaded && (this.imageAtlasTexture = new e.T(t, o.image, i.RGBA8, {\n          useMipmap: !!o.patternPositions.size\n        }), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t, this.glyphAtlasImage, i.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t, this.lineAtlas.image, i.R8), this.lineAtlas.uploaded = !0);\n      }\n      prepare(e, t, i) {\n        if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture, i), !t || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;\n        const o = t.style.getBrightness();\n        (this._lastUpdatedBrightness || o) && (this._lastUpdatedBrightness && o && Math.abs(this._lastUpdatedBrightness - o) < .001 || (this.updateBuckets(t, this._lastUpdatedBrightness !== o), this._lastUpdatedBrightness = o));\n      }\n      queryRenderedFeatures(t, i, o, s, r, n) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};\n        const a = function (t, i) {\n          const o = e.bq([], [.5 * t.width, .5 * -t.height, 1]);\n          return e.br(o, o, [1, -1, 0]), e.aB(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);\n        }(r, this.tileID);\n        return this.latestFeatureIndex.query(t, {\n          tilespaceGeometry: i,\n          pixelPosMatrix: a,\n          transform: s,\n          availableImages: o,\n          tileTransform: this.tileTransform,\n          worldview: this.worldview\n        });\n      }\n      querySourceFeatures(t, i) {\n        const o = this.latestFeatureIndex;\n        if (!o || !o.rawTileData) return;\n        const s = o.loadVTLayers(),\n          r = i ? i.sourceLayer : \"\",\n          n = s._geojsonTileLayer || s[r];\n        if (!n) return;\n        const a = e.b6(i && i.filter),\n          {\n            z: l,\n            x: c,\n            y: h\n          } = this.tileID.canonical,\n          d = {\n            z: l,\n            x: c,\n            y: h\n          };\n        for (let i = 0; i < n.length; i++) {\n          const s = n.feature(i);\n          if (a.needGeometry) {\n            const t = e.b7(s, !0);\n            if (!a.filter(new e.ac(this.tileID.overscaledZ, {\n              worldview: this.worldview\n            }), t, this.tileID.canonical)) continue;\n          } else if (!a.filter(new e.ac(this.tileID.overscaledZ, {\n            worldview: this.worldview\n          }), s)) continue;\n          const u = o.getId(s, r),\n            _ = new e.b8(s, l, c, h, u);\n          _.tile = d, t.push(_);\n        }\n      }\n      loaded() {\n        return \"loaded\" === this.state || \"errored\" === this.state;\n      }\n      hasData() {\n        return \"loaded\" === this.state || \"reloading\" === this.state || \"expired\" === this.state;\n      }\n      patternsLoaded() {\n        return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;\n      }\n      setExpiryData(t) {\n        const i = this.expirationTime;\n        if (t.cacheControl) {\n          const i = e.b9(t.cacheControl);\n          i[\"max-age\"] && (this.expirationTime = Date.now() + 1e3 * i[\"max-age\"]);\n        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n        if (this.expirationTime) {\n          const e = Date.now();\n          let t = !1;\n          if (this.expirationTime > e) t = !1;else if (i) {\n            if (this.expirationTime < i) t = !0;else {\n              const o = this.expirationTime - i;\n              o ? this.expirationTime = e + Math.max(o, 3e4) : t = !0;\n            }\n          } else t = !0;\n          t ? (this.expiredRequestCount++, this.state = \"expired\") : this.expiredRequestCount = 0;\n        }\n      }\n      getExpiryTimeout() {\n        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n      }\n      refreshFeatureState(e) {\n        this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e && this.updateBuckets(e);\n      }\n      updateBuckets(t, i) {\n        if (!this.latestFeatureIndex) return;\n        if (!t.style) return;\n        const o = this.latestFeatureIndex.loadVTLayers(),\n          s = t.style.listImages(),\n          r = t.style.getBrightness();\n        for (const n in this.buckets) {\n          if (!t.style.hasLayer(n)) continue;\n          const a = this.buckets[n],\n            l = a.layers[0],\n            c = l.sourceLayer || \"_geojsonTileLayer\",\n            h = o[c],\n            d = t.style.getLayerSourceCache(l);\n          let u = {};\n          d && (u = d._state.getState(c, void 0));\n          const _ = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {},\n            p = Object.keys(u).length > 0 && !i;\n          (p && 0 !== a.stateDependentLayers.length || i) && a.update(u, h, s, _, p ? a.stateDependentLayers : a.layers, i, r), (a instanceof e.ba || a instanceof e.bb) && t._terrain && t._terrain.enabled && d && a.uploadPending() && t._terrain._clearRenderCacheForTile(d.id, this.tileID);\n          const f = t && t.style && t.style.getOwnLayer(n);\n          f && (this.queryPadding = Math.max(this.queryPadding, f.queryRadius(a)));\n        }\n      }\n      holdingForFade() {\n        return void 0 !== this.symbolFadeHoldUntil;\n      }\n      symbolFadeFinished() {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.o.now();\n      }\n      clearFadeHold() {\n        this.symbolFadeHoldUntil = void 0;\n      }\n      setHoldDuration(t) {\n        this.symbolFadeHoldUntil = e.o.now() + t;\n      }\n      setTexture(t, i) {\n        const o = i.context,\n          s = o.gl;\n        this.texture = this.texture || i.getTileTexture(t.width), this.texture && this.texture instanceof e.T ? this.texture.update(t) : (this.texture = new e.T(o, t, s.RGBA8, {\n          useMipmap: !0\n        }), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));\n      }\n      setDependencies(e, t) {\n        const i = {};\n        for (const e of t) i[e] = !0;\n        this.dependencies[e] = i;\n      }\n      hasDependency(e, t) {\n        for (const i of e) {\n          const e = this.dependencies[i];\n          if (e) for (const i of t) if (e[i]) return !0;\n        }\n        return !1;\n      }\n      clearQueryDebugViz() {}\n      _makeDebugTileBoundsBuffers(t, i) {\n        if (!i || \"mercator\" === i.name || this._tileDebugBuffer) return;\n        const o = e.bc(Tt, this.tileID.canonical, this.tileTransform)[0],\n          s = new e.bd(),\n          r = new e.be();\n        for (let e = 0; e < o.length; e++) {\n          const {\n            x: t,\n            y: i\n          } = o[e];\n          s.emplaceBack(t, i), r.emplaceBack(e);\n        }\n        r.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(r), this._tileDebugBuffer = t.createVertexBuffer(s, e.bf.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, s.length, r.length);\n      }\n      _makeTileBoundsBuffers(t, i) {\n        if (this._tileBoundsBuffer || !i || \"mercator\" === i.name) return;\n        const o = e.bc(Tt, this.tileID.canonical, this.tileTransform)[0];\n        let s, r;\n        if (this.isRaster) {\n          const t = function (t, i) {\n            const o = e.aZ(t, i),\n              s = Math.pow(2, t.z);\n            for (let r = 0; r < gt; r++) for (let n = 0; n < gt; n++) {\n              const a = e.a_((t.x + (n + wt(n)) / mt) / s),\n                l = e.a$((t.y + (r + wt(r)) / mt) / s),\n                c = i.project(a, l),\n                h = r * gt + n;\n              yt[2 * h + 0] = Math.round((c.x * o.scale - o.x) * e.al), yt[2 * h + 1] = Math.round((c.y * o.scale - o.y) * e.al);\n            }\n            xt.fill(0), bt.fill(0);\n            for (let e = 2045; e >= 0; e--) {\n              const t = 4 * e,\n                i = vt[t + 0],\n                o = vt[t + 1],\n                s = vt[t + 2],\n                r = vt[t + 3],\n                n = i + s >> 1,\n                a = o + r >> 1,\n                l = n + a - o,\n                c = a + i - n,\n                h = o * gt + i,\n                d = r * gt + s,\n                u = a * gt + n,\n                _ = Math.hypot((yt[2 * h + 0] + yt[2 * d + 0]) / 2 - yt[2 * u + 0], (yt[2 * h + 1] + yt[2 * d + 1]) / 2 - yt[2 * u + 1]) >= 16;\n              xt[u] = xt[u] || (_ ? 1 : 0), e < 1022 && (xt[u] = xt[u] || xt[(o + c >> 1) * gt + (i + l >> 1)] || xt[(r + c >> 1) * gt + (s + l >> 1)]);\n            }\n            const r = new e.b0(),\n              n = new e.b1();\n            let a = 0;\n            function l(t, i) {\n              const o = i * gt + t;\n              return 0 === bt[o] && (r.emplaceBack(yt[2 * o + 0], yt[2 * o + 1], t * e.al / mt, i * e.al / mt), bt[o] = ++a), bt[o] - 1;\n            }\n            function c(e, t, i, o, s, r) {\n              const a = e + i >> 1,\n                h = t + o >> 1;\n              if (Math.abs(e - s) + Math.abs(t - r) > 1 && xt[h * gt + a]) c(s, r, e, t, a, h), c(i, o, s, r, a, h);else {\n                const a = l(e, t),\n                  c = l(i, o),\n                  h = l(s, r);\n                n.emplaceBack(a, c, h);\n              }\n            }\n            return c(0, 0, mt, mt, mt, 0), c(mt, mt, 0, 0, 0, mt), {\n              vertices: r,\n              indices: n\n            };\n          }(this.tileID.canonical, i);\n          s = t.vertices, r = t.indices;\n        } else {\n          s = new e.b0(), r = new e.b1();\n          for (const {\n            x: e,\n            y: t\n          } of o) s.emplaceBack(e, t, 0, 0);\n          const t = e.bh(s.int16.subarray(0, 4 * s.length), void 0, 4);\n          for (let e = 0; e < t.length; e += 3) r.emplaceBack(t[e], t[e + 1], t[e + 2]);\n        }\n        this._tileBoundsBuffer = t.createVertexBuffer(s, e.bi.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(r), this._tileBoundsSegments = e.bg.simpleSegment(0, 0, s.length, r.length);\n      }\n      _makeGlobeTileDebugBuffers(t, i) {\n        const o = i.projection;\n        if (!o || \"globe\" !== o.name || i.freezeTileCoverage) return;\n        const s = this.tileID.canonical,\n          r = e.bj(s, i),\n          n = e.bk(r),\n          a = e.aj(i.zoom);\n        let l;\n        a > 0 && (l = e.bl(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, s, i, n, l, a), this._makeGlobeTileDebugTextBuffer(t, s, i, n, l, a);\n      }\n      _globePoint(t, i, o, s, r, n, a) {\n        let l = e.bm(t, i, o);\n        if (n) {\n          const r = 1 << o.z,\n            c = e.aF(s.center.lng),\n            h = e.aJ(s.center.lat),\n            d = (o.x + .5) / r - c;\n          let u = 0;\n          d > .5 ? u = -1 : d < -.5 && (u = 1);\n          let _ = (t / e.al + o.x) / r + u,\n            p = (i / e.al + o.y) / r;\n          _ = (_ - c) * s._pixelsPerMercatorPixel + c, p = (p - h) * s._pixelsPerMercatorPixel + h;\n          const f = [_ * s.worldSize, p * s.worldSize, 0];\n          e.af(f, f, n), l = e.bn(l, f, a);\n        }\n        return e.af(l, l, r);\n      }\n      _makeGlobeTileDebugBorderBuffer(t, i, o, s, r, n) {\n        const a = new e.bd(),\n          l = new e.be(),\n          c = new e.bo(),\n          h = (e, t, h, d, u) => {\n            const _ = (h - e) / (u - 1),\n              p = (d - t) / (u - 1),\n              f = a.length;\n            for (let h = 0; h < u; h++) {\n              const d = e + h * _,\n                u = t + h * p;\n              a.emplaceBack(d, u);\n              const m = this._globePoint(d, u, i, o, s, r, n);\n              c.emplaceBack(m[0], m[1], m[2]), l.emplaceBack(f + h);\n            }\n          },\n          d = e.al;\n        h(0, 0, d, 0, 16), h(d, 0, d, d, 16), h(d, d, 0, d, 16), h(0, d, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(l), this._tileDebugBuffer = t.createVertexBuffer(a, e.bf.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(c, e.bp.members), this._tileDebugSegments = e.bg.simpleSegment(0, 0, a.length, l.length);\n      }\n      _makeGlobeTileDebugTextBuffer(t, i, o, s, r, n) {\n        const a = e.al / 4,\n          l = new e.bd(),\n          c = new e.b1(),\n          h = new e.bo(),\n          d = 25;\n        c.reserve(32), l.reserve(d), h.reserve(d);\n        const u = (e, t) => d * e + t;\n        for (let e = 0; e < d; e++) {\n          const t = e * a;\n          for (let e = 0; e < d; e++) {\n            const c = e * a;\n            l.emplaceBack(c, t);\n            const d = this._globePoint(c, t, i, o, s, r, n);\n            h.emplaceBack(d[0], d[1], d[2]);\n          }\n        }\n        for (let e = 0; e < 4; e++) for (let t = 0; t < 4; t++) {\n          const i = u(e, t),\n            o = u(e, t + 1),\n            s = u(e + 1, t),\n            r = u(e + 1, t + 1);\n          c.emplaceBack(i, o, s), c.emplaceBack(s, o, r);\n        }\n        this._tileDebugTextIndexBuffer = t.createIndexBuffer(c), this._tileDebugTextBuffer = t.createVertexBuffer(l, e.bf.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(h, e.bp.members), this._tileDebugTextSegments = e.bg.simpleSegment(0, 0, d, 32);\n      }\n      destroy() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        for (const e in this.buckets) this.buckets[e].destroy();\n        this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = \"unloaded\";\n      }\n    }\n    e.bs.setPbf(e.bt);\n    class St extends Et {\n      constructor(e, t, i, o, s) {\n        super(e, t, i, o, s), this._workQueuePerLayer = new Map(), this._fetchQueuePerLayer = new Map(), this._taskQueue = new Map(), this._isHeaderLoaded = !1, this.textureDescriptorPerLayer = new Map(), this.texturePerLayer = new Map();\n      }\n      getLayers() {\n        return this._mrt ? Object.values(this._mrt.layers) : [];\n      }\n      getLayer(e) {\n        return this._mrt && this._mrt.getLayer(e);\n      }\n      setTexturePerLayer(t, i, o) {\n        const s = o.context,\n          r = s.gl;\n        let n = this.texturePerLayer.get(t) || o.getTileTexture(i.width);\n        n && n instanceof e.T ? n.update(i, {\n          premultiply: !1\n        }) : n = new e.T(s, i, r.RGBA8, {\n          premultiply: !1\n        }), this.texturePerLayer.has(t) || this.texturePerLayer.set(t, n);\n      }\n      flushQueues(e) {\n        const t = this._workQueuePerLayer.get(e) || [],\n          i = this._fetchQueuePerLayer.get(e) || [];\n        for (; t.length;) t.pop()();\n        for (; i.length;) i.pop()();\n      }\n      flushAllQueues() {\n        for (const e of this._workQueuePerLayer.keys()) {\n          const t = this._workQueuePerLayer.get(e) || [];\n          for (; t.length;) t.pop()();\n        }\n        for (const e of this._fetchQueuePerLayer.keys()) {\n          const t = this._fetchQueuePerLayer.get(e) || [];\n          for (; t.length;) t.pop()();\n        }\n      }\n      fetchHeader() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16384;\n        let i = arguments.length > 1 ? arguments[1] : undefined;\n        const o = this._mrt = new e.bs(30),\n          s = Object.assign({}, this.requestParams, {\n            headers: {\n              Range: \"bytes=0-\" + (t - 1)\n            }\n          });\n        return this.entireBuffer = null, this.request = e.bu(s, (e, s, r, n) => {\n          if (e) i(e);else try {\n            const e = o.getHeaderLength(s);\n            if (e > t) return void (this.request = this.fetchHeader(e, i));\n            o.parseHeader(s), this._isHeaderLoaded = !0;\n            let a = 0;\n            for (const e of Object.values(o.layers)) a = Math.max(a, e.dataIndex[e.dataIndex.length - 1].lastByte);\n            s.byteLength >= a && (this.entireBuffer = s), i(null, this.entireBuffer || s, r, n);\n          } catch (e) {\n            i(e);\n          }\n        }), this.request;\n      }\n      fetchBandForRender(e, t, i, o) {\n        this.fetchBand(e, t, i, s => {\n          if (s) return void o(s);\n          this.updateTextureDescriptor(e, t, i);\n          const r = this.textureDescriptorPerLayer.get(t);\n          o(null, r ? r.img : null);\n        });\n      }\n      fetchBand(t, i, o, s) {\n        let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;\n        const n = this._mrt;\n        if (!this._isHeaderLoaded || !n) return void s(new Error(\"Tile header is not ready\"));\n        const a = this.actor;\n        if (!a) return void s(new Error(\"Can't fetch tile band without an actor\"));\n        let l;\n        const c = e.B(String(o), e.B(this.tileID.key, t));\n        let h = this._taskQueue.get(c);\n        h ? h.add(s) : (h = new Set(), h.add(s), this._taskQueue.set(c, h));\n        const d = (e, t) => {\n            l.complete(e, t), e ? s(e) : (h.values().forEach(e => e(null, t)), this._taskQueue.delete(c));\n          },\n          u = (e, t) => {\n            if (e) return s(e);\n            const o = a.send(\"decodeRasterArray\", {\n              type: \"raster-array\",\n              source: this.source,\n              scope: this.scope,\n              tileID: this.tileID,\n              uid: this.uid,\n              buffer: t,\n              task: l\n            }, d, void 0, !0);\n            if (null !== i) {\n              const e = this._workQueuePerLayer.get(i) || [];\n              e.push(() => {\n                o && o.cancel(), l.cancel();\n              }), this._workQueuePerLayer.has(i) || this._workQueuePerLayer.set(i, e);\n            }\n          };\n        let _;\n        try {\n          _ = n.getLayer(t);\n        } catch (e) {\n          if (\"reloading\" === this.state) return;\n          throw e;\n        }\n        if (!_) return void s(new Error(\"Unknown sourceLayer \\\"\".concat(t, \"\\\"\")));\n        if (_.hasDataForBand(o)) return h.values().forEach(e => e(null, null)), void this._taskQueue.delete(c);\n        const p = _.getDataRange([o]);\n        if (l = n.createDecodingTask(p), !l || l.tasks.length) if (null !== i && this.flushQueues(i), this.entireBuffer) u(null, this.entireBuffer.slice(p.firstByte, p.lastByte + 1));else {\n          const t = Object.assign({}, this.requestParams, {\n              headers: {\n                Range: \"bytes=\".concat(p.firstByte, \"-\").concat(p.lastByte)\n              }\n            }),\n            o = e.bu(t, u);\n          if (null !== i) {\n            const e = this._fetchQueuePerLayer.get(i) || [];\n            e.push(() => {\n              o.cancel(), l.cancel();\n            }), this._fetchQueuePerLayer.has(i) || this._fetchQueuePerLayer.set(i, e);\n          }\n        }\n      }\n      updateNeeded(e, t) {\n        return (!this.textureDescriptorPerLayer.get(e) || this.textureDescriptorPerLayer.get(e).band !== t || this.refreshedUponExpiration) && \"errored\" !== this.state;\n      }\n      updateTextureDescriptor(t, i, o) {\n        if (!this._mrt) return;\n        const s = this._mrt.getLayer(t);\n        if (!s || !s.hasBand(o) || !s.hasDataForBand(o)) return;\n        const {\n            bytes: r,\n            tileSize: n,\n            buffer: a,\n            offset: l,\n            scale: c\n          } = s.getBandView(o),\n          h = n + 2 * a,\n          d = new e.q({\n            width: h,\n            height: h\n          }, r),\n          u = this.texturePerLayer.get(i);\n        u && u instanceof e.T && u.update(d, {\n          premultiply: !1\n        }), this.textureDescriptorPerLayer.set(i, {\n          layer: t,\n          band: o,\n          img: d,\n          buffer: a,\n          offset: l,\n          tileSize: n,\n          format: s.pixelFormat,\n          mix: [c, 256 * c, 65536 * c, 16777216 * c]\n        });\n      }\n      destroy() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        if (super.destroy(t), delete this._mrt, !t) for (const t of this.texturePerLayer.values()) t && t instanceof e.T && t.destroy();\n        this.texturePerLayer.clear(), this.textureDescriptorPerLayer.clear(), this.fbo && (this.fbo.destroy(), delete this.fbo), delete this.request, delete this.requestParams, this._isHeaderLoaded = !1;\n      }\n    }\n    class It {\n      constructor(e, t) {\n        this.max = e, this.onRemove = t, this.reset();\n      }\n      reset() {\n        for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);\n        return this.data = {}, this.order = [], this;\n      }\n      add(e, t, i) {\n        const o = e.wrapped().key;\n        void 0 === this.data[o] && (this.data[o] = []);\n        const s = {\n          value: t,\n          timeout: void 0\n        };\n        if (void 0 !== i && (s.timeout = setTimeout(() => {\n          this.remove(e, s);\n        }, i)), this.data[o].push(s), this.order.push(o), this.order.length > this.max) {\n          const e = this._getAndRemoveByKey(this.order[0]);\n          e && this.onRemove(e);\n        }\n        return this;\n      }\n      has(e) {\n        return e.wrapped().key in this.data;\n      }\n      getAndRemove(e) {\n        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;\n      }\n      _getAndRemoveByKey(e) {\n        const t = this.data[e].shift();\n        return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;\n      }\n      getByKey(e) {\n        const t = this.data[e];\n        return t ? t[0].value : null;\n      }\n      get(e) {\n        return this.has(e) ? this.data[e.wrapped().key][0].value : null;\n      }\n      remove(e, t) {\n        if (!this.has(e)) return this;\n        const i = e.wrapped().key,\n          o = void 0 === t ? 0 : this.data[i].indexOf(t),\n          s = this.data[i][o];\n        return this.data[i].splice(o, 1), s.timeout && clearTimeout(s.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(s.value), this.order.splice(this.order.indexOf(i), 1), this;\n      }\n      setMaxSize(e) {\n        for (this.max = e; this.order.length > this.max;) {\n          const e = this._getAndRemoveByKey(this.order[0]);\n          e && this.onRemove(e);\n        }\n        return this;\n      }\n      filter(e) {\n        const t = [];\n        for (const i in this.data) for (const o of this.data[i]) e(o.value) || t.push(o);\n        for (const e of t) this.remove(e.value.tileID, e);\n      }\n    }\n    class Ct {\n      constructor() {\n        this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n      }\n      updateState(e, t, i) {\n        const o = String(t);\n        if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][o] = this.stateChanges[e][o] || {}, Object.assign(this.stateChanges[e][o], i), null === this.deletedStates[e]) {\n          this.deletedStates[e] = {};\n          for (const t in this.state[e]) t !== o && (this.deletedStates[e][t] = null);\n        } else if (this.deletedStates[e] && null === this.deletedStates[e][o]) {\n          this.deletedStates[e][o] = {};\n          for (const t in this.state[e][o]) i[t] || (this.deletedStates[e][o][t] = null);\n        } else for (const t in i) this.deletedStates[e] && this.deletedStates[e][o] && null === this.deletedStates[e][o][t] && delete this.deletedStates[e][o][t];\n      }\n      removeFeatureState(e, t, i) {\n        if (null === this.deletedStates[e]) return;\n        const o = String(t);\n        if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t) null !== this.deletedStates[e][o] && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);else if (void 0 !== t) {\n          if (this.stateChanges[e] && this.stateChanges[e][o]) for (i in this.deletedStates[e][o] = {}, this.stateChanges[e][o]) this.deletedStates[e][o][i] = null;else this.deletedStates[e][o] = null;\n        } else this.deletedStates[e] = null;\n      }\n      getState(e, t) {\n        const i = this.state[e] || {},\n          o = this.stateChanges[e] || {},\n          s = this.deletedStates[e];\n        if (null === s) return {};\n        if (void 0 !== t) {\n          const e = String(t),\n            r = Object.assign({}, i[e], o[e]);\n          if (s) {\n            const e = s[t];\n            if (null === e) return {};\n            for (const t in e) delete r[t];\n          }\n          return r;\n        }\n        const r = Object.assign({}, i, o);\n        if (s) for (const e in s) delete r[e];\n        return r;\n      }\n      initializeTileState(e, t) {\n        e.refreshFeatureState(t);\n      }\n      coalesceChanges(e, t) {\n        const i = {};\n        for (const e in this.stateChanges) {\n          this.state[e] = this.state[e] || {};\n          const t = {};\n          for (const i in this.stateChanges[e]) this.state[e][i] || (this.state[e][i] = {}), Object.assign(this.state[e][i], this.stateChanges[e][i]), t[i] = this.state[e][i];\n          i[e] = t;\n        }\n        for (const e in this.deletedStates) {\n          this.state[e] = this.state[e] || {};\n          const t = {};\n          if (null === this.deletedStates[e]) for (const i in this.state[e]) t[i] = {}, this.state[e][i] = {};else for (const i in this.deletedStates[e]) {\n            if (null === this.deletedStates[e][i]) this.state[e][i] = {};else if (this.state[e][i]) for (const t of Object.keys(this.deletedStates[e][i])) delete this.state[e][i][t];\n            t[i] = this.state[e][i];\n          }\n          i[e] = i[e] || {}, Object.assign(i[e], t);\n        }\n        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(i).length) for (const i in e) e[i].refreshFeatureState(t);\n      }\n    }\n    class Rt extends e.E {\n      constructor(e, t, i) {\n        super(), this.id = e, this._onlySymbols = i, t.on(\"data\", e => {\n          \"source\" === e.dataType && \"metadata\" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && \"source\" === e.dataType && \"content\" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform));\n        }), t.on(\"error\", () => {\n          this._sourceErrored = !0;\n        }), this._source = t, this._tiles = {}, this._cache = new It(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Ct(), this._isRaster = \"raster\" === this._source.type || \"raster-dem\" === this._source.type || \"raster-array\" === this._source.type || \"custom\" === this._source.type && \"raster\" === this._source._dataType;\n      }\n      onAdd(e) {\n        this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize;\n      }\n      loaded() {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n        for (const e in this._tiles) if (!this._tiles[e].loaded()) return !1;\n        return !0;\n      }\n      getSource() {\n        return this._source;\n      }\n      pause() {\n        this._paused = !0;\n      }\n      resume() {\n        if (!this._paused) return;\n        const e = this._shouldReloadOnResume;\n        this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);\n      }\n      _loadTile(e, t) {\n        return e.isSymbolTile = this._onlySymbols, e.isExtraShadowCaster = this._shadowCasterTiles[e.tileID.key], this._source.loadTile(e, t);\n      }\n      _unloadTile(e) {\n        if (this._source.unloadTile) return this._source.unloadTile(e);\n      }\n      _abortTile(e) {\n        if (this._source.abortTile) return this._source.abortTile(e);\n      }\n      serialize() {\n        return this._source.serialize();\n      }\n      prepare(e) {\n        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n        for (const t in this._tiles) {\n          const i = this._tiles[t];\n          i.upload(e), i.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);\n        }\n      }\n      getIds() {\n        return Object.values(this._tiles).map(e => e.tileID).sort(At).map(e => e.key);\n      }\n      getRenderableIds(t, i) {\n        const o = [];\n        for (const e in this._tiles) this._isIdRenderable(+e, t, i) && o.push(this._tiles[e]);\n        return t ? o.sort((t, i) => {\n          const o = t.tileID,\n            s = i.tileID,\n            r = new e.P(o.canonical.x, o.canonical.y)._rotate(this.transform.angle),\n            n = new e.P(s.canonical.x, s.canonical.y)._rotate(this.transform.angle);\n          return o.overscaledZ - s.overscaledZ || n.y - r.y || n.x - r.x;\n        }).map(e => e.tileID.key) : o.map(e => e.tileID).sort(At).map(e => e.key);\n      }\n      hasRenderableParent(e) {\n        const t = this.findLoadedParent(e, 0);\n        return !!t && this._isIdRenderable(t.tileID.key);\n      }\n      _isIdRenderable(e, t, i) {\n        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade()) && (i || !this._shadowCasterTiles[e]);\n      }\n      reload() {\n        if (this._paused) this._shouldReloadOnResume = !0;else {\n          this._cache.reset();\n          for (const e in this._tiles) \"errored\" !== this._tiles[e].state && this._reloadTile(+e, \"reloading\");\n        }\n      }\n      _reloadTile(e, t) {\n        const i = this._tiles[e];\n        i && (\"loading\" !== i.state && (i.state = t), this._loadTile(i, this._tileLoaded.bind(this, i, e, t)));\n      }\n      _tileLoaded(t, i, o, s) {\n        if (s) {\n          if (t.state = \"errored\", 404 !== s.status) this._source.fire(new e.y(s, {\n            tile: t\n          }));else {\n            if (this._source.fire(new e.z(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"error\",\n              sourceId: this._source.id,\n              tile: t\n            })), !(t.tileID.key in this._loadedParentTiles)) return;\n            if (\"raster-dem\" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {\n              const e = this.map.painter.terrain;\n              this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id);\n            } else this.update(this.transform);\n          }\n        } else t.timeAdded = e.o.now(), \"expired\" === o && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t), \"raster-dem\" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new e.z(\"data\", {\n          dataType: \"source\",\n          tile: t,\n          coord: t.tileID,\n          sourceCacheId: this.id\n        }));\n      }\n      _backfillDEM(e) {\n        const t = this.getRenderableIds();\n        for (let o = 0; o < t.length; o++) {\n          const s = t[o];\n          if (e.neighboringTiles && e.neighboringTiles[s]) {\n            const t = this.getTileByID(s);\n            i(e, t), i(t, e);\n          }\n        }\n        function i(e, t) {\n          if (!e.dem || e.dem.borderReady) return;\n          e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;\n          let i = t.tileID.canonical.x - e.tileID.canonical.x;\n          const o = t.tileID.canonical.y - e.tileID.canonical.y,\n            s = Math.pow(2, e.tileID.canonical.z),\n            r = t.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + s) ? i += s : 1 === Math.abs(i - s) && (i -= s)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, i, o), e.neighboringTiles && e.neighboringTiles[r] && (e.neighboringTiles[r].backfilled = !0)));\n        }\n      }\n      getTile(e) {\n        return this.getTileByID(e.key);\n      }\n      getTileByID(e) {\n        return this._tiles[e];\n      }\n      _retainLoadedChildren(e, t, i, o) {\n        for (const s in this._tiles) {\n          let r = this._tiles[s];\n          if (o[s] || !r.hasData() || r.tileID.overscaledZ <= t || r.tileID.overscaledZ > i) continue;\n          let n = r.tileID;\n          for (; r && r.tileID.overscaledZ > t + 1;) {\n            const e = r.tileID.scaledTo(r.tileID.overscaledZ - 1);\n            r = this._tiles[e.key], r && r.hasData() && (n = e);\n          }\n          let a = n;\n          for (; a.overscaledZ > t;) if (a = a.scaledTo(a.overscaledZ - 1), e[a.key]) {\n            o[n.key] = n;\n            break;\n          }\n        }\n      }\n      findLoadedParent(e, t) {\n        if (e.key in this._loadedParentTiles) {\n          const i = this._loadedParentTiles[e.key];\n          return i && i.tileID.overscaledZ >= t ? i : null;\n        }\n        for (let i = e.overscaledZ - 1; i >= t; i--) {\n          const t = e.scaledTo(i),\n            o = this._getLoadedTile(t);\n          if (o) return o;\n        }\n      }\n      _getLoadedTile(e) {\n        const t = this._tiles[e.key];\n        return t && t.hasData() ? t : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);\n      }\n      updateCacheSize(e, t) {\n        t = t || this._source.tileSize;\n        const i = Math.ceil(e.width / t) + 1,\n          o = Math.ceil(e.height / t) + 1,\n          s = Math.floor(i * o * 5),\n          r = \"number\" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s) : s,\n          n = \"number\" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r) : r;\n        this._cache.setMaxSize(n);\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);\n        if (this._prevLng = e, t) {\n          const e = {};\n          for (const i in this._tiles) {\n            const o = this._tiles[i];\n            o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t), e[o.tileID.key] = o;\n          }\n          this._tiles = e;\n          for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];\n          for (const e in this._tiles) this._setTileReloadTimer(+e, this._tiles[e]);\n        }\n      }\n      update(t, i, o, s, r) {\n        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;\n        if (this.usedForTerrain && !o) return;\n        this.updateCacheSize(t, i), \"globe\" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};\n        const n = \"batched-model\" === this._source.type;\n        let a,\n          l = this._source.maxzoom;\n        const c = this.map && this.map.painter ? this.map.painter._terrain : null;\n        if (c && c.sourceCache === this && c.attenuationRange()) {\n          const e = c.attenuationRange()[0],\n            t = Math.floor(e) - Math.log2(c.getDemUpscale());\n          l > t && (l = t);\n        }\n        if (this.used || this.usedForTerrain) {\n          if (this._source.tileID) a = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new e.aO(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y));else if (0 !== this.tileCoverLift) {\n            const s = t.clone();\n            s.tileCoverLift = this.tileCoverLift, a = s.coveringTiles({\n              tileSize: i || this._source.tileSize,\n              minzoom: this._source.minzoom,\n              maxzoom: l,\n              roundZoom: this._source.roundZoom && !o,\n              reparseOverscaled: this._source.reparseOverscaled,\n              isTerrainDEM: this.usedForTerrain,\n              calculateQuadrantVisibility: n\n            }), this._source.minzoom <= 1 && \"globe\" === t.projection.name && (a.push(new e.aO(1, 0, 1, 0, 0)), a.push(new e.aO(1, 0, 1, 1, 0)), a.push(new e.aO(1, 0, 1, 0, 1)), a.push(new e.aO(1, 0, 1, 1, 1)));\n          } else if (a = t.coveringTiles({\n            tileSize: i || this._source.tileSize,\n            minzoom: this._source.minzoom,\n            maxzoom: l,\n            roundZoom: this._source.roundZoom && !o,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain,\n            calculateQuadrantVisibility: n\n          }), this._source.hasTile) {\n            const e = this._source.hasTile.bind(this._source);\n            a = a.filter(t => e(t));\n          }\n        } else a = [];\n        if (a.length > 0 && \"globe\" !== this.transform.projection.name && !this.usedForTerrain && !Dt(this._source.type)) {\n          const e = t.coveringZoomLevel({\n              tileSize: i || this._source.tileSize,\n              roundZoom: this._source.roundZoom && !o\n            }),\n            l = Math.min(e, this._source.maxzoom);\n          if (n) {\n            const e = t.extendTileCover(a, l);\n            for (const t of e) a.push(t);\n          } else if (r) {\n            const e = t.extendTileCoverToNearPlane(a, this.transform.getFrustum(l), l);\n            for (const t of e) a.push(t);\n          } else if (this.castsShadows && s) {\n            const e = t.extendTileCover(a, l, s);\n            for (const t of e) this._shadowCasterTiles[t.key] = !0, a.push(t);\n          }\n        }\n        const h = this._updateRetainedTiles(a);\n        if (Dt(this._source.type) && 0 !== a.length) {\n          const t = {},\n            i = {},\n            o = Object.keys(h);\n          for (const s of o) {\n            const o = h[s],\n              r = this._tiles[s];\n            if (!r || r.fadeEndTime && r.fadeEndTime <= e.o.now()) continue;\n            const n = this.findLoadedParent(o, Math.max(o.overscaledZ - Rt.maxOverzooming, this._source.minzoom));\n            n && (this._addTile(n.tileID), t[n.tileID.key] = n.tileID), i[s] = o;\n          }\n          const s = a[a.length - 1].overscaledZ;\n          for (const e in this._tiles) {\n            const t = this._tiles[e];\n            if (h[e] || !t.hasData()) continue;\n            let o = t.tileID;\n            for (; o.overscaledZ > s;) {\n              o = o.scaledTo(o.overscaledZ - 1);\n              const s = this._tiles[o.key];\n              if (s && s.hasData() && i[o.key]) {\n                h[e] = t.tileID;\n                break;\n              }\n            }\n          }\n          for (const e in t) h[e] || (this._coveredTiles[e] = !0, h[e] = t[e]);\n        }\n        for (const e in h) this._tiles[e].clearFadeHold();\n        const d = e.bv(this._tiles, h);\n        for (const e of d) {\n          const t = this._tiles[e];\n          t.hasSymbolBuckets && !t.holdingForFade() ? t.setHoldDuration(this.map._fadeDuration) : t.hasSymbolBuckets && !t.symbolFadeFinished() || this._removeTile(+e);\n        }\n        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();\n      }\n      releaseSymbolFadeTiles() {\n        for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(+e);\n      }\n      _updateRetainedTiles(e) {\n        const t = {};\n        if (0 === e.length) return t;\n        const i = {},\n          o = e.reduce((e, t) => Math.min(e, t.overscaledZ), 1 / 0),\n          s = e[0].overscaledZ,\n          r = Math.max(s - Rt.maxOverzooming, this._source.minzoom),\n          n = Math.max(s + Rt.maxUnderzooming, this._source.minzoom),\n          a = {};\n        for (const i of e) {\n          const e = this._addTile(i);\n          t[i.key] = i, e.hasData() || o < this._source.maxzoom && (a[i.key] = i);\n        }\n        this._retainLoadedChildren(a, o, n, t);\n        for (const o of e) {\n          let e = this._tiles[o.key];\n          if (e.hasData()) continue;\n          if (o.canonical.z >= this._source.maxzoom) {\n            const e = o.children(this._source.maxzoom)[0],\n              i = this.getTile(e);\n            if (i && i.hasData()) {\n              t[e.key] = e;\n              continue;\n            }\n          } else {\n            const e = o.children(this._source.maxzoom);\n            if (t[e[0].key] && t[e[1].key] && t[e[2].key] && t[e[3].key]) continue;\n          }\n          let s = e.wasRequested();\n          for (let n = o.overscaledZ - 1; n >= r; --n) {\n            const r = o.scaledTo(n);\n            if (i[r.key]) break;\n            if (i[r.key] = !0, e = this.getTile(r), !e && s && (e = this._addTile(r)), e && (t[r.key] = r, s = e.wasRequested(), e.hasData())) break;\n          }\n        }\n        return t;\n      }\n      _updateLoadedParentTileCache() {\n        this._loadedParentTiles = {};\n        for (const e in this._tiles) {\n          const t = [];\n          let i,\n            o = this._tiles[e].tileID;\n          for (; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n            t.push(o.key);\n            const e = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(e), i) break;\n            o = e;\n          }\n          for (const e of t) this._loadedParentTiles[e] = i;\n        }\n      }\n      _addTile(t) {\n        let i = this._tiles[t.key];\n        if (i) return !0 !== i.isExtraShadowCaster || !!this._shadowCasterTiles[t.key] || this._reloadTile(t.key, \"reloading\"), i;\n        i = this._cache.getAndRemove(t), i && (this._setTileReloadTimer(t.key, i), i.tileID = t, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, i)));\n        const o = Boolean(i);\n        if (!o) {\n          const e = this.map ? this.map.painter : null,\n            o = this._source.tileSize * t.overscaleFactor();\n          i = \"raster-array\" === this._source.type ? new St(t, o, this.transform.tileZoom, e, this._isRaster) : new Et(t, o, this.transform.tileZoom, e, this._isRaster, this._source.worldview), this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state));\n        }\n        return i.uses++, this._tiles[t.key] = i, o || this._source.fire(new e.z(\"dataloading\", {\n          tile: i,\n          coord: i.tileID,\n          dataType: \"source\"\n        })), i;\n      }\n      _setTileReloadTimer(e, t) {\n        e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);\n        const i = t.getExpiryTimeout();\n        i && (this._timers[e] = setTimeout(() => {\n          this._reloadTile(e, \"expired\"), delete this._timers[e];\n        }, i));\n      }\n      _removeTile(e) {\n        const t = this._tiles[e];\n        t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() && \"reloading\" !== t.state || \"empty\" === t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t))));\n      }\n      clearTiles() {\n        this._shouldReloadOnResume = !1, this._paused = !1;\n        for (const e in this._tiles) this._removeTile(+e);\n        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);\n      }\n      tilesIn(t, i, o) {\n        const s = [],\n          r = this.transform;\n        if (!r) return s;\n        const n = \"globe\" === r.projection.name,\n          a = e.aF(r.center.lng);\n        for (const l in this._tiles) {\n          const c = this._tiles[l];\n          if (o && c.clearQueryDebugViz(), c.holdingForFade()) continue;\n          let h;\n          if (n) {\n            const t = c.tileID.canonical;\n            if (0 === t.z) {\n              const i = [Math.abs(e.aA(a, ...Lt(t, -1)) - a), Math.abs(e.aA(a, ...Lt(t, 1)) - a)];\n              h = [0, 2 * i.indexOf(Math.min(...i)) - 1];\n            } else {\n              const i = [Math.abs(e.aA(a, ...Lt(t, -1)) - a), Math.abs(e.aA(a, ...Lt(t, 0)) - a), Math.abs(e.aA(a, ...Lt(t, 1)) - a)];\n              h = [i.indexOf(Math.min(...i)) - 1];\n            }\n          } else h = [0];\n          for (const e of h) {\n            const o = t.containsTile(c, r, i, e);\n            o && s.push(o);\n          }\n        }\n        return s;\n      }\n      getShadowCasterCoordinates() {\n        return this._getRenderableCoordinates(!1, !0);\n      }\n      getVisibleCoordinates(e) {\n        return this._getRenderableCoordinates(e);\n      }\n      _getRenderableCoordinates(e, t) {\n        const i = this.getRenderableIds(e, t).map(e => this._tiles[e].tileID),\n          o = \"globe\" === this.transform.projection.name;\n        for (const e of i) e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped()), e.expandedProjMatrix = o ? this.transform.calculateProjMatrix(e.toUnwrapped(), !1, !0) : e.projMatrix;\n        return i;\n      }\n      sortCoordinatesByDistance(e) {\n        const t = e.slice(),\n          i = this.transform._camera.position,\n          o = this.transform._camera.forward(),\n          s = {};\n        for (const e of t) {\n          const t = 1 / (1 << e.canonical.z);\n          s[e.key] = ((e.canonical.x + .5) * t + e.wrap - i[0]) * o[0] + ((e.canonical.y + .5) * t - i[1]) * o[1] - i[2] * o[2];\n        }\n        return t.sort((e, t) => s[e.key] - s[t.key]), t;\n      }\n      hasTransition() {\n        if (this._source.hasTransition()) return !0;\n        if (Dt(this._source.type)) for (const t in this._tiles) {\n          const i = this._tiles[t];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.o.now()) return !0;\n        }\n        return !1;\n      }\n      setFeatureState(e, t, i) {\n        this._state.updateState(e = e || \"_geojsonTileLayer\", t, i);\n      }\n      removeFeatureState(e, t, i) {\n        this._state.removeFeatureState(e = e || \"_geojsonTileLayer\", t, i);\n      }\n      getFeatureState(e, t) {\n        return this._state.getState(e = e || \"_geojsonTileLayer\", t);\n      }\n      setDependencies(e, t, i) {\n        const o = this._tiles[e];\n        o && o.setDependencies(t, i);\n      }\n      reloadTilesForDependencies(e, t) {\n        for (const i in this._tiles) this._tiles[i].hasDependency(e, t) && this._reloadTile(+i, \"reloading\");\n        this._cache.filter(i => !i.hasDependency(e, t));\n      }\n      _preloadTiles(t, i) {\n        if (!this._sourceLoaded) {\n          const e = () => {\n            this._sourceLoaded && (this._source.off(\"data\", e), this._preloadTiles(t, i));\n          };\n          return void this._source.on(\"data\", e);\n        }\n        const o = new Map(),\n          s = Array.isArray(t) ? t : [t],\n          r = this.map.painter.terrain,\n          n = this.usedForTerrain && r ? r.getScaledDemTileSize() : this._source.tileSize;\n        for (const e of s) {\n          const t = e.coveringTiles({\n            tileSize: n,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom && !this.usedForTerrain,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain\n          });\n          for (const e of t) o.set(e.key, e);\n          this.usedForTerrain && e.updateElevation(!1);\n        }\n        const a = Array.from(o.values());\n        e.bw(a, (e, t) => {\n          const i = new Et(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster, this._source.worldview);\n          this._loadTile(i, e => {\n            \"raster-dem\" === this._source.type && i.dem && this._backfillDEM(i), t(e, i);\n          });\n        }, i);\n      }\n    }\n    function At(e, t) {\n      const i = Math.abs(2 * e.wrap) - +(e.wrap < 0),\n        o = Math.abs(2 * t.wrap) - +(t.wrap < 0);\n      return e.overscaledZ - t.overscaledZ || o - i || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x;\n    }\n    function Dt(e) {\n      return \"raster\" === e || \"image\" === e || \"video\" === e || \"custom\" === e;\n    }\n    function Lt(e, t) {\n      const i = 1 << e.z;\n      return [e.x / i + t, (e.x + 1) / i + t];\n    }\n    Rt.maxOverzooming = 10, Rt.maxUnderzooming = 3;\n    class Pt {\n      constructor(e) {\n        this.style = e, this.layersGotHidden = !1, this.layers = [];\n      }\n      processLayersChanged() {\n        this.layers = [];\n        const e = !1,\n          t = !1;\n        for (const i in this.style._mergedLayers) {\n          const o = this.style._mergedLayers[i];\n          if (\"fill-extrusion\" === o.type || \"building\" === o.type) this.layers.push({\n            layer: o,\n            visible: e,\n            visibilityChanged: t\n          });else if (\"model\" === o.type) {\n            const i = this.style.getLayerSource(o);\n            i && \"batched-model\" === i.type && this.layers.push({\n              layer: o,\n              visible: e,\n              visibilityChanged: t\n            });\n          }\n        }\n      }\n      onNewFrame(e) {\n        this.layersGotHidden = !1;\n        for (const t of this.layers) {\n          const i = t.layer;\n          let o = !1;\n          \"fill-extrusion\" === i.type ? o = !i.isHidden(e) && i.paint.get(\"fill-extrusion-opacity\") > 0 : \"building\" === i.type ? o = !i.isHidden(e) && i.paint.get(\"building-opacity\") > 0 : \"model\" === i.type && (o = !i.isHidden(e) && i.paint.get(\"model-opacity\").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o && t.visible, t.visible = o;\n        }\n      }\n      updateZOffset(e, t) {\n        this.currentBuildingBuckets = [];\n        for (const e of this.layers) {\n          const i = e.layer,\n            o = this.style.getLayerSourceCache(i);\n          let s = 1;\n          \"fill-extrusion\" === i.type ? s = e.visible ? i.paint.get(\"fill-extrusion-vertical-scale\") : 0 : \"building\" === i.type && (s = e.visible ? i.paint.get(\"building-vertical-scale\") : 0);\n          let r = o ? o.getTile(t) : null;\n          if (!r && o) for (const e in o._tiles) {\n            const i = o._tiles[e];\n            if (t.canonical.isChildOf(i.tileID.canonical)) {\n              r = i;\n              break;\n            }\n          }\n          this.currentBuildingBuckets.push({\n            bucket: r ? r.getBucket(i) : null,\n            tileID: r ? r.tileID : t,\n            verticalScale: s\n          });\n        }\n        e.hasAnyZOffset = !1;\n        let i = !1;\n        for (let o = 0; o < e.symbolInstances.length; o++) {\n          const s = e.symbolInstances.get(o),\n            r = s.zOffset,\n            n = this._getHeightAtTileOffset(t, s.tileAnchorX, s.tileAnchorY);\n          s.zOffset = n !== Number.NEGATIVE_INFINITY ? n : r, i || r === s.zOffset || (i = !0), e.hasAnyZOffset || 0 === s.zOffset || (e.hasAnyZOffset = !0);\n        }\n        i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);\n      }\n      _mapCoordToOverlappingTile(t, i, o, s) {\n        let r = i,\n          n = o;\n        if (t.canonical.z !== s.canonical.z) {\n          const a = s.canonical,\n            l = 1 / (1 << t.canonical.z - a.z);\n          r = (i + t.canonical.x * e.al) * l - a.x * e.al | 0, n = (o + t.canonical.y * e.al) * l - a.y * e.al | 0;\n        }\n        return {\n          tileX: r,\n          tileY: n\n        };\n      }\n      _getHeightAtTileOffset(e, t, i) {\n        let o, s;\n        for (let r = 0; r < this.layers.length; ++r) {\n          const n = this.layers[r].layer;\n          if (\"fill-extrusion\" !== n.type && \"building\" !== n.type) continue;\n          const {\n            bucket: a,\n            tileID: l,\n            verticalScale: c\n          } = this.currentBuildingBuckets[r];\n          if (!a) continue;\n          const {\n              tileX: h,\n              tileY: d\n            } = this._mapCoordToOverlappingTile(e, t, i, l),\n            u = a.getHeightAtTileCoord(h, d);\n          u && void 0 !== u.height && (u.hidden ? o = u.height : s = Math.max(u.height * c, s || 0));\n        }\n        if (void 0 !== s) return s;\n        for (let s = 0; s < this.layers.length; ++s) {\n          const r = this.layers[s];\n          if (\"model\" !== r.layer.type || !r.visible) continue;\n          const {\n            bucket: n,\n            tileID: a\n          } = this.currentBuildingBuckets[s];\n          if (!n) continue;\n          const {\n              tileX: l,\n              tileY: c\n            } = this._mapCoordToOverlappingTile(e, t, i, a),\n            h = n.getHeightAtTileCoord(l, c);\n          if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : h.height ? h.height * h.verticalScale : Number.NEGATIVE_INFINITY;\n        }\n        return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;\n      }\n    }\n    function zt(t, i) {\n      const o = {};\n      for (const e in t) \"ref\" !== e && (o[e] = t[e]);\n      return e.bx.forEach(e => {\n        e in i && (o[e] = i[e]);\n      }), o;\n    }\n    function Ot(e) {\n      e = e.slice();\n      const t = Object.create(null);\n      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];\n      for (let i = 0; i < e.length; i++) \"ref\" in e[i] && (e[i] = zt(e[i], t[e[i].ref]));\n      return e;\n    }\n    const Mt = {\n      setStyle: \"setStyle\",\n      addLayer: \"addLayer\",\n      removeLayer: \"removeLayer\",\n      setPaintProperty: \"setPaintProperty\",\n      setLayoutProperty: \"setLayoutProperty\",\n      setSlot: \"setSlot\",\n      setFilter: \"setFilter\",\n      addSource: \"addSource\",\n      removeSource: \"removeSource\",\n      setGeoJSONSourceData: \"setGeoJSONSourceData\",\n      setLayerZoomRange: \"setLayerZoomRange\",\n      setLayerProperty: \"setLayerProperty\",\n      setCenter: \"setCenter\",\n      setZoom: \"setZoom\",\n      setBearing: \"setBearing\",\n      setPitch: \"setPitch\",\n      setSprite: \"setSprite\",\n      setGlyphs: \"setGlyphs\",\n      setTransition: \"setTransition\",\n      setLight: \"setLight\",\n      setTerrain: \"setTerrain\",\n      setFog: \"setFog\",\n      setSnow: \"setSnow\",\n      setRain: \"setRain\",\n      setCamera: \"setCamera\",\n      setLights: \"setLights\",\n      setProjection: \"setProjection\",\n      addImport: \"addImport\",\n      removeImport: \"removeImport\",\n      updateImport: \"updateImport\",\n      addIconset: \"addIconset\",\n      removeIconset: \"removeIconset\"\n    };\n    function Ft(e, t, i) {\n      i.push({\n        command: Mt.addSource,\n        args: [e, t[e]]\n      });\n    }\n    function Bt(e, t, i) {\n      t.push({\n        command: Mt.removeSource,\n        args: [e]\n      }), i[e] = !0;\n    }\n    function kt(e, t, i, o) {\n      Bt(e, i, o), Ft(e, t, i);\n    }\n    function Nt(t, i, o) {\n      let s;\n      for (s in t[o]) if (t[o].hasOwnProperty(s) && \"data\" !== s && !e.by(t[o][s], i[o][s])) return !1;\n      for (s in i[o]) if (i[o].hasOwnProperty(s) && \"data\" !== s && !e.by(t[o][s], i[o][s])) return !1;\n      return !0;\n    }\n    function Ut(t, i, o, s, r, n) {\n      let a;\n      for (a in i = i || {}, t = t || {}) t.hasOwnProperty(a) && (e.by(t[a], i[a]) || o.push({\n        command: n,\n        args: [s, a, i[a], r]\n      }));\n      for (a in i) i.hasOwnProperty(a) && !t.hasOwnProperty(a) && (e.by(t[a], i[a]) || o.push({\n        command: n,\n        args: [s, a, i[a], r]\n      }));\n    }\n    function jt(e) {\n      return e.id;\n    }\n    function Vt(e, t) {\n      return e[t.id] = t, e;\n    }\n    function Gt(t, i, o) {\n      const s = i.createTileMatrix(t, t.worldSize, o.toUnwrapped());\n      return e.aB(new Float32Array(16), t.projMatrix, s);\n    }\n    function Ht(e, t, i) {\n      if (t.projection.name === i.projection.name) return e.projMatrix;\n      const o = i.clone();\n      return o.setProjection(t.projection), Gt(o, t.getProjection(), e);\n    }\n    function qt(e, t, i) {\n      return t.name === i.projection.name ? e.projMatrix : Gt(i, t, e);\n    }\n    class Zt {\n      constructor(e, t) {\n        this.reset(e, t);\n      }\n      reset(e, t) {\n        this.points = e || [], this._distances = [0];\n        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);\n        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n      }\n      lerp(t) {\n        if (1 === this.points.length) return this.points[0];\n        t = e.aA(t, 0, 1);\n        let i = 1,\n          o = this._distances[i];\n        const s = t * this.paddedLength + this.padding;\n        for (; o < s && i < this._distances.length;) o = this._distances[++i];\n        const r = i - 1,\n          n = this._distances[r],\n          a = o - n,\n          l = a > 0 ? (s - n) / a : 0;\n        return this.points[r].mult(1 - l).add(this.points[i].mult(l));\n      }\n    }\n    class Wt {\n      constructor(e, t, i) {\n        const o = this.boxCells = [],\n          s = this.circleCells = [];\n        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);\n        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), s.push([]);\n        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;\n      }\n      keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n      }\n      insert(e, t, i, o, s) {\n        this._forEachCell(t, i, o, s, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(s);\n      }\n      insertCircle(e, t, i, o) {\n        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);\n      }\n      _insertBoxCell(e, t, i, o, s, r) {\n        this.boxCells[s].push(r);\n      }\n      _insertCircleCell(e, t, i, o, s, r) {\n        this.circleCells[s].push(r);\n      }\n      _query(e, t, i, o, s, r) {\n        if (i < 0 || e > this.width || o < 0 || t > this.height) return !s && [];\n        const n = [];\n        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {\n          if (s) return !0;\n          for (let e = 0; e < this.boxKeys.length; e++) n.push({\n            key: this.boxKeys[e],\n            x1: this.bboxes[4 * e],\n            y1: this.bboxes[4 * e + 1],\n            x2: this.bboxes[4 * e + 2],\n            y2: this.bboxes[4 * e + 3]\n          });\n          for (let e = 0; e < this.circleKeys.length; e++) {\n            const t = this.circles[3 * e],\n              i = this.circles[3 * e + 1],\n              o = this.circles[3 * e + 2];\n            n.push({\n              key: this.circleKeys[e],\n              x1: t - o,\n              y1: i - o,\n              x2: t + o,\n              y2: i + o\n            });\n          }\n          return r ? n.filter(r) : n;\n        }\n        return this._forEachCell(e, t, i, o, this._queryCell, n, {\n          hitTest: s,\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, r), s ? n.length > 0 : n;\n      }\n      _queryCircle(e, t, i, o, s) {\n        const r = e - i,\n          n = e + i,\n          a = t - i,\n          l = t + i;\n        if (n < 0 || r > this.width || l < 0 || a > this.height) return !o && [];\n        const c = [];\n        return this._forEachCell(r, a, n, l, this._queryCellCircle, c, {\n          hitTest: o,\n          circle: {\n            x: e,\n            y: t,\n            radius: i\n          },\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, s), o ? c.length > 0 : c;\n      }\n      query(e, t, i, o, s) {\n        return this._query(e, t, i, o, !1, s);\n      }\n      hitTest(e, t, i, o, s) {\n        return this._query(e, t, i, o, !0, s);\n      }\n      hitTestCircle(e, t, i, o) {\n        return this._queryCircle(e, t, i, !0, o);\n      }\n      _queryCell(e, t, i, o, s, r, n, a) {\n        const l = n.seenUids,\n          c = this.boxCells[s];\n        if (null !== c) {\n          const s = this.bboxes;\n          for (const h of c) if (!l.box[h]) {\n            l.box[h] = !0;\n            const c = 4 * h;\n            if (e <= s[c + 2] && t <= s[c + 3] && i >= s[c + 0] && o >= s[c + 1] && (!a || a(this.boxKeys[h]))) {\n              if (n.hitTest) return r.push(!0), !0;\n              r.push({\n                key: this.boxKeys[h],\n                x1: s[c],\n                y1: s[c + 1],\n                x2: s[c + 2],\n                y2: s[c + 3]\n              });\n            }\n          }\n        }\n        const h = this.circleCells[s];\n        if (null !== h) {\n          const s = this.circles;\n          for (const c of h) if (!l.circle[c]) {\n            l.circle[c] = !0;\n            const h = 3 * c;\n            if (this._circleAndRectCollide(s[h], s[h + 1], s[h + 2], e, t, i, o) && (!a || a(this.circleKeys[c]))) {\n              if (n.hitTest) return r.push(!0), !0;\n              {\n                const e = s[h],\n                  t = s[h + 1],\n                  i = s[h + 2];\n                r.push({\n                  key: this.circleKeys[c],\n                  x1: e - i,\n                  y1: t - i,\n                  x2: e + i,\n                  y2: t + i\n                });\n              }\n            }\n          }\n        }\n      }\n      _queryCellCircle(e, t, i, o, s, r, n, a) {\n        const l = n.circle,\n          c = n.seenUids,\n          h = this.boxCells[s];\n        if (null !== h) {\n          const e = this.bboxes;\n          for (const t of h) if (!c.box[t]) {\n            c.box[t] = !0;\n            const i = 4 * t;\n            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t]))) return r.push(!0), !0;\n          }\n        }\n        const d = this.circleCells[s];\n        if (null !== d) {\n          const e = this.circles;\n          for (const t of d) if (!c.circle[t]) {\n            c.circle[t] = !0;\n            const i = 3 * t;\n            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t]))) return r.push(!0), !0;\n          }\n        }\n      }\n      _forEachCell(e, t, i, o, s, r, n, a) {\n        const l = this._convertToXCellCoord(e),\n          c = this._convertToYCellCoord(t),\n          h = this._convertToXCellCoord(i),\n          d = this._convertToYCellCoord(o);\n        for (let u = l; u <= h; u++) for (let l = c; l <= d; l++) if (s.call(this, e, t, i, o, this.xCellCount * l + u, r, n, a)) return;\n      }\n      _convertToXCellCoord(e) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));\n      }\n      _convertToYCellCoord(e) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));\n      }\n      _circlesCollide(e, t, i, o, s, r) {\n        const n = o - e,\n          a = s - t,\n          l = i + r;\n        return l * l > n * n + a * a;\n      }\n      _circleAndRectCollide(e, t, i, o, s, r, n) {\n        const a = (r - o) / 2,\n          l = Math.abs(e - (o + a));\n        if (l > a + i) return !1;\n        const c = (n - s) / 2,\n          h = Math.abs(t - (s + c));\n        if (h > c + i) return !1;\n        if (l <= a || h <= c) return !0;\n        const d = l - a,\n          u = h - c;\n        return d * d + u * u <= i * i;\n      }\n    }\n    const $t = {\n        unknown: 0,\n        flipRequired: 1,\n        flipNotRequired: 2\n      },\n      Xt = Math.tan(85 * Math.PI / 180);\n    function Yt(t, i, o, s, r, n, a) {\n      const l = e.bC();\n      if (o) {\n        if (\"globe\" === n.name) {\n          const t = e.bD(r, i);\n          e.aB(l, l, t);\n        } else {\n          const t = e.bE([], a);\n          l[0] = t[0], l[1] = t[1], l[4] = t[2], l[5] = t[3], s || e.bB(l, l, r.angle);\n        }\n      } else e.aB(l, r.labelPlaneMatrix, t);\n      return l;\n    }\n    function Kt(e, t, i, o, s, r, n) {\n      const a = Yt(e, t, i, o, s, r, n);\n      return \"globe\" === r.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;\n    }\n    function Jt(t, i, o, s, r, n, a) {\n      if (o) {\n        if (\"globe\" === n.name) {\n          const l = Yt(t, i, o, s, r, n, a);\n          return e.bl(l, l), e.aB(l, t, l), l;\n        }\n        {\n          const i = e.bz(t),\n            o = e.bA([]);\n          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.aB(i, i, o), s || e.bB(i, i, -r.angle), i;\n        }\n      }\n      return r.glCoordMatrix;\n    }\n    function Qt(t, i, o, s) {\n      const r = [t, i, o, 1];\n      o ? e.aC(r, r, s) : hi(r, r, s);\n      const n = r[3];\n      return r[0] /= n, r[1] /= n, r[2] /= n, r;\n    }\n    function ei(e, t) {\n      return Math.min(.5 + e / t * .5, 1.5);\n    }\n    function ti(e, t) {\n      const i = e[0] / e[3],\n        o = e[1] / e[3];\n      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];\n    }\n    function ii(t, i, o, s, r, n, a, l, c, h) {\n      const d = o.transform,\n        u = s ? t.textSizeData : t.iconSizeData,\n        _ = e.bK(u, o.transform.zoom),\n        p = \"globe\" === d.projection.name,\n        f = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n        m = s ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;\n      m.clear();\n      let g = null;\n      p && (g = s ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray);\n      const v = t.lineVertexArray,\n        y = s ? t.text.placedSymbolArray : t.icon.placedSymbolArray,\n        x = o.transform.width / o.transform.height;\n      let b,\n        w = !1;\n      for (let s = 0; s < y.length; s++) {\n        const p = y.get(s),\n          {\n            numGlyphs: T,\n            writingMode: E\n          } = p;\n        if (E !== e.bL.vertical || w || b === e.bL.horizontal || (w = !0), b = E, (p.hidden || E === e.bL.vertical) && !w) {\n          ci(T, m);\n          continue;\n        }\n        w = !1;\n        const S = new e.P(p.tileAnchorX, p.tileAnchorY);\n        let {\n          x: I,\n          y: C,\n          z: R\n        } = d.projection.projectTilePoint(S.x, S.y, h.canonical);\n        if (c) {\n          const [e, t, i] = c(S);\n          I += e, C += t, R += i;\n        }\n        const A = [I, C, R, 1];\n        if (e.aC(A, A, i), !ti(A, f)) {\n          ci(T, m);\n          continue;\n        }\n        const D = A[3],\n          L = ei(o.transform.getCameraToCenterDistance(d.projection), D),\n          P = e.bM(u, _, p),\n          z = a ? P / L : P * L,\n          O = Qt(I, C, R, r);\n        if (O[3] <= 0) {\n          ci(T, m);\n          continue;\n        }\n        let M = {};\n        const F = e.an(t.layers[0].layout.get(\"text-max-angle\")),\n          B = Math.cos(F),\n          k = a ? null : c,\n          N = ri(p, z, !1, l, i, r, n, t.glyphOffsetArray, v, m, g, O, S, M, x, k, d.projection, h, a, B);\n        w = N.useVertical, k && N.needsFlipping && (M = {}), (N.notEnoughRoom || w || N.needsFlipping && ri(p, z, !0, l, i, r, n, t.glyphOffsetArray, v, m, g, O, S, M, x, k, d.projection, h, a, B).notEnoughRoom) && ci(T, m);\n      }\n      s ? (t.text.dynamicLayoutVertexBuffer.updateData(m), g && t.text.globeExtVertexBuffer && t.text.globeExtVertexBuffer.updateData(g)) : (t.icon.dynamicLayoutVertexBuffer.updateData(m), g && t.icon.globeExtVertexBuffer && t.icon.globeExtVertexBuffer.updateData(g));\n    }\n    function oi(e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m) {\n      const {\n          lineStartIndex: g,\n          glyphStartIndex: v,\n          segment: y\n        } = a,\n        x = v + a.numGlyphs,\n        b = g + a.lineLength,\n        w = t.getoffsetX(v),\n        T = t.getoffsetX(x - 1),\n        E = li(e * w, i, o, s, r, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);\n      if (!E) return null;\n      const S = li(e * T, i, o, s, r, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);\n      return S ? {\n        first: E,\n        last: S\n      } : null;\n    }\n    function si(t, i, o, s) {\n      return t === e.bL.horizontal && Math.abs(s) > Math.abs(o) ? {\n        useVertical: !0\n      } : t === e.bL.vertical ? s > 0 ? {\n        needsFlipping: !0\n      } : null : i !== $t.unknown && function (e, t) {\n        return 0 === e || Math.abs(t / e) > Xt;\n      }(o, s) ? i === $t.flipRequired ? {\n        needsFlipping: !0\n      } : null : o < 0 ? {\n        needsFlipping: !0\n      } : null;\n    }\n    function ri(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {\n      const b = i / 24,\n        w = t.lineOffsetX * b,\n        T = t.lineOffsetY * b,\n        {\n          lineStartIndex: E,\n          glyphStartIndex: S,\n          numGlyphs: I,\n          segment: C,\n          writingMode: R,\n          flipState: A\n        } = t,\n        D = E + t.lineLength,\n        L = t => {\n          if (d) {\n            const [i, o, s] = t.up,\n              r = h.length;\n            e.bN(d, r + 0, i, o, s), e.bN(d, r + 1, i, o, s), e.bN(d, r + 2, i, o, s), e.bN(d, r + 3, i, o, s);\n          }\n          const [i, o, s] = t.point;\n          e.bO(h, i, o, s, t.angle);\n        };\n      if (I > 1) {\n        const e = oi(b, l, w, T, o, u, _, t, c, n, p, m, !1, g, v, y, x);\n        if (!e) return {\n          notEnoughRoom: !0\n        };\n        if (s && !o) {\n          let [i, o, s] = e.first.point,\n            [r, n, l] = e.last.point;\n          [i, o] = Qt(i, o, s, a), [r, n] = Qt(r, n, l, a);\n          const c = si(R, A, (r - i) * f, n - o);\n          if (t.flipState = c && c.needsFlipping ? $t.flipRequired : $t.flipNotRequired, c) return c;\n        }\n        L(e.first);\n        for (let e = S + 1; e < S + I - 1; e++) {\n          const t = li(b * l.getoffsetX(e), w, T, o, u, _, C, E, D, c, n, p, m, !1, !1, g, v, y, x);\n          if (!t) return h.length -= 4 * (e - S), {\n            notEnoughRoom: !0\n          };\n          L(t);\n        }\n        L(e.last);\n      } else {\n        if (s && !o) {\n          const i = Qt(_.x, _.y, 0, r),\n            o = E + C + 1,\n            s = new e.P(c.getx(o), c.gety(o)),\n            n = Qt(s.x, s.y, 0, r),\n            a = n[3] > 0 ? n : ai(_, s, i, 1, r, void 0, g, v.canonical),\n            l = si(R, A, (a[0] - i[0]) * f, a[1] - i[1]);\n          if (t.flipState = l && l.needsFlipping ? $t.flipRequired : $t.flipNotRequired, l) return l;\n        }\n        const i = li(b * l.getoffsetX(S), w, T, o, u, _, C, E, D, c, n, p, m, !1, !1, g, v, y, x);\n        if (!i) return {\n          notEnoughRoom: !0\n        };\n        L(i);\n      }\n      return {};\n    }\n    function ni(e, t, i, o, s) {\n      const {\n        x: r,\n        y: n,\n        z: a\n      } = o.projectTilePoint(e.x, e.y, t);\n      if (!s) return Qt(r, n, a, i);\n      const [l, c, h] = s(e);\n      return Qt(r + l, n + c, a + h, i);\n    }\n    function ai(t, i, o, s, r, n, a, l) {\n      const c = ni(t.sub(i)._unit()._add(t), l, r, a, n);\n      return e.av(c, o, c), e.aw(c, c), e.bH(c, o, c, s);\n    }\n    function li(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y) {\n      const x = s ? t - i : t + i;\n      let b = x > 0 ? 1 : -1,\n        w = 0;\n      s && (b *= -1, w = Math.PI), b < 0 && (w += Math.PI);\n      let T = l + a + (b > 0 ? 0 : 1) | 0,\n        E = r,\n        S = r,\n        I = 0,\n        C = 0;\n      const R = Math.abs(x),\n        A = [],\n        D = [];\n      let L = n,\n        P = L,\n        z = e.bF([]);\n      const O = () => ai(P, L, S, R - I + 1, d, _, m, g.canonical);\n      for (; I + C <= R;) {\n        if (T += b, T < l || T >= c) return null;\n        if (S = E, P = L, A.push(S), p && D.push(P), L = new e.P(h.getx(T), h.gety(T)), E = u[T], !E) {\n          const e = ni(L, g.canonical, d, m, _);\n          E = e[3] > 0 ? u[T] = e : O();\n        }\n        I += C;\n        const t = e.av([], E, S),\n          i = e.bG(S, E);\n        if (o && i > 0 && C > 0 && e.bJ(z, t) / (C * i) < y) return null;\n        C = i, z = t;\n      }\n      f && _ && (u[T] && (E = O(), C = e.bG(S, E), z = e.av([], E, S)), u[T] = E);\n      const M = (R - I) / C,\n        F = L.sub(P)._mult(M)._add(P),\n        B = e.bH([], S, z, M);\n      let k = [0, 0, 1],\n        N = z[0],\n        U = z[1];\n      if (v && (k = m.upVector(g.canonical, F.x, F.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {\n        const t = [k[2], 0, -k[0]],\n          i = e.bI([], k, t);\n        e.aw(t, t), e.aw(i, i), N = e.bJ(z, t), U = e.bJ(z, i);\n      }\n      if (o) {\n        const t = e.bI([], k, z);\n        e.aw(t, t), e.bH(B, B, t, o * b);\n      }\n      const j = w + Math.atan2(U, N);\n      return A.push(B), p && D.push(F), {\n        point: B,\n        angle: j,\n        path: A,\n        tilePath: D,\n        up: k\n      };\n    }\n    function ci(e, t) {\n      const i = t.length,\n        o = i + 4 * e;\n      t.resize(o), t.float32.fill(-1 / 0, 4 * i, 4 * o);\n    }\n    function hi(e, t, i) {\n      const o = t[0],\n        s = t[1];\n      return e[0] = i[0] * o + i[4] * s + i[12], e[1] = i[1] * o + i[5] * s + i[13], e[3] = i[3] * o + i[7] * s + i[15], e;\n    }\n    const di = 100;\n    class ui {\n      constructor(e, t) {\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Wt(e.width + 200, e.height + 200, 25);\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Wt(e.width + 200, e.height + 200, 25);\n        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + di, this.screenBottomBoundary = e.height + di, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;\n      }\n      placeCollisionBox(t, i, o, s, r, n, a, l, c, h, d) {\n        let u = o.projectedAnchorX,\n          _ = o.projectedAnchorY,\n          p = o.projectedAnchorZ;\n        const f = o.tileAnchorX,\n          m = o.tileAnchorY,\n          g = o.elevation,\n          v = o.tileID,\n          y = t.getProjection();\n        if (g && v) {\n          const [e, t, i] = y.upVector(v.canonical, o.tileAnchorX, o.tileAnchorY),\n            s = y.upVectorScale(v.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;\n          u += e * g * s, _ += t * g * s, p += i * g * s;\n        }\n        const x = \"globe\" === t.projection.name,\n          b = \"globe\" === t.projection.name ? e.aj(this.transform.zoom) : 0;\n        if (v && x && b < 1 && !n) {\n          const t = 1 << v.canonical.z,\n            i = e.bP(f, m);\n          e.bQ(i, i, 1 / e.al), e.bR(i, i, e.bP(v.canonical.x, v.canonical.y)), e.bQ(i, i, 1 / t), e.bS(i, i, e.bP(s[0], s[1])), i[0] = e.bT(i[0], -.5, .5), e.bQ(i, i, e.al);\n          const o = e.bU(i[0], i[1], e.al / (2 * Math.PI), 1);\n          e.aC(o, o, r), u = e.ak(u, o[0], b), _ = e.ak(_, o[1], b), p = e.ak(p, o[2], b);\n        }\n        const w = this.projectAndGetPerspectiveRatio(h, u, _, p, o.tileID, \"globe\" === y.name || !!g || this.transform.pitch > 0, y),\n          T = c * w.perspectiveRatio,\n          E = (o.x1 * i + a.x - o.padding) * T + w.point.x,\n          S = (o.y1 * i + a.y - o.padding) * T + w.point.y,\n          I = (o.x2 * i + a.x + o.padding) * T + w.point.x,\n          C = (o.y2 * i + a.y + o.padding) * T + w.point.y,\n          R = w.perspectiveRatio <= .55 || w.occluded;\n        return !this.isInsideGrid(E, S, I, C) || !l && this.grid.hitTest(E, S, I, C, d) || R ? {\n          box: [],\n          offscreen: !1,\n          occluded: w.occluded\n        } : {\n          box: [E, S, I, C],\n          offscreen: this.isOffscreen(E, S, I, C),\n          occluded: !1\n        };\n      }\n      placeCollisionCircles(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f) {\n        const m = [],\n          g = this.transform.elevation,\n          v = t.getProjection(),\n          y = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, v) : null,\n          x = new e.P(o.tileAnchorX, o.tileAnchorY);\n        let {\n          x: b,\n          y: w,\n          z: T\n        } = v.projectTilePoint(x.x, x.y, f.canonical);\n        if (y) {\n          const [e, t, i] = y(x);\n          b += e, w += t, T += i;\n        }\n        const E = \"globe\" === v.name,\n          S = this.projectAndGetPerspectiveRatio(a, b, w, T, f, E || !!g || this.transform.pitch > 0, v),\n          {\n            perspectiveRatio: I\n          } = S,\n          C = (d ? n / I : n * I) / e.bX,\n          R = Qt(b, w, T, l),\n          A = o.lineOffsetX * C,\n          D = o.lineOffsetY * C,\n          L = e.an(t.layers[0].layout.get(\"text-max-angle\")),\n          P = Math.cos(L),\n          z = S.signedDistanceFromCamera > 0 ? oi(C, r, A, D, !1, R, x, o, s, l, {}, g && !d ? y : null, d && !!g, v, f, d, P) : null;\n        let O = !1,\n          M = !1,\n          F = !0;\n        if (z && !S.occluded) {\n          const t = .5 * _ * I + p,\n            o = new e.P(-100, -100),\n            s = new e.P(this.screenRightBoundary, this.screenBottomBoundary),\n            r = new Zt(),\n            {\n              first: n,\n              last: a\n            } = z,\n            l = n.path.length;\n          let d = [];\n          for (let e = l - 1; e >= 1; e--) d.push(n.path[e]);\n          for (let e = 1; e < a.path.length; e++) d.push(a.path[e]);\n          const f = 2.5 * t;\n          c && (d = d.map((_ref87, o) => {\n            let [e, t, i] = _ref87;\n            return y && !E && (i = y(o < l - 1 ? n.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), Qt(e, t, i, c);\n          }), d.some(e => e[3] <= 0) && (d = []));\n          let g = [];\n          if (d.length > 0) {\n            let t = 1 / 0,\n              i = -1 / 0,\n              r = 1 / 0,\n              n = -1 / 0;\n            for (const e of d) t = Math.min(t, e[0]), r = Math.min(r, e[1]), i = Math.max(i, e[0]), n = Math.max(n, e[1]);\n            i >= o.x && t <= s.x && n >= o.y && r <= s.y && (g = [d.map(t => new e.P(t[0], t[1]))], (t < o.x || i > s.x || r < o.y || n > s.y) && (g = e.bV(g, o.x, o.y, s.x, s.y)));\n          }\n          for (const e of g) {\n            r.reset(e, .25 * t);\n            let o = 0;\n            o = r.length <= .5 * t ? 1 : Math.ceil(r.paddedLength / f) + 1;\n            for (let e = 0; e < o; e++) {\n              const s = e / Math.max(o - 1, 1),\n                n = r.lerp(s),\n                a = n.x + di,\n                l = n.y + di;\n              m.push(a, l, t, 0);\n              const c = a - t,\n                d = l - t,\n                _ = a + t,\n                p = l + t;\n              if (F = F && this.isOffscreen(c, d, _, p), M = M || this.isInsideGrid(c, d, _, p), !i && this.grid.hitTestCircle(a, l, t, u) && (O = !0, !h)) return {\n                circles: [],\n                offscreen: !1,\n                collisionDetected: O,\n                occluded: !1\n              };\n            }\n          }\n        }\n        return {\n          circles: !h && O || !M ? [] : m,\n          offscreen: F,\n          collisionDetected: O,\n          occluded: S.occluded\n        };\n      }\n      queryRenderedSymbols(t) {\n        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n        const i = [];\n        let o = 1 / 0,\n          s = 1 / 0,\n          r = -1 / 0,\n          n = -1 / 0;\n        for (const a of t) {\n          const t = new e.P(a.x + di, a.y + di);\n          o = Math.min(o, t.x), s = Math.min(s, t.y), r = Math.max(r, t.x), n = Math.max(n, t.y), i.push(t);\n        }\n        const a = this.grid.query(o, s, r, n).concat(this.ignoredGrid.query(o, s, r, n)),\n          l = {},\n          c = {};\n        for (const t of a) {\n          const o = t.key;\n          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;\n          const s = [new e.P(t.x1, t.y1), new e.P(t.x2, t.y1), new e.P(t.x2, t.y2), new e.P(t.x1, t.y2)];\n          e.bW(i, s) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));\n        }\n        return c;\n      }\n      insertCollisionBox(e, t, i, o, s) {\n        (t ? this.ignoredGrid : this.grid).insert({\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: s\n        }, e[0], e[1], e[2], e[3]);\n      }\n      insertCollisionCircles(e, t, i, o, s) {\n        const r = t ? this.ignoredGrid : this.grid,\n          n = {\n            bucketInstanceId: i,\n            featureIndex: o,\n            collisionGroupID: s\n          };\n        for (let t = 0; t < e.length; t += 4) r.insertCircle(n, e[t], e[t + 1], e[t + 2]);\n      }\n      projectAndGetPerspectiveRatio(t, i, o, s, r, n, a) {\n        const l = [i, o, s, 1];\n        let c = !1;\n        if (s || this.transform.pitch > 0) {\n          if (e.aC(l, l, t), this.fogState && r && \"globe\" !== a.name) {\n            const t = function (t, i, o, s, r, n) {\n              const a = n.calculateFogTileMatrix(r),\n                l = [i, o, s];\n              return e.af(l, l, a), ke(t, e.ag(l), n.pitch, n._fov);\n            }(this.fogState, i, o, s, r.toUnwrapped(), this.transform);\n            c = t > .9;\n          }\n        } else hi(l, l, t);\n        const h = l[3];\n        return {\n          point: new e.P((l[0] / h + 1) / 2 * this.transform.width + di, (-l[1] / h + 1) / 2 * this.transform.height + di),\n          perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),\n          signedDistanceFromCamera: h,\n          occluded: n && l[2] > h || c\n        };\n      }\n      isOffscreen(e, t, i, o) {\n        return i < di || e >= this.screenRightBoundary || o < di || t > this.screenBottomBoundary;\n      }\n      isInsideGrid(e, t, i, o) {\n        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;\n      }\n      getViewportMatrix() {\n        const t = e.bA([]);\n        return e.br(t, t, [-100, -100, 0]), t;\n      }\n    }\n    class _i {\n      constructor(e, t, i, o) {\n        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;\n      }\n      isHidden() {\n        return 0 === this.opacity && !this.placed;\n      }\n    }\n    class pi {\n      constructor(e, t, i, o, s) {\n        let r = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;\n        this.text = new _i(e ? e.text : null, t, i, s), this.icon = new _i(e ? e.icon : null, t, o, s), this.clipped = r;\n      }\n      isHidden() {\n        return this.text.isHidden() && this.icon.isHidden();\n      }\n    }\n    class fi {\n      constructor(e, t, i) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;\n      }\n    }\n    class mi {\n      constructor() {\n        this.invProjMatrix = e.bC(), this.viewportMatrix = e.bC(), this.circles = [];\n      }\n    }\n    class gi {\n      constructor(e, t, i, o, s) {\n        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = s;\n      }\n    }\n    class vi {\n      constructor(e) {\n        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};\n      }\n      get(e) {\n        if (this.crossSourceCollisions) return {\n          ID: 0,\n          predicate: null\n        };\n        if (!this.collisionGroups[e]) {\n          const t = ++this.maxGroupID;\n          this.collisionGroups[e] = {\n            ID: t,\n            predicate: e => e.collisionGroupID === t\n          };\n        }\n        return this.collisionGroups[e];\n      }\n    }\n    function yi(t, i, o, s, r) {\n      const {\n          horizontalAlign: n,\n          verticalAlign: a\n        } = e.c0(t),\n        l = -(n - .5) * i,\n        c = -(a - .5) * o,\n        h = e.c1(t, s);\n      return new e.P(l + h[0] * r, c + h[1] * r);\n    }\n    function xi(t, i, o, s, r) {\n      const n = new e.P(t, i);\n      return o && n._rotate(s ? r : -r), n;\n    }\n    class bi {\n      constructor(e, t, i, o, s, r) {\n        this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new ui(this.transform, s), this.buildingIndex = r, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new vi(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n      }\n      getBucketParts(t, i, o, s) {\n        let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n        const n = o.getBucket(i),\n          a = o.latestFeatureIndex;\n        if (!n || !a || i.fqid !== n.layerIds[0]) return;\n        const l = n.layers[0].layout,\n          c = n.layers[0].paint,\n          h = o.collisionBoxArray,\n          d = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n          u = o.tileSize / e.al,\n          _ = o.tileID.toUnwrapped();\n        this.transform.setProjection(n.projection);\n        const p = (f = o.tileID, m = n.getProjection(), g = this.transform, m.name === this.projection ? g.calculateProjMatrix(f.toUnwrapped()) : Gt(g, m, f));\n        var f, m, g;\n        const v = \"map\" === l.get(\"text-pitch-alignment\"),\n          y = \"map\" === l.get(\"text-rotation-alignment\");\n        i.compileFilter(i.options);\n        const x = i.dynamicFilter(),\n          b = i.dynamicFilterNeedsFeature(),\n          w = this.transform.calculatePixelsToTileUnitsMatrix(o),\n          T = Kt(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);\n        let E = null;\n        const S = n.getProjection().createInversionMatrix(this.transform, o.tileID.canonical);\n        if (v) {\n          const t = Jt(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);\n          E = e.aB([], this.transform.labelPlaneMatrix, t);\n        }\n        let I = null;\n        x && o.latestFeatureIndex && (I = {\n          unwrappedTileID: _,\n          dynamicFilter: x,\n          dynamicFilterNeedsFeature: b\n        }), this.retainedQueryData[n.bucketInstanceId] = new gi(n.bucketInstanceId, a, n.sourceLayerIndex, n.index, o.tileID);\n        const [C, R] = n.layers[0].layout.get(\"text-size-scale-range\"),\n          A = e.aA(r, C, R),\n          [D, L] = l.get(\"icon-size-scale-range\"),\n          P = e.aA(r, D, L),\n          z = {\n            bucket: n,\n            layout: l,\n            paint: c,\n            posMatrix: p,\n            invMatrix: S,\n            mercatorCenter: [e.aF(this.transform.center.lng), e.aJ(this.transform.center.lat)],\n            textLabelPlaneMatrix: T,\n            labelToScreenMatrix: E,\n            clippingData: I,\n            scale: d,\n            textPixelRatio: u,\n            holdingForFade: o.holdingForFade(),\n            collisionBoxArray: h,\n            partiallyEvaluatedTextSize: e.bK(n.textSizeData, this.transform.zoom, A),\n            partiallyEvaluatedIconSize: e.bK(n.iconSizeData, this.transform.zoom, P),\n            collisionGroup: this.collisionGroups.get(n.sourceID),\n            latestFeatureIndex: o.latestFeatureIndex\n          };\n        if (s) for (const e of n.sortKeyRanges) {\n          const {\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: s\n          } = e;\n          t.push({\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: s,\n            parameters: z\n          });\n        } else t.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: n.symbolInstances.length,\n          parameters: z\n        });\n      }\n      attemptAnchorPlacement(e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {\n        const {\n            textOffset0: b,\n            textOffset1: w,\n            crossTileID: T\n          } = p,\n          E = [b, w],\n          S = yi(e, r, n, E, a),\n          I = this.collisionIndex.placeCollisionBox(m, a, t, i, o, s, xi(S.x, S.y, l, c, this.transform.angle), _, h, d, u.predicate);\n        if (v) {\n          const e = m.getSymbolInstanceIconSize(x, this.transform.zoom, p.placedIconSymbolIndex);\n          if (0 === this.collisionIndex.placeCollisionBox(m, e, v, i, o, s, xi(S.x, S.y, l, c, this.transform.angle), _, h, d, u.predicate).box.length) return;\n        }\n        if (I.box.length > 0) {\n          let t;\n          return this.prevPlacement && this.prevPlacement.variableOffsets[T] && this.prevPlacement.placements[T] && this.prevPlacement.placements[T].text && (t = this.prevPlacement.variableOffsets[T].anchor), this.variableOffsets[T] = {\n            textOffset: E,\n            width: r,\n            height: n,\n            anchor: e,\n            textScale: a,\n            prevAnchor: t\n          }, this.markUsedJustification(m, e, p, g), m.allowVerticalPlacement && (this.markUsedOrientation(m, g, p), this.placedOrientations[T] = g), {\n            shift: S,\n            placedGlyphBoxes: I\n          };\n        }\n      }\n      placeLayerBucketPart(t, i, o, s) {\n        let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n        const {\n            bucket: n,\n            layout: a,\n            paint: l,\n            posMatrix: c,\n            textLabelPlaneMatrix: h,\n            labelToScreenMatrix: d,\n            clippingData: u,\n            textPixelRatio: _,\n            mercatorCenter: p,\n            invMatrix: f,\n            holdingForFade: m,\n            collisionBoxArray: g,\n            partiallyEvaluatedTextSize: v,\n            partiallyEvaluatedIconSize: y,\n            collisionGroup: x,\n            latestFeatureIndex: b\n          } = t.parameters,\n          w = a.get(\"text-optional\"),\n          T = a.get(\"icon-optional\"),\n          E = a.get(\"text-allow-overlap\"),\n          S = a.get(\"icon-allow-overlap\"),\n          I = \"map\" === a.get(\"text-rotation-alignment\"),\n          C = \"map\" === a.get(\"icon-rotation-alignment\"),\n          R = \"map\" === a.get(\"text-pitch-alignment\"),\n          A = l.get(\"symbol-z-offset\"),\n          D = \"sea\" === a.get(\"symbol-elevation-reference\"),\n          L = a.get(\"symbol-placement\"),\n          [P, z] = a.get(\"text-size-scale-range\"),\n          [O, M] = a.get(\"icon-size-scale-range\"),\n          F = e.aA(r, P, z),\n          B = e.aA(r, O, M),\n          k = a.get(\"text-variable-anchor\"),\n          N = I && \"point\" !== L,\n          U = C && \"point\" !== L,\n          j = k && n.hasTextData(),\n          V = n.hasIconTextFit() && j && n.hasIconData();\n        this.transform.setProjection(n.projection);\n        const G = j || N,\n          H = U || V;\n        let q = E && (S || !n.hasIconData() || T),\n          Z = S && (E || !n.hasTextData() || w);\n        const W = !A.isConstant();\n        !n.collisionArrays && g && n.deserializeCollisionBoxes(g), o && s && n.updateCollisionDebugBuffers(this.transform.zoom, g, F, B);\n        const $ = (t, s, r) => {\n            const {\n              crossTileID: l,\n              numVerticalGlyphVertices: g\n            } = t;\n            let C = null;\n            if (u && u.dynamicFilterNeedsFeature || W) {\n              const e = this.retainedQueryData[n.bucketInstanceId];\n              C = b.loadFeature({\n                featureIndex: t.featureIndex,\n                bucketIndex: e.bucketIndex,\n                sourceLayerIndex: e.sourceLayerIndex,\n                layoutVertexArrayOffset: 0\n              });\n            }\n            if (u && !(0, u.dynamicFilter)({\n              zoom: this.transform.zoom,\n              pitch: this.transform.pitch\n            }, C, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.P(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return this.placements[l] = new fi(!1, !1, !1, !0), void i.add(l);\n            const L = A.evaluate(C, {});\n            if (i.has(l)) return;\n            if (m) return void (this.placements[l] = new fi(!1, !1, !1));\n            let P = !1,\n              z = !1,\n              O = !0,\n              M = !1,\n              F = !1,\n              B = null,\n              N = {\n                box: null,\n                offscreen: null,\n                occluded: null\n              },\n              U = {\n                box: null\n              },\n              j = null,\n              V = null,\n              $ = null,\n              X = 0,\n              Y = 0,\n              K = 0;\n            r.textFeatureIndex ? X = r.textFeatureIndex : t.useRuntimeCollisionCircles && (X = t.featureIndex), r.verticalTextFeatureIndex && (Y = r.verticalTextFeatureIndex);\n            const J = e => {\n                e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;\n                const i = this.transform.elevation;\n                e.elevation = D ? L : L + (i ? i.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0), e.elevation += t.zOffset;\n              },\n              Q = r.textBox;\n            if (Q) {\n              J(Q);\n              const i = i => {\n                  let o = e.bL.horizontal;\n                  if (n.allowVerticalPlacement && !i && this.prevPlacement) {\n                    const e = this.prevPlacement.placedOrientations[l];\n                    e && (this.placedOrientations[l] = e, o = e, this.markUsedOrientation(n, o, t));\n                  }\n                  return o;\n                },\n                o = (t, i) => {\n                  if (n.allowVerticalPlacement && g > 0 && r.verticalTextBox) {\n                    for (const o of n.writingModes) if (o === e.bL.vertical ? (N = i(), U = N) : N = t(), N && N.box && N.box.length) break;\n                  } else N = t();\n                };\n              if (k) {\n                let a = k;\n                if (this.prevPlacement && this.prevPlacement.variableOffsets[l]) {\n                  const e = this.prevPlacement.variableOffsets[l];\n                  a.indexOf(e.anchor) > 0 && (a = a.filter(t => t !== e.anchor), a.unshift(e.anchor));\n                }\n                const h = (e, i, o) => {\n                  const r = n.getSymbolInstanceTextSize(v, t, this.transform.zoom, s),\n                    l = (e.x2 - e.x1) * r + 2 * e.padding,\n                    h = (e.y2 - e.y1) * r + 2 * e.padding,\n                    d = t.hasIconTextFit && !S ? i : null;\n                  d && J(d);\n                  let u = {\n                    box: [],\n                    offscreen: !1,\n                    occluded: !1\n                  };\n                  const m = E ? 2 * a.length : a.length;\n                  for (let i = 0; i < m; ++i) {\n                    const m = this.attemptAnchorPlacement(a[i % a.length], e, p, f, G, l, h, r, I, R, _, c, x, i >= a.length, t, s, n, o, d, v, y);\n                    if (m && (u = m.placedGlyphBoxes, u && u.box && u.box.length)) {\n                      P = !0, B = m.shift;\n                      break;\n                    }\n                  }\n                  return u;\n                };\n                o(() => h(Q, r.iconBox, e.bL.horizontal), () => {\n                  const t = r.verticalTextBox;\n                  return t && J(t), n.allowVerticalPlacement && !(N && N.box && N.box.length) && g > 0 && t ? h(t, r.verticalIconBox, e.bL.vertical) : {\n                    box: null,\n                    offscreen: null,\n                    occluded: null\n                  };\n                }), N && (P = N.box, O = N.offscreen, M = N.occluded);\n                const d = i(!(!N || !N.box));\n                if (!P && this.prevPlacement) {\n                  const e = this.prevPlacement.variableOffsets[l];\n                  e && (this.variableOffsets[l] = e, this.markUsedJustification(n, e.anchor, t, d));\n                }\n              } else {\n                const a = (i, o) => {\n                  const r = n.getSymbolInstanceTextSize(v, t, this.transform.zoom, s),\n                    a = this.collisionIndex.placeCollisionBox(n, r, i, p, f, G, new e.P(0, 0), E, _, c, x.predicate);\n                  return a && a.box && a.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[l] = o), a;\n                };\n                o(() => a(Q, e.bL.horizontal), () => {\n                  const t = r.verticalTextBox;\n                  return n.allowVerticalPlacement && g > 0 && t ? (J(t), a(t, e.bL.vertical)) : {\n                    box: null,\n                    offscreen: null,\n                    occluded: null\n                  };\n                }), i(!!(N && N.box && N.box.length));\n              }\n            }\n            if (j = N, P = j && j.box && j.box.length > 0, O = j && j.offscreen, M = j && j.occluded, t.useRuntimeCollisionCircles) {\n              const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),\n                s = e.bM(n.textSizeData, v, i),\n                r = a.get(\"text-padding\");\n              V = this.collisionIndex.placeCollisionCircles(n, E, i, n.lineVertexArray, n.glyphOffsetArray, s, c, h, d, o, R, x.predicate, t.collisionCircleDiameter * s / e.bX, r, this.retainedQueryData[n.bucketInstanceId].tileID), P = E || V.circles.length > 0 && !V.collisionDetected, O = O && V.offscreen, M = V.occluded;\n            }\n            if (r.iconFeatureIndex && (K = r.iconFeatureIndex), r.iconBox) {\n              const i = i => {\n                J(i);\n                const o = t.hasIconTextFit && B ? xi(B.x, B.y, I, R, this.transform.angle) : new e.P(0, 0),\n                  s = n.getSymbolInstanceIconSize(y, this.transform.zoom, t.placedIconSymbolIndex);\n                return this.collisionIndex.placeCollisionBox(n, s, i, p, f, H, o, S, _, c, x.predicate);\n              };\n              U && U.box && U.box.length && r.verticalIconBox ? ($ = i(r.verticalIconBox), z = $.box.length > 0) : ($ = i(r.iconBox), z = $.box.length > 0), O = O && $.offscreen, F = $.occluded;\n            }\n            const ee = w || 0 === t.numHorizontalGlyphVertices && 0 === g,\n              te = T || 0 === t.numIconVertices;\n            if (ee || te ? te ? ee || (z = z && P) : P = z && P : z = P = z && P, P && j && j.box && this.collisionIndex.insertCollisionBox(j.box, a.get(\"text-ignore-placement\"), n.bucketInstanceId, U && U.box && Y ? Y : X, x.ID), z && $ && this.collisionIndex.insertCollisionBox($.box, a.get(\"icon-ignore-placement\"), n.bucketInstanceId, K, x.ID), V && (P && this.collisionIndex.insertCollisionCircles(V.circles, a.get(\"text-ignore-placement\"), n.bucketInstanceId, X, x.ID), o)) {\n              const e = n.bucketInstanceId;\n              let t = this.collisionCircleArrays[e];\n              void 0 === t && (t = this.collisionCircleArrays[e] = new mi());\n              for (let e = 0; e < V.circles.length; e += 4) t.circles.push(V.circles[e + 0]), t.circles.push(V.circles[e + 1]), t.circles.push(V.circles[e + 2]), t.circles.push(V.collisionDetected ? 1 : 0);\n            }\n            const ie = \"globe\" !== n.projection.name;\n            q = q && (ie || !M), Z = Z && (ie || !F), this.placements[l] = new fi(P || q, z || Z, O || n.justReloaded), i.add(l);\n          },\n          X = this.retainedQueryData[n.bucketInstanceId].tileID;\n        if (\"offset\" === n.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n, X), \"road\" === n.elevationType && n.updateRoadElevation(X.canonical), n.updateZOffset(), n.sortFeaturesByY) {\n          const t = n.getSortedSymbolIndexes(this.transform.angle);\n          for (let e = t.length - 1; e >= 0; --e) {\n            const i = t[e];\n            $(n.symbolInstances.get(i), i, n.collisionArrays[i]);\n          }\n          n.hasAnyZOffset && e.w(\"\".concat(n.layerIds[0], \" layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y\"));\n        } else if (n.hasAnyZOffset) {\n          const e = n.getSortedIndexesByZOffset();\n          for (let t = 0; t < e.length; ++t) {\n            const i = e[t];\n            $(n.symbolInstances.get(i), i, n.collisionArrays[i]);\n          }\n        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) $(n.symbolInstances.get(e), e, n.collisionArrays[e]);\n        if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n          const t = this.collisionCircleArrays[n.bucketInstanceId];\n          e.bl(t.invProjMatrix, c), t.viewportMatrix = this.collisionIndex.getViewportMatrix();\n        }\n        n.justReloaded = !1;\n      }\n      markUsedJustification(t, i, o, s) {\n        const {\n            leftJustifiedTextSymbolIndex: r,\n            centerJustifiedTextSymbolIndex: n,\n            rightJustifiedTextSymbolIndex: a,\n            verticalPlacedTextSymbolIndex: l,\n            crossTileID: c\n          } = o,\n          h = e.c2(i),\n          d = s === e.bL.vertical ? l : \"left\" === h ? r : \"center\" === h ? n : \"right\" === h ? a : -1;\n        r >= 0 && (t.text.placedSymbolArray.get(r).crossTileID = d >= 0 && r !== d ? 0 : c), n >= 0 && (t.text.placedSymbolArray.get(n).crossTileID = d >= 0 && n !== d ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = d >= 0 && a !== d ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = d >= 0 && l !== d ? 0 : c);\n      }\n      markUsedOrientation(t, i, o) {\n        const s = i === e.bL.horizontal || i === e.bL.horizontalOnly ? i : 0,\n          r = i === e.bL.vertical ? i : 0,\n          {\n            leftJustifiedTextSymbolIndex: n,\n            centerJustifiedTextSymbolIndex: a,\n            rightJustifiedTextSymbolIndex: l,\n            verticalPlacedTextSymbolIndex: c\n          } = o,\n          h = t.text.placedSymbolArray;\n        n >= 0 && (h.get(n).placedOrientation = s), a >= 0 && (h.get(a).placedOrientation = s), l >= 0 && (h.get(l).placedOrientation = s), c >= 0 && (h.get(c).placedOrientation = r);\n      }\n      commit(e) {\n        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;\n        const t = this.prevPlacement;\n        let i = !1;\n        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;\n        const o = t ? t.symbolFadeChange(e) : 1,\n          s = t ? t.opacities : {},\n          r = t ? t.variableOffsets : {},\n          n = t ? t.placedOrientations : {};\n        for (const e in this.placements) {\n          const t = this.placements[e],\n            r = s[e];\n          r ? (this.opacities[e] = new pi(r, o, t.text, t.icon, null, t.clipped), i = i || t.text !== r.text.placed || t.icon !== r.icon.placed) : (this.opacities[e] = new pi(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);\n        }\n        for (const e in s) {\n          const t = s[e];\n          if (!this.opacities[e]) {\n            const s = new pi(t, o, !1, !1);\n            s.isHidden() || (this.opacities[e] = s, i = i || t.text.placed || t.icon.placed);\n          }\n        }\n        for (const e in r) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = r[e]);\n        for (const e in n) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = n[e]);\n        i ? this.lastPlacementChangeTime = e : \"number\" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);\n      }\n      updateLayerOpacities(e, t, i, o) {\n        const s = new Set();\n        for (const r of t) {\n          const t = r.getBucket(e);\n          t && r.latestFeatureIndex && e.fqid === t.layerIds[0] && (this.updateBucketOpacities(t, s, r, r.collisionBoxArray, i, o, r.tileID, e.scope), \"offset\" === t.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t, r.tileID), \"road\" === t.elevationType && t.updateRoadElevation(r.tileID.canonical), t.updateZOffset());\n        }\n      }\n      updateBucketOpacities(t, i, o, s, r, n, a, l) {\n        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();\n        const c = t.layers[0].layout,\n          h = t.layers[0].paint,\n          d = !!t.layers[0].dynamicFilter(),\n          u = new pi(null, 0, !1, !1, !0),\n          _ = c.get(\"text-allow-overlap\"),\n          p = c.get(\"icon-allow-overlap\"),\n          f = c.get(\"text-variable-anchor\"),\n          m = \"map\" === c.get(\"text-rotation-alignment\"),\n          g = \"map\" === c.get(\"text-pitch-alignment\"),\n          v = h.get(\"symbol-z-offset\"),\n          y = \"sea\" === c.get(\"symbol-elevation-reference\"),\n          x = !v.isConstant(),\n          b = new pi(null, 0, _ && (p || !t.hasIconData() || c.get(\"icon-optional\")), p && (_ || !t.hasTextData() || c.get(\"text-optional\")), !0);\n        !t.collisionArrays && s && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(s);\n        const w = (e, t, i) => {\n          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);\n        };\n        let T = 0;\n        n && t.updateReplacement(a, n);\n        for (let s = 0; s < t.symbolInstances.length; s++) {\n          const c = t.symbolInstances.get(s),\n            {\n              numHorizontalGlyphVertices: h,\n              numVerticalGlyphVertices: _,\n              crossTileID: p,\n              numIconVertices: E,\n              tileAnchorX: S,\n              tileAnchorY: I\n            } = c;\n          let C = null;\n          const R = this.retainedQueryData[t.bucketInstanceId];\n          x && c && R && (C = o.latestFeatureIndex.loadFeature({\n            featureIndex: c.featureIndex,\n            bucketIndex: R.bucketIndex,\n            sourceLayerIndex: R.sourceLayerIndex,\n            layoutVertexArrayOffset: 0\n          }));\n          const A = v.evaluate(C, {}),\n            D = i.has(p);\n          let L = this.opacities[p];\n          D ? L = u : L || (L = b, this.opacities[p] = L), i.add(p);\n          const P = h > 0 || _ > 0,\n            z = E > 0,\n            O = this.placedOrientations[p],\n            M = O === e.bL.vertical,\n            F = O === e.bL.horizontal || O === e.bL.horizontalOnly;\n          !P && !z || L.isHidden() || T++;\n          let B = !1;\n          if ((P || z) && n) for (const i of t.activeReplacements) {\n            if (e.bY(i, r, e.bZ.Symbol, l)) continue;\n            if (i.min.x > S || S > i.max.x || i.min.y > I || I > i.max.y) continue;\n            const t = e.b_(S, I, a.canonical, i.footprintTileId.canonical);\n            if (B = e.b$(t, i.footprint), B) break;\n          }\n          if (P) {\n            const e = B ? Li : Di(L.text);\n            w(t.text, h, M ? Li : e), w(t.text, _, F ? Li : e);\n            const i = L.text.isHidden(),\n              {\n                leftJustifiedTextSymbolIndex: o,\n                centerJustifiedTextSymbolIndex: s,\n                rightJustifiedTextSymbolIndex: r,\n                verticalPlacedTextSymbolIndex: n\n              } = c,\n              a = t.text.placedSymbolArray,\n              l = i || M ? 1 : 0;\n            o >= 0 && (a.get(o).hidden = l), s >= 0 && (a.get(s).hidden = l), r >= 0 && (a.get(r).hidden = l), n >= 0 && (a.get(n).hidden = i || F ? 1 : 0);\n            const d = this.variableOffsets[p];\n            d && this.markUsedJustification(t, d.anchor, c, O);\n            const u = this.placedOrientations[p];\n            u && (this.markUsedJustification(t, \"left\", c, u), this.markUsedOrientation(t, u, c));\n          }\n          if (z) {\n            const e = B ? Li : Di(L.icon),\n              {\n                placedIconSymbolIndex: i,\n                verticalPlacedIconSymbolIndex: o\n              } = c,\n              s = t.icon.placedSymbolArray,\n              r = L.icon.isHidden() ? 1 : 0;\n            i >= 0 && (w(t.icon, E, M ? Li : e), s.get(i).hidden = r), o >= 0 && (w(t.icon, c.numVerticalIconVertices, F ? Li : e), s.get(o).hidden = r);\n          }\n          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {\n            const i = t.collisionArrays[s];\n            if (i) {\n              let o = new e.P(0, 0),\n                s = !0;\n              if (i.textBox || i.verticalTextBox) {\n                if (f) {\n                  const e = this.variableOffsets[p];\n                  e ? (o = yi(e.anchor, e.width, e.height, e.textOffset, e.textScale), m && o._rotate(g ? this.transform.angle : -this.transform.angle)) : s = !1;\n                }\n                d && (s = !L.clipped), i.textBox && wi(t.textCollisionBox.collisionVertexArray, L.text.placed, !s || M, A, y, o.x, o.y), i.verticalTextBox && wi(t.textCollisionBox.collisionVertexArray, L.text.placed, !s || F, A, y, o.x, o.y);\n              }\n              const r = s && Boolean(!F && i.verticalIconBox);\n              i.iconBox && wi(t.iconCollisionBox.collisionVertexArray, L.icon.placed, r, A, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0), i.verticalIconBox && wi(t.iconCollisionBox.collisionVertexArray, L.icon.placed, !r, A, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0);\n            }\n          }\n        }\n        if (t.fullyClipped = 0 === T, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {\n          const e = this.collisionCircleArrays[t.bucketInstanceId];\n          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];\n        }\n      }\n      symbolFadeChange(e) {\n        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n      }\n      zoomAdjustment(e) {\n        return Math.max(0, (this.transform.zoom - e) / 1.5);\n      }\n      hasTransitions(e) {\n        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;\n      }\n      stillRecent(e, t) {\n        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;\n        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;\n      }\n      setStale() {\n        this.stale = !0;\n      }\n    }\n    function wi(e, t, i, o, s, r, n) {\n      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0);\n    }\n    const Ti = Math.pow(2, 25),\n      Ei = Math.pow(2, 24),\n      Si = Math.pow(2, 17),\n      Ii = Math.pow(2, 16),\n      Ci = Math.pow(2, 9),\n      Ri = Math.pow(2, 8),\n      Ai = Math.pow(2, 1);\n    function Di(e) {\n      if (0 === e.opacity && !e.placed) return 0;\n      if (1 === e.opacity && e.placed) return 4294967295;\n      const t = e.placed ? 1 : 0,\n        i = Math.floor(127 * e.opacity);\n      return i * Ti + t * Ei + i * Si + t * Ii + i * Ci + t * Ri + i * Ai + t;\n    }\n    const Li = 0;\n    class Pi {\n      constructor(e) {\n        this._sortAcrossTiles = \"viewport-y\" !== e.layout.get(\"symbol-z-order\") && void 0 !== e.layout.get(\"symbol-sort-key\").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set(), this._bucketParts = [];\n      }\n      continuePlacement(e, t, i, o, s, r) {\n        const n = this._bucketParts;\n        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles, r), this._currentTileIndex++, s()) return !0;\n        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {\n          const e = n[this._currentPartIndex];\n          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart, r), this._currentPartIndex++, s()) return !0;\n        }\n        return !1;\n      }\n    }\n    class zi {\n      constructor(e, t, i, o, s, r, n, a, l) {\n        this.placement = new bi(e, s, r, n, a, l), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n      }\n      isDone() {\n        return this._done;\n      }\n      continuePlacement(t, i, o, s, r) {\n        const n = e.o.now(),\n          a = () => {\n            const t = e.o.now() - n;\n            return !this._forceFullPlacement && t > 2;\n          };\n        for (; this._currentPlacementIndex >= 0;) {\n          const n = i[t[this._currentPlacementIndex]],\n            l = this.placement.collisionIndex.transform.zoom;\n          if (\"symbol\" === n.type && (!n.minzoom || n.minzoom <= l) && (!n.maxzoom || n.maxzoom > l)) {\n            const t = n,\n              i = t.layout.get(\"symbol-z-elevate\"),\n              l = void 0 !== t.layout.get(\"symbol-sort-key\").constantOr(1),\n              c = t.layout.get(\"symbol-z-order\"),\n              h = \"viewport-y\" === c || \"auto\" === c && !(\"viewport-y\" !== c && l),\n              d = t.layout.get(\"text-allow-overlap\") || t.layout.get(\"icon-allow-overlap\") || t.layout.get(\"text-ignore-placement\") || t.layout.get(\"icon-ignore-placement\"),\n              u = h && d,\n              _ = this._inProgressLayer = this._inProgressLayer || new Pi(t),\n              p = e.B(n.source, n.scope);\n            if (_.continuePlacement(i || u ? s[p] : o[p], this.placement, this._showCollisionBoxes, n, a, r)) return;\n            delete this._inProgressLayer;\n          }\n          this._currentPlacementIndex--;\n        }\n        this._done = !0;\n      }\n      commit(e) {\n        return this.placement.commit(e), this.placement;\n      }\n    }\n    const Oi = 512 / e.al / 2;\n    class Mi {\n      constructor(t, i, o) {\n        this.tileID = t, this.bucketInstanceId = o, this.index = new e.c3(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];\n        const s = t.canonical.x * e.al,\n          r = t.canonical.y * e.al;\n        for (let e = 0; e < i.length; e++) {\n          const {\n              key: t,\n              crossTileID: o,\n              tileAnchorX: n,\n              tileAnchorY: a\n            } = i.get(e),\n            l = Math.floor((s + n) * Oi),\n            c = Math.floor((r + a) * Oi);\n          this.index.add(l, c), this.keys.push(t), this.crossTileIDs.push(o);\n        }\n        this.index.finish();\n      }\n      findMatches(t, i, o) {\n        const s = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z),\n          r = Oi / Math.pow(2, i.canonical.z - this.tileID.canonical.z),\n          n = i.canonical.x * e.al,\n          a = i.canonical.y * e.al;\n        for (let e = 0; e < t.length; e++) {\n          const i = t.get(e);\n          if (i.crossTileID) continue;\n          const {\n              key: l,\n              tileAnchorX: c,\n              tileAnchorY: h\n            } = i,\n            d = Math.floor((n + c) * r),\n            u = Math.floor((a + h) * r),\n            _ = this.index.range(d - s, u - s, d + s, u + s).sort((e, t) => e - t);\n          for (const e of _) {\n            const t = this.crossTileIDs[e];\n            if (this.keys[e] === l && !o.has(t)) {\n              o.add(t), i.crossTileID = t;\n              break;\n            }\n          }\n        }\n      }\n    }\n    class Fi {\n      constructor() {\n        this.maxCrossTileID = 0;\n      }\n      generate() {\n        return ++this.maxCrossTileID;\n      }\n    }\n    class Bi {\n      constructor() {\n        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - this.lng) / 360);\n        if (0 !== t) for (const e in this.indexes) {\n          const i = this.indexes[e],\n            o = {};\n          for (const e in i) {\n            const s = i[e];\n            s.tileID = s.tileID.unwrapTo(s.tileID.wrap + t), o[s.tileID.key] = s;\n          }\n          this.indexes[e] = o;\n        }\n        this.lng = e;\n      }\n      addBucket(e, t, i) {\n        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {\n          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;\n          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;\n        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set());\n        const o = this.usedCrossTileIDs[e.overscaledZ];\n        for (const i in this.indexes) {\n          const s = this.indexes[i];\n          if (Number(i) > e.overscaledZ) for (const i in s) {\n            const r = s[i];\n            r.tileID.isChildOf(e) && r.findMatches(t.symbolInstances, e, o);\n          } else {\n            const r = s[e.scaledTo(Number(i)).key];\n            r && r.findMatches(t.symbolInstances, e, o);\n          }\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) {\n          const s = t.symbolInstances.get(e);\n          s.crossTileID || (s.crossTileID = i.generate(), o.add(s.crossTileID));\n        }\n        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Mi(e, t.symbolInstances, t.bucketInstanceId), !0;\n      }\n      removeBucketCrossTileIDs(e, t) {\n        for (const i of t.crossTileIDs) this.usedCrossTileIDs[e].delete(i);\n      }\n      removeStaleBuckets(e) {\n        let t = !1;\n        for (const i in this.indexes) {\n          const o = this.indexes[i];\n          for (const s in o) e[o[s].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[s]), delete o[s], t = !0);\n        }\n        return t;\n      }\n    }\n    class ki {\n      constructor() {\n        this.layerIndexes = {}, this.crossTileIDs = new Fi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n      }\n      addLayer(e, t, i, o) {\n        let s = this.layerIndexes[e.fqid];\n        void 0 === s && (s = this.layerIndexes[e.fqid] = new Bi());\n        let r = !1;\n        const n = {};\n        \"globe\" !== o.name && s.handleWrapJump(i);\n        for (const i of t) {\n          const t = i.getBucket(e);\n          t && e.fqid === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), s.addBucket(i.tileID, t, this.crossTileIDs) && (r = !0), n[t.bucketInstanceId] = !0);\n        }\n        return s.removeStaleBuckets(n) && (r = !0), r;\n      }\n      pruneUnusedLayers(e) {\n        const t = {};\n        e.forEach(e => {\n          t[e] = !0;\n        });\n        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];\n      }\n    }\n    const Ni = 771;\n    class Ui {\n      constructor(e, t, i, o) {\n        this.blendFunction = e, this.blendColor = t.toNonPremultipliedRenderColor(null), this.mask = i, this.blendEquation = o;\n      }\n    }\n    Ui.Replace = [1, 0, 1, 0], Ui.disabled = new Ui(Ui.Replace, e.ao.transparent, [!1, !1, !1, !1]), Ui.unblended = new Ui(Ui.Replace, e.ao.transparent, [!0, !0, !0, !0]), Ui.alphaBlended = new Ui([1, Ni, 1, Ni], e.ao.transparent, [!0, !0, !0, !0]), Ui.alphaBlendedNonPremultiplied = new Ui([770, Ni, 770, Ni], e.ao.transparent, [!0, !0, !0, !0]), Ui.multiply = new Ui([774, 0, 774, 0], e.ao.transparent, [!0, !0, !0, !0]);\n    class ji {\n      constructor(e, t, i) {\n        this.func = e, this.mask = t, this.range = i;\n      }\n    }\n    ji.ReadOnly = !1, ji.ReadWrite = !0, ji.disabled = new ji(519, ji.ReadOnly, [0, 1]);\n    const Vi = 7680;\n    class Gi {\n      constructor(e, t, i, o, s, r) {\n        this.test = e, this.ref = t, this.mask = i, this.fail = o, this.depthFail = s, this.pass = r;\n      }\n    }\n    Gi.disabled = new Gi({\n      func: 519,\n      mask: 0\n    }, 0, 0, Vi, Vi, Vi);\n    const Hi = 1029,\n      qi = 2305;\n    class Zi {\n      constructor(e, t, i) {\n        this.enable = e, this.mode = t, this.frontFace = i;\n      }\n    }\n    function Wi(t, i) {\n      const o = e.c9(t, 3);\n      e.cb(t, i), e.cf(t, 3, o);\n    }\n    function $i(t, i) {\n      const o = e.c6([]);\n      return e.c7(o, o, -i), e.c8(o, o, -t), o;\n    }\n    function Xi(t, i) {\n      const o = [t[0], t[1], 0],\n        s = [i[0], i[1], 0];\n      if (e.ag(o) >= 1e-15) {\n        const t = e.aw([], o);\n        e.c4(s, t, e.bJ(s, t)), i[0] = s[0], i[1] = s[1];\n      }\n      const r = e.bI([], i, t);\n      if (e.c5(r) < 1e-15) return null;\n      const n = Math.atan2(-r[1], r[0]);\n      return $i(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), n);\n    }\n    Zi.disabled = new Zi(!1, Hi, qi), Zi.backCCW = new Zi(!0, Hi, qi), Zi.backCW = new Zi(!0, Hi, 2304), Zi.frontCW = new Zi(!0, 1028, 2304), Zi.frontCCW = new Zi(!0, 1028, qi);\n    class Yi {\n      constructor(e, t) {\n        this.position = e, this.orientation = t;\n      }\n      get position() {\n        return this._position;\n      }\n      set position(t) {\n        if (t) {\n          const i = t instanceof e.ae ? t : new e.ae(t[0], t[1], t[2]);\n          this._renderWorldCopies && (i.x = e.bT(i.x, 0, 1)), this._position = i;\n        } else this._position = null;\n      }\n      lookAtPoint(t, i) {\n        if (this.orientation = null, !this.position) return;\n        const o = this.position,\n          s = this._elevation ? this._elevation.getAtPointOrZero(e.ae.fromLngLat(t)) : 0,\n          r = e.ae.fromLngLat(t, s),\n          n = [r.x - o.x, r.y - o.y, r.z - o.z];\n        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = Xi(n, i);\n      }\n      setPitchBearing(t, i) {\n        this.orientation = $i(e.an(t), e.an(-i));\n      }\n    }\n    class Ki {\n      constructor(t, i) {\n        this._transform = e.bA([]), this.orientation = i, this.position = t;\n      }\n      get mercatorPosition() {\n        const t = this.position;\n        return new e.ae(t[0], t[1], t[2]);\n      }\n      get position() {\n        const t = e.c9(this._transform, 3);\n        return [t[0], t[1], t[2]];\n      }\n      set position(t) {\n        var i;\n        t && e.cf(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);\n      }\n      get orientation() {\n        return this._orientation;\n      }\n      set orientation(t) {\n        this._orientation = t || e.c6([]), t && Wi(this._transform, this._orientation);\n      }\n      getPitchBearing() {\n        const e = this.forward(),\n          t = this.right();\n        return {\n          bearing: Math.atan2(-t[1], t[0]),\n          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])\n        };\n      }\n      setPitchBearing(e, t) {\n        this._orientation = $i(e, t), Wi(this._transform, this._orientation);\n      }\n      forward() {\n        const t = e.c9(this._transform, 2);\n        return [-t[0], -t[1], -t[2]];\n      }\n      up() {\n        const t = e.c9(this._transform, 1);\n        return [-t[0], -t[1], -t[2]];\n      }\n      right() {\n        const t = e.c9(this._transform, 0);\n        return [t[0], t[1], t[2]];\n      }\n      getCameraToWorld(t, i) {\n        const o = new Float64Array(16);\n        return e.bl(o, this.getWorldToCamera(t, i)), o;\n      }\n      getCameraToWorldMercator() {\n        return this._transform;\n      }\n      getWorldToCameraPosition(t, i, o) {\n        const s = this.position;\n        e.c4(s, s, -t);\n        const r = new Float64Array(16);\n        return e.bq(r, [o, o, o]), e.br(r, r, s), r[10] *= i, r;\n      }\n      getWorldToCamera(t, i) {\n        const o = new Float64Array(16),\n          s = new Float64Array(4),\n          r = this.position;\n        return e.ca(s, this._orientation), e.c4(r, r, -t), e.cb(o, s), e.br(o, o, r), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;\n      }\n      getCameraToClipPerspective(t, i, o, s) {\n        const r = new Float64Array(16);\n        return e.cc(r, t, i, o, s), r;\n      }\n      getCameraToClipOrthographic(t, i, o, s, r, n) {\n        const a = new Float64Array(16);\n        return e.cd(a, t, i, o, s, r, n), a;\n      }\n      getDistanceToElevation(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        const o = 0 === t ? 0 : e.ce(t, i ? e.a$(this.position[1]) : this.position[1]),\n          s = this.forward();\n        return (o - this.position[2]) / s[2];\n      }\n      clone() {\n        return new Ki([...this.position], [...this.orientation]);\n      }\n    }\n    const Ji = {\n      BaseColor: 5,\n      MetallicRoughness: 6,\n      Normal: 7,\n      Occlusion: 8,\n      Emission: 9,\n      LUT: 10,\n      ShadowMap0: 11\n    };\n    class Qi {\n      constructor() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error(\"Invalid value for edge-insets, top, bottom, left and right must all be numbers\");\n        this.top = e, this.bottom = t, this.left = i, this.right = o;\n      }\n      interpolate(t, i, o) {\n        return null != i.top && null != t.top && (this.top = e.ak(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.ak(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.ak(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.ak(t.right, i.right, o)), this;\n      }\n      getCenter(t, i) {\n        const o = e.aA((this.left + t - this.right) / 2, 0, t),\n          s = e.aA((this.top + i - this.bottom) / 2, 0, i);\n        return new e.P(o, s);\n      }\n      equals(e) {\n        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;\n      }\n      clone() {\n        return new Qi(this.top, this.bottom, this.left, this.right);\n      }\n      toJSON() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n    }\n    const eo = 15;\n    class to {\n      constructor(t, i, o, s, r, n, a) {\n        this.tileSize = 512, this._renderWorldCopies = void 0 === r || r, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = o !== null && o !== void 0 ? o : 0, this._maxPitch = s !== null && s !== void 0 ? s : 60, this.setProjection(n), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.aR(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Qi(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Ki(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = \"ground\", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1;\n      }\n      clone() {\n        const e = new to(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);\n        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e._allowWorldUnderZoom = this._allowWorldUnderZoom, e;\n      }\n      get isOrthographic() {\n        return \"globe\" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < eo;\n      }\n      get elevation() {\n        return this._elevation;\n      }\n      set elevation(e) {\n        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());\n      }\n      get depthOcclusionForSymbolsAndCircles() {\n        return \"globe\" !== this.projection.name && !this.isOrthographic;\n      }\n      updateElevation(e) {\n        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;\n        (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t), this._calcMatrices();\n      }\n      getProjection() {\n        return e.aH(this.projection, [\"name\", \"center\", \"parallels\"]);\n      }\n      setProjection(t) {\n        this.projectionOptions = t || {\n          name: \"mercator\"\n        };\n        const i = this.projection ? this.getProjection() : void 0;\n        this.projection = e.cl(this.projectionOptions);\n        const o = this.getProjection(),\n          s = !e.by(i, o);\n        return s && this._calcMatrices(), this.mercatorFromTransition = !1, s;\n      }\n      setOrthographicProjectionAtLowPitch(e) {\n        return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);\n      }\n      setMercatorFromTransition() {\n        const t = this.projection.name;\n        this.mercatorFromTransition = !0, this.projectionOptions = {\n          name: \"mercator\"\n        }, this.projection = e.cl({\n          name: \"mercator\"\n        });\n        const i = t !== this.projection.name;\n        return i && this._calcMatrices(), i;\n      }\n      get minZoom() {\n        return this._minZoom;\n      }\n      set minZoom(e) {\n        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));\n      }\n      get maxZoom() {\n        return this._maxZoom;\n      }\n      set maxZoom(e) {\n        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));\n      }\n      get minPitch() {\n        return this._minPitch;\n      }\n      set minPitch(e) {\n        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));\n      }\n      get maxPitch() {\n        return this._maxPitch;\n      }\n      set maxPitch(e) {\n        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));\n      }\n      get renderWorldCopies() {\n        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;\n      }\n      set renderWorldCopies(e) {\n        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;\n      }\n      get worldSize() {\n        return this.tileSize * this.scale;\n      }\n      get cameraWorldSizeForFog() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get cameraWorldSize() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get pixelsPerMeter() {\n        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);\n      }\n      get cameraPixelsPerMeter() {\n        return e.ce(1, this.center.lat) * this.cameraWorldSizeForFog;\n      }\n      get centerOffset() {\n        return this.centerPoint._sub(this.size._div(2));\n      }\n      get size() {\n        return new e.P(this.width, this.height);\n      }\n      get bearing() {\n        return e.bT(this.rotation, -180, 180);\n      }\n      set bearing(e) {\n        this.rotation = e;\n      }\n      get rotation() {\n        return -this.angle / Math.PI * 180;\n      }\n      set rotation(t) {\n        const i = -t * Math.PI / 180;\n        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.cm(), e.cn(this.rotationMatrix, this.rotationMatrix, this.angle));\n      }\n      get pitch() {\n        return this._pitch / Math.PI * 180;\n      }\n      set pitch(t) {\n        const i = e.aA(t, this.minPitch, this.maxPitch) / 180 * Math.PI;\n        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n      }\n      get aspect() {\n        return this.width / this.height;\n      }\n      get fov() {\n        return this._fov / Math.PI * 180;\n      }\n      set fov(t) {\n        t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.an(t), this._calcMatrices());\n      }\n      get fovX() {\n        return this._fov;\n      }\n      get fovY() {\n        const e = 1 / Math.tan(.5 * this.fovX);\n        return 2 * Math.atan(1 / this.aspect / e);\n      }\n      get averageElevation() {\n        return this._averageElevation;\n      }\n      set averageElevation(e) {\n        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};\n      }\n      get zoom() {\n        return this._zoom;\n      }\n      set zoom(e) {\n        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);\n        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());\n      }\n      _setZoom(e) {\n        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;\n      }\n      get tileCoverLift() {\n        return this._tileCoverLift;\n      }\n      set tileCoverLift(e) {\n        this._tileCoverLift !== e && (this._tileCoverLift = e);\n      }\n      _updateCameraOnTerrain() {\n        const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY,\n          t = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;\n        if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);\n        const i = this._elevation;\n        t || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();\n      }\n      _updateSeaLevelZoom() {\n        if (void 0 === this._centerAltitudeValidForExaggeration) return;\n        const e = Math.max(0, (this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize);\n        this._seaLevelZoom = this._zoomFromMercatorZ(e);\n      }\n      sampleAverageElevation() {\n        if (!this._elevation) return 0;\n        const t = this._elevation,\n          i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],\n          o = this.horizonLineFromTop();\n        let s = 0,\n          r = 0;\n        for (let n = 0; n < i.length; n++) {\n          const a = new e.P(i[n][0] * this.width, o + i[n][1] * (this.height - o)),\n            l = t.pointCoordinate(a);\n          if (!l) continue;\n          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);\n          s += l[3] * c, r += c;\n        }\n        return 0 === r ? NaN : s / r;\n      }\n      get center() {\n        return this._center;\n      }\n      set center(e) {\n        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && (\"ground\" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());\n      }\n      _updateZoomFromElevation() {\n        if (null == this._seaLevelZoom || !this._elevation) return;\n        const e = this._seaLevelZoom,\n          t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),\n          i = this.pixelsPerMeter / this.worldSize * t,\n          o = this._mercatorZfromZoom(e),\n          s = this._mercatorZfromZoom(this._maxZoom),\n          r = Math.max(o - i, s);\n        this._setZoom(this._zoomFromMercatorZ(r));\n      }\n      get padding() {\n        return this._edgeInsets.toJSON();\n      }\n      set padding(e) {\n        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());\n      }\n      computeZoomRelativeTo(t) {\n        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));\n        let o;\n        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];\n        const s = e.ag(e.av([], this._camera.position, o));\n        return e.aA(this._zoomFromMercatorZ(s), this._minZoom, this._maxZoom);\n      }\n      setFreeCameraOptions(t) {\n        if (!this.height) return;\n        if (!t.position && !t.orientation) return;\n        this._updateCameraState();\n        let i = !1;\n        if (t.orientation && !e.co(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {\n          const o = [t.position.x, t.position.y, t.position.z];\n          e.cp(o, this._camera.position) || (this._setCameraPosition(o), i = !0);\n        }\n        i && (this._updateStateFromCamera(), this.recenterOnTerrain());\n      }\n      getFreeCameraOptions() {\n        this._updateCameraState();\n        const t = this._camera.position,\n          i = new Yi();\n        return i.position = new e.ae(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;\n      }\n      _setCameraOrientation(t) {\n        if (!e.cq(t)) return !1;\n        e.cr(t, t);\n        const i = e.cs([], [0, 0, -1], t),\n          o = e.cs([], [0, -1, 0], t);\n        if (o[2] < 0) return !1;\n        const s = Xi(i, o);\n        return !!s && (this._camera.orientation = s, !0);\n      }\n      _setCameraPosition(t) {\n        const i = this.zoomScale(this.minZoom) * this.tileSize,\n          o = this.zoomScale(this.maxZoom) * this.tileSize,\n          s = this.cameraToCenterDistance;\n        t[2] = e.aA(t[2], s / o, s / i), this._camera.position = t;\n      }\n      get centerPoint() {\n        return this._edgeInsets.getCenter(this.width, this.height);\n      }\n      get fovAboveCenter() {\n        return this._fov * (.5 + this.centerOffset.y / this.height);\n      }\n      isPaddingEqual(e) {\n        return this._edgeInsets.equals(e);\n      }\n      interpolatePadding(e, t, i) {\n        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();\n      }\n      coveringZoomLevel(e) {\n        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));\n        return Math.max(0, t);\n      }\n      getVisibleUnwrappedCoordinates(t) {\n        const i = [new e.ct(0, t)];\n        if (this.renderWorldCopies) {\n          const o = this.pointCoordinate(new e.P(0, 0)),\n            s = this.pointCoordinate(new e.P(this.width, 0)),\n            r = this.pointCoordinate(new e.P(this.width, this.height)),\n            n = this.pointCoordinate(new e.P(0, this.height)),\n            a = Math.floor(Math.min(o.x, s.x, r.x, n.x)),\n            l = Math.floor(Math.max(o.x, s.x, r.x, n.x)),\n            c = 1;\n          for (let o = a - c; o <= l + c; o++) 0 !== o && i.push(new e.ct(o, t));\n        }\n        return i;\n      }\n      isLODDisabled(e) {\n        return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;\n      }\n      extendTileCover(t, i, o) {\n        let s = [];\n        const r = null != o,\n          n = !r;\n        if (n && this.zoom < i) return s;\n        if (r && 0 === o[0] && 0 === o[1]) return s;\n        const a = new Set(),\n          l = (t, i, o, r, n) => {\n            const l = e.cX(i, t, o, r, n);\n            a.has(l) || (s.push(new e.aO(t, i, o, r, n)), a.add(l));\n          };\n        for (let e = 0; e < t.length; e++) {\n          const s = t[e];\n          if (n && s.canonical.z !== i) continue;\n          const a = s.canonical,\n            c = s.overscaledZ,\n            h = s.wrap,\n            d = 1 << a.z,\n            u = a.x + 1 < d,\n            _ = a.x > 0,\n            p = a.y + 1 < d,\n            f = a.y > 0,\n            m = s.wrap - (_ ? 0 : 1),\n            g = s.wrap + (u ? 0 : 1),\n            v = _ ? a.x - 1 : d - 1,\n            y = u ? a.x + 1 : 0;\n          if (r) o[0] < 0 ? (l(c, g, a.z, y, a.y), o[1] < 0 && p && (l(c, h, a.z, a.x, a.y + 1), l(c, g, a.z, y, a.y + 1)), o[1] > 0 && f && (l(c, h, a.z, a.x, a.y - 1), l(c, g, a.z, y, a.y - 1))) : o[0] > 0 ? (l(c, m, a.z, v, a.y), o[1] < 0 && p && (l(c, h, a.z, a.x, a.y + 1), l(c, m, a.z, v, a.y + 1)), o[1] > 0 && f && (l(c, h, a.z, a.x, a.y - 1), l(c, m, a.z, v, a.y - 1))) : o[1] < 0 && p ? l(c, h, a.z, a.x, a.y + 1) : f && l(c, h, a.z, a.x, a.y - 1);else {\n            const e = s.visibleQuadrants;\n            1 & e && (l(c, m, a.z, v, a.y), f && (l(c, h, a.z, a.x, a.y - 1), l(c, m, a.z, v, a.y - 1))), 2 & e && (l(c, g, a.z, y, a.y), f && (l(c, h, a.z, a.x, a.y - 1), l(c, g, a.z, y, a.y - 1))), 4 & e && (l(c, m, a.z, v, a.y), p && (l(c, h, a.z, a.x, a.y + 1), l(c, m, a.z, v, a.y + 1))), 8 & e && (l(c, g, a.z, y, a.y), p && (l(c, h, a.z, a.x, a.y + 1), l(c, g, a.z, y, a.y + 1)));\n          }\n        }\n        const c = [];\n        for (const e of s) s.some(t => e.isChildOf(t)) || c.push(e);\n        if (s = c.filter(e => !t.some(t => !!(e.overscaledZ < i && t.isChildOf(e)) || e.equals(t) || e.isChildOf(t))), n) {\n          const e = 1 << i,\n            t = \"globe\" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n            o = [e * t.x, e * t.y],\n            r = 4,\n            n = r * r;\n          s = s.filter(e => {\n            const t = e.canonical.x + .5 - o[0],\n              i = e.canonical.y + .5 - o[1];\n            return t * t + i * i < n;\n          });\n        }\n        return s;\n      }\n      extendTileCoverToNearPlane(t, i, o) {\n        const s = [],\n          r = new Set();\n        for (const e of t) r.add(e.key);\n        const n = (t, i, o, n, a) => {\n            const l = e.cX(i, t, o, n, a);\n            r.has(l) || (s.push(new e.aO(t, i, o, n, a)), r.add(l));\n          },\n          a = t.reduce((e, t) => Math.max(e, t.overscaledZ), o),\n          l = 1 << o,\n          c = [new e.P(0, 0), new e.P(e.al, 0), new e.P(e.al, e.al), new e.P(0, e.al)],\n          h = new e.P(0, 0),\n          d = new e.P(0, 0),\n          u = (t, i) => {\n            const s = Math.floor(t[0]),\n              r = Math.floor(t[1]),\n              u = (t[0] - s) * e.al,\n              _ = (t[1] - r) * e.al,\n              p = Math.floor(i[0]),\n              f = Math.floor(i[1]),\n              m = (i[0] - p) * e.al,\n              g = (i[1] - f) * e.al;\n            for (let t = -1; t <= 1; t++) {\n              const i = s + t;\n              if (!(i < 0 || i >= l)) {\n                h.x = u - t * e.al, d.x = m - (i - p) * e.al;\n                for (let t = -1; t <= 1; t++) {\n                  const s = r + t;\n                  h.y = _ - t * e.al, d.y = g - (s - f) * e.al, e.cY(h, d, c) && n(a, 0, o, i, s);\n                }\n              }\n            }\n          },\n          _ = i.points,\n          p = _[e.cu],\n          f = _[e.cv],\n          m = this._projectToGround(p, _[e.cw]),\n          g = this._projectToGround(f, _[e.cx]);\n        return u(p, m), u(f, g), s;\n      }\n      _projectToGround(t, i) {\n        return e.cy(e.cz(), t, i, t[2] / (t[2] - i[2]));\n      }\n      coveringTiles(t) {\n        let i = this.coveringZoomLevel(t);\n        const o = i,\n          s = this.elevation && this.elevation.exaggeration(),\n          r = s && !t.isTerrainDEM,\n          n = \"mercator\" === this.projection.name;\n        if (void 0 !== t.minzoom && i < t.minzoom) return [];\n        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);\n        const a = this.locationCoordinate(this.center),\n          l = this.center.lat,\n          c = 1 << i,\n          h = [c * a.x, c * a.y, 0],\n          d = \"globe\" === this.projection.name,\n          u = !d,\n          _ = e.cA.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u),\n          p = d ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n          f = c * e.ce(1, this.center.lat),\n          m = this._camera.position[2] / e.ce(1, this.center.lat),\n          g = [c * p.x, c * p.y, m * (u ? 1 : f)],\n          v = d || s,\n          y = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),\n          x = this.isLODDisabled(!0) ? i : 0;\n        let b;\n        if (this._elevation && t.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();else if (this._elevation) {\n          const e = this._elevation.getMinMaxForVisibleTiles();\n          b = e ? e.max : this._centerAltitude;\n        } else b = this._centerAltitude;\n        const w = t.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,\n          T = this.projection.isReprojectedInTileSpace ? e.cB(this) : 1,\n          E = t => {\n            const i = 1 / 4e4,\n              o = new e.ae(t.x + i, t.y, t.z),\n              s = new e.ae(t.x, t.y + i, t.z),\n              r = t.toLngLat(),\n              n = o.toLngLat(),\n              a = s.toLngLat(),\n              l = this.locationCoordinate(r),\n              c = this.locationCoordinate(n),\n              h = this.locationCoordinate(a),\n              d = Math.hypot(c.x - l.x, c.y - l.y),\n              u = Math.hypot(h.x - l.x, h.y - l.y);\n            return Math.sqrt(d * u) * T / i;\n          },\n          S = t => {\n            const i = b,\n              o = w;\n            return {\n              aabb: e.cE(this, c, 0, 0, 0, t, o, i, this.projection),\n              zoom: 0,\n              x: 0,\n              y: 0,\n              minZ: o,\n              maxZ: i,\n              wrap: t,\n              fullyVisible: !1\n            };\n          },\n          I = [];\n        let C = [];\n        const R = i,\n          A = t.reparseOverscaled ? o : i,\n          D = (m - this._centerAltitude) * f,\n          L = e => {\n            if (!this._elevation || !e.tileID || !n) return;\n            const t = this._elevation.getMinMaxForTile(e.tileID),\n              i = e.aabb;\n            t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = z(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));\n          },\n          P = (e, t) => {\n            if (.707 * t < e) return 1;\n            const i = t / e;\n            return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);\n          },\n          z = t => {\n            if (t.zoom < x) return !0;\n            if (t.zoom === R) return !1;\n            if (null != t.shouldSplit) return t.shouldSplit;\n            const i = t.aabb.distanceX(g),\n              s = t.aabb.distanceY(g);\n            let a = D,\n              c = 1;\n            if (d) {\n              a = t.aabb.distanceZ(g);\n              const i = Math.pow(2, t.zoom),\n                o = e.a$((t.y + 1) / i),\n                s = e.a$(t.y / i),\n                r = Math.min(Math.max(l, o), s),\n                n = e.d0(r) / e.d0(l);\n              if (c = r === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, n / this._mercatorScaleRatio), this.zoom <= e.cZ && t.zoom === R - 1 && n >= .9) return !0;\n            } else if (r && (a = t.aabb.distanceZ(g) * f), this.projection.isReprojectedInTileSpace && o <= 5) {\n              const i = Math.pow(2, t.zoom),\n                o = E(new e.ae((t.x + .5) / i, (t.y + .5) / i));\n              c = o > .85 ? 1 : o;\n            }\n            if (!n) {\n              const e = Math.sqrt(i * i + s * s + a * a);\n              let o = (1 << R - t.zoom) * y * c;\n              return o *= P(Math.max(a, D), e), e < o;\n            }\n            let u = Number.MAX_VALUE,\n              _ = 0;\n            const p = t.aabb.getCorners(),\n              m = [];\n            for (const t of p) {\n              e.av(m, t, g), d || (r ? m[2] *= f : m[2] = D);\n              const i = e.bJ(m, this._camera.forward());\n              i < u && (u = i, _ = Math.abs(m[2]));\n            }\n            let v = (1 << R - t.zoom) * y * c;\n            if (v *= P(Math.max(_, D), u), u < v) return !0;\n            const b = t.aabb.closestPoint(h);\n            return b[0] === h[0] && b[1] === h[1];\n          };\n        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) I.push(S(-e)), I.push(S(e));\n        for (I.push(S(0)); I.length > 0;) {\n          const o = I.pop(),\n            s = o.x,\n            a = o.y;\n          let l = o.fullyVisible;\n          const u = () => \"globe\" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);\n          if (!l) {\n            let t = v ? o.aabb.intersects(_) : o.aabb.intersectsFlat(_);\n            if (0 === t && u()) {\n              const i = new e.cC(o.zoom, s, a);\n              t = e.cD(this, c, i, !0).intersects(_);\n            }\n            if (0 === t) continue;\n            l = 2 === t;\n          }\n          if (o.zoom !== R && z(o)) for (let t = 0; t < 4; t++) {\n            const i = (s << 1) + t % 2,\n              h = (a << 1) + (t >> 1),\n              u = {\n                aabb: n ? o.aabb.quadrant(t) : e.cE(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),\n                zoom: o.zoom + 1,\n                x: i,\n                y: h,\n                wrap: o.wrap,\n                fullyVisible: l,\n                tileID: void 0,\n                shouldSplit: void 0,\n                minZ: o.minZ,\n                maxZ: o.maxZ\n              };\n            r && !d && (u.tileID = new e.aO(o.zoom + 1 === R ? A : o.zoom + 1, o.wrap, o.zoom + 1, i, h), L(u)), I.push(u);\n          } else {\n            const r = o.zoom === R ? A : o.zoom;\n            if (t.minzoom && t.minzoom > r) continue;\n            let n = 0;\n            if (!l) {\n              let i = v ? o.aabb.intersectsPrecise(_) : o.aabb.intersectsPreciseFlat(_);\n              if (0 === i && u()) {\n                const t = new e.cC(o.zoom, s, a);\n                i = e.cD(this, c, t, !0).intersectsPrecise(_);\n              }\n              if (0 === i) continue;\n              if (t.calculateQuadrantVisibility) if (_.containsPoint(o.aabb.center)) n = 15;else for (let e = 0; e < 4; e++) 0 !== o.aabb.quadrant(e).intersects(_) && (n |= 1 << e);\n            }\n            const d = h[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom),\n              p = h[1] - .5 - a,\n              f = o.tileID ? o.tileID : new e.aO(r, o.wrap, o.zoom, s, a);\n            t.calculateQuadrantVisibility && (f.visibleQuadrants = n), C.push({\n              tileID: f,\n              distanceSq: d * d + p * p\n            });\n          }\n        }\n        if (this.fogCullDistSq) {\n          const i = this.fogCullDistSq,\n            o = this.horizonLineFromTop();\n          C = C.filter(s => {\n            const r = [0, 0, 0, 1],\n              n = [e.al, e.al, 0, 1],\n              a = this.calculateFogTileMatrix(s.tileID.toUnwrapped());\n            e.aC(r, r, a), e.aC(n, n, a);\n            const l = e.cF([], r, n),\n              c = e.cG([], r, n),\n              h = e.c_(l, c);\n            if (0 === h) return !0;\n            let d = !1;\n            const u = this._elevation;\n            if (u && h > i && 0 !== o) {\n              const i = this.calculateProjMatrix(s.tileID.toUnwrapped());\n              let r;\n              t.isTerrainDEM || (r = u.getMinMaxForTile(s.tileID)), r || (r = {\n                min: w,\n                max: b\n              });\n              const n = e.cH(this.rotation),\n                a = [n[0] * e.al, n[1] * e.al, r.max];\n              e.af(a, a, i), d = (1 - a[1]) * this.height * .5 < o;\n            }\n            return h < i || d;\n          });\n        }\n        return C.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);\n      }\n      resize(e, t) {\n        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();\n      }\n      get unmodified() {\n        return this._unmodified;\n      }\n      zoomScale(e) {\n        return Math.pow(2, e);\n      }\n      scaleZoom(e) {\n        return Math.log2(e);\n      }\n      project(t) {\n        const i = e.aA(t.lat, -e.cI, e.cI),\n          o = this.projection.project(t.lng, i);\n        return new e.P(o.x * this.worldSize, o.y * this.worldSize);\n      }\n      unproject(e) {\n        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);\n      }\n      get point() {\n        return this.project(this.center);\n      }\n      get pointMerc() {\n        return this.point._div(this.worldSize);\n      }\n      get pixelsPerMeterRatio() {\n        return this.pixelsPerMeter / e.ce(1, this.center.lat) / this.worldSize;\n      }\n      setLocationAtPoint(t, i) {\n        let o, s;\n        const r = this.centerPoint;\n        if (\"globe\" === this.projection.name) {\n          const e = this.worldSize;\n          o = (i.x - r.x) / e, s = (i.y - r.y) / e;\n        } else {\n          const e = this.pointCoordinate(i),\n            t = this.pointCoordinate(r);\n          o = e.x - t.x, s = e.y - t.y;\n        }\n        const n = this.locationCoordinate(t);\n        this.setLocation(new e.ae(n.x - o, n.y - s));\n      }\n      setLocation(e) {\n        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());\n      }\n      locationPoint(e, t) {\n        return this.projection.locationPoint(this, e, t);\n      }\n      locationPoint3D(e, t) {\n        return this.projection.locationPoint(this, e, t, !0);\n      }\n      pointLocation(e) {\n        return this.coordinateLocation(this.pointCoordinate(e));\n      }\n      pointLocation3D(e, t) {\n        return this.coordinateLocation(this.pointCoordinate3D(e, t));\n      }\n      locationCoordinate(t, i) {\n        const o = i ? e.ce(i, t.lat) : void 0,\n          s = this.projection.project(t.lng, t.lat);\n        return new e.ae(s.x, s.y, o);\n      }\n      coordinateLocation(e) {\n        return this.projection.unproject(e.x, e.y);\n      }\n      pointRayIntersection(t, i) {\n        const o = null != i ? i : this._centerAltitude,\n          s = [t.x, t.y, 0, 1],\n          r = [t.x, t.y, 1, 1];\n        e.aC(s, s, this.pixelMatrixInverse), e.aC(r, r, this.pixelMatrixInverse);\n        const n = r[3];\n        e.cJ(s, s, 1 / s[3]), e.cJ(r, r, 1 / n);\n        const a = s[2],\n          l = r[2];\n        return {\n          p0: s,\n          p1: r,\n          t: a === l ? 0 : (o - a) / (l - a)\n        };\n      }\n      screenPointToMercatorRay(t) {\n        const i = [t.x, t.y, 0, 1],\n          o = [t.x, t.y, 1, 1];\n        return e.aC(i, i, this.pixelMatrixInverse), e.aC(o, o, this.pixelMatrixInverse), e.cJ(i, i, 1 / i[3]), e.cJ(o, o, 1 / o[3]), i[2] = e.ce(i[2], this._center.lat) * this.worldSize, o[2] = e.ce(o[2], this._center.lat) * this.worldSize, e.cJ(i, i, 1 / this.worldSize), e.cJ(o, o, 1 / this.worldSize), new e.ax([i[0], i[1], i[2]], e.aw([], e.av([], o, i)));\n      }\n      rayIntersectionCoordinate(t) {\n        const {\n            p0: i,\n            p1: o,\n            t: s\n          } = t,\n          r = e.ce(i[2], this._center.lat),\n          n = e.ce(o[2], this._center.lat);\n        return new e.ae(e.ak(i[0], o[0], s) / this.worldSize, e.ak(i[1], o[1], s) / this.worldSize, e.ak(r, n, s));\n      }\n      pointCoordinate(e) {\n        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._centerAltitude;\n        return this.projection.pointCoordinate(this, e.x, e.y, t);\n      }\n      pointCoordinate3D(t, i) {\n        if (!this.elevation) return this.pointCoordinate(t, i);\n        let o = this.projection.pointCoordinate3D(this, t.x, t.y);\n        if (o) return new e.ae(o[0], o[1], o[2]);\n        let s = 0,\n          r = this.horizonLineFromTop();\n        if (t.y > r) return this.pointCoordinate(t, i);\n        const n = .02 * r,\n          a = t.clone();\n        for (let t = 0; t < 10 && r - s > n; t++) {\n          a.y = e.ak(s, r, .66);\n          const t = this.projection.pointCoordinate3D(this, a.x, a.y);\n          t ? (r = a.y, o = t) : s = a.y;\n        }\n        return o ? new e.ae(o[0], o[1], o[2]) : this.pointCoordinate(t);\n      }\n      isPointAboveHorizon(e) {\n        return this.projection.isPointAboveHorizon(this, e);\n      }\n      isPointOnSurface(t) {\n        if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;\n        if (this.elevation || this.zoom >= e.cK) return !this.isPointAboveHorizon(t);\n        const i = this.pointCoordinate(t);\n        return i.y >= 0 && i.y <= 1;\n      }\n      _coordinatePoint(t, i) {\n        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,\n          s = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];\n        return e.aC(s, s, this.pixelMatrix), s[3] > 0 ? new e.P(s[0] / s[3], s[1] / s[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);\n      }\n      _getBoundsNonRectangular() {\n        const {\n            top: t,\n            left: i\n          } = this._edgeInsets,\n          o = this.height - this._edgeInsets.bottom,\n          s = this.width - this._edgeInsets.right,\n          r = this.pointLocation3D(new e.P(i, t)),\n          n = this.pointLocation3D(new e.P(s, t)),\n          a = this.pointLocation3D(new e.P(s, o)),\n          l = this.pointLocation3D(new e.P(i, o));\n        let c = Math.min(r.lng, n.lng, a.lng, l.lng),\n          h = Math.max(r.lng, n.lng, a.lng, l.lng),\n          d = Math.min(r.lat, n.lat, a.lat, l.lat),\n          u = Math.max(r.lat, n.lat, a.lat, l.lat);\n        const _ = Math.pow(2, -this.zoom) / 16 * 270,\n          p = \"globe\" === this.projection.name ? 1 : 4,\n          f = (t, i, o, s, r) => {\n            const n = (t + o) / 2,\n              a = (i + s) / 2,\n              l = new e.P(n, a),\n              {\n                lng: m,\n                lat: g\n              } = this.pointLocation3D(l),\n              v = Math.max(0, c - m, d - g, m - h, g - u);\n            c = Math.min(c, m), h = Math.max(h, m), d = Math.min(d, g), u = Math.max(u, g), (r < p || v > _) && (f(t, i, n, a, r + 1), f(n, a, o, s, r + 1));\n          };\n        if (f(i, t, s, t, 1), f(s, t, s, o, 1), f(s, o, i, o, 1), f(i, o, i, t, 1), \"globe\" === this.projection.name) {\n          const [t, i] = e.cL(this);\n          t ? (u = 90, h = 180, c = -180) : i && (d = -90, h = 180, c = -180);\n        }\n        return new e.aI(new e.aR(c, d), new e.aR(h, u));\n      }\n      _getBoundsRectangular(t, i) {\n        const {\n            top: o,\n            left: s\n          } = this._edgeInsets,\n          r = this.height - this._edgeInsets.bottom,\n          n = this.width - this._edgeInsets.right,\n          a = new e.P(s, o),\n          l = new e.P(n, o),\n          c = new e.P(n, r),\n          h = new e.P(s, r);\n        let d = this.pointCoordinate(a, t),\n          u = this.pointCoordinate(l, t);\n        const _ = this.pointCoordinate(c, i),\n          p = this.pointCoordinate(h, i),\n          f = (e, t) => (t.y - e.y) / (t.x - e.x);\n        return d.y > 1 && u.y >= 0 ? d = new e.ae((1 - p.y) / f(p, d) + p.x, 1) : d.y < 0 && u.y <= 1 && (d = new e.ae(-p.y / f(p, d) + p.x, 0)), u.y > 1 && d.y >= 0 ? u = new e.ae((1 - _.y) / f(_, u) + _.x, 1) : u.y < 0 && d.y <= 1 && (u = new e.ae(-_.y / f(_, u) + _.x, 0)), new e.aI().extend(this.coordinateLocation(d)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_));\n      }\n      _getBoundsRectangularTerrain() {\n        const e = this.elevation;\n        if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);\n        const t = e.visibleDemTiles.reduce((e, t) => {\n          if (t.dem) {\n            const i = t.dem.tree;\n            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);\n          }\n          return e;\n        }, {\n          min: Number.MAX_VALUE,\n          max: 0\n        });\n        return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration());\n      }\n      getBounds() {\n        return \"mercator\" === this.projection.name || \"equirectangular\" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();\n      }\n      horizonLineFromTop() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y,\n          i = this.height / 2 - t * (1 - this._horizonShift);\n        return e ? Math.max(0, i) : i;\n      }\n      getMaxBounds() {\n        return this.maxBounds;\n      }\n      setMaxBounds(t) {\n        this.maxBounds = t, this.minLat = -e.cI, this.maxLat = e.cI, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.aF(this.minLng) * this.tileSize, this.worldMaxX = e.aF(this.maxLng) * this.tileSize, this.worldMinY = e.aJ(this.maxLat) * this.tileSize, this.worldMaxY = e.aJ(this.minLat) * this.tileSize, this._constrain();\n      }\n      calculatePosMatrix(e, t) {\n        return this.projection.createTileMatrix(this, t, e);\n      }\n      calculateDistanceTileData(t) {\n        const i = t.key,\n          o = this._distanceTileDataCache;\n        if (o[i]) return o[i];\n        const s = t.canonical,\n          r = 1 / this.height,\n          n = this.cameraWorldSize,\n          a = n / this.zoomScale(s.z),\n          l = (s.x + Math.pow(2, s.z) * t.wrap) * a,\n          c = s.y * a,\n          h = this.point;\n        h.x *= n / this.worldSize, h.y *= n / this.worldSize;\n        const d = this.angle,\n          u = Math.sin(-d),\n          _ = -Math.cos(-d);\n        return o[i] = {\n          bearing: [u, _],\n          center: [(h.x - l) * r, (h.y - c) * r],\n          scale: a / e.al * r\n        }, o[i];\n      }\n      calculateFogTileMatrix(t) {\n        const i = t.key,\n          o = this._fogTileMatrixCache;\n        if (o[i]) return o[i];\n        const s = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);\n        return e.aB(s, this.worldToFogMatrix, s), o[i] = new Float32Array(s), o[i];\n      }\n      calculateProjMatrix(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        const s = t.key;\n        let r;\n        if (r = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, r[s]) return r[s];\n        const n = this.calculatePosMatrix(t, this.worldSize);\n        let a;\n        return a = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.aB(n, a, n), r[s] = new Float32Array(n), r[s];\n      }\n      calculatePixelsToTileUnitsMatrix(t) {\n        const i = t.tileID.key,\n          o = this._pixelsToTileUnitsCache;\n        if (o[i]) return o[i];\n        const s = e.cM(t, this);\n        return o[i] = s, o[i];\n      }\n      customLayerMatrix() {\n        return this.mercatorMatrix.slice();\n      }\n      globeToMercatorMatrix() {\n        if (\"globe\" === this.projection.name) {\n          const t = 1 / this.worldSize,\n            i = e.bq([], [t, t, t]);\n          return e.aB(i, i, this.globeMatrix), i;\n        }\n      }\n      recenterOnTerrain() {\n        if (!this._elevation || \"globe\" === this.projection.name) return;\n        const t = this._elevation;\n        this._updateCameraState();\n        const i = e.ce(1, this._center.lat) * this.worldSize,\n          o = this._computeCameraPosition(i),\n          s = this._camera.forward(),\n          r = e.ce(1, this._center.lat);\n        o[2] /= r, s[2] /= r, e.aw(s, s);\n        const n = t.raycast(o, s, t.exaggeration());\n        if (n) {\n          const t = e.bH([], o, s, n),\n            i = new e.ae(t[0], t[1], e.ce(t[2], e.a$(t[1]))),\n            a = (i.z + e.ag([i.x - o[0], i.y - o[1], i.z - o[2] * r])) * this._pixelsPerMercatorPixel;\n          this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();\n        }\n      }\n      _constrainCamera() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        if (!this._elevation) return;\n        const i = this._elevation,\n          o = e.ce(1, this._center.lat) * this.worldSize,\n          s = this._computeCameraPosition(o),\n          r = i.getAtPointOrZero(new e.ae(...s)),\n          n = this.pixelsPerMeter / this.worldSize * r,\n          a = this._minimumHeightOverTerrain(),\n          l = s[2] - n;\n        if (l <= a) if (l < 0 || t) {\n          const t = this.locationCoordinate(this._center, this._centerAltitude),\n            i = [s[0], s[1], t.z - s[2]],\n            o = e.ag(i);\n          i[2] -= (a - l) / this._pixelsPerMercatorPixel;\n          const r = e.ag(i);\n          if (0 === r) return;\n          e.c4(i, i, o / r * this._pixelsPerMercatorPixel), this._camera.position = [s[0], s[1], t.z * this._pixelsPerMercatorPixel - i[2]], this._updateStateFromCamera();\n        } else this._isCameraConstrained = !0;\n      }\n      _constrain() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n        this._constraining = !0;\n        const t = \"globe\" === this.projection.name || this.mercatorFromTransition;\n        if (this.projection.isReprojectedInTileSpace || t) {\n          const i = this.center;\n          return i.lat = e.aA(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (i.lng = e.aA(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);\n        }\n        const i = this._unmodified,\n          {\n            x: o,\n            y: s\n          } = this.point;\n        let r = 0,\n          n = o,\n          a = s;\n        const l = this.width / 2,\n          c = this.height / 2,\n          h = this.worldMinY * this.scale,\n          d = this.worldMaxY * this.scale;\n        if (s - c < h && (a = h + c), s + c > d && (a = d - c), d - h < this.height && (r = Math.max(r, this.height / (d - h)), a = (d + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {\n          const e = this.worldMinX * this.scale,\n            t = this.worldMaxX * this.scale,\n            i = this.worldSize / 2 - (e + t) / 2;\n          n = (o + i + this.worldSize) % this.worldSize - i, n - l < e && (n = e + l), n + l > t && (n = t - l), t - e < this.width && (r = Math.max(r, this.width / (t - e)), n = (t + e) / 2);\n        }\n        n === o && a === s || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n, a))), r && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;\n      }\n      _minZoomForBounds() {\n        let e = Math.max(0, this.scaleZoom(Math.max(0, this.height) / (this.worldMaxY - this.worldMinY)));\n        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;\n      }\n      _maxCameraBoundsDistance() {\n        return this._mercatorZfromZoom(this._minZoomForBounds());\n      }\n      _calcMatrices() {\n        if (!this.height) return;\n        const t = this.centerOffset,\n          i = \"globe\" === this.projection.name,\n          o = this.pixelsPerMeter;\n        \"globe\" === this.projection.name && (this._mercatorScaleRatio = e.ce(1, this.center.lat) / e.ce(1, e.d1));\n        const s = e.cN(this.projection, this.zoom, this.width, this.height, 1024);\n        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;\n        const r = \"meters\" === this.projection.zAxisUnit ? o : 1,\n          n = this._camera.getWorldToCamera(this.worldSize, r);\n        let a;\n        const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);\n        if (l[8] = 2 * -t.x / this.width, l[9] = 2 * t.y / this.height, this.isOrthographic) {\n          let i = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov),\n            o = i * this.aspect,\n            s = -o,\n            r = -i;\n          o -= t.x, s -= t.x, i += t.y, r += t.y, a = this._camera.getCameraToClipOrthographic(s, o, r, i, this._nearZ, this._farZ), ((t, i, o, s) => {\n            for (let r = 0; r < 16; r++) t[r] = e.ak(i[r], o[r], s);\n          })(a, a, l, e.c$(this.pitch >= eo ? 1 : this.pitch / eo));\n        } else a = l;\n        const c = e.cO([], l, n);\n        let h = e.cO([], a, n);\n        if (this.projection.isReprojectedInTileSpace) {\n          const t = this.locationCoordinate(this.center),\n            i = e.bA([]);\n          e.br(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.aB(i, i, e.cP(this)), e.br(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.aB(h, h, i), e.aB(c, c, i), this.inverseAdjustmentMatrix = e.cQ(this);\n        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];\n        if (this.mercatorMatrix = e.cR([], h, [this.worldSize, this.worldSize, this.worldSize / r, 1]), this.projMatrix = h, this.invProjMatrix = e.bl(new Float64Array(16), this.projMatrix), i) {\n          const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);\n          i[8] = 2 * -t.x / this.width, i[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = e.cO([], i, n);\n        } else this.expandedFarZProjMatrix = this.projMatrix;\n        const d = e.bl([], a);\n        this.frustumCorners = e.cS.fromInvProjectionMatrix(d, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.cA.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);\n        const u = new Float32Array(16);\n        e.bA(u), e.cR(u, u, [1, -1, 1]), e.cT(u, u, this._pitch), e.bB(u, u, this.angle);\n        const _ = e.cc(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);\n        this.starsProjMatrix = e.bz(_);\n        const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;\n        _[8] = 2 * -t.x / this.width, _[9] = 2 * (t.y + p) / this.height, this.skyboxMatrix = e.aB(u, _, u);\n        const f = this.point,\n          m = f.x,\n          g = f.y,\n          v = this.width % 2 / 2,\n          y = this.height % 2 / 2,\n          x = Math.cos(this.angle),\n          b = Math.sin(this.angle),\n          w = m - Math.round(m) + x * v + b * y,\n          T = g - Math.round(g) + x * y + b * v,\n          E = new Float64Array(h);\n        if (e.br(E, E, [w > .5 ? w - 1 : w, T > .5 ? T - 1 : T, 0]), this.alignedProjMatrix = E, h = e.bC(), e.cR(h, h, [this.width / 2, -this.height / 2, 1]), e.br(h, h, [1, -1, 0]), this.labelPlaneMatrix = h, h = e.bC(), e.cR(h, h, [1, -1, 1]), e.br(h, h, [-1, -1, 0]), e.cR(h, h, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h, this.pixelMatrix = e.aB(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.bl(new Float64Array(16), this.pixelMatrix), !h) throw new Error(\"failed to invert matrix\");\n        if (this.pixelMatrixInverse = h, \"globe\" === this.projection.name || this.mercatorFromTransition) {\n          this.globeMatrix = e.cU(this);\n          const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];\n          this.globeCenterInViewSpace = e.af(t, t, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;\n        } else this.globeMatrix = h;\n        this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};\n      }\n      _calcFogMatrices() {\n        this._fogTileMatrixCache = {};\n        const t = this.cameraWorldSizeForFog,\n          i = this.cameraPixelsPerMeter,\n          o = this._camera.position,\n          s = 1 / this.height / this._pixelsPerMercatorPixel,\n          r = [t, t, i];\n        e.c4(r, r, s), e.c4(o, o, -1), e.cV(o, o, r);\n        const n = e.bC();\n        e.br(n, n, o), e.cR(n, n, r), this.mercatorFogMatrix = n, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, s);\n      }\n      _computeCameraPosition(e) {\n        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,\n          i = this._camera.forward(),\n          o = this.point,\n          s = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;\n        return [o.x / this.worldSize - i[0] * s, o.y / this.worldSize - i[1] * s, e / this.worldSize * this._centerAltitude - i[2] * s];\n      }\n      _updateCameraState() {\n        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());\n      }\n      _translateCameraConstrained(t) {\n        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),\n          o = this._camera.position[2],\n          s = t[2];\n        let r = 1;\n        this.projection.wrap && (this.center = this.center.wrap()), s > 0 && (r = Math.min((i - o) / s, 1)), this._camera.position = e.bH([], this._camera.position, t, r), this._updateStateFromCamera();\n      }\n      _updateStateFromCamera() {\n        const t = this._camera.position,\n          i = this._camera.forward(),\n          {\n            pitch: o,\n            bearing: s\n          } = this._camera.getPitchBearing(),\n          r = e.ce(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,\n          n = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.an(this._maxPitch)),\n          a = Math.max((t[2] - r) / Math.cos(o), n),\n          l = this._zoomFromMercatorZ(a);\n        e.bH(t, t, i, a), this._pitch = e.aA(o, e.an(this.minPitch), e.an(this.maxPitch)), this.angle = e.bT(s, -Math.PI, Math.PI), this._setZoom(e.aA(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ae(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();\n      }\n      _worldSizeFromZoom(e) {\n        return Math.pow(2, e) * this.tileSize;\n      }\n      _mercatorZfromZoom(e) {\n        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);\n      }\n      _minimumHeightOverTerrain() {\n        const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;\n        return this._mercatorZfromZoom(e);\n      }\n      _zoomFromMercatorZ(e) {\n        return this.scaleZoom(this.cameraToCenterDistance / (Math.max(0, e) * this.tileSize));\n      }\n      zoomFromMercatorZAdjusted(t) {\n        let i = 0,\n          o = e.cK,\n          s = 0,\n          r = 1 / 0;\n        for (; o - i > 1e-6 && o > i;) {\n          const e = i + .5 * (o - i),\n            n = this.tileSize * Math.pow(2, e),\n            a = this.getCameraToCenterDistance(this.projection, e, n),\n            l = this.scaleZoom(a / (Math.max(0, t) * this.tileSize)),\n            c = Math.abs(e - l);\n          c < r && (r = c, s = e), e < l ? i = e : o = e;\n        }\n        return s;\n      }\n      _terrainEnabled() {\n        return !(!this._elevation || !this.projection.supportsTerrain && (e.w(\"Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.\"), 1));\n      }\n      anyCornerOffEdge(t, i) {\n        const o = Math.min(t.x, i.x),\n          s = Math.max(t.x, i.x),\n          r = Math.min(t.y, i.y),\n          n = Math.max(t.y, i.y);\n        if (r < this.horizonLineFromTop(!1)) return !0;\n        if (\"mercator\" !== this.projection.name) return !1;\n        const a = [new e.P(o, r), new e.P(s, n), new e.P(o, n), new e.P(s, r)],\n          l = this.renderWorldCopies ? -3 : 0,\n          c = this.renderWorldCopies ? 4 : 1;\n        for (const e of a) {\n          const t = this.pointRayIntersection(e);\n          if (t.t < 0) return !0;\n          const i = this.rayIntersectionCoordinate(t);\n          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;\n        }\n        return !1;\n      }\n      isHorizonVisible() {\n        return this.pitch + e.cW(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));\n      }\n      zoomDeltaToMovement(t, i) {\n        const o = e.ag(e.av([], this._camera.position, t)),\n          s = this._zoomFromMercatorZ(o) + i;\n        return o - this._mercatorZfromZoom(s);\n      }\n      getCameraPoint() {\n        if (\"globe\" === this.projection.name) {\n          const t = function (_ref88, s) {\n            let [t, i, o] = _ref88;\n            const r = [t, i, o, 1];\n            e.aC(r, r, s);\n            const n = r[3] = Math.max(r[3], 1e-6);\n            return r[0] /= n, r[1] /= n, r[2] /= n, r;\n          }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);\n          return new e.P(t[0], t[1]);\n        }\n        {\n          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n          return this.centerPoint.add(new e.P(0, t));\n        }\n      }\n      getCameraToCenterDistance(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.zoom;\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.worldSize;\n        const s = e.cN(t, i, this.width, this.height, 1024),\n          r = t.pixelSpaceConversion(this.center.lat, o, s);\n        let n = .5 / Math.tan(.5 * this._fov) * this.height * r;\n        return this.isOrthographic && (n = e.ak(1, n, e.c$(this.pitch >= eo ? 1 : this.pitch / eo))), n;\n      }\n      getWorldToCameraMatrix() {\n        const t = this._camera.getWorldToCamera(this.worldSize, \"meters\" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);\n        return \"globe\" === this.projection.name && e.aB(t, t, this.globeMatrix), t;\n      }\n      getFrustum(t) {\n        return e.cA.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, \"meters\" === this.projection.zAxisUnit);\n      }\n    }\n    const io = (t, i) => {\n        if (i > 0 && t.terrain && e.w(\"Cutoff is currently disabled on terrain\"), i <= 0 || t.terrain) return {\n          shouldRenderCutoff: !1,\n          uniformValues: {\n            u_cutoff_params: [0, 0, 0, 1]\n          }\n        };\n        const o = t.transform,\n          s = Math.max(Math.abs(o._zoom - (t.minCutoffZoom - 1)), 1),\n          r = o.isLODDisabled(!1) ? e.ah(60, 45, o.pitch) : e.ah(30, 15, o.pitch),\n          n = o._farZ - o._nearZ,\n          a = i * o.height,\n          l = ((1 - (c = r)) * o.cameraToCenterDistance + c * (o._farZ + a)) * s;\n        var c;\n        return {\n          shouldRenderCutoff: r < 1,\n          uniformValues: {\n            u_cutoff_params: [o._nearZ, o._farZ, (l - o._nearZ) / n, (l - a - o._nearZ) / n]\n          }\n        };\n      },\n      oo = {\n        cascadeCount: 2,\n        normalOffset: 3,\n        shadowMapResolution: 2048\n      };\n    class so {\n      constructor(e, t) {\n        this.aabb = e, this.lastCascade = t;\n      }\n    }\n    class ro {\n      add(e, t) {\n        const i = this.receivers[e.key];\n        void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t.max[2])) : this.receivers[e.key] = new so(t, null);\n      }\n      clear() {\n        this.receivers = {};\n      }\n      get(e) {\n        return this.receivers[e.key];\n      }\n      computeRequiredCascades(t, i, o) {\n        const s = e.d8.fromPoints(t.points);\n        let r = 0;\n        for (const t in this.receivers) {\n          const n = this.receivers[t];\n          if (!n) continue;\n          if (!s.intersectsAabb(n.aabb)) continue;\n          n.aabb.min = s.closestPoint(n.aabb.min), n.aabb.max = s.closestPoint(n.aabb.max);\n          const a = n.aabb.getCorners();\n          for (let t = 0; t < o.length; t++) {\n            let s = !0;\n            for (const r of a) {\n              const n = [r[0] * i, r[1] * i, r[2]];\n              if (e.af(n, n, o[t].matrix), n[0] < -1 || n[0] > 1 || n[1] < -1 || n[1] > 1) {\n                s = !1;\n                break;\n              }\n            }\n            if (n.lastCascade = t, r = Math.max(r, t), s) break;\n          }\n        }\n        return r + 1;\n      }\n    }\n    class no {\n      constructor(e) {\n        this.painter = e, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new ro(), this._depthMode = new ji(e.context.gl.LEQUAL, ji.ReadWrite, [0, 1]), this._uniformValues = {\n          u_light_matrix_0: new Float32Array(16),\n          u_light_matrix_1: new Float32Array(16),\n          u_shadow_intensity: 0,\n          u_fade_range: [0, 0],\n          u_shadow_normal_offset: [1, 1, 1],\n          u_shadow_texel_size: 1,\n          u_shadow_map_resolution: 1,\n          u_shadow_direction: [0, 0, 1],\n          u_shadow_bias: [36e-5, .0012, .012],\n          u_shadowmap_0: 0,\n          u_shadowmap_1: 0\n        }, this._forceDisable = !1, this.useNormalOffset = !1, e.tp.registerParameter(this, [\"Shadows\"], \"_forceDisable\", {\n          label: \"forceDisable\"\n        }, () => {\n          this.painter.style.map.triggerRepaint();\n        }), e.tp.registerParameter(oo, [\"Shadows\"], \"cascadeCount\", {\n          min: 1,\n          max: 2,\n          step: 1\n        }), e.tp.registerParameter(oo, [\"Shadows\"], \"normalOffset\", {\n          min: 0,\n          max: 10,\n          step: .05\n        }), e.tp.registerParameter(oo, [\"Shadows\"], \"shadowMapResolution\", {\n          min: 32,\n          max: 2048,\n          step: 32\n        }), e.tp.registerBinding(this, [\"Shadows\"], \"_numCascadesToRender\", {\n          readonly: !0,\n          label: \"numCascadesToRender\"\n        });\n      }\n      destroy() {\n        for (const e of this._cascades) e.texture.destroy(), e.framebuffer.destroy();\n        this._cascades = [];\n      }\n      updateShadowParameters(t, i) {\n        const o = this.painter;\n        if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i || !i.properties) return;\n        const s = i.properties.get(\"shadow-intensity\");\n        if (!i.shadowsEnabled() || s <= 0) return;\n        if (this._shadowLayerCount = o.style.order.reduce((e, i) => {\n          const s = o.style._mergedLayers[i];\n          return e + (s.hasShadowPass() && !s.isHidden(t.zoom) ? 1 : 0);\n        }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;\n        const r = o.context,\n          n = oo.shadowMapResolution,\n          a = oo.shadowMapResolution;\n        if (0 === this._cascades.length || oo.shadowMapResolution !== this._cascades[0].texture.size[0]) {\n          this._cascades = [];\n          for (let t = 0; t < oo.cascadeCount; ++t) {\n            const t = o._shadowMapDebug,\n              i = r.gl,\n              s = r.createFramebuffer(n, a, t, \"texture\"),\n              l = new e.T(r, {\n                width: n,\n                height: a,\n                data: null\n              }, i.DEPTH_COMPONENT16);\n            if (s.depthAttachment.set(l.texture), t) {\n              const t = new e.T(r, {\n                width: n,\n                height: a,\n                data: null\n              }, i.RGBA8);\n              s.colorAttachment.set(t.texture);\n            }\n            this._cascades.push({\n              framebuffer: s,\n              texture: l,\n              matrix: [],\n              far: 0,\n              boundingSphereRadius: 0,\n              frustum: new e.cA(),\n              scale: 0\n            });\n          }\n        }\n        this.shadowDirection = lo(i);\n        let l = 0;\n        if (t.elevation) {\n          const e = t.elevation,\n            i = [1e4, -1e4];\n          e.visibleDemTiles.filter(e => e.dem).forEach(e => {\n            const t = e.dem.tree;\n            i[0] = Math.min(i[0], t.minimums[0]), i[1] = Math.max(i[1], t.maximums[0]);\n          }), 1e4 !== i[0] && (l = (i[1] - i[0]) * e.exaggeration());\n        }\n        const c = 1.5 * t.cameraToCenterDistance,\n          h = 3 * c,\n          d = new Float64Array(16);\n        for (let i = 0; i < this._cascades.length; ++i) {\n          const o = this._cascades[i];\n          let s = t.height / 50,\n            r = 1;\n          1 === oo.cascadeCount ? r = h : 0 === i ? r = c : (s = c, r = h);\n          const [n, a] = ho(t, this.shadowDirection, s, r, oo.shadowMapResolution, l);\n          o.scale = t.scale, o.matrix = n, o.boundingSphereRadius = a, e.bl(d, o.matrix), o.frustum = e.cA.fromInvProjectionMatrix(d, 1, 0, !0), o.far = r;\n        }\n        const u = this._cascades.length - 1;\n        this._uniformValues.u_fade_range = [.75 * this._cascades[u].far, this._cascades[u].far], this._uniformValues.u_shadow_intensity = s, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / oo.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = oo.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Ji.ShadowMap0, this._uniformValues.u_shadowmap_1 = Ji.ShadowMap0 + 1, this._groundShadowTiles = o.transform.coveringTiles({\n          tileSize: 512,\n          renderWorldCopies: !0\n        });\n        const _ = o.transform.elevation;\n        for (const e of this._groundShadowTiles) {\n          let t = {\n            min: 0,\n            max: 0\n          };\n          if (_) {\n            const i = _.getMinMaxForTile(e);\n            i && (t = i);\n          }\n          this.addShadowReceiver(e.toUnwrapped(), t.min, t.max);\n        }\n      }\n      get enabled() {\n        return this._enabled && !this._forceDisable;\n      }\n      set enabled(e) {\n        this._enabled = e;\n      }\n      drawShadowPass(t, i) {\n        if (!this.enabled) return;\n        const o = this.painter,\n          s = o.context;\n        this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), s.viewport.set([0, 0, oo.shadowMapResolution, oo.shadowMapResolution]);\n        for (let r = 0; r < this._numCascadesToRender; ++r) {\n          o.currentShadowCascade = r, s.bindFramebuffer.set(this._cascades[r].framebuffer.framebuffer), s.clear({\n            color: e.ao.white,\n            depth: 1\n          });\n          for (const e of t.order) {\n            const s = t._mergedLayers[e];\n            if (!s.hasShadowPass() || s.isHidden(o.transform.zoom)) continue;\n            const r = t.getLayerSourceCache(s),\n              n = r ? i[r.id] : void 0;\n            (\"model\" === s.type || n && n.length) && o.renderLayer(o, r, s, n);\n          }\n        }\n        o.currentShadowCascade = 0;\n      }\n      drawGroundShadows() {\n        if (!this.enabled) return;\n        const e = this.painter,\n          t = e.style,\n          i = e.context,\n          o = i.gl,\n          s = t.directionalLight,\n          r = t.ambientLight;\n        if (!s || !r) return;\n        const n = [],\n          a = io(e, e.longestCutoffRange);\n        a.shouldRenderCutoff && n.push(\"RENDER_CUTOFF\"), n.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), this.useNormalOffset && n.push(\"NORMAL_OFFSET\");\n        const l = co(t, s, r),\n          c = new ji(o.LEQUAL, ji.ReadOnly, e.depthRangeFor3D),\n          h = new Gi({\n            func: o.EQUAL,\n            mask: 255\n          }, 0, 255, o.KEEP, o.KEEP, o.KEEP);\n        for (const t of this._groundShadowTiles) {\n          const s = t.toUnwrapped(),\n            r = e.isTileAffectedByFog(t),\n            d = e.getOrCreateProgram(\"groundShadow\", {\n              defines: n,\n              overrideFog: r\n            });\n          this.setupShadows(s, d), e.uploadCommonUniforms(i, d, s, null, a);\n          const u = {\n            u_matrix: e.transform.calculateProjMatrix(s),\n            u_ground_shadow_factor: l\n          };\n          d.draw(e, o.TRIANGLES, c, h, Ui.multiply, Zi.disabled, u, \"ground_shadow\", e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments, null, e.transform.zoom, null, null);\n        }\n      }\n      getShadowPassColorMode() {\n        return this.painter._shadowMapDebug ? Ui.unblended : Ui.disabled;\n      }\n      getShadowPassDepthMode() {\n        return this._depthMode;\n      }\n      getShadowCastingLayerCount() {\n        return this._shadowLayerCount;\n      }\n      calculateShadowPassMatrixFromTile(t) {\n        const i = this.painter.transform,\n          o = i.calculatePosMatrix(t, i.worldSize);\n        return e.aB(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);\n      }\n      calculateShadowPassMatrixFromMatrix(t) {\n        return e.aB(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);\n      }\n      setupShadows(t, i, o) {\n        if (!this.enabled) return;\n        const s = this.painter.transform,\n          r = this.painter.context,\n          n = r.gl,\n          a = this._uniformValues,\n          l = new Float64Array(16),\n          c = s.calculatePosMatrix(t, s.worldSize);\n        for (let t = 0; t < this._cascades.length; t++) e.aB(l, this._cascades[t].matrix, c), a[0 === t ? \"u_light_matrix_0\" : \"u_light_matrix_1\"] = Float32Array.from(l), r.activeTexture.set(n.TEXTURE0 + Ji.ShadowMap0 + t), this._cascades[t].texture.bindExtraParam(n.LINEAR, n.LINEAR, n.CLAMP_TO_EDGE, n.CLAMP_TO_EDGE, n.GREATER);\n        if (this.useNormalOffset = !!o, this.useNormalOffset) {\n          const i = e.d6(t.canonical),\n            r = 2 / s.tileSize * e.al / oo.shadowMapResolution,\n            n = r * this._cascades[0].boundingSphereRadius,\n            l = r * this._cascades[this._cascades.length - 1].boundingSphereRadius,\n            c = (\"vector-tile\" === o ? 1 : 3) * function (t, i, o, s, r) {\n              const n = e.aA((t - 22) / -22, 0, 1);\n              return .125 * (1 - n) + 4 * n;\n            }(s.zoom);\n          a.u_shadow_normal_offset = [i, n * c, l * c], a.u_shadow_bias = [1e-4, .0012, .012];\n        } else a.u_shadow_bias = [36e-5, .0012, .012];\n        i.setShadowUniformValues(r, a);\n      }\n      setupShadowsFromMatrix(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        if (!this.enabled) return;\n        const s = this.painter.context,\n          r = s.gl,\n          n = this._uniformValues,\n          a = new Float64Array(16);\n        for (let i = 0; i < oo.cascadeCount; i++) e.aB(a, this._cascades[i].matrix, t), n[0 === i ? \"u_light_matrix_0\" : \"u_light_matrix_1\"] = Float32Array.from(a), s.activeTexture.set(r.TEXTURE0 + Ji.ShadowMap0 + i), this._cascades[i].texture.bindExtraParam(r.LINEAR, r.LINEAR, r.CLAMP_TO_EDGE, r.CLAMP_TO_EDGE, r.GREATER);\n        if (this.useNormalOffset = o, o) {\n          const e = oo.normalOffset;\n          n.u_shadow_normal_offset = [1, e, e], n.u_shadow_bias = [6e-5, .0012, .012];\n        } else n.u_shadow_bias = [36e-5, .0012, .012];\n        i.setShadowUniformValues(s, n);\n      }\n      getShadowUniformValues() {\n        return this._uniformValues;\n      }\n      getCurrentCascadeFrustum() {\n        return this._cascades[this.painter.currentShadowCascade].frustum;\n      }\n      computeSimplifiedTileShadowVolume(t, i, o, s) {\n        if (s[2] >= 0) return {};\n        const r = function (t, i, o) {\n            const s = o / (1 << t.canonical.z);\n            return new e.d8([t.canonical.x * s + t.wrap * o, t.canonical.y * s + t.wrap * o, 0], [(t.canonical.x + 1) * s + t.wrap * o, (t.canonical.y + 1) * s + t.wrap * o, i]);\n          }(t, i, o).getCorners(),\n          n = i / -s[2];\n        s[0] < 0 ? (e.d7(r[0], r[0], [s[0] * n, 0, 0]), e.d7(r[3], r[3], [s[0] * n, 0, 0])) : s[0] > 0 && (e.d7(r[1], r[1], [s[0] * n, 0, 0]), e.d7(r[2], r[2], [s[0] * n, 0, 0])), s[1] < 0 ? (e.d7(r[0], r[0], [0, s[1] * n, 0]), e.d7(r[1], r[1], [0, s[1] * n, 0])) : s[1] > 0 && (e.d7(r[2], r[2], [0, s[1] * n, 0]), e.d7(r[3], r[3], [0, s[1] * n, 0]));\n        const a = {};\n        return a.vertices = r, a.planes = [ao(r[1], r[0], r[4]), ao(r[2], r[1], r[5]), ao(r[3], r[2], r[6]), ao(r[0], r[3], r[7])], a;\n      }\n      addShadowReceiver(t, i, o) {\n        this._receivers.add(t, e.d8.fromTileIdAndHeight(t, i, o));\n      }\n      getMaxCascadeForTile(e) {\n        const t = this._receivers.get(e);\n        return t && t.lastCascade ? t.lastCascade : 0;\n      }\n    }\n    function ao(t, i, o) {\n      const s = e.av([], o, i),\n        r = e.av([], t, i),\n        n = e.bI([], s, r),\n        a = e.ag(n);\n      return 0 === a ? [0, 0, 1, 0] : (e.c4(n, n, 1 / a), [n[0], n[1], n[2], -e.bJ(n, i)]);\n    }\n    function lo(t) {\n      const i = t.properties.get(\"direction\"),\n        o = e.d3(i.x, i.y, i.z);\n      o[2] = e.aA(o[2], 0, 75);\n      const s = e.d5([o[0], o[1], o[2]]);\n      return e.d4(s.x, s.y, s.z);\n    }\n    function co(t, i, o) {\n      const s = \"none\" === i.properties.get(\"color-use-theme\"),\n        r = i.properties.get(\"color\"),\n        n = i.properties.get(\"intensity\"),\n        a = i.properties.get(\"direction\"),\n        l = [a.x, a.y, a.z],\n        c = \"none\" === o.properties.get(\"color-use-theme\"),\n        h = o.properties.get(\"color\"),\n        d = o.properties.get(\"intensity\"),\n        u = Math.max(e.bJ([0, 0, 1], l), 0),\n        _ = [0, 0, 0];\n      e.c4(_, h.toPremultipliedRenderColor(c ? null : t.getLut(i.scope)).toArray01Linear().slice(0, 3), d);\n      const p = [0, 0, 0];\n      return e.c4(p, r.toPremultipliedRenderColor(s ? null : t.getLut(o.scope)).toArray01Linear().slice(0, 3), u * n), e.da([_[0] > 0 ? _[0] / (_[0] + p[0]) : 0, _[1] > 0 ? _[1] / (_[1] + p[1]) : 0, _[2] > 0 ? _[2] / (_[2] + p[2]) : 0]);\n    }\n    function ho(t, i, o, s, r, n) {\n      const a = t.zoom,\n        l = t.scale,\n        c = t.worldSize,\n        h = 1 / c,\n        d = t.aspect,\n        u = Math.sqrt(1 + d * d) * Math.tan(.5 * t.fovX),\n        _ = u * u,\n        p = s - o,\n        f = s + o;\n      let m, g;\n      _ > p / f ? (m = s, g = s * u) : (m = .5 * f * (1 + _), g = .5 * Math.sqrt(p * p + 2 * (s * s + o * o) * _ + f * f * _ * _));\n      const v = t.projection.pixelsPerMeter(t.center.lat, c),\n        y = t._camera.getCameraToWorldMercator(),\n        x = [0, 0, -m * h];\n      e.af(x, x, y);\n      let b = g * h;\n      const w = t._edgeInsets;\n      if (!(0 === w.left && 0 === w.top && 0 === w.right && 0 === w.bottom || w.left === w.right && w.top === w.bottom)) {\n        const i = t._camera.getWorldToCamera(t.worldSize, \"meters\" === t.projection.zAxisUnit ? v : 1),\n          r = t._camera.getCameraToClipPerspective(t._fov, t.width / t.height, o, s);\n        r[8] = 2 * -t.centerOffset.x / t.width, r[9] = 2 * t.centerOffset.y / t.height;\n        const n = new Float64Array(16);\n        e.cO(n, r, i);\n        const h = new Float64Array(16);\n        e.bl(h, n);\n        const d = e.cA.fromInvProjectionMatrix(h, c, a, !0);\n        for (const i of d.points) {\n          const o = ((T = i)[0] /= l, T[1] /= l, T[2] = e.ce(T[2], t._center.lat), T);\n          b = Math.max(b, e.c5(e.d9([], x, o)));\n        }\n      }\n      var T;\n      b *= r / (r - 1);\n      const E = Math.acos(i[2]),\n        S = Math.atan2(-i[0], -i[1]),\n        I = new Ki();\n      I.position = x, I.setPitchBearing(E, S);\n      const C = I.getWorldToCamera(c, v),\n        R = b * c,\n        A = Math.min(t._mercatorZfromZoom(17) * c * -2, -2 * R),\n        D = I.getCameraToClipOrthographic(-R, R, -R, R, A, (R + n * v) / i[2]),\n        L = new Float64Array(16);\n      e.aB(L, D, C);\n      const P = e.d4(Math.floor(1e6 * x[0]) / 1e6 * c, Math.floor(1e6 * x[1]) / 1e6 * c, 0),\n        z = .5 * r,\n        O = [0, 0, 0];\n      e.af(O, P, L), e.c4(O, O, z);\n      const M = [Math.floor(O[0]), Math.floor(O[1]), Math.floor(O[2])],\n        F = [0, 0, 0];\n      e.av(F, O, M), e.c4(F, F, -1 / z);\n      const B = new Float64Array(16);\n      return e.bA(B), e.br(B, B, F), e.aB(L, B, L), [L, R];\n    }\n    class uo extends e.E {\n      constructor(e) {\n        super(), this.requestManager = e, this.models = {\n          \"\": {}\n        }, this.modelUris = {\n          \"\": {}\n        }, this.modelByURL = {}, this.numModelsLoading = {};\n      }\n      loadModel(t, i) {\n        return e.aV(this.requestManager.transformRequest(i, e.R.Model).url).then(i => {\n          if (!i) return;\n          const o = e.aW(i),\n            s = new e.aX(t, void 0, void 0, o);\n          return s.computeBoundsAndApplyParent(), s;\n        }).catch(o => {\n          if (o && 404 === o.status) return null;\n          this.fire(new e.y(new Error(\"Could not load model \".concat(t, \" from \").concat(i, \": \").concat(o.message))));\n        });\n      }\n      load(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          forceReload: !1\n        };\n        this.models[i] || (this.models[i] = {});\n        const s = Object.keys(t),\n          r = [],\n          n = [];\n        for (const e of s) {\n          const s = t[e];\n          this.hasURLBeenRequested(s) && !o.forceReload || (this.modelByURL[s] = {\n            modelId: e,\n            scope: i\n          }, r.push(this.loadModel(e, s)), n.push(e)), this.models[i][e] || (this.models[i][e] = {\n            model: null,\n            numReferences: 1\n          });\n        }\n        this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + n.length, Promise.allSettled(r).then(t => {\n          for (let e = 0; e < t.length; e++) {\n            const {\n              status: o\n            } = t[e];\n            if (\"rejected\" === o) continue;\n            const {\n              value: s\n            } = t[e];\n            this.models[i][n[e]] || (this.models[i][n[e]] = {\n              model: null,\n              numReferences: 1\n            }), this.models[i][n[e]].model = s;\n          }\n          this.numModelsLoading[i] -= n.length, this.fire(new e.z(\"data\", {\n            dataType: \"style\"\n          }));\n        }).catch(t => {\n          this.fire(new e.y(new Error(\"Could not load models: \".concat(t.message))));\n        });\n      }\n      isLoaded() {\n        for (const e in this.numModelsLoading) if (this.numModelsLoading[e] > 0) return !1;\n        return !0;\n      }\n      hasModel(e, t) {\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          exactIdMatch: !1\n        };\n        return !!(i.exactIdMatch ? this.getModel(e, t) : this.getModelByURL(this.modelUris[t][e]));\n      }\n      getModel(e, t) {\n        return this.models[t] || (this.models[t] = {}), this.models[t][e] ? this.models[t][e].model : void 0;\n      }\n      getModelByURL(e) {\n        if (!e) return null;\n        const t = this.modelByURL[e];\n        return t ? this.models[t.scope][t.modelId].model : null;\n      }\n      hasModelBeenAdded(e, t) {\n        return this.models[t] && void 0 !== this.models[t][e];\n      }\n      getModelURIs(e) {\n        return this.modelUris[e] || {};\n      }\n      addModel(e, t, i) {\n        this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {});\n        const o = this.requestManager.normalizeModelURL(t);\n        if ((this.hasModel(e, i, {\n          exactIdMatch: !0\n        }) || this.hasModelBeenAdded(e, i)) && this.modelUris[i][e] === o) this.models[i][e].numReferences++;else if (this.hasURLBeenRequested(o)) {\n          const {\n            scope: e,\n            modelId: t\n          } = this.modelByURL[o];\n          this.models[e][t].numReferences++;\n        } else this.modelUris[i][e] = o, this.load({\n          [e]: this.modelUris[i][e]\n        }, i);\n      }\n      addModelURLs(e, t) {\n        this.models[t] || (this.models[t] = {}), this.modelUris[t] || (this.modelUris[t] = {});\n        const i = this.modelUris[t];\n        for (const t in e) i[t] = this.requestManager.normalizeModelURL(e[t]);\n      }\n      reloadModels(e) {\n        this.load(this.modelUris[e], e, {\n          forceReload: !0\n        });\n      }\n      addModelsFromBucket(t, i) {\n        this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {});\n        const o = {};\n        for (const s of t) this.hasModel(s, i, {\n          exactIdMatch: !0\n        }) || this.hasURLBeenRequested(s) ? this.models[i][s].numReferences++ : this.modelUris[i][s] && !this.hasURLBeenRequested(s) ? o[s] = this.modelUris[i][s] : !this.hasURLBeenRequested(s) && e.db(s, !1) && (this.modelUris[i][s] = this.requestManager.normalizeModelURL(s), o[s] = this.modelUris[i][s]);\n        this.load(o, i);\n      }\n      hasURLBeenRequested(e) {\n        return void 0 !== this.modelByURL[e];\n      }\n      removeModel(e, t) {\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n        if (this.models[t] && this.models[t][e] && (this.models[t][e].numReferences--, 0 === this.models[t][e].numReferences || o)) {\n          const o = this.modelUris[t][e];\n          i || delete this.modelUris[t][e], delete this.modelByURL[o];\n          const s = this.models[t][e].model;\n          if (!s) return;\n          delete this.models[t][e], s.destroy();\n        }\n      }\n      destroy() {\n        for (const e of Object.keys(this.models)) for (const t of Object.keys(this.models[e])) {\n          const i = this.models[e][t].model;\n          delete this.models[e][t], i && i.destroy();\n        }\n        this.models = {\n          \"\": {}\n        }, this.modelUris = {\n          \"\": {}\n        }, this.modelByURL = {}, this.numModelsLoading = {};\n      }\n      listModels(e) {\n        return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);\n      }\n      upload(e, t) {\n        this.models[t] || (this.models[t] = {});\n        for (const i in this.models[t]) this.models[t][i].model && this.models[t][i].model.upload(e.context);\n      }\n    }\n    const _o = new e.a9({\n      data: new e.aa(e.a6.colorTheme.data)\n    });\n    function po(t) {\n      if (!t.metadata || !t.metadata.content_area) return;\n      const i = e.o.devicePixelRatio,\n        {\n          left: o,\n          top: s,\n          width: r,\n          height: n\n        } = t.metadata.content_area,\n        a = o * i,\n        l = s * i;\n      return [a, l, a + r * i, l + n * i];\n    }\n    function fo(t) {\n      if (t) return t.map(_ref89 => {\n        let [t, i] = _ref89;\n        return [t * e.o.devicePixelRatio, i * e.o.devicePixelRatio];\n      });\n    }\n    class mo {\n      constructor(e, t, i) {\n        this.id = e, this.scope = t, this.sourceCache = i, this.pendingRequests = new Set(), this.missingRequests = new Set();\n      }\n      addPendingRequest(e) {\n        this.missingRequests.has(e.name) || this.pendingRequests.has(e.name) || this.pendingRequests.add(e.name);\n      }\n      hasPendingRequests() {\n        return this.pendingRequests.size > 0;\n      }\n      resolvePendingRequests() {\n        const t = new Map();\n        if (!this.sourceCache.loaded()) return t;\n        const i = this.sourceCache.getVisibleCoordinates();\n        if (0 === i.length) return t;\n        const o = this.sourceCache.getSource();\n        if (!(o instanceof nt)) return t;\n        const s = i.map(e => this.sourceCache.getTile(e)),\n          r = o.getImages(s, Array.from(this.pendingRequests));\n        for (const [i, o] of r) t.set(e.I.from({\n          name: i,\n          iconsetId: this.id\n        }), o), this.pendingRequests.delete(i);\n        for (const e of this.pendingRequests) this.missingRequests.add(e);\n        return this.pendingRequests.clear(), t;\n      }\n    }\n    const go = (e, t) => Le(e, t && t.filter(e => \"source.canvas\" !== e.identifier)),\n      vo = e.aH(Mt, [\"addLayer\", \"removeLayer\", \"setLights\", \"setPaintProperty\", \"setLayoutProperty\", \"setSlot\", \"setFilter\", \"addSource\", \"removeSource\", \"setLayerZoomRange\", \"setLight\", \"setTransition\", \"setGeoJSONSourceData\", \"setTerrain\", \"setFog\", \"setSnow\", \"setRain\", \"setProjection\", \"setCamera\", \"addImport\", \"removeImport\", \"updateImport\", \"addIconset\", \"removeIconset\"]),\n      yo = e.aH(Mt, [\"setCenter\", \"setZoom\", \"setBearing\", \"setPitch\"]),\n      xo = new Set([\"background\", \"sky\", \"slot\", \"custom\"]),\n      bo = {\n        version: 8,\n        layers: [],\n        sources: {}\n      },\n      wo = {\n        duration: 300,\n        delay: 0\n      };\n    class To extends e.E {\n      constructor(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(), this.map = t, this.scope = i.scope || \"\", this.globalId = null, this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map(), this.resolvedImports = i.resolvedImports || new Set(), this.transition = Object.assign({}, wo), this._buildingIndex = new Pt(this), this.crossTileSymbolIndex = new ki(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = i.styleChanges || new V(), this.dispatcher = i.dispatcher ? i.dispatcher : new e.D(e.dd(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new H(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.de(t._requestManager, i.localFontFamily ? e.df.all : i.localIdeographFontFamily ? e.df.ideographs : e.df.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new uo(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = !1, this.options = i.configOptions ? i.configOptions : new Map(), this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set(), this._config = i.config, this._styleColorTheme = {\n          lut: null,\n          lutLoading: !1,\n          lutLoadingCorrelationID: 0,\n          colorTheme: null,\n          colorThemeOverride: i.colorThemeOverride\n        }, this._styleColorThemeForScope = {}, this._initialConfig = i.initialConfig, this.dispatcher.broadcast(\"setReferrer\", e.dg());\n        const o = this;\n        this._rtlTextPluginCallback = To.registerForPluginStateChange(t => {\n          o.dispatcher.broadcast(\"syncRTLPluginState\", {\n            pluginStatus: t.pluginStatus,\n            pluginURL: t.pluginURL\n          }, (t, i) => {\n            if (e.dh(t), i && i.every(e => e)) for (const e in o._sourceCaches) {\n              const t = o._sourceCaches[e],\n                i = t.getSource().type;\n              \"vector\" !== i && \"geojson\" !== i || t.reload();\n            }\n          });\n        }), this.on(\"data\", e => {\n          if (\"source\" !== e.dataType || \"metadata\" !== e.sourceDataType) return;\n          const t = this.getOwnSource(e.sourceId);\n          if (t && t.vectorLayerIds) for (const e in this._layers) {\n            const i = this._layers[e];\n            i.source === t.id && this._validateLayer(i);\n          }\n        });\n      }\n      load(e) {\n        return e ? (\"string\" == typeof e ? this.loadURL(e) : this.loadJSON(e), this) : this;\n      }\n      _getGlobalId(t) {\n        if (!t) return null;\n        if (\"string\" == typeof t) {\n          if (e.h(t)) return t;\n          const i = e.di(t);\n          if (!i.startsWith(\"http\")) try {\n            return new URL(i, location.href).toString();\n          } catch (e) {\n            return i;\n          }\n          return i;\n        }\n        return \"json://\".concat(e.dj(JSON.stringify(t)));\n      }\n      _diffStyle(t, i, o) {\n        this.globalId = this._getGlobalId(t);\n        const s = (e, t) => {\n          try {\n            t(null, this.setState(e, o));\n          } catch (e) {\n            t(e, !1);\n          }\n        };\n        if (\"string\" == typeof t) {\n          const o = this.map._requestManager.normalizeStyleURL(t),\n            r = this.map._requestManager.transformRequest(o, e.R.Style);\n          e.m(r, (t, o) => {\n            t ? this.fire(new e.y(t)) : o && s(o, i);\n          });\n        } else \"object\" == typeof t && s(t, i);\n      }\n      loadURL(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.fire(new e.z(\"dataloading\", {\n          dataType: \"style\"\n        }));\n        const o = \"boolean\" == typeof i.validate ? i.validate : !e.h(t);\n        this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, i.accessToken), this.resolvedImports.add(t);\n        const s = this.importsCache.get(t);\n        if (s) return this._load(s, o);\n        const r = this.map._requestManager.transformRequest(t, e.R.Style);\n        this._request = e.m(r, (i, s) => {\n          if (this._request = null, i) this.fire(new e.y(i));else if (s) return this.importsCache.set(t, s), this._load(s, o);\n        });\n      }\n      loadJSON(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.fire(new e.z(\"dataloading\", {\n          dataType: \"style\"\n        })), this.globalId = this._getGlobalId(t), this._request = e.o.frame(() => {\n          this._request = null, this._load(t, !1 !== i.validate);\n        });\n      }\n      loadEmpty() {\n        this.fire(new e.z(\"dataloading\", {\n          dataType: \"style\"\n        })), this._load(bo, !1);\n      }\n      _loadImports(t, i, o) {\n        if (this.importDepth >= 4) return e.w(\"Style doesn't support nesting deeper than 5\"), Promise.resolve();\n        const s = [];\n        for (const e of t) {\n          const t = this._createFragmentStyle(e),\n            r = new Promise(e => {\n              t.once(\"style.import.load\", e), t.once(\"error\", e);\n            }).then(() => this.mergeAll());\n          if (s.push(r), this.resolvedImports.has(e.url)) {\n            t.loadEmpty();\n            continue;\n          }\n          const n = e.data || this.importsCache.get(e.url);\n          n ? (t.loadJSON(n, {\n            validate: i\n          }), this._isInternalStyle(n) && (t.globalId = null)) : e.url ? t.loadURL(e.url, {\n            validate: i\n          }) : t.loadEmpty();\n          const a = {\n            style: t,\n            id: e.id,\n            config: e.config\n          };\n          if (o) {\n            const e = this.fragments.findIndex(_ref90 => {\n              let {\n                id: e\n              } = _ref90;\n              return e === o;\n            });\n            this.fragments = this.fragments.slice(0, e).concat(a).concat(this.fragments.slice(e));\n          } else this.fragments.push(a);\n        }\n        return Promise.allSettled(s);\n      }\n      getImportGlobalIds() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n        for (const i of e.fragments) i.style.globalId && t.add(i.style.globalId), this.getImportGlobalIds(i.style, t);\n        return [...t.values()];\n      }\n      _createFragmentStyle(t) {\n        const i = this.scope ? e.B(t.id, this.scope) : t.id;\n        let o;\n        const s = this._initialConfig && this._initialConfig[i];\n        (t.config || s) && (o = Object.assign({}, t.config, s));\n        const r = new To(this.map, {\n          scope: i,\n          styleChanges: this._changes,\n          importDepth: this.importDepth + 1,\n          importsCache: this.importsCache,\n          resolvedImports: new Set(this.resolvedImports),\n          dispatcher: this.dispatcher,\n          imageManager: this.imageManager,\n          glyphManager: this.glyphManager,\n          modelManager: this.modelManager,\n          config: o,\n          configOptions: this.options,\n          colorThemeOverride: t[\"color-theme\"],\n          configDependentLayers: this._configDependentLayers\n        });\n        return r.setEventedParent(this.map, {\n          style: r\n        }), r;\n      }\n      _reloadImports() {\n        this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast(\"setLayers\", {\n          layers: this._serializeLayers(this._order),\n          scope: this.scope,\n          options: this.options\n        }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();\n      }\n      _isInternalStyle(e) {\n        return this.isRootStyle() && (e.fragment || !!e.schema && !1 !== e.fragment);\n      }\n      _load(t, i) {\n        if (this._isInternalStyle(t)) {\n          const e = Object.assign({}, bo, {\n            imports: [{\n              id: \"basemap\",\n              data: t,\n              url: \"\"\n            }]\n          });\n          return void this._load(e, i);\n        }\n        if (this.updateConfig(this._config, t.schema), i && go(this, ge(t))) return;\n        this._loaded = !0, this.stylesheet = e.dk(t);\n        const o = () => {\n          for (const e in t.sources) this.addSource(e, t.sources[e], {\n            validate: !1,\n            isInitialLoad: !0\n          });\n          if (t.iconsets) for (const e in t.iconsets) this.addIconset(e, t.iconsets[e]);\n          t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          })), !this.glyphManager.url && t.glyphs && this.glyphManager.setURL(t.glyphs);\n          const o = Ot(this.stylesheet.layers);\n          if (this._order = o.map(e => e.id), this.stylesheet.light && e.w(\"The `light` root property is deprecated, prefer using `lights` with `flat` light type instead.\"), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && \"flat\" === this.stylesheet.lights[0].type) {\n            const e = this.stylesheet.lights[0];\n            this.light = new ze(e.properties, e.id);\n          } else this.setLights(this.stylesheet.lights);\n          this.light || (this.light = new ze(this.stylesheet.light)), this._layers = {};\n          for (const t of o) {\n            const i = e.dq(t, this.scope, this._styleColorTheme.lut, this.options);\n            0 !== i.configDependencies.size && this._configDependentLayers.add(i.fqid), i.setEventedParent(this, {\n              layer: {\n                id: i.id\n              }\n            }), this._layers[i.id] = i;\n            const o = this.getOwnLayerSourceCache(i),\n              s = !!this.directionalLight && this.directionalLight.shadowsEnabled();\n            o && i.canCastShadows() && s && (o.castsShadows = !0);\n          }\n          this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);\n          const s = this.stylesheet.terrain;\n          s && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.z(\"data\", {\n            dataType: \"style\"\n          }));\n          const r = this.isRootStyle();\n          t.imports ? this._loadImports(t.imports, i).then(() => {\n            this._reloadImports(), this.fire(new e.z(r ? \"style.load\" : \"style.import.load\"));\n          }).catch(t => {\n            this.fire(new e.y(new Error(\"Failed to load imports\", t))), this.fire(new e.z(r ? \"style.load\" : \"style.import.load\"));\n          }) : (this._reloadImports(), this.fire(new e.z(r ? \"style.load\" : \"style.import.load\")));\n        };\n        this._styleColorTheme.colorTheme = this.stylesheet[\"color-theme\"];\n        const s = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;\n        if (s) {\n          const t = this._evaluateColorThemeData(s);\n          this._loadColorTheme(t).then(() => {\n            o();\n          }).catch(t => {\n            e.w(\"Couldn't load color theme from the stylesheet: \".concat(t)), o();\n          });\n        } else this._styleColorTheme.lut = null, o();\n      }\n      isRootStyle() {\n        return 0 === this.importDepth;\n      }\n      mergeAll() {\n        let e, t, i, o, s, r, n, a, l, c;\n        const h = {};\n        this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(d => {\n          if (d.stylesheet) {\n            if (null != d.light && (e = d.light), d.stylesheet.lights) for (const e of d.stylesheet.lights) \"ambient\" === e.type && null != d.ambientLight && (t = d.ambientLight), \"directional\" === e.type && null != d.directionalLight && (i = d.directionalLight);\n            o = this._prioritizeTerrain(o, d.terrain, d.stylesheet.terrain), d.stylesheet.fog && null != d.fog && (s = d.fog), d.stylesheet.snow && null != d.snow && (r = d.snow), d.stylesheet.rain && null != d.rain && (n = d.rain), null != d.stylesheet.camera && (c = d.stylesheet.camera), null != d.stylesheet.projection && (a = d.stylesheet.projection), null != d.stylesheet.transition && (l = d.stylesheet.transition), h[d.scope] = d._styleColorTheme;\n          }\n        }), this.light = e, this.ambientLight = t, this.directionalLight = i, this.fog = s, this.snow = r, this.rain = n, this._styleColorThemeForScope = h, null === o ? delete this.terrain : this.terrain = o, this.camera = c || {\n          \"camera-projection\": \"perspective\"\n        }, this.projection = a || {\n          name: \"mercator\"\n        }, this.transition = Object.assign({}, wo, l), this.mergeSources(), this.mergeLayers();\n      }\n      forEachFragmentStyle(e) {\n        const t = i => {\n          for (const e of i.fragments) t(e.style);\n          e(i);\n        };\n        t(this);\n      }\n      _prioritizeTerrain(e, t, i) {\n        const o = e && 0 === e.drapeRenderMode;\n        return null === i ? t && 0 === t.drapeRenderMode ? t : o ? e : null : null != t && (!e || o || t && 1 === t.drapeRenderMode) ? t : e;\n      }\n      mergeTerrain() {\n        let e;\n        this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(t => {\n          e = this._prioritizeTerrain(e, t.terrain, t.stylesheet.terrain);\n        }), null === e ? delete this.terrain : this.terrain = e;\n      }\n      mergeProjection() {\n        let e;\n        this.forEachFragmentStyle(t => {\n          null != t.stylesheet.projection && (e = t.stylesheet.projection);\n        }), this.projection = e || {\n          name: \"mercator\"\n        };\n      }\n      mergeSources() {\n        const t = {},\n          i = {},\n          o = {};\n        this.forEachFragmentStyle(s => {\n          for (const i in s._sourceCaches) {\n            const o = e.B(i, s.scope);\n            t[o] = s._sourceCaches[i];\n          }\n          for (const t in s._otherSourceCaches) {\n            const o = e.B(t, s.scope);\n            i[o] = s._otherSourceCaches[t];\n          }\n          for (const t in s._symbolSourceCaches) {\n            const i = e.B(t, s.scope);\n            o[i] = s._symbolSourceCaches[t];\n          }\n        }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;\n      }\n      mergeLayers() {\n        var _this2 = this;\n        const t = {},\n          i = [],\n          o = {};\n        this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle(o => {\n          for (const s of o._order) {\n            const r = o._layers[s];\n            if (\"slot\" === r.type) {\n              const i = e.dl(s);\n              if (t[i]) continue;\n              t[i] = [];\n            }\n            r.slot && t[r.slot] ? t[r.slot].push(r) : i.push(r);\n          }\n        }), this._mergedOrder = [];\n        let s = -1;\n        const r = function () {\n          let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          for (const n of i) if (\"slot\" === n.type) {\n            const i = e.dl(n.id);\n            t[i] && r(t[i]), _this2._mergedSlots.push(i);\n          } else {\n            const t = e.B(n.id, n.scope);\n            _this2._mergedOrder.push(t), o[t] = n, n.is3D(!!_this2.terrain) && (_this2._has3DLayers = !0, s = _this2._mergedOrder.length - 1), \"circle\" === n.type && (_this2._hasCircleLayers = !0), \"symbol\" === n.type && (_this2._hasSymbolLayers = !0), \"clip\" === n.type && (_this2._clipLayerPresent = !0);\n          }\n        };\n        if (r(i), this._has3DLayers) {\n          const e = {};\n          for (let t = 0; t < this._mergedOrder.length; ++t) {\n            const i = this._mergedOrder[t];\n            e[i] = t === s ? 1 : t < s ? o[i].hasOcclusionOpacityProperties ? 2 : 0 : 4;\n          }\n          this._mergedOrder.sort((t, i) => e[t] - e[i]);\n        }\n        this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();\n      }\n      terrainSetForDrapingOnly() {\n        return !!this.terrain && 0 === this.terrain.drapeRenderMode;\n      }\n      getCamera() {\n        return this.stylesheet.camera;\n      }\n      setCamera(e) {\n        return this.stylesheet.camera = Object.assign({}, this.stylesheet.camera, e), this.camera = this.stylesheet.camera, this;\n      }\n      _evaluateColorThemeData(t) {\n        return t.data ? function (t, i, o, s) {\n          const r = Object.assign({}, i);\n          for (const t of Object.keys(e.a6.colorTheme)) void 0 === r[t] && (r[t] = e.a6.colorTheme[t].default);\n          const n = new e.a8(_o, t, new Map(o));\n          return n.setTransitionOrValue(r, o), n.untransitioned().possiblyEvaluate(new e.ac(0, {\n            worldview: void 0\n          }));\n        }(this.scope, t, this.options).get(\"data\") : null;\n      }\n      _loadColorTheme(t) {\n        this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;\n        const i = this._styleColorTheme.lutLoadingCorrelationID;\n        return new Promise((o, s) => {\n          const r = \"data:image/png;base64,\";\n          if (!t || 0 === t.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o();\n          let n = t;\n          n.startsWith(r) || (n = r + n);\n          const a = e.I.from(\"mapbox-reserved-lut\"),\n            l = new Image();\n          l.src = n, l.onerror = () => {\n            this._styleColorTheme.lutLoading = !1, s(new Error(\"Failed to load image data\"));\n          }, l.onload = () => {\n            if (this._styleColorTheme.lutLoadingCorrelationID !== i) return void o();\n            this._styleColorTheme.lutLoading = !1;\n            const {\n              width: r,\n              height: n,\n              data: c\n            } = e.o.getImageData(l);\n            if (n > 32) return void s(new Error(\"The height of the image must be less than or equal to 32 pixels.\"));\n            if (r !== n * n) return void s(new Error(\"The width of the image must be equal to the height squared.\"));\n            this.getImage(a) && this.removeImage(a), this.addImage(a, {\n              data: new e.q({\n                width: r,\n                height: n\n              }, c),\n              pixelRatio: 1,\n              sdf: !1,\n              usvg: !1,\n              version: 0\n            });\n            const h = this.imageManager.getImage(a, this.scope);\n            h ? (this._styleColorTheme.lut = {\n              image: h.data,\n              data: t\n            }, o()) : s(new Error(\"Missing LUT image.\"));\n          };\n        });\n      }\n      getLut(e) {\n        const t = this._styleColorThemeForScope[e];\n        return t ? t.lut : null;\n      }\n      setProjection(e) {\n        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();\n      }\n      applyProjectionUpdate() {\n        this._loaded && (this.dispatcher.broadcast(\"setProjection\", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));\n      }\n      _updateMapProjection() {\n        this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));\n      }\n      _loadSprite(t) {\n        this._spriteRequest = function (t, i, o) {\n          let s, r, n;\n          const a = e.o.devicePixelRatio > 1 ? \"@2x\" : \"\";\n          let l = e.m(i.transformRequest(i.normalizeSpriteURL(t, a, \".json\"), e.R.SpriteJSON), (e, t) => {\n              l = null, n || (n = e, s = t, h());\n            }),\n            c = e.n(i.transformRequest(i.normalizeSpriteURL(t, a, \".png\"), e.R.SpriteImage), (e, t) => {\n              c = null, n || (n = e, r = t, h());\n            });\n          function h() {\n            if (n) o(n);else if (s && r) {\n              const t = e.o.getImageData(r),\n                i = {};\n              for (const o in s) {\n                const {\n                    width: r,\n                    height: n,\n                    x: a,\n                    y: l,\n                    sdf: c,\n                    pixelRatio: h,\n                    stretchX: d,\n                    stretchY: u,\n                    content: _\n                  } = s[o],\n                  p = new e.q({\n                    width: r,\n                    height: n\n                  });\n                e.q.copy(t, p, {\n                  x: a,\n                  y: l\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: r,\n                  height: n\n                }, null), i[o] = {\n                  data: p,\n                  pixelRatio: void 0 !== h ? h : 1,\n                  sdf: void 0 !== c && c,\n                  stretchX: d,\n                  stretchY: u,\n                  content: _,\n                  usvg: !1,\n                  version: 0\n                };\n              }\n              o(null, i);\n            }\n          }\n          return {\n            cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n          };\n        }(t, this.map._requestManager, (t, i) => {\n          if (this._spriteRequest = null, t) this.fire(new e.y(t));else if (i) {\n            const t = new Map();\n            for (const o in i) t.set(e.I.from(o), i[o]);\n            this.addImages(t);\n          }\n          this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          }), this.fire(new e.z(\"data\", {\n            dataType: \"style\"\n          }));\n        });\n      }\n      addIconset(t, i) {\n        if (\"sprite\" === i.type) return void this._loadSprite(i.url);\n        const o = this.getOwnSourceCache(i.source);\n        if (!o) return void this.fire(new e.y(new Error(\"Source \\\"\".concat(i.source, \"\\\" as specified by iconset \\\"\").concat(t, \"\\\" does not exist and cannot be used as an iconset source\"))));\n        const s = o.getSource();\n        if (\"raster-array\" !== s.type) return void this.fire(new e.y(new Error(\"Source \\\"\".concat(i.source, \"\\\" as specified by iconset \\\"\").concat(t, \"\\\" is not a \\\"raster-array\\\" source and cannot be used as an iconset source\"))));\n        s.partial = !1;\n        const r = new mo(t, this.scope, o);\n        this.imageManager.addImageProvider(r, this.scope);\n      }\n      removeIconset(e) {\n        this.imageManager.removeImageProvider(e, this.scope);\n      }\n      _loadIconset(t) {\n        if (!e.h(t) && \"icon_set\" !== this.map._spriteFormat || \"raster\" === this.map._spriteFormat) return void this._loadSprite(t);\n        const i = \"auto\" === this.map._spriteFormat;\n        var o, s;\n        this._spriteRequest = (s = (o, s) => {\n          if (this._spriteRequest = null, o) i ? this._loadSprite(t) : this.fire(new e.y(o));else if (s) {\n            const t = new Map();\n            for (const i in s) t.set(e.I.from(i), s[i]);\n            this.addImages(t);\n          }\n          this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          }), this.fire(new e.z(\"data\", {\n            dataType: \"style\"\n          }));\n        }, e.bu((o = this.map._requestManager).transformRequest(o.normalizeIconsetURL(t), e.R.Iconset), (t, i) => {\n          if (t) return void s(t);\n          const o = {},\n            r = e.dc(new e.bt(i));\n          for (const t of r.icons) {\n            const i = {\n              version: 1,\n              pixelRatio: e.o.devicePixelRatio,\n              content: po(t),\n              stretchX: t.metadata ? fo(t.metadata.stretch_x_areas) : void 0,\n              stretchY: t.metadata ? fo(t.metadata.stretch_y_areas) : void 0,\n              sdf: !1,\n              usvg: !0,\n              icon: t\n            };\n            o[t.name] = i;\n          }\n          s(null, o);\n        }));\n      }\n      _validateLayer(t) {\n        const i = this.getOwnSource(t.source);\n        if (!i) return;\n        const o = t.sourceLayer;\n        o && (\"geojson\" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.y(new Error(\"Source layer \\\"\".concat(o, \"\\\" does not exist on source \\\"\").concat(i.id, \"\\\" as specified by style layer \\\"\").concat(t.id, \"\\\"\"))));\n      }\n      loaded() {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;\n        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;\n        if (!this.imageManager.isLoaded()) return !1;\n        if (this.imageManager.hasPatternsInFlight()) return !1;\n        if (!this.modelManager.isLoaded()) return !1;\n        if (this._styleColorTheme.lutLoading) return !1;\n        for (const {\n          style: e\n        } of this.fragments) if (!e.loaded()) return !1;\n        return !0;\n      }\n      _serializeImports() {\n        if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t) => {\n          const i = this.fragments[t];\n          return i && i.style && (e.data = i.style.serialize()), e;\n        });\n      }\n      _serializeSources() {\n        const e = {};\n        for (const t in this._sourceCaches) {\n          const i = this._sourceCaches[t].getSource();\n          e[i.id] || (e[i.id] = i.serialize());\n        }\n        return e;\n      }\n      _serializeLayers(e) {\n        const t = [];\n        for (const i of e) {\n          const e = this._layers[i];\n          e && \"custom\" !== e.type && t.push(e.serialize());\n        }\n        return t;\n      }\n      hasLightTransitions() {\n        return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());\n      }\n      hasFogTransition() {\n        return !!this.fog && this.fog.hasTransition();\n      }\n      hasSnowTransition() {\n        return !!this.snow && this.snow.hasTransition();\n      }\n      hasRainTransition() {\n        return !!this.rain && this.rain.hasTransition();\n      }\n      hasTransitions() {\n        if (this.hasLightTransitions()) return !0;\n        if (this.hasFogTransition()) return !0;\n        if (this.hasSnowTransition()) return !0;\n        if (this.hasRainTransition()) return !0;\n        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;\n        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;\n        return !1;\n      }\n      get order() {\n        return this.terrain ? this._drapedFirstOrder : this._mergedOrder;\n      }\n      _getOrder(e) {\n        return e ? this.order : this._mergedOrder;\n      }\n      isLayerDraped(e) {\n        return !!this.terrain && e.isDraped(this.getLayerSourceCache(e));\n      }\n      _checkLoaded() {\n        if (!this._loaded) throw new Error(\"Style is not done loading\");\n      }\n      _checkLayer(t) {\n        const i = this.getOwnLayer(t);\n        if (i) return i;\n        this.fire(new e.y(new Error(\"The layer '\".concat(t, \"' does not exist in the map's style.\"))));\n      }\n      _checkSource(t) {\n        const i = this.getOwnSource(t);\n        if (i) return i;\n        this.fire(new e.y(new Error(\"The source '\".concat(t, \"' does not exist in the map's style.\"))));\n      }\n      precompilePrograms(e, t) {\n        const i = this.map.painter;\n        if (i) for (let o = e.minzoom || 0; o < (e.maxzoom || 25.5); o++) {\n          const o = e.getProgramIds();\n          if (o) for (const s of o) {\n            const o = e.getDefaultProgramParams(s, t.zoom, this._styleColorTheme.lut);\n            o && (i.style = this, this.fog && (i._fogVisible = !0, o.overrideFog = !0, i.getOrCreateProgram(s, o)), i._fogVisible = !1, o.overrideFog = !1, i.getOrCreateProgram(s, o), (this.stylesheet.terrain || this.stylesheet.projection && \"globe\" === this.stylesheet.projection.name) && (o.overrideRtt = !0, i.getOrCreateProgram(s, o)));\n          }\n        }\n      }\n      update(t) {\n        if (!this._loaded) return;\n        this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);\n        const i = this.calculateLightsBrightness();\n        t.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast(\"setBrightness\", i)), t.worldview !== this._worldview && (this._worldview = t.worldview, this.dispatcher.broadcast(\"setWorldview\", this._worldview));\n        const o = this._changes.isDirty();\n        let s = !1;\n        if (this._changes.isDirty()) {\n          const e = this._changes.getLayerUpdatesByScope();\n          for (const t in e) {\n            const {\n              updatedIds: i,\n              removedIds: o\n            } = e[t];\n            (i || o) && (this._updateWorkerLayers(t, i, o), s = !0);\n          }\n          this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset();\n        }\n        const r = {};\n        for (const e in this._mergedSourceCaches) {\n          const t = this._mergedSourceCaches[e];\n          r[e] = t.used, t.used = !1, t.tileCoverLift = 0;\n        }\n        for (const e of this._mergedOrder) {\n          const i = this._mergedLayers[e];\n          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {\n            const e = this.getLayerSourceCache(i);\n            e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));\n          }\n          !this._precompileDone && this._shouldPrecompile && (\"requestIdleCallback\" in window ? requestIdleCallback(() => {\n            this.precompilePrograms(i, t);\n          }) : this.precompilePrograms(i, t));\n        }\n        this._shouldPrecompile && (this._precompileDone = !0), this.terrain && s && this.mergeLayers();\n        const n = this.imageManager.getPendingImageProviders();\n        for (const e of n) e.sourceCache.used = !0;\n        for (const t in r) {\n          const i = this._mergedSourceCaches[t];\n          r[t] !== i.used && i.getSource().fire(new e.z(\"data\", {\n            sourceDataType: \"visibility\",\n            dataType: \"source\",\n            sourceId: i.getSource().id\n          }));\n        }\n        this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), o && this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      updateImageProviders() {\n        const e = this.imageManager.getPendingImageProviders();\n        for (const t of e) {\n          const e = t.resolvePendingRequests(),\n            i = this.getFragmentStyle(t.scope);\n          i && i.addImages(e);\n        }\n      }\n      _updateTilesForChangedImages() {\n        const e = {};\n        for (const t in this._mergedSourceCaches) {\n          const i = this._mergedSourceCaches[t].getSource().scope;\n          e[i] = e[i] || this._changes.getUpdatedImages(i), 0 !== e[i].length && this._mergedSourceCaches[t].reloadTilesForDependencies([\"icons\", \"patterns\"], e[i]);\n        }\n        for (const t in e) this._changes.resetUpdatedImages(t);\n      }\n      _updateWorkerLayers(e, t, i) {\n        const o = this.getFragmentStyle(e);\n        o && this.dispatcher.broadcast(\"updateLayers\", {\n          layers: t ? o._serializeLayers(t) : [],\n          scope: e,\n          removedIds: i || [],\n          options: o.options\n        });\n      }\n      setState(t, i) {\n        if (this._checkLoaded(), go(this, ge(t))) return !1;\n        (t = e.dk(t)).layers = Ot(t.layers);\n        const o = function (t, i) {\n          if (!t) return [{\n            command: Mt.setStyle,\n            args: [i]\n          }];\n          let o = [];\n          try {\n            if (!e.by(t.version, i.version)) return [{\n              command: Mt.setStyle,\n              args: [i]\n            }];\n            if (e.by(t.center, i.center) || o.push({\n              command: Mt.setCenter,\n              args: [i.center]\n            }), e.by(t.zoom, i.zoom) || o.push({\n              command: Mt.setZoom,\n              args: [i.zoom]\n            }), e.by(t.bearing, i.bearing) || o.push({\n              command: Mt.setBearing,\n              args: [i.bearing]\n            }), e.by(t.pitch, i.pitch) || o.push({\n              command: Mt.setPitch,\n              args: [i.pitch]\n            }), e.by(t.sprite, i.sprite) || o.push({\n              command: Mt.setSprite,\n              args: [i.sprite]\n            }), e.by(t.glyphs, i.glyphs) || o.push({\n              command: Mt.setGlyphs,\n              args: [i.glyphs]\n            }), e.by(t.imports, i.imports) || function () {\n              let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n              let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n              let o = arguments.length > 2 ? arguments[2] : undefined;\n              i = i || [];\n              const s = (t = t || []).map(jt),\n                r = i.map(jt),\n                n = t.reduce(Vt, {}),\n                a = i.reduce(Vt, {}),\n                l = s.slice();\n              let c, h, d, u;\n              for (c = 0, h = 0; c < s.length; c++) d = s[c], a.hasOwnProperty(d) ? h++ : (o.push({\n                command: Mt.removeImport,\n                args: [d]\n              }), l.splice(l.indexOf(d, h), 1));\n              for (c = 0, h = 0; c < r.length; c++) d = r[r.length - 1 - c], l[l.length - 1 - c] !== d && (n.hasOwnProperty(d) ? (o.push({\n                command: Mt.removeImport,\n                args: [d]\n              }), l.splice(l.lastIndexOf(d, l.length - h), 1)) : h++, u = l[l.length - c], o.push({\n                command: Mt.addImport,\n                args: [a[d], u]\n              }), l.splice(l.length - c, 0, d));\n              for (const t of i) {\n                const i = n[t.id];\n                i && (delete i.data, e.by(i, t) || o.push({\n                  command: Mt.updateImport,\n                  args: [t.id, t]\n                }));\n              }\n            }(t.imports, i.imports, o), e.by(t.transition, i.transition) || o.push({\n              command: Mt.setTransition,\n              args: [i.transition]\n            }), e.by(t.light, i.light) || o.push({\n              command: Mt.setLight,\n              args: [i.light]\n            }), e.by(t.fog, i.fog) || o.push({\n              command: Mt.setFog,\n              args: [i.fog]\n            }), e.by(t.snow, i.snow) || o.push({\n              command: Mt.setSnow,\n              args: [i.snow]\n            }), e.by(t.rain, i.rain) || o.push({\n              command: Mt.setRain,\n              args: [i.rain]\n            }), e.by(t.projection, i.projection) || o.push({\n              command: Mt.setProjection,\n              args: [i.projection]\n            }), e.by(t.lights, i.lights) || o.push({\n              command: Mt.setLights,\n              args: [i.lights]\n            }), e.by(t.camera, i.camera) || o.push({\n              command: Mt.setCamera,\n              args: [i.camera]\n            }), e.by(t.iconsets, i.iconsets) || function (t, i, o) {\n              let s;\n              for (s in i = i || {}, t = t || {}) t.hasOwnProperty(s) && (i.hasOwnProperty(s) || o.push({\n                command: Mt.removeIconset,\n                args: [s]\n              }));\n              for (s in i) {\n                if (!i.hasOwnProperty(s)) continue;\n                const r = i[s];\n                t.hasOwnProperty(s) ? e.by(t[s], r) || (o.push({\n                  command: Mt.removeIconset,\n                  args: [s]\n                }), o.push({\n                  command: Mt.addIconset,\n                  args: [s, r]\n                })) : o.push({\n                  command: Mt.addIconset,\n                  args: [s, r]\n                });\n              }\n            }(t.iconsets, i.iconsets, o), !e.by(t[\"color-theme\"], i[\"color-theme\"])) return [{\n              command: Mt.setStyle,\n              args: [i]\n            }];\n            const s = {},\n              r = [];\n            !function (t, i, o, s) {\n              let r;\n              for (r in i = i || {}, t = t || {}) t.hasOwnProperty(r) && (i.hasOwnProperty(r) || Bt(r, o, s));\n              for (r in i) {\n                if (!i.hasOwnProperty(r)) continue;\n                const n = i[r];\n                t.hasOwnProperty(r) ? e.by(t[r], n) || (\"geojson\" === t[r].type && \"geojson\" === n.type && Nt(t, i, r) ? o.push({\n                  command: Mt.setGeoJSONSourceData,\n                  args: [r, n.data]\n                }) : kt(r, i, o, s)) : Ft(r, i, o);\n              }\n            }(t.sources, i.sources, r, s);\n            const n = [];\n            t.layers && t.layers.forEach(e => {\n              e.source && s[e.source] ? o.push({\n                command: Mt.removeLayer,\n                args: [e.id]\n              }) : n.push(e);\n            });\n            let a = t.terrain;\n            a && s[a.source] && (o.push({\n              command: Mt.setTerrain,\n              args: [void 0]\n            }), a = void 0), o = o.concat(r), e.by(a, i.terrain) || o.push({\n              command: Mt.setTerrain,\n              args: [i.terrain]\n            }), function (t, i, o) {\n              i = i || [];\n              const s = (t = t || []).map(jt),\n                r = i.map(jt),\n                n = t.reduce(Vt, {}),\n                a = i.reduce(Vt, {}),\n                l = s.slice(),\n                c = Object.create(null);\n              let h, d, u, _, p, f, m;\n              for (h = 0, d = 0; h < s.length; h++) u = s[h], a.hasOwnProperty(u) ? d++ : (o.push({\n                command: Mt.removeLayer,\n                args: [u]\n              }), l.splice(l.indexOf(u, d), 1));\n              for (h = 0, d = 0; h < r.length; h++) u = r[r.length - 1 - h], l[l.length - 1 - h] !== u && (n.hasOwnProperty(u) ? (o.push({\n                command: Mt.removeLayer,\n                args: [u]\n              }), l.splice(l.lastIndexOf(u, l.length - d), 1)) : d++, f = l[l.length - h], o.push({\n                command: Mt.addLayer,\n                args: [a[u], f]\n              }), l.splice(l.length - h, 0, u), c[u] = !0);\n              for (h = 0; h < r.length; h++) if (u = r[h], _ = n[u], p = a[u], !c[u] && !e.by(_, p)) if (e.by(_.source, p.source) && e.by(_[\"source-layer\"], p[\"source-layer\"]) && e.by(_.type, p.type)) {\n                for (m in Ut(_.layout, p.layout, o, u, null, Mt.setLayoutProperty), Ut(_.paint, p.paint, o, u, null, Mt.setPaintProperty), e.by(_.slot, p.slot) || o.push({\n                  command: Mt.setSlot,\n                  args: [u, p.slot]\n                }), e.by(_.filter, p.filter) || o.push({\n                  command: Mt.setFilter,\n                  args: [u, p.filter]\n                }), e.by(_.minzoom, p.minzoom) && e.by(_.maxzoom, p.maxzoom) || o.push({\n                  command: Mt.setLayerZoomRange,\n                  args: [u, p.minzoom, p.maxzoom]\n                }), _) _.hasOwnProperty(m) && \"layout\" !== m && \"paint\" !== m && \"filter\" !== m && \"metadata\" !== m && \"minzoom\" !== m && \"maxzoom\" !== m && \"slot\" !== m && (0 === m.indexOf(\"paint.\") ? Ut(_[m], p[m], o, u, m.slice(6), Mt.setPaintProperty) : e.by(_[m], p[m]) || o.push({\n                  command: Mt.setLayerProperty,\n                  args: [u, m, p[m]]\n                }));\n                for (m in p) p.hasOwnProperty(m) && !_.hasOwnProperty(m) && \"layout\" !== m && \"paint\" !== m && \"filter\" !== m && \"metadata\" !== m && \"minzoom\" !== m && \"maxzoom\" !== m && \"slot\" !== m && (0 === m.indexOf(\"paint.\") ? Ut(_[m], p[m], o, u, m.slice(6), Mt.setPaintProperty) : e.by(_[m], p[m]) || o.push({\n                  command: Mt.setLayerProperty,\n                  args: [u, m, p[m]]\n                }));\n              } else o.push({\n                command: Mt.removeLayer,\n                args: [u]\n              }), f = l[l.lastIndexOf(u) + 1], o.push({\n                command: Mt.addLayer,\n                args: [p, f]\n              });\n            }(n, i.layers, o);\n          } catch (e) {\n            console.warn(\"Unable to compute style diff:\", e), o = [{\n              command: Mt.setStyle,\n              args: [i]\n            }];\n          }\n          return o;\n        }(this.serialize(), t).filter(e => !(e.command in yo));\n        if (0 === o.length) return !1;\n        const s = o.filter(e => !(e.command in vo));\n        if (s.length > 0) throw new Error(\"Unimplemented: \".concat(s.map(e => e.command).join(\", \"), \".\"));\n        const r = [];\n        return o.forEach(e => {\n          r.push(this[e.command](...e.args));\n        }), i && Promise.all(r).then(i).catch(i), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast(\"setLayers\", {\n          layers: this._serializeLayers(this._order),\n          scope: this.scope,\n          options: this.options\n        }), !0;\n      }\n      _updateWorkerImages() {\n        this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast(\"setImages\", {\n          scope: this.scope,\n          images: this._availableImages\n        });\n      }\n      _updateWorkerModels() {\n        this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast(\"setModels\", {\n          scope: this.scope,\n          models: this._availableModels\n        });\n      }\n      addImages(t) {\n        if (0 === t.size) return this;\n        for (const [i, o] of t.entries()) {\n          if (this.getImage(i)) return this.fire(new e.y(new Error(\"An image with the name \\\"\".concat(i.name, \"\\\" already exists.\"))));\n          this.imageManager.addImage(i, this.scope, o), this._changes.updateImage(i, this.scope);\n        }\n        return this._updateWorkerImages(), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        })), this;\n      }\n      addImage(t, i) {\n        return this.getImage(t) ? this.fire(new e.y(new Error(\"An image with the name \\\"\".concat(t.name, \"\\\" already exists.\")))) : (this.imageManager.addImage(t, this.scope, i), this._changes.updateImage(t, this.scope), this._updateWorkerImages(), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        })), this);\n      }\n      updateImage(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        this.imageManager.updateImage(t, this.scope, i), o && (this._changes.updateImage(t, this.scope), this._updateWorkerImages(), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        })));\n      }\n      getImage(e) {\n        return this.imageManager.getImage(e, this.scope);\n      }\n      removeImage(t) {\n        return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._changes.updateImage(t, this.scope), this._updateWorkerImages(), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        })), this) : this.fire(new e.y(new Error(\"No image with this name exists.\")));\n      }\n      listImages() {\n        return this._checkLoaded(), this._availableImages.slice();\n      }\n      addModelURLs(t) {\n        return this.modelManager.addModelURLs(t, this.scope), this._updateWorkerModels(), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        })), this;\n      }\n      addModel(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this._checkLoaded(), this._validate(Ae, \"models.\".concat(t), i, null, o) || (this.modelManager.addModel(t, i, this.scope), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        }))), this;\n      }\n      hasModel(e) {\n        return this.modelManager.hasModel(e, this.scope);\n      }\n      removeModel(t) {\n        return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope, !1, !0), this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        })), this) : this.fire(new e.y(new Error(\"No model with this ID exists.\")));\n      }\n      listModels() {\n        return this._checkLoaded(), this.modelManager.listModels(this.scope);\n      }\n      addSource(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (this._checkLoaded(), void 0 !== this.getOwnSource(t)) throw new Error(\"There is already a source with ID \\\"\".concat(t, \"\\\".\"));\n        if (!i.type) throw new Error(\"The type property must be defined, but only the following properties were given: \".concat(Object.keys(i).join(\", \"), \".\"));\n        if ([\"vector\", \"raster\", \"geojson\", \"video\", \"image\"].indexOf(i.type) >= 0 && this._validate(ve, \"sources.\".concat(t), i, null, o)) return;\n        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n        const s = lt(t, i, this.dispatcher, this);\n        s.scope = this.scope, s.setEventedParent(this, () => ({\n          isSourceLoaded: this._isSourceCacheLoaded(s.id),\n          source: s.serialize(),\n          sourceId: s.id\n        }));\n        const r = t => {\n          const i = (t ? \"symbol:\" : \"other:\") + s.id,\n            o = e.B(i, this.scope),\n            r = this._sourceCaches[i] = new Rt(o, s, t);\n          (t ? this._symbolSourceCaches : this._otherSourceCaches)[s.id] = r, r.onAdd(this.map);\n        };\n        r(!1), \"vector\" !== i.type && \"geojson\" !== i.type || r(!0), s.onAdd && s.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());\n      }\n      removeSource(t) {\n        this._checkLoaded();\n        const i = this.getOwnSource(t);\n        if (!i) throw new Error(\"There is no source with this ID\");\n        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.y(new Error(\"Source \\\"\".concat(t, \"\\\" cannot be removed while layer \\\"\").concat(i, \"\\\" is using it.\"))));\n        if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new e.y(new Error(\"Source \\\"\".concat(t, \"\\\" cannot be removed while terrain is using it.\"))));\n        if (this.stylesheet.iconsets) {\n          const i = Object.entries(this.stylesheet.iconsets).find(_ref91 => {\n            let [e, i] = _ref91;\n            return \"source\" === i.type && i.source === t;\n          });\n          if (i) return this.fire(new e.y(new Error(\"Source \\\"\".concat(t, \"\\\" cannot be removed while iconset \\\"\").concat(i[0], \"\\\" is using it.\"))));\n        }\n        const o = this.getOwnSourceCaches(t);\n        for (const t of o) {\n          const i = e.dl(t.id);\n          delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t.id), t.fire(new e.z(\"data\", {\n            sourceDataType: \"metadata\",\n            dataType: \"source\",\n            sourceId: t.getSource().id\n          })), t.setEventedParent(null), t.clearTiles();\n        }\n        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;\n      }\n      setGeoJSONSourceData(e, t) {\n        this._checkLoaded(), this.getOwnSource(e).setData(t), this._changes.setDirty();\n      }\n      getOwnSource(e) {\n        const t = this.getOwnSourceCache(e);\n        return t && t.getSource();\n      }\n      getOwnSources() {\n        const e = [];\n        for (const t in this._otherSourceCaches) {\n          const i = this.getOwnSourceCache(t);\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      areTilesLoaded() {\n        const e = this._mergedSourceCaches;\n        for (const t in e) {\n          const i = e[t]._tiles;\n          for (const e in i) {\n            const t = i[e];\n            if (\"loaded\" !== t.state && \"errored\" !== t.state) return !1;\n          }\n        }\n        return !0;\n      }\n      setLights(t) {\n        if (this._checkLoaded(), !t) return delete this.ambientLight, void delete this.directionalLight;\n        const i = this._getTransitionParameters();\n        for (const o of t) {\n          if (this._validate(xe, \"lights\", o)) return;\n          switch (o.type) {\n            case \"ambient\":\n              if (this.ambientLight) {\n                const e = this.ambientLight;\n                e.set(o), e.updateTransitions(i);\n              } else this.ambientLight = new Xe(o, qe || (qe = new e.a9({\n                color: new e.aa(e.a6.properties_light_ambient.color),\n                \"color-use-theme\": new e.aa({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-constant\"\n                }),\n                intensity: new e.aa(e.a6.properties_light_ambient.intensity)\n              })), this.scope, this.options);\n              break;\n            case \"directional\":\n              if (this.directionalLight) {\n                const e = this.directionalLight;\n                e.set(o), e.updateTransitions(i);\n              } else this.directionalLight = new Xe(o, Ze || (Ze = new e.a9({\n                direction: new e.ap(e.a6.properties_light_directional.direction),\n                color: new e.aa(e.a6.properties_light_directional.color),\n                \"color-use-theme\": new e.aa({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-constant\"\n                }),\n                intensity: new e.aa(e.a6.properties_light_directional.intensity),\n                \"cast-shadows\": new e.aa(e.a6.properties_light_directional[\"cast-shadows\"]),\n                \"shadow-quality\": new e.aa(e.a6.properties_light_directional[\"shadow-quality\"]),\n                \"shadow-intensity\": new e.aa(e.a6.properties_light_directional[\"shadow-intensity\"])\n              })), this.scope, this.options);\n          }\n        }\n        const o = Object.assign(i, {\n            worldview: this.map.getWorldview()\n          }),\n          s = new e.ac(this.z || 0, o);\n        this.ambientLight && this.ambientLight.recalculate(s), this.directionalLight && this.directionalLight.recalculate(s), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast(\"setBrightness\", this._brightness);\n      }\n      calculateLightsBrightness() {\n        const t = this.directionalLight,\n          i = this.ambientLight;\n        if (!t || !i) return;\n        const o = e => .2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)),\n          s = t.properties.get(\"color\").toNonPremultipliedRenderColor(null).toArray01(),\n          r = t.properties.get(\"intensity\"),\n          n = t.properties.get(\"direction\"),\n          a = 1 - e.d3(n.x, n.y, n.z)[2] / 90,\n          l = o(s) * r * a,\n          c = i.properties.get(\"color\").toNonPremultipliedRenderColor(null).toArray01(),\n          h = i.properties.get(\"intensity\"),\n          d = o(c) * h;\n        return Number(((l + d) / 2).toFixed(6));\n      }\n      getBrightness() {\n        return this._brightness;\n      }\n      getLights() {\n        if (!this.enable3dLights()) return null;\n        const e = [];\n        return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;\n      }\n      enable3dLights() {\n        return !!this.ambientLight && !!this.directionalLight;\n      }\n      getFragmentStyle(t) {\n        if (null == t || \"\" === t && this.isRootStyle()) return this;\n        if (e.dm(t)) {\n          const i = e.dn(t),\n            o = this.fragments.find(_ref92 => {\n              let {\n                id: e\n              } = _ref92;\n              return e === i;\n            });\n          if (!o) return;\n          const s = e.dl(t);\n          return o.style.getFragmentStyle(s);\n        }\n        {\n          const e = this.fragments.find(_ref93 => {\n            let {\n              id: e\n            } = _ref93;\n            return e === t;\n          });\n          return e ? e.style : void 0;\n        }\n      }\n      setFeaturesetSelectors(t) {\n        if (!t) return;\n        const i = {},\n          o = function (e) {\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n            return \"\".concat(e, \"::\").concat(t);\n          };\n        this._featuresetSelectors = {};\n        for (const s in t) {\n          const r = this._featuresetSelectors[s] = [];\n          for (const n of t[s].selectors) {\n            if (n.featureNamespace) {\n              const t = this.getOwnLayer(n.layer);\n              if (!t) {\n                e.w(\"Layer is undefined for selector: \".concat(n.layer));\n                continue;\n              }\n              const r = o(t.source, t.sourceLayer);\n              if (r in i && i[r] !== n.featureNamespace) {\n                e.w(\"\\\"featureNamespace \".concat(n.featureNamespace, \" of featureset \").concat(s, \"'s selector is not associated to the same source, skip this selector\"));\n                continue;\n              }\n              i[r] = n.featureNamespace;\n            }\n            let t;\n            if (n.properties) for (const i in n.properties) {\n              const o = e.U(n.properties[i]);\n              \"success\" === o.result && (t = t || {}, t[i] = o.value);\n            }\n            r.push({\n              layerId: n.layer,\n              namespace: n.featureNamespace,\n              properties: t,\n              uniqueFeatureID: n._uniqueFeatureID\n            });\n          }\n        }\n      }\n      getFeaturesetDescriptors(e) {\n        const t = this.getFragmentStyle(e);\n        if (!t || !t.stylesheet.featuresets) return [];\n        const i = [];\n        for (const e in t.stylesheet.featuresets) i.push({\n          featuresetId: e,\n          importId: t.scope ? t.scope : void 0\n        });\n        return i;\n      }\n      getFeaturesetLayers(t, i) {\n        const o = this.getFragmentStyle(i),\n          s = o.stylesheet.featuresets;\n        if (!s || !s[t]) return this.fire(new e.y(new Error(\"The featureset '\".concat(t, \"' does not exist in the map's style and cannot be queried.\")))), [];\n        const r = [];\n        for (const e of s[t].selectors) {\n          const t = o.getOwnLayer(e.layer);\n          t && r.push(t);\n        }\n        return r;\n      }\n      getConfigProperty(t, i) {\n        const o = this.getFragmentStyle(t);\n        if (!o) return null;\n        const s = e.B(i, o.scope),\n          r = o.options.get(s),\n          n = r ? r.value || r.default : null;\n        return n ? n.serialize() : null;\n      }\n      setConfigProperty(t, i, o) {\n        const s = this.getFragmentStyle(t);\n        if (!s) return;\n        const r = s.stylesheet.schema;\n        if (!r || !r[i]) return;\n        const n = e.U(o);\n        if (\"success\" !== n.result) return void go(this, n.value);\n        const a = n.value.expression,\n          l = e.B(i, s.scope),\n          c = s.options.get(l);\n        if (!c) return;\n        let h;\n        const {\n            minValue: d,\n            maxValue: u,\n            stepValue: _,\n            type: p,\n            values: f\n          } = r[i],\n          m = e.U(r[i].default);\n        \"success\" === m.result && (h = m.value.expression), h ? (this.options.set(l, Object.assign({}, c, {\n          value: a,\n          default: h,\n          minValue: d,\n          maxValue: u,\n          stepValue: _,\n          type: p,\n          values: f\n        })), this.updateConfigDependencies(i)) : this.fire(new e.y(new Error(\"No schema defined for the config option \\\"\".concat(i, \"\\\" in the \\\"\").concat(t, \"\\\" fragment.\"))));\n      }\n      getConfig(t) {\n        const i = this.getFragmentStyle(t);\n        if (!i) return null;\n        const o = i.stylesheet.schema;\n        if (!o) return null;\n        const s = {};\n        for (const t in o) {\n          const o = e.B(t, i.scope),\n            r = i.options.get(o),\n            n = r ? r.value || r.default : null;\n          s[t] = n ? n.serialize() : null;\n        }\n        return s;\n      }\n      setConfig(e, t) {\n        const i = this.getFragmentStyle(e);\n        i && (i.updateConfig(t, i.stylesheet.schema), this.updateConfigDependencies());\n      }\n      getSchema(e) {\n        const t = this.getFragmentStyle(e);\n        return t ? t.stylesheet.schema : null;\n      }\n      setSchema(e, t) {\n        const i = this.getFragmentStyle(e);\n        i && (i.stylesheet.schema = t, i.updateConfig(i._config, t), this.updateConfigDependencies());\n      }\n      updateConfig(t, i) {\n        if (this._config = t, t || i) if (i) for (const o in i) {\n          let s, r;\n          const n = e.U(i[o].default);\n          if (\"success\" === n.result && (s = n.value.expression), t && void 0 !== t[o]) {\n            const i = e.U(t[o]);\n            \"success\" === i.result && (r = i.value.expression);\n          }\n          const {\n            minValue: a,\n            maxValue: l,\n            stepValue: c,\n            type: h,\n            values: d\n          } = i[o];\n          if (s) {\n            const t = e.B(o, this.scope);\n            this.options.set(t, {\n              default: s,\n              value: r,\n              minValue: a,\n              maxValue: l,\n              stepValue: c,\n              type: h,\n              values: d\n            });\n          } else this.fire(new e.y(new Error(\"No schema defined for config option \\\"\".concat(o, \"\\\".\"))));\n        } else this.fire(new e.y(new Error(\"Attempting to set config for a style without schema.\")));\n      }\n      updateConfigDependencies(e) {\n        for (const t of this._configDependentLayers) {\n          const i = this.getLayer(t);\n          if (i) {\n            if (e && !i.configDependencies.has(e)) continue;\n            i.possiblyEvaluateVisibility(), this._updateLayer(i);\n          }\n        }\n        this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle(e => {\n          const t = e._styleColorTheme.colorThemeOverride ? e._styleColorTheme.colorThemeOverride : e._styleColorTheme.colorTheme;\n          if (t) {\n            const i = e._evaluateColorThemeData(t);\n            (!e._styleColorTheme.lut && \"\" !== i || e._styleColorTheme.lut && i !== e._styleColorTheme.lut.data) && e.setColorTheme(t);\n          }\n        }), this._changes.setDirty();\n      }\n      addLayer(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this._checkLoaded();\n        const s = t.id;\n        if (this._layers[s]) return void this.fire(new e.y(new Error(\"Layer with id \\\"\".concat(s, \"\\\" already exists on this map\"))));\n        let r;\n        if (\"custom\" === t.type) {\n          if (go(this, e.dp(t))) return;\n          r = e.dq(t, this.scope, this._styleColorTheme.lut, this.options);\n        } else {\n          if (\"object\" == typeof t.source && (this.addSource(s, t.source), t = e.dk(t), t = Object.assign(t, {\n            source: s\n          })), this._validate(Se, \"layers.\".concat(s), t, {\n            arrayIndex: -1\n          }, o)) return;\n          r = e.dq(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r), r.setEventedParent(this, {\n            layer: {\n              id: s\n            }\n          });\n        }\n        0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid);\n        let n = this._order.length;\n        if (i) {\n          const t = this._order.indexOf(i);\n          if (-1 === t) return void this.fire(new e.y(new Error(\"Layer with id \\\"\".concat(i, \"\\\" does not exist on this map.\"))));\n          r.slot === this._layers[i].slot ? n = t : e.w(\"Layer with id \\\"\".concat(i, \"\\\" has a different slot. Layers can only be rearranged within the same slot.\"));\n        }\n        this._order.splice(n, 0, s), this._layerOrderChanged = !0, this._layers[s] = r;\n        const a = this.getOwnLayerSourceCache(r),\n          l = !!this.directionalLight && this.directionalLight.shadowsEnabled();\n        a && r.canCastShadows() && l && (a.castsShadows = !0);\n        const c = this._changes.getRemovedLayer(r);\n        if (c && r.source && a && \"custom\" !== r.type) {\n          this._changes.discardLayerRemoval(r);\n          const t = e.B(r.source, r.scope);\n          c.type !== r.type ? this._changes.updateSourceCache(t, \"clear\") : (this._changes.updateSourceCache(t, \"reload\"), a.pause());\n        }\n        this._updateLayer(r), r.onAdd && r.onAdd(this.map), r.scope = this.scope, this.mergeLayers();\n      }\n      moveLayer(t, i) {\n        this._checkLoaded();\n        const o = this._checkLayer(t);\n        if (!o) return;\n        if (t === i) return;\n        const s = this._order.indexOf(t);\n        this._order.splice(s, 1);\n        let r = this._order.length;\n        if (i) {\n          const t = this._order.indexOf(i);\n          if (-1 === t) return void this.fire(new e.y(new Error(\"Layer with id \\\"\".concat(i, \"\\\" does not exist on this map.\"))));\n          o.slot === this._layers[i].slot ? r = t : e.w(\"Layer with id \\\"\".concat(i, \"\\\" has a different slot. Layers can only be rearranged within the same slot.\"));\n        }\n        this._order.splice(r, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();\n      }\n      removeLayer(e) {\n        this._checkLoaded();\n        const t = this._checkLayer(e);\n        if (!t) return;\n        t.setEventedParent(null);\n        const i = this._order.indexOf(e);\n        this._order.splice(i, 1), delete this._layers[e], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t.fqid), this._changes.removeLayer(t);\n        const o = this.getOwnLayerSourceCache(t);\n        if (o && o.castsShadows) {\n          let e = !1;\n          for (const i in this._layers) if (this._layers[i].source === t.source && this._layers[i].canCastShadows()) {\n            e = !0;\n            break;\n          }\n          o.castsShadows = e;\n        }\n        t.onRemove && t.onRemove(this.map), this.mergeLayers();\n      }\n      getOwnLayer(e) {\n        return this._layers[e];\n      }\n      hasLayer(e) {\n        return e in this._mergedLayers;\n      }\n      hasLayerType(e) {\n        for (const t in this._layers) if (this._layers[t].type === e) return !0;\n        return !1;\n      }\n      setLayerZoomRange(e, t, i) {\n        this._checkLoaded();\n        const o = this._checkLayer(e);\n        o && (o.minzoom === t && o.maxzoom === i || (null != t && (o.minzoom = t), null != i && (o.maxzoom = i), this._updateLayer(o)));\n      }\n      getSlots() {\n        return this._checkLoaded(), this._mergedSlots;\n      }\n      setSlot(e, t) {\n        this._checkLoaded();\n        const i = this._checkLayer(e);\n        i && i.slot !== t && (i.slot = t, this._updateLayer(i));\n      }\n      setFilter(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this._checkLoaded();\n        const s = this._checkLayer(t);\n        if (s && !e.by(s.filter, i)) return null == i ? (s.filter = void 0, void this._updateLayer(s)) : void (this._validate(Ie, \"layers.\".concat(s.id, \".filter\"), i, {\n          layerType: s.type\n        }, o) || (s.filter = e.dk(i), this._updateLayer(s)));\n      }\n      getFilter(t) {\n        const i = this._checkLayer(t);\n        if (i) return e.dk(i.filter);\n      }\n      setLayoutProperty(t, i, o) {\n        let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        this._checkLoaded();\n        const r = this._checkLayer(t);\n        if (r && !e.by(r.getLayoutProperty(i), o)) {\n          if (null != o && (!s || !1 !== s.validate) && go(r, Re.call(ge, {\n            key: \"layers.\".concat(t, \".layout.\").concat(i),\n            layerType: r.type,\n            objectKey: i,\n            value: o,\n            styleSpec: e.a6,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            }\n          }))) return;\n          r.setLayoutProperty(i, o), 0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid), this._updateLayer(r);\n        }\n      }\n      getLayoutProperty(e, t) {\n        const i = this._checkLayer(e);\n        if (i) return i.getLayoutProperty(t);\n      }\n      setPaintProperty(t, i, o) {\n        let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        this._checkLoaded();\n        const r = this._checkLayer(t);\n        if (!r) return;\n        if (e.by(r.getPaintProperty(i), o)) return;\n        if (null != o && (!s || !1 !== s.validate) && go(r, Ce.call(ge, {\n          key: \"layers.\".concat(t, \".paint.\").concat(i),\n          layerType: r.type,\n          objectKey: i,\n          value: o,\n          styleSpec: e.a6\n        }))) return;\n        const n = r.setPaintProperty(i, o);\n        0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid), n && this._updateLayer(r), this._changes.updatePaintProperties(r);\n      }\n      getPaintProperty(e, t) {\n        const i = this._checkLayer(e);\n        if (i) return i.getPaintProperty(t);\n      }\n      setFeatureState(t, i) {\n        if (this._checkLoaded(), \"target\" in t) {\n          if (\"featuresetId\" in t.target) {\n            const {\n                featuresetId: e,\n                importId: o\n              } = t.target,\n              s = this.getFragmentStyle(o),\n              r = s.getFeaturesetLayers(e);\n            for (const {\n              source: e,\n              sourceLayer: o\n            } of r) s.setFeatureState({\n              id: t.id,\n              source: e,\n              sourceLayer: o\n            }, i);\n          } else if (\"layerId\" in t.target) {\n            const {\n                layerId: e\n              } = t.target,\n              o = this.getLayer(e);\n            this.setFeatureState({\n              id: t.id,\n              source: o.source,\n              sourceLayer: o.sourceLayer\n            }, i);\n          }\n          return;\n        }\n        const o = t.source,\n          s = t.sourceLayer,\n          r = this._checkSource(o);\n        if (!r) return;\n        const n = r.type;\n        if (\"geojson\" === n && s) return void this.fire(new e.y(new Error(\"GeoJSON sources cannot have a sourceLayer parameter.\")));\n        if (\"vector\" === n && !s) return void this.fire(new e.y(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        void 0 === t.id && this.fire(new e.y(new Error(\"The feature id parameter must be provided.\")));\n        const a = this.getOwnSourceCaches(o);\n        for (const e of a) e.setFeatureState(s, t.id, i);\n      }\n      removeFeatureState(t, i) {\n        if (this._checkLoaded(), \"target\" in t) {\n          if (\"featuresetId\" in t.target) {\n            const {\n                featuresetId: e,\n                importId: o\n              } = t.target,\n              s = this.getFragmentStyle(o),\n              r = s.getFeaturesetLayers(e);\n            for (const {\n              source: e,\n              sourceLayer: o\n            } of r) s.removeFeatureState({\n              id: t.id,\n              source: e,\n              sourceLayer: o\n            }, i);\n          } else if (\"layerId\" in t.target) {\n            const {\n                layerId: e\n              } = t.target,\n              o = this.getLayer(e);\n            this.removeFeatureState({\n              id: t.id,\n              source: o.source,\n              sourceLayer: o.sourceLayer\n            }, i);\n          }\n          return;\n        }\n        const o = t.source,\n          s = this._checkSource(o);\n        if (!s) return;\n        const r = s.type,\n          n = \"vector\" === r ? t.sourceLayer : void 0;\n        if (\"vector\" === r && !n) return void this.fire(new e.y(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        if (i && \"string\" != typeof t.id && \"number\" != typeof t.id) return void this.fire(new e.y(new Error(\"A feature id is required to remove its specific state property.\")));\n        const a = this.getOwnSourceCaches(o);\n        for (const e of a) e.removeFeatureState(n, t.id, i);\n      }\n      getFeatureState(t) {\n        if (this._checkLoaded(), \"target\" in t) {\n          let i;\n          if (\"featuresetId\" in t.target) {\n            const {\n                featuresetId: o,\n                importId: s\n              } = t.target,\n              r = this.getFragmentStyle(s),\n              n = r.getFeaturesetLayers(o);\n            for (const {\n              source: o,\n              sourceLayer: s\n            } of n) {\n              const n = r.getFeatureState({\n                id: t.id,\n                source: o,\n                sourceLayer: s\n              });\n              if (n && !i) i = n;else if (!e.by(i, n)) return void this.fire(new e.y(new Error(\"The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.\")));\n            }\n          } else if (\"layerId\" in t.target) {\n            const {\n                layerId: e\n              } = t.target,\n              o = this.getLayer(e);\n            i = this.getFeatureState({\n              id: t.id,\n              source: o.source,\n              sourceLayer: o.sourceLayer\n            });\n          }\n          return i;\n        }\n        const i = t.source,\n          o = t.sourceLayer,\n          s = this._checkSource(i);\n        if (s) {\n          if (\"vector\" !== s.type || o) return void 0 === t.id && this.fire(new e.y(new Error(\"The feature id parameter must be provided.\"))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t.id);\n          this.fire(new e.y(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        }\n      }\n      setTransition(e) {\n        return this.stylesheet.transition = Object.assign({}, this.stylesheet.transition, e), this.transition = this.stylesheet.transition, this;\n      }\n      getTransition() {\n        return Object.assign({}, this.stylesheet.transition);\n      }\n      serialize() {\n        this._checkLoaded();\n        const t = this.getTerrain(),\n          i = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;\n        return e.dr({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          fragment: this.stylesheet.fragment,\n          iconsets: this.stylesheet.iconsets,\n          imports: this._serializeImports(),\n          schema: this.stylesheet.schema,\n          camera: this.stylesheet.camera,\n          light: this.stylesheet.light,\n          lights: this.stylesheet.lights,\n          terrain: i,\n          fog: this.stylesheet.fog,\n          snow: this.stylesheet.snow,\n          rain: this.stylesheet.rain,\n          center: this.stylesheet.center,\n          \"color-theme\": this.stylesheet[\"color-theme\"],\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          projection: this.stylesheet.projection,\n          sources: this._serializeSources(),\n          layers: this._serializeLayers(this._order)\n        }, e => void 0 !== e);\n      }\n      _updateFilteredLayers(e) {\n        for (const t of Object.values(this._mergedLayers)) e(t) && this._updateLayer(t);\n      }\n      _updateLayer(t) {\n        this._changes.updateLayer(t);\n        const i = this.getLayerSourceCache(t),\n          o = e.B(t.source, t.scope),\n          s = this._changes.getUpdatedSourceCaches();\n        t.source && !s[o] && i && \"raster\" !== i.getSource().type && (this._changes.updateSourceCache(o, \"reload\"), i.pause()), t.invalidateCompiledFilter();\n      }\n      _flattenAndSortRenderedFeatures(e) {\n        const t = e => this._mergedLayers[e].is3D(!!this.terrain),\n          i = this.order,\n          o = {},\n          s = [];\n        for (let r = i.length - 1; r >= 0; r--) {\n          const n = i[r];\n          if (t(n)) {\n            o[n] = r;\n            for (const t of e) {\n              const e = t[n];\n              if (e) for (const t of e) s.push(t);\n            }\n          }\n        }\n        s.sort((e, t) => t.intersectionZ - e.intersectionZ);\n        const r = [];\n        for (let n = i.length - 1; n >= 0; n--) {\n          const a = i[n];\n          if (t(a)) for (let e = s.length - 1; e >= 0; e--) {\n            const t = s[e].feature;\n            if (t.layer && o[t.layer.id] < n) break;\n            r.push(t), s.pop();\n          } else for (const t of e) {\n            const e = t[a];\n            if (e) for (const t of e) r.push(t.feature);\n          }\n        }\n        return r;\n      }\n      queryRasterValue(t, i, o) {\n        const s = this.getOwnSource(t);\n        return s ? \"raster-array\" !== s.type ? (this.fire(new e.y(new Error('queryRasterValue support only \"raster-array\" sources.'))), Promise.resolve(null)) : s.queryRasterArrayValue(i, o) : (this.fire(new e.y(new Error(\"Source with id \\\"\".concat(t, \"\\\" does not exist in the style.\")))), Promise.resolve(null));\n      }\n      queryRenderedFeatures(t, i, o) {\n        let s;\n        i && !Array.isArray(i) && i.filter && (this._validate(Ie, \"queryRenderedFeatures.filter\", i.filter, null, i), s = e.b6(i.filter));\n        const r = {},\n          n = e => {\n            if (xo.has(e.type)) return;\n            const t = this.getOwnLayerSourceCache(e),\n              i = r[t.id] = r[t.id] || {\n                sourceCache: t,\n                layers: {},\n                has3DLayers: !1\n              };\n            e.is3D(!!this.terrain) && (i.has3DLayers = !0), i.layers[e.fqid] = i.layers[e.fqid] || {\n              styleLayer: e,\n              targets: []\n            }, i.layers[e.fqid].targets.push({\n              filter: s\n            });\n          };\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new e.y(new Error(\"parameters.layers must be an Array.\"))), [];\n          for (const t of i.layers) {\n            const i = this._layers[t];\n            if (!i) return this.fire(new e.y(new Error(\"The layer '\".concat(t, \"' does not exist in the map's style and cannot be queried for features.\")))), [];\n            n(i);\n          }\n        } else for (const e in this._layers) n(this._layers[e]);\n        const a = this._queryRenderedFeatures(t, r, o),\n          l = this._flattenAndSortRenderedFeatures(a),\n          c = [];\n        for (const t of l) e.ds(t.layer.id) === this.scope && c.push(t);\n        return c;\n      }\n      queryRenderedFeatureset(t, i, o) {\n        let s;\n        i && !Array.isArray(i) && i.filter && (this._validate(Ie, \"queryRenderedFeatures.filter\", i.filter, null, i), s = e.b6(i.filter));\n        const r = \"mock\",\n          n = [];\n        if (i && i.target) n.push(Object.assign({}, i, {\n          targetId: r,\n          filter: s\n        }));else {\n          const e = this.getFeaturesetDescriptors();\n          for (const t of e) n.push({\n            targetId: r,\n            filter: s,\n            target: t\n          });\n          for (const {\n            style: e\n          } of this.fragments) {\n            const t = e.getFeaturesetDescriptors();\n            for (const e of t) n.push({\n              targetId: r,\n              filter: s,\n              target: e\n            });\n          }\n        }\n        const a = this.queryRenderedTargets(t, n, o),\n          l = [],\n          c = new Set();\n        for (const t of a) for (const i of t.variants[r]) ht(i, t, c) || l.push(new e.dt(t, i));\n        return l;\n      }\n      queryRenderedTargets(t, i, o) {\n        const s = {},\n          r = (e, t, i, o) => {\n            const r = s[t.id] = s[t.id] || {\n              sourceCache: t,\n              layers: {},\n              has3DLayers: !1\n            };\n            if (r.layers[e.fqid] = r.layers[e.fqid] || {\n              styleLayer: e,\n              targets: []\n            }, e.is3D(!!this.terrain) && (r.has3DLayers = !0), !o) return i.uniqueFeatureID = !1, void r.layers[e.fqid].targets.push(i);\n            r.layers[e.fqid].targets.push(Object.assign({}, i, {\n              namespace: o.namespace,\n              properties: o.properties,\n              uniqueFeatureID: o.uniqueFeatureID\n            }));\n          };\n        for (const t of i) if (\"featuresetId\" in t.target) {\n          const {\n              featuresetId: i,\n              importId: o\n            } = t.target,\n            s = this.getFragmentStyle(o);\n          if (!s || !s._featuresetSelectors) continue;\n          const n = s._featuresetSelectors[i];\n          if (!n) {\n            this.fire(new e.y(new Error(\"The featureset '\".concat(i, \"' does not exist in the map's style and cannot be queried for features.\"))));\n            continue;\n          }\n          for (const e of n) {\n            const i = s.getOwnLayer(e.layerId);\n            i && !xo.has(i.type) && r(i, s.getOwnLayerSourceCache(i), t, e);\n          }\n        } else if (\"layerId\" in t.target) {\n          const {\n              layerId: e\n            } = t.target,\n            i = this.getLayer(e);\n          if (!i || xo.has(i.type)) continue;\n          r(i, this.getLayerSourceCache(i), t);\n        }\n        const n = this._queryRenderedFeatures(t, s, o);\n        return this._flattenAndSortRenderedFeatures(n);\n      }\n      _queryRenderedFeatures(e, t, i) {\n        const o = [],\n          s = !!this.map._showQueryGeometry,\n          r = Ye.createFromScreenPoints(e, i);\n        for (const e in t) {\n          const n = dt(r, t[e], this._availableImages, i, s);\n          Object.keys(n).length && o.push(n);\n        }\n        if (this.placement) for (const e in t) {\n          if (!t[e].sourceCache._onlySymbols) continue;\n          const i = ut(r.screenGeometry, t[e], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData, this.map.getWorldview());\n          Object.keys(i).length && o.push(i);\n        }\n        return o;\n      }\n      querySourceFeatures(e, t) {\n        const i = t && t.filter;\n        i && this._validate(Ie, \"querySourceFeatures.filter\", i, null, t);\n        let o = [];\n        const s = this.getOwnSourceCaches(e);\n        for (const e of s) o = o.concat(_t(e, t));\n        return o;\n      }\n      addSourceType(e, t, i) {\n        return To.getSourceType(e) ? i(new Error(\"A source type called \\\"\".concat(e, \"\\\" already exists.\"))) : (To.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast(\"loadWorkerSource\", {\n          name: e,\n          url: t.workerSourceURL\n        }, i) : i(null, null));\n      }\n      getFlatLight() {\n        return this.light.getLight();\n      }\n      setFlatLight(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this._checkLoaded();\n        const s = this.light.getLight();\n        let r = !1;\n        for (const i in t) if (!e.by(t[i], s[i])) {\n          r = !0;\n          break;\n        }\n        if (!r) return;\n        const n = this._getTransitionParameters();\n        this.light.setLight(t, i, o), this.light.updateTransitions(n);\n      }\n      getTerrain() {\n        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;\n      }\n      setTerrainForDraping() {\n        this.setTerrain({\n          source: \"\",\n          exaggeration: 0\n        }, 0);\n      }\n      checkCanvasFingerprintNoise() {\n        void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.o.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w(\"Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).\"));\n      }\n      setTerrain(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        if (this._checkLoaded(), !t) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i && delete this.terrain, null === t ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);\n        this.checkCanvasFingerprintNoise();\n        let o = t;\n        const s = null == t.source;\n        if (1 === i) {\n          if (this.disableElevatedTerrain) return;\n          if (\"object\" == typeof o.source) {\n            const t = \"terrain-dem-src\";\n            this.addSource(t, o.source), o = e.dk(o), o = Object.assign(o, {\n              source: t\n            });\n          }\n          const t = Object.assign({}, o),\n            i = {};\n          if (this.terrain && s) {\n            t.source = this.terrain.get().source;\n            const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;\n            e && (i.style = e.serialize());\n          }\n          if (this._validate(be, \"terrain\", t, i)) return;\n        }\n        if (!this.terrain || this.terrain.scope !== this.scope && !s || this.terrain && i !== this.terrain.drapeRenderMode) {\n          if (!o) return;\n          this._createTerrain(o, i), this.fire(new e.z(\"data\", {\n            dataType: \"style\"\n          }));\n        } else {\n          const i = this.terrain,\n            s = i.get();\n          for (const t of Object.keys(e.a6.terrain)) !o.hasOwnProperty(t) && e.a6.terrain[t].default && (o[t] = e.a6.terrain[t].default);\n          for (const o in t) if (!e.by(t[o], s[o])) {\n            i.set(t, this.options), this.stylesheet.terrain = t;\n            const o = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(o), this.fire(new e.z(\"data\", {\n              dataType: \"style\"\n            }));\n            break;\n          }\n        }\n        this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;\n      }\n      _createFog(e) {\n        const t = this.fog = new Ve(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.fog = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _createSnow(e) {\n        const t = this.snow = new We(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.snow = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _createRain(e) {\n        const t = this.rain = new $e(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.rain = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _updateMarkersOpacity() {\n        0 !== this.map._markers.length && this.map._requestDomTask(() => {\n          for (const e of this.map._markers) e._evaluateOpacity();\n        });\n      }\n      getFog() {\n        return this.fog ? this.fog.get() : null;\n      }\n      setFog(t) {\n        if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);\n        if (this.fog) {\n          const i = this.fog;\n          if (!e.by(i.get(), t)) {\n            i.set(t, this.options), this.stylesheet.fog = i.get();\n            const e = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n          }\n        } else this._createFog(t);\n        this._markersNeedUpdate = !0;\n      }\n      getSnow() {\n        return this.snow ? this.snow.get() : null;\n      }\n      setSnow(t) {\n        if (this._checkLoaded(), !t) return delete this.snow, void delete this.stylesheet.snow;\n        if (this.snow) {\n          const i = this.snow;\n          if (!e.by(i.get(), t)) {\n            i.set(t, this.options), this.stylesheet.snow = i.get();\n            const e = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n          }\n        } else this._createSnow(t);\n        this._markersNeedUpdate = !0;\n      }\n      getRain() {\n        return this.rain ? this.rain.get() : null;\n      }\n      setRain(t) {\n        if (this._checkLoaded(), !t) return delete this.rain, void delete this.stylesheet.rain;\n        if (this.rain) {\n          const i = this.rain;\n          if (!e.by(i.get(), t)) {\n            i.set(t, this.options), this.stylesheet.rain = i.get();\n            const e = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n          }\n        } else this._createRain(t);\n        this._markersNeedUpdate = !0;\n      }\n      _reloadColorTheme() {\n        const t = () => {\n            for (const e in this._layers) this._layers[e].lut = this._styleColorTheme.lut;\n            for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles();\n          },\n          i = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;\n        if (!i) return this._styleColorTheme.lut = null, void t();\n        const o = this._evaluateColorThemeData(i);\n        this._loadColorTheme(o).then(() => {\n          this.fire(new e.z(\"colorthemeset\")), t();\n        }).catch(t => {\n          e.w(\"Couldn't set color theme: \".concat(t));\n        });\n      }\n      setColorTheme(t) {\n        this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w(\"Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible.\"), this._styleColorTheme.colorTheme = t, this._reloadColorTheme();\n      }\n      setImportColorTheme(e, t) {\n        const i = this.getFragmentStyle(e);\n        i && (i._styleColorTheme.colorThemeOverride = t, i._reloadColorTheme());\n      }\n      _getTransitionParameters(t) {\n        return {\n          now: e.o.now(),\n          transition: Object.assign(this.transition, t)\n        };\n      }\n      updateDrapeFirstLayers() {\n        if (!this.terrain) return;\n        const e = [],\n          t = [];\n        for (const i of this._mergedOrder) this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t.push(i);\n        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);\n      }\n      _createTerrain(e, t) {\n        const i = this.terrain = new Oe(e, t, this.scope, this.options, this.map.getWorldview());\n        1 === t && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();\n        const o = this._getTransitionParameters({\n          duration: 0\n        });\n        i.updateTransitions(o);\n      }\n      _force3DLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"fill-extrusion\" === t.type && this._updateLayer(t);\n        }\n      }\n      _forceSymbolLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this._updateLayer(t);\n        }\n      }\n      _validate(t, i, o, s) {\n        let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        if (r && !1 === r.validate) return !1;\n        const n = Object.assign({}, this.serialize());\n        return go(this, t.call(ge, Object.assign({\n          key: i,\n          style: n,\n          value: o,\n          styleSpec: e.a6\n        }, s)));\n      }\n      _remove() {\n        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.du.off(\"pluginStateChange\", this._rtlTextPluginCallback);\n        for (const e in this._mergedLayers) this._mergedLayers[e].setEventedParent(null);\n        for (const e in this._mergedSourceCaches) this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);\n        this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());\n      }\n      clearSource(e) {\n        const t = this.getSourceCaches(e);\n        for (const e of t) e.clearTiles();\n      }\n      clearSources() {\n        for (const e in this._mergedSourceCaches) this._mergedSourceCaches[e].clearTiles();\n      }\n      clearLayers() {\n        for (const e in this._mergedLayers) {\n          const t = this._mergedLayers[e];\n          t._clear && t._clear();\n        }\n      }\n      reloadSource(e) {\n        const t = this.getSourceCaches(e);\n        for (const e of t) e.resume(), e.reload();\n      }\n      reloadSources() {\n        for (const e of this.getSources()) e.reload && e.reload();\n      }\n      reloadModels() {\n        this.modelManager.reloadModels(\"\"), this.forEachFragmentStyle(e => {\n          e.modelManager.reloadModels(e.scope);\n        });\n      }\n      updateSources(e) {\n        let t;\n        this.directionalLight && (t = lo(this.directionalLight));\n        const i = new Set();\n        for (const e in this._mergedLayers) {\n          const t = this._mergedLayers[e];\n          t.hasElevation() && !i.has(t.source) && i.add(t.source);\n        }\n        for (const o in this._mergedSourceCaches) {\n          const s = this._mergedSourceCaches[o],\n            r = i.has(s._source.id);\n          s.update(e, void 0, void 0, t, r);\n        }\n      }\n      _generateCollisionBoxes() {\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          t.resume(), t.reload();\n        }\n      }\n      _updatePlacement(t, i, o, s, r, n) {\n        let a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;\n        let l = !1,\n          c = !1;\n        const h = {},\n          d = {};\n        for (const t of this._mergedOrder) {\n          const o = this._mergedLayers[t];\n          if (\"symbol\" !== o.type) continue;\n          const s = e.B(o.source, o.scope);\n          let r = h[s];\n          if (!r) {\n            const e = this.getLayerSourceCache(o);\n            if (!e) continue;\n            const t = e.getRenderableIds(!0).map(t => e.getTileByID(t));\n            d[s] = t.slice(), r = h[s] = t.sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));\n          }\n          const n = this.crossTileSymbolIndex.addLayer(o, r, i.center.lng, i.projection);\n          l = l || n;\n        }\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), a = a || this._layerOrderChanged || 0 === s, this._layerOrderChanged && this.fire(new e.z(\"neworder\")), (a || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.o.now(), i.zoom)) && (this.pauseablePlacement = new zi(i, this._mergedOrder, a, o, s, r, this.placement, this.fog && i.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h, d, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.o.now()), c = !0), l && this.pauseablePlacement.placement.setStale()), c || l) {\n          this._buildingIndex.onNewFrame(i.zoom);\n          for (let t = 0; t < this._mergedOrder.length; t++) {\n            const i = this._mergedLayers[this._mergedOrder[t]];\n            if (\"symbol\" !== i.type) continue;\n            const o = this.isLayerClipped(i);\n            this.placement.updateLayerOpacities(i, h[e.B(i.source, i.scope)], t, o ? n : null);\n          }\n        }\n        return {\n          needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.o.now())\n        };\n      }\n      _releaseSymbolFadeTiles() {\n        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();\n      }\n      addImport(t, i) {\n        this._checkLoaded();\n        const o = this.stylesheet.imports = this.stylesheet.imports || [];\n        if (-1 !== o.findIndex(_ref94 => {\n          let {\n            id: e\n          } = _ref94;\n          return e === t.id;\n        })) return void this.fire(new e.y(new Error(\"Import with id '\".concat(t.id, \"' already exists in the map's style.\"))));\n        if (!i) return o.push(t), this._loadImports([t], !0);\n        const s = o.findIndex(_ref95 => {\n          let {\n            id: e\n          } = _ref95;\n          return e === i;\n        });\n        return -1 === s && this.fire(new e.y(new Error(\"Import with id \\\"\".concat(i, \"\\\" does not exist on this map.\")))), this.stylesheet.imports = o.slice(0, s).concat(t).concat(o.slice(s)), this._loadImports([t], !0, i);\n      }\n      updateImport(t, i) {\n        this._checkLoaded();\n        const o = this.stylesheet.imports || [],\n          s = this.getImportIndex(t);\n        return -1 === s ? this : \"string\" == typeof i ? (this.setImportUrl(t, i), this) : (i.url && i.url !== o[s].url && this.setImportUrl(t, i.url), e.by(i.config, o[s].config) || this.setImportConfig(t, i.config, i.data.schema), e.by(i.data, o[s].data) || this.setImportData(t, i.data), this);\n      }\n      moveImport(e, t) {\n        this._checkLoaded();\n        let i = this.stylesheet.imports || [];\n        const o = this.getImportIndex(e);\n        if (-1 === o) return this;\n        const s = this.getImportIndex(t);\n        if (-1 === s) return this;\n        const r = i[o],\n          n = this.fragments[o];\n        return i = i.filter(_ref96 => {\n          let {\n            id: t\n          } = _ref96;\n          return t !== e;\n        }), this.fragments = this.fragments.filter(_ref97 => {\n          let {\n            id: t\n          } = _ref97;\n          return t !== e;\n        }), this.stylesheet.imports = i.slice(0, s).concat(r).concat(i.slice(s)), this.fragments = this.fragments.slice(0, s).concat(n).concat(this.fragments.slice(s)), this.mergeLayers(), this;\n      }\n      setImportUrl(e, t) {\n        this._checkLoaded();\n        const i = this.stylesheet.imports || [],\n          o = this.getImportIndex(e);\n        if (-1 === o) return this;\n        i[o].url = t;\n        const s = this.fragments[o];\n        return s.style = this._createFragmentStyle(i[o]), s.style.on(\"style.import.load\", () => this.mergeAll()), s.style.loadURL(t), this;\n      }\n      setImportData(e, t) {\n        this._checkLoaded();\n        const i = this.getImportIndex(e),\n          o = this.stylesheet.imports || [];\n        return -1 === i ? this : t ? (this.fragments[i].style.setState(t), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));\n      }\n      setImportConfig(e, t, i) {\n        this._checkLoaded();\n        const o = this.getImportIndex(e),\n          s = this.stylesheet.imports || [];\n        if (-1 === o) return this;\n        t ? s[o].config = t : delete s[o].config;\n        const r = this.fragments[o];\n        i && r.style.stylesheet && (r.style.stylesheet.schema = i);\n        const n = r.style.stylesheet && r.style.stylesheet.schema;\n        return r.config = t, r.style.updateConfig(t, n), this.updateConfigDependencies(), this;\n      }\n      removeImport(e) {\n        this._checkLoaded();\n        const t = this.stylesheet.imports || [],\n          i = this.getImportIndex(e);\n        -1 !== i && (t.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports());\n      }\n      getImportIndex(t) {\n        const i = (this.stylesheet.imports || []).findIndex(e => e.id === t);\n        return -1 === i && this.fire(new e.y(new Error(\"Import '\".concat(t, \"' does not exist in the map's style and cannot be updated.\")))), i;\n      }\n      getLayer(e) {\n        return this._mergedLayers[e];\n      }\n      getSources() {\n        const e = [];\n        for (const t in this._mergedOtherSourceCaches) {\n          const i = this._mergedOtherSourceCaches[t];\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      getSource(e, t) {\n        const i = this.getSourceCache(e, t);\n        return i && i.getSource();\n      }\n      getLayerSource(e) {\n        const t = this.getLayerSourceCache(e);\n        return t && t.getSource();\n      }\n      getSourceCache(t, i) {\n        const o = e.B(t, i);\n        return this._mergedOtherSourceCaches[o];\n      }\n      getLayerSourceCache(t) {\n        const i = e.B(t.source, t.scope);\n        return \"symbol\" === t.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];\n      }\n      getSourceCaches(e) {\n        if (null == e) return Object.values(this._mergedSourceCaches);\n        const t = [];\n        return this._mergedOtherSourceCaches[e] && t.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t.push(this._mergedSymbolSourceCaches[e]), t;\n      }\n      updateSourceCaches() {\n        const e = this._changes.getUpdatedSourceCaches();\n        for (const t in e) {\n          const i = e[t];\n          \"reload\" === i ? this.reloadSource(t) : \"clear\" === i && this.clearSource(t);\n        }\n      }\n      updateLayers(e) {\n        const t = this._changes.getUpdatedPaintProperties();\n        for (const i of t) {\n          const t = this.getLayer(i);\n          t && t.updateTransitions(e);\n        }\n      }\n      getGlyphsUrl() {\n        return this.stylesheet.glyphs;\n      }\n      setGlyphsUrl(e) {\n        this.stylesheet.glyphs = e, this.glyphManager.setURL(e);\n      }\n      getImages(t, i, o) {\n        this.imageManager.getImages(i.images, i.scope, o), this._updateTilesForChangedImages();\n        const s = t => {\n            if (t) {\n              const o = i.images.map(t => e.I.toString(t));\n              t.setDependencies(i.tileID.key, i.type, o);\n            }\n          },\n          r = e.B(i.source, i.scope);\n        s(this._mergedOtherSourceCaches[r]), s(this._mergedSymbolSourceCaches[r]), i.images.some(e => e.iconsetId) && this.fire(new e.z(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      rasterizeImages(e, t, i) {\n        this.imageManager.rasterizeImages(t, i);\n      }\n      getGlyphs(e, t, i) {\n        this.glyphManager.getGlyphs(t.stacks, i);\n      }\n      getResource(t, i, o) {\n        return e.dv(i, o);\n      }\n      getOwnSourceCache(e) {\n        return this._otherSourceCaches[e];\n      }\n      getOwnLayerSourceCache(e) {\n        return \"symbol\" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];\n      }\n      getOwnSourceCaches(e) {\n        const t = [];\n        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;\n      }\n      _isSourceCacheLoaded(t) {\n        const i = this.getOwnSourceCaches(t);\n        return 0 === i.length ? (this.fire(new e.y(new Error(\"There is no source with ID '\".concat(t, \"'\")))), !1) : i.every(e => e.loaded());\n      }\n      has3DLayers() {\n        return this._has3DLayers;\n      }\n      hasSymbolLayers() {\n        return this._hasSymbolLayers;\n      }\n      hasCircleLayers() {\n        return this._hasCircleLayers;\n      }\n      isLayerClipped(e, t) {\n        if (!this._clipLayerPresent && \"fill-extrusion\" !== e.type && \"building\" !== e.type) return !1;\n        const i = \"fill-extrusion\" === e.type && (\"building\" === e.sourceLayer || \"procedural_buildings\" === e.sourceLayer),\n          o = \"building\" === e.type;\n        if (e.is3D(!!this.terrain)) {\n          if (i || o || t && \"batched-model\" === t.type) return !0;\n          if (\"model\" === e.type) return !0;\n        } else if (\"symbol\" === e.type) return !0;\n        return !1;\n      }\n      _clearWorkerCaches() {\n        this.dispatcher.broadcast(\"clearCaches\");\n      }\n      destroy() {\n        this._clearWorkerCaches(), this.fragments.forEach(e => {\n          e.style._remove();\n        }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);\n      }\n    }\n    To.getSourceType = function (e) {\n      return at[e];\n    }, To.setSourceType = function (e, t) {\n      at[e] = t;\n    }, To.registerForPluginStateChange = e.dw;\n    class Eo {\n      execute(e) {\n        const t = this._makeBuildingsQueryArea(e),\n          i = this._makeFloorsQueryArea(e),\n          o = e.queryRenderedFeatures(t).reduce((e, t) => {\n            const i = t.properties.id;\n            return \"building\" !== t.properties.type || e.some(e => e.properties.id === i) || e.push(t), e;\n          }, []),\n          s = e.queryRenderedFeatures(i).reduce((e, t) => {\n            const i = t.properties.id;\n            return \"floor\" !== t.properties.type || e.some(e => e.properties.id === i) || e.push(t), e;\n          }, []),\n          r = [e.getCenter().lng, e.getCenter().lat],\n          n = this._findBuildingAtCenter(r, o),\n          a = o.length > 0 ? o[0] : null;\n        return {\n          floors: s.map(e => ({\n            id: e.properties.id,\n            name: e.properties.name,\n            isDefault: e.properties.is_default,\n            zIndex: e.properties.z_index,\n            connectedFloorIds: e.properties.connected_floor_ids,\n            conflictedFloorIds: e.properties.conflicted_floor_ids,\n            buildingIds: e.properties.building_ids\n          })),\n          building: n ? {\n            id: n.properties.id,\n            name: n.properties.name\n          } : {\n            id: a.properties.id,\n            name: a.properties.name\n          }\n        };\n      }\n      _makeBuildingsQueryArea(t) {\n        const i = t.transform.width,\n          o = t.transform.height,\n          s = Math.min(i, o) * (1 / 8),\n          r = .5 * (i - s),\n          n = .5 * (o - s);\n        return [new e.P(r, n), new e.P(r + s, n + s)];\n      }\n      _makeFloorsQueryArea(t) {\n        const i = t.transform.width,\n          o = t.transform.height;\n        return [new e.P(0, 0), new e.P(i, o)];\n      }\n      _findBuildingAtCenter(e, t) {\n        for (const i of t) if (\"Polygon\" === i.geometry.type && this._pointInPolygon(e, i.geometry.coordinates[0])) return i;\n        return null;\n      }\n      _pointInPolygon(e, t) {\n        let i = !1;\n        for (let o = 0, s = t.length - 1; o < t.length; s = o++) {\n          const r = t[o][0],\n            n = t[o][1],\n            a = t[s][1];\n          n > e[1] != a > e[1] && e[0] < (t[s][0] - r) * (e[1] - n) / (a - n) + r && (i = !i);\n        }\n        return i;\n      }\n    }\n    class So {\n      constructor() {\n        this._floors = new Map(), this._buildings = new Map();\n      }\n      append(e) {\n        const t = e.building;\n        let i = !1;\n        if (t) {\n          const e = t.id;\n          e && (this._buildings.set(e, t), i || this._buildings.has(e) || (i = !0));\n        }\n        return e.floors.forEach(e => {\n          const t = e.id;\n          i || this._floors.has(t) || (i = !0), this._floors.set(t, e);\n        }), i;\n      }\n      clear() {\n        this._floors.clear(), this._buildings.clear();\n      }\n      getFloors() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        const t = Array.from(this._floors.values());\n        return e ? t.filter(t => {\n          const i = t.buildingIds;\n          return !!i && i.split(\";\").includes(e);\n        }) : t;\n      }\n    }\n    class Io {\n      constructor() {\n        this._selectedFloorId = null, this._selectedBuildingId = null, this._lastActiveFloors = [], this._featuresStorage = new So();\n      }\n      setIndoorData(e) {\n        const t = this._featuresStorage.append(e);\n        return this._selectedBuildingId = e.building ? e.building.id : null, t;\n      }\n      setFloorId(e) {\n        const t = this._selectedFloorId !== e;\n        return t && (this._selectedFloorId = e), t;\n      }\n      getCurrentBuildingSelection() {\n        if (!this._selectedBuildingId) return {\n          selectedFloorId: null,\n          floors: []\n        };\n        const e = this._featuresStorage.getFloors(this._selectedBuildingId),\n          t = this.getActiveFloors().find(e => {\n            const t = e.buildingIds;\n            if (!t) return !1;\n            const i = t.split(\";\");\n            return !!this._selectedBuildingId && i.includes(this._selectedBuildingId);\n          });\n        return {\n          selectedFloorId: t ? t.id : null,\n          floors: e\n        };\n      }\n      getActiveFloors() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        const t = this._featuresStorage.getFloors(),\n          i = t.find(e => e.id === this._selectedFloorId),\n          o = t.filter(e => !0 === e.isDefault);\n        let s = [];\n        if (i) return s = this._calculateCurrentActiveFloors(t, i, o, e), s;\n        if (0 === o.length) {\n          const e = this._featuresStorage.getFloors(this._selectedBuildingId);\n          s = e.length > 0 ? [e[0]] : [];\n        } else s = o;\n        const r = this._getNonConflictingLastActiveFloors(s),\n          n = [...s, ...r];\n        return this._lastActiveFloors = n, n;\n      }\n      hasBuildingChanged(e) {\n        return this._selectedBuildingId !== (e.building ? e.building.id : null);\n      }\n      hasActiveBuilding() {\n        return null !== this._selectedBuildingId;\n      }\n      isEmpty() {\n        return null === this._selectedFloorId && null === this._selectedBuildingId && 0 === this._lastActiveFloors.length;\n      }\n      _calculateCurrentActiveFloors(e, t, i, o) {\n        if (!t) return this._getNonConflictingDefaultFloors(this._lastActiveFloors, i);\n        const s = this._getConnectedFloors(t, e);\n        return o ? this._buildExplicitSelectionFloors(t, s, i) : this._buildImplicitSelectionFloors(s, i);\n      }\n      _getConnectedFloors(e, t) {\n        const i = e.connectedFloorIds;\n        if (!i) return [];\n        const o = new Set(i.split(\";\"));\n        return t.filter(e => o.has(e.id));\n      }\n      _buildExplicitSelectionFloors(e, t, i) {\n        const o = [e, ...t],\n          s = this._getNonConflictingLastActiveFloors(o),\n          r = [...o, ...s],\n          n = this._deduplicateFloors(r),\n          a = this._getConflictingFloorIdsFrom(n),\n          l = i.filter(e => !a.has(e.id)),\n          c = [...n, ...l];\n        return this._lastActiveFloors = c, c;\n      }\n      _buildImplicitSelectionFloors(e, t) {\n        const i = this._getConflictingFloorIdsFrom(this._lastActiveFloors),\n          o = t.filter(e => !i.has(e.id)),\n          s = this._deduplicateFloors([...this._lastActiveFloors, ...o]);\n        return this._lastActiveFloors = s, s;\n      }\n      _getNonConflictingDefaultFloors(e, t) {\n        const i = this._getConflictingFloorIdsFrom(e),\n          o = t.filter(e => !i.has(e.id)),\n          s = this._deduplicateFloors([...e, ...o]);\n        return this._lastActiveFloors = s, s;\n      }\n      _deduplicateFloors(e) {\n        const t = new Set();\n        return e.filter(e => {\n          const i = e.id;\n          return !t.has(i) && (t.add(i), !0);\n        });\n      }\n      _getConflictingFloorIdsFrom(e) {\n        const t = new Set();\n        return e.forEach(e => {\n          const i = e.conflictedFloorIds;\n          i && i.split(\";\").forEach(e => t.add(e));\n        }), t;\n      }\n      _getNonConflictingLastActiveFloors(e) {\n        if (!this._lastActiveFloors || 0 === this._lastActiveFloors.length) return [];\n        const t = new Set(e.map(e => e.id)),\n          i = this._getConflictingFloorIdsFrom(e);\n        return this._lastActiveFloors.filter(e => {\n          const o = e.id;\n          return !t.has(o) && !i.has(o);\n        });\n      }\n      _isFloorConflicted(e, t) {\n        const i = e.id;\n        return t.some(e => {\n          const t = e.conflictedFloorIds;\n          return !!t && t.split(\";\").includes(i);\n        });\n      }\n      reset() {\n        this._selectedFloorId = null, this._selectedBuildingId = null, this._lastActiveFloors = [], this._featuresStorage.clear();\n      }\n    }\n    class Co extends e.E {\n      constructor(t) {\n        super(), e.aY([\"_onLoad\", \"_onMove\"], this), this._map = t, this._floorSelectionState = new Io(), this._queryIndoor(), this._map.on(\"load\", this._onLoad), this._map.on(\"move\", this._onMove);\n      }\n      destroy() {\n        this._map.off(\"load\", this._onLoad), this._map.off(\"move\", this._onMove), this._map = null, this._floorSelectionState = null;\n      }\n      selectFloor(e) {\n        this._floorSelectionState.setFloorId(e) && this._updateIndoorConfig(!0);\n      }\n      _onLoad() {\n        this._map.style.forEachFragmentStyle(t => {\n          t.stylesheet.indoor && (this._indoorDataQuery ? this.fire(new e.y(new Error(\"Multiple indoor map styles detected, simultaneous usage is not allowed currently.\"))) : (this._scope = t.scope, this._indoorDataQuery = new Eo()));\n        }), this._map._addIndoorControl(), this._queryIndoor();\n      }\n      _onMove() {\n        this._queryIndoor();\n      }\n      _queryIndoor() {\n        if (!this._indoorDataQuery || !this._map.isStyleLoaded()) return;\n        if (this._map.transform.zoom < 15) return void this._clearIndoorData();\n        const e = this._indoorDataQuery.execute(this._map);\n        if (!e || 0 === e.floors.length || this._map.transform.zoom < 16) this._clearIndoorData();else if (this._floorSelectionState.hasBuildingChanged(e)) {\n          if (!e.building && this._floorSelectionState.getActiveFloors().length <= 0) return void this._clearIndoorData();\n          this._setIndoorData(e), e.building && this._updateIndoorSelector();\n        } else this._setIndoorData(e);\n      }\n      _setIndoorData(e) {\n        this._floorSelectionState.setIndoorData(e) && this._updateIndoorConfig();\n      }\n      _clearIndoorData() {\n        this._floorSelectionState.isEmpty() || (this._floorSelectionState.reset(), this._updateIndoorSelector(), this._map.setConfigProperty(this._scope, \"activeFloors\", [\"literal\", []]));\n      }\n      _updateIndoorSelector() {\n        const t = this._floorSelectionState.getCurrentBuildingSelection(),\n          i = t.floors.map(e => ({\n            id: e.id,\n            name: e.name,\n            shortName: e.zIndex.toString(),\n            levelOrder: e.zIndex\n          }));\n        this.fire(new e.z(\"indoorupdate\", {\n          selectedFloorId: t.selectedFloorId,\n          floors: i\n        }));\n      }\n      _updateIndoorConfig() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        const t = this._floorSelectionState.getActiveFloors(e).map(e => e.id) || [];\n        this._map.setConfigProperty(this._scope, \"activeFloors\", [\"literal\", t]);\n      }\n    }\n    var Ro = \"\\n#define EPSILON 0.0000001\\n#define PI 3.141592653589793\\n#ifdef RENDER_CUTOFF\\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\\n#endif\",\n      Ao = \"\\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\\n#ifdef INDICATOR_CUTOUT\\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\\n#endif\\nvec4 applyCutout(vec4 color,float height) {\\n#ifdef INDICATOR_CUTOUT\\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\\n#else\\nreturn color;\\n#endif\\n}\\n#ifdef DEBUG_WIREFRAME\\n#define HANDLE_WIREFRAME_DEBUG \\\\\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\\\\ngl_FragDepth=gl_FragCoord.z-0.0001;\\n#else\\n#define HANDLE_WIREFRAME_DEBUG\\n#endif\\n#ifdef RENDER_CUTOFF\\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\\n#endif\\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb*col.a,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}\",\n      Do = \"\\n#define EXTENT 8192.0\\n#define RAD_TO_DEG 180.0/PI\\n#define DEG_TO_RAD PI/180.0\\n#define GLOBE_RADIUS EXTENT/PI/2.0\\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\\n#ifndef PROJECTED_POS_ON_VIEWPORT\\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\\n#ifdef RENDER_CUTOFF\\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\\n#endif\\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\",\n      Lo = \"in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}\",\n      Po = \"\\n#define ELEVATION_SCALE 7.0\\n#define ELEVATION_OFFSET 450.0\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\\n#else\\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\\n#endif\\n#ifdef TERRAIN\\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}float prevElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}\\n#ifdef TERRAIN_VERTEX_MORPHING\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\\n#else\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nreturn currentElevation(apos);}\\n#endif\\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\\n#else\\nfloat elevation(vec2 pos) { return 0.0; }\\n#endif\\n#ifdef DEPTH_OCCLUSION\\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\\n#ifdef DEPTH_D24\\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\\n#else\\nhighp float unpack_depth_rgba(vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\\n#endif\\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\\n#ifdef DEPTH_D24\\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\\n#else\\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\\n#endif\\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\\n#ifdef DEPTH_D24\\nhighp vec4 depth=vec4(\\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\\n);depth=unpack_depth4(depth);\\n#else\\nhighp vec4 depth=vec4(\\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\\n);\\n#endif\\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\\n#ifdef DEPTH_D24\\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\\n#else\\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\\n#endif\\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\\n#else\\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\\n#endif//DEPTH_OCCLUSION\",\n      zo = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\\n#endif\",\n      Oo = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;\\n#ifdef FLIP_Y\\nuv.y=1.0-uv.y;\\n#endif\\nhighp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\\n#endif\",\n      Mo = \"#ifdef RASTER_ARRAY\\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\\n#endif\",\n      Fo = \"#ifdef RASTER_ARRAY\\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\\n#endif\\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}\",\n      Bo = \"#ifdef RENDER_SHADOWS\\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\\n#endif//RENDER_SHADOWS\",\n      ko = \"#ifdef RENDER_SHADOWS\\nprecision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {\\n#ifdef CLIP_ZERO_TO_ONE\\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z-bias);\\n#else\\nhighp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);\\n#endif\\nreturn texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;\\n#ifdef SHADOWS_SINGLE_CASCADE\\nvec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);\\n#else\\nlight_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\\n#endif\\n}highp float calculate_shadow_bias(float NDotL) {\\n#ifdef NORMAL_OFFSET\\nreturn 0.5*u_shadow_bias.x;\\n#else\\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\\n#endif\\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\\n{highp vec2 biasUV=vec2(\\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\\n#endif\";\n    const No = [];\n    qo(Ro, No), qo(Do, No), qo(Ao, No);\n    const Uo = {\n        \"_prelude_fog.vertex.glsl\": zo,\n        \"_prelude_terrain.vertex.glsl\": Po,\n        \"_prelude_shadow.vertex.glsl\": Bo,\n        \"_prelude_fog.fragment.glsl\": Oo,\n        \"_prelude_shadow.fragment.glsl\": ko,\n        \"_prelude_lighting.glsl\": \"\\n#ifdef LIGHTING_3D_MODE\\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\\n#endif//LIGHTING_3D_MODE\",\n        \"_prelude_raster_array.glsl\": Mo,\n        \"_prelude_raster_particle.glsl\": Fo\n      },\n      jo = {};\n    Zo(\"\", Po), Zo(Oo, zo), Zo(ko, Bo), Zo(Mo, \"\"), Zo(Fo, \"\");\n    const Vo = Zo(Ao, Do),\n      Go = Ro;\n    var Ho = {\n      background: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec4 u_color;uniform float u_opacity;\\n#ifdef LIGHTING_3D_MODE\\nin vec4 v_color;\\n#endif\\nvoid main() {vec4 out_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=v_color;\\n#else\\nout_color=u_color;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec2 a_pos;uniform mat4 u_matrix;\\n#ifdef LIGHTING_3D_MODE\\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef LIGHTING_3D_MODE\\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      backgroundPattern: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      building: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nconst float window_depth=0.5;const float ao_radius=0.2;in vec4 v_color;in highp vec3 v_normal;in highp vec3 v_pos;\\n#ifdef BUILDING_FAUX_FACADE\\nin lowp float v_faux_facade;in highp float v_faux_facade_ed;in highp vec2 v_faux_facade_window;in highp vec2 v_faux_facade_floor;in highp vec2 v_faux_facade_range;in highp float v_aspect;in highp vec3 v_tbn_0;in highp vec3 v_tbn_1;in highp vec3 v_tbn_2;in highp vec4 v_faux_color_emissive;uniform float u_faux_facade_ao_intensity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\\n#endif\\nuniform lowp float u_opacity;uniform vec3 u_camera_pos;uniform highp float u_tile_to_meter;uniform float u_facade_emissive_chance;vec3 linearTosRGB(in vec3 color) {return pow(color,vec3(1./2.2));}\\n#ifdef BUILDING_FAUX_FACADE\\nfloat hash12(in vec2 p) {vec3 p3 =fract(vec3(p.xyx)*0.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float min3(in vec3 v) {return min(min(v.x,v.y),v.z);}vec2 get_uv_mask_id(in vec2 q,out float mask,out vec2 id) {vec2 p=q;mask=step(v_faux_facade_range.x,p.y)*step(p.y,v_faux_facade_range.y);p.y=p.y-v_faux_facade_range.x;vec2 uv=modf(p/v_faux_facade_floor,id);vec4 d=(v_faux_facade_floor.xyxy+vec4(-v_faux_facade_window,v_faux_facade_window))*0.5;vec4 edge=d/v_faux_facade_floor.xyxy;vec2 m=step(edge.xy,uv)*step(uv,edge.zw);mask*=m.x*m.y;uv-=vec2(0.5);uv*=vec2(0.5)/(vec2(0.5)-edge.xy);uv+=vec2(0.5);return uv;}float ray_unit_box(in vec3 ray_o,in vec3 ray_d,in vec3 bmin,in vec3 bmax) {vec3 planes=mix(bmin,bmax,step(0.0,ray_d));vec3 t=(planes-ray_o)/ray_d;return min3(t);}float get_emissive(in vec2 id) {if (u_facade_emissive_chance > 0.0) {return (step(hash12(id),u_facade_emissive_chance)+0.05)*v_faux_color_emissive.a;}return 0.0;}vec3 get_shade_info(in vec3 v,in vec3 v_normalized,in vec3 color,in vec2 id,in mat3 tbn,inout vec3 out_normal,inout float out_emissive) {vec3 out_color=color;vec3 abs_v=abs(v_normalized);bool x_major=abs_v.x >=abs_v.y && abs_v.x >=abs_v.z;bool y_major=abs_v.y >=abs_v.x && abs_v.y >=abs_v.z;bool z_major=abs_v.z >=abs_v.x && abs_v.z >=abs_v.y;\\n#if 0\\nif (x_major) {out_color=v.x > 0.0 ? vec3(1.0,0.0,0.0) : vec3(0.0,1.0,1.0);} else if (y_major) {out_color=v.y > 0.0 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,1.0);} else if (z_major) {out_color=v.z > 0.0 ? vec3(0.0,0.0,1.0) : vec3(1.0,1.0,0.0);}out_emissive=1.0;\\n#else\\nif (x_major) {out_normal=sign(v.x)*tbn[0];} else if (y_major) {out_normal=vec3(0.0,0.0,-sign(v.y));} else if (z_major) {out_color=v_faux_color_emissive.rgb;out_emissive=v.z <=0.0 ? get_emissive(id) : out_emissive;}float ao=1.0;if (u_faux_facade_ao_intensity > 0.0) {vec4 ao_range=v_faux_facade_window.xxyy*0.5-vec4(0,ao_radius,0,ao_radius);vec2 ao_range_z=vec2(window_depth*0.5)-vec2(0.0,ao_radius);if (x_major || y_major) {ao*=smoothstep(-ao_range_z.x,-ao_range_z.y,v.z);} else if (z_major) {ao*=smoothstep(-ao_range.x,-ao_range.y,v.x)*(1.0-smoothstep(ao_range.y,ao_range.x,v.x));ao*=smoothstep(-ao_range.z,-ao_range.w,v.y)*(1.0-smoothstep(ao_range.w,ao_range.z,v.y));}ao=mix(1.0,min(1.0,ao+0.25),u_faux_facade_ao_intensity);}out_color*=ao;\\n#endif\\nreturn out_color;}\\n#endif\\nvec3 apply_lighting_linear(in vec3 color,in vec3 normal,in float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec3 normal=normalize(v_normal);vec3 base_color=v_color.rgb;float emissive=v_color.a;\\n#ifdef BUILDING_FAUX_FACADE\\nif (v_faux_facade > 0.0) {mat3 tbn=mat3(v_tbn_0,v_tbn_1,v_tbn_2);vec3 v=vec3(v_pos.xy,v_pos.z/u_tile_to_meter)-u_camera_pos;vec3 view_tangent=transpose(tbn)*v;vec2 q=vec2(v_faux_facade_ed,v_pos.z);float mask=0.0;vec2 id=vec2(0.0);vec2 uv=get_uv_mask_id(q,mask,id);uv*=v_faux_facade_window;vec3 bmin=vec3(0.0,0.0,-window_depth);vec3 bmax=bmin+vec3(v_faux_facade_window,window_depth);vec3 ray_o=vec3(uv,0.0);vec3 ray_d=normalize(view_tangent);float t_min=ray_unit_box(ray_o,ray_d,bmin,bmax);vec3 hit=ray_o+t_min*ray_d;vec3 r=vec3(v_faux_facade_window,-window_depth);hit-=r*0.5;vec3 normalized=hit/r;vec3 out_normal=normal;float out_emissive=emissive;vec3 room_color=get_shade_info(hit,normalized,base_color,id,tbn,out_normal,out_emissive);base_color=mix(base_color,room_color,mask);normal=mix(normal,out_normal,mask);emissive=mix(emissive,out_emissive,mask);}\\n#endif\\nvec4 color=vec4(base_color,1.0);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\\n#ifdef RENDER_SHADOWS\\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nshadowed_lighting_factor=dot(normal,u_lighting_directional_dir);\\n#endif\\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,base_color.rgb,emissive);\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_pos.z));\\n#endif\\ncolor.rgb=linearTosRGB(color.rgb);color*=u_opacity;\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color,v_pos.z);\\n#endif\\nglFragColor=color; \\n#ifdef DEBUG_SHOW_NORMALS\\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec3 a_pos_3f;in vec3 a_normal_3;in vec3 a_centroid_3;in vec4 a_faux_facade_data;in vec2 a_faux_facade_vertical_range;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;uniform highp float u_tile_to_meter;out vec4 v_color;out vec3 v_normal;out highp vec3 v_pos;\\n#ifdef BUILDING_FAUX_FACADE\\nout lowp float v_faux_facade;out highp float v_faux_facade_ed;out highp vec2 v_faux_facade_window;out highp vec2 v_faux_facade_floor;out highp vec2 v_faux_facade_range;out highp float v_aspect;out highp vec3 v_tbn_0;out highp vec3 v_tbn_1;out highp vec3 v_tbn_2;out highp vec4 v_faux_color_emissive;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\\n#endif\\nconst float MAX_UINT_16=65535.0;const float MAX_INT_16=32767.0;const float MAX_UINT_8=255.0;const float TWO_POW_8=256.0;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\\n#ifdef BUILDING_FAUX_FACADE\\nmat3 get_tbn(in vec3 normal) {const vec3 bitangent=vec3(0.0,0.0,1.0);vec3 tangent=normalize(vec3(normal.y,-normal.x,0.0));return mat3(tangent,bitangent,normal);}\\n#endif\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 faux_facade_color_emissive\\nvoid main() {\\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\\n#pragma mapbox: initialize-attribute-custom highp vec2 faux_facade_color_emissive\\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);vec3 a_normal_3f=a_normal_3/MAX_INT_16;v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));float hidden=0.0;\\n#ifdef BUILDING_FAUX_FACADE\\nv_faux_facade=a_faux_facade_data.x;if (v_faux_facade > 0.0) {v_faux_facade_ed=a_faux_facade_data.x *u_tile_to_meter;float window_x_perc=floor(a_faux_facade_data.y/TWO_POW_8);float window_y_perc=a_faux_facade_data.y-TWO_POW_8*window_x_perc;vec2 window_perc=vec2(window_x_perc,window_y_perc)/MAX_UINT_8;v_faux_facade_floor=(a_faux_facade_data.zw/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_faux_facade_window=window_perc*v_faux_facade_floor;v_faux_facade_range=(a_faux_facade_vertical_range/MAX_UINT_16*EXTENT)*u_tile_to_meter;v_aspect=v_faux_facade_window.x/v_faux_facade_window.y;mat3 tbn=get_tbn(normalize(v_normal));v_tbn_0=tbn[0];v_tbn_1=tbn[1];v_tbn_2=tbn[2];v_faux_color_emissive=decode_color(faux_facade_color_emissive);v_faux_color_emissive.rgb=sRGBToLinear(v_faux_color_emissive.rgb);}\\n#endif\\nv_pos=a_pos_3f;\\n#ifdef RENDER_CUTOFF\\nvec4 ground=u_matrix*vec4(a_centroid_3,1.0);v_cutoff_opacity=cutoff_opacity(u_cutoff_params,ground.z);hidden=float(v_cutoff_opacity==0.0);v_pos.z*=v_cutoff_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 shadow_pos=v_pos;\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(v_pos);\\n#endif\\ngl_Position=mix(u_matrix*vec4(v_pos,1),AWAY,hidden);}'),\n      buildingBloom: Zo(\"in vec4 v_color_emissive;\\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\\nfloat saturate(float val) {return clamp(val,0.0,1.0);}void main() {float emission=v_color_emissive.a;float opacity=1.0;\\n#ifdef HAS_ATTRIBUTE_a_bloom_attenuation\\nfloat distance=length(vec2(1.3*max(0.0,abs(bloom_attenuation.x)-bloom_attenuation.z),bloom_attenuation.y));distance+= mix(0.5,0.0,clamp(emission-1.0,0.0,1.0));opacity*=saturate(1.0-distance*distance);\\n#endif\\nglFragColor=vec4(v_color_emissive.rgb,1.0)*opacity;}\", \"in vec3 a_pos_3f;\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\\n#pragma mapbox: define-attribute highp vec4 bloom_attenuation\\nout vec4 v_color_emissive;uniform mat4 u_matrix;vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\\n#pragma mapbox: initialize-attribute highp vec4 bloom_attenuation\\n#ifdef HAS_ATTRIBUTE_a_part_color_emissive\\nvec4 color_emissive=decode_color(part_color_emissive);float part_emissive=color_emissive.a*5.0;v_color_emissive=vec4(sRGBToLinear(color_emissive.rgb),part_emissive);\\n#else\\nv_color_emissive=vec4(1.0);\\n#endif\\ngl_Position=u_matrix*vec4(a_pos_3f,1.0);}\"),\n      buildingDepth: Zo(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", \"in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}\"),\n      circle: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec3 v_data;in float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nuniform float u_emissive_strength;void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \\nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \\nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\\n#endif\\nglFragColor=out_color*(v_visibility*opacity_t);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define NUM_VISIBILITY_RINGS 2\\n#define INV_SQRT2 0.70710678\\n#define ELEVATION_BIAS 0.0001\\n#define NUM_SAMPLES_PER_RING 16\\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin float a_circle_z_offset;\\n#endif\\nout vec3 v_data;out float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\\n#if defined(TERRAIN)\\nreturn elevation(pos)+ELEVATION_BIAS;\\n#else\\nreturn 0.0;\\n#endif\\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\\n#ifdef PITCH_WITH_MAP\\n#ifdef PROJECTION_GLOBE_VIEW\\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\\n#else\\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\\n#endif\\n#else\\nreturn projected_center+vec4(sample_offset,0,0);\\n#endif\\n}float get_sample_step() {\\n#ifdef PITCH_WITH_MAP\\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\\n#else\\nreturn PI/float(NUM_SAMPLES_PER_RING);\\n#endif\\n}void main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\\n#else \\nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\\n#endif\\n#ifdef ELEVATED_ROADS\\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\\n#endif\\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\\n#ifdef PITCH_WITH_MAP\\n#ifdef SCALE_WITH_MAP\\nview_scale=1.0;\\n#else\\nview_scale=projected_center.w/u_camera_to_center_distance;\\n#endif\\n#else\\n#ifdef SCALE_WITH_MAP\\nview_scale=u_camera_to_center_distance;\\n#else\\nview_scale=projected_center.w;\\n#endif\\n#endif\\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\\n#ifdef TERRAIN\\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\\n#ifdef PITCH_WITH_MAP\\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\\n#else\\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\\n#endif\\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\\n#else\\nvisibility=1.0;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nvisibility=1.0;\\n#endif\\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\\n#ifdef FOG\\nv_fog_pos=fog_position(world_center.xyz);\\n#endif\\n}'),\n      clippingMask: Zo(\"void main() {glFragColor=vec4(1.0);}\", \"in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      heatmap: Zo('#include \"_prelude_fog.fragment.glsl\"\\nuniform highp float u_intensity;in vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef FOG\\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nout vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#else\\npos=vec3(tilePos+extrude,elevation(tilePos));\\n#endif\\ngl_Position=u_matrix*vec4(pos,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      heatmapTexture: Zo(\"uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(0.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}\", \"in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}\"),\n      collisionBox: Zo(\"in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform float u_zoom_transition;\\n#endif\\nout float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec3 proj_pos=a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation);\\n#ifdef PROJECTION_GLOBE_VIEW\\n#ifndef PROJECTED_POS_ON_VIEWPORT\\nvec3 globe_pos=proj_pos;vec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,a_anchor_pos,u_tile_id,u_merc_center);proj_pos=mix_globe_mercator(globe_pos,mercator_pos,u_zoom_transition);\\n#endif\\n#endif\\nvec4 projectedPoint=u_matrix*vec4(proj_pos,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),\n      collisionCircle: Zo(\"in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}\", \"in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}\"),\n      debug: Zo(\"uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;\\n#endif\\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\\n#else\\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\\n#endif\\n}'),\n      elevatedStructuresDepth: Zo(\"void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=vec4(0.);\\n#endif\\n}\", \"in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}\"),\n      elevatedStructuresDepthReconstruct: Zo(\"#ifdef DEPTH_RECONSTRUCTION\\nin float v_height;\\n#endif\\nvoid main() {\\n#ifdef DEPTH_RECONSTRUCTION\\nif (v_height >=0.0)\\ndiscard;\\n#else\\n#ifdef FEATURE_CUTOUT\\napply_feature_cutout(vec4(0.0,0.0,0.0,1.0),gl_FragCoord);\\n#endif\\n#endif\\nglFragColor=vec4(1.0,0.0,0.0,1.0);}\", \"in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\\n#ifdef DEPTH_RECONSTRUCTION\\nout float v_height;\\n#endif\\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\\n#ifdef DEPTH_RECONSTRUCTION\\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\\n#endif\\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}\"),\n      elevatedStructures: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nin vec3 v_normal;in float v_height;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\\n#endif\\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)\\n{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;\\n#pragma mapbox: define highp vec4 structure_color\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 structure_color\\nvec3 color=structure_color.xyz;\\n#ifdef LIGHTING_3D_MODE\\nvec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);\\n#ifdef RENDER_SHADOWS\\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);\\n#else\\ncolor=apply_lighting(color,transformed_normal);\\n#endif\\ncolor=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\\n#endif\\n#ifdef FOG\\ncolor=fog_apply(color,v_fog_pos);\\n#endif\\nvec4 out_color=vec4(color,1.0);\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,v_height);\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\\n#endif\\n#pragma mapbox: define highp vec4 structure_color\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 structure_color\\nv_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fill: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nuniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin highp float v_road_z_offset;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\nvec4 out_color=color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nout_color*=opacity;\\n#ifdef INDICATOR_CUTOUT\\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;out highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\nuniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp float z_offset\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=z_offset;\\n#endif\\n}'),\n      fillOutline: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nin highp vec2 v_pos;uniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\nglFragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp float z_offset\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\\n#ifdef FLIP_Y\\nv_pos=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\\n#else\\nv_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillOutlinePattern: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;\\n#ifdef FILL_PATTERN_TRANSITION\\nuniform float u_pattern_transition;\\n#endif\\nuniform float u_emissive_strength;\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\nin highp vec2 v_pos;in highp vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef APPLY_LUT_ON_GPU\\nout_color=applyLUT(u_lutTexture,out_color);\\n#endif\\n#ifdef FILL_PATTERN_TRANSITION\\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\nout highp vec2 v_pos;out highp vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: define lowp float pixel_ratio\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: initialize lowp float pixel_ratio\\n#pragma mapbox: initialize highp float z_offset\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\\n#ifdef FLIP_Y\\nv_pos_world=(vec2(gl_Position.x,-gl_Position.y)/gl_Position.w+1.0)/2.0*u_world;\\n#else\\nv_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillPattern: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;\\n#ifdef FILL_PATTERN_TRANSITION\\nuniform float u_pattern_transition;\\n#endif\\nin highp vec2 v_pos;uniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin highp float v_road_z_offset;\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef APPLY_LUT_ON_GPU\\nout_color=applyLUT(u_lutTexture,out_color);\\n#endif\\n#ifdef FILL_PATTERN_TRANSITION\\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#ifdef ELEVATED_ROADS\\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\\n#else\\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;out highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\nout highp vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: define lowp float pixel_ratio\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\n#pragma mapbox: initialize highp float z_offset\\n#ifdef FILL_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;v_road_z_offset=z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillExtrusion: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec4 v_color;in vec4 v_flat;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\\n#endif\\nuniform lowp float u_opacity;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;in vec2 v_ao;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nin vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nin highp vec3 v_normal;\\n#endif\\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\\nin float v_flood_radius;in float v_has_floodlight;\\n#endif\\nin float v_height;\\n#pragma mapbox: define highp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp float emissive_strength\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nvec3 normal=normalize(v_normal);\\n#endif\\nfloat z;vec4 color=v_color;\\n#ifdef ZERO_ROOF_RADIUS\\nz=float(normal.z > 0.00001);\\n#ifdef LIGHTING_3D_MODE\\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\\n#else\\ncolor=mix(v_color,v_roof_color,z);\\n#endif\\n#endif\\nfloat h=max(0.0,v_height);float ao_shade=1.0;\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\\n#ifdef ZERO_ROOF_RADIUS\\nconcave*=(1.0-z);\\n#endif\\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef FLOOD_LIGHT\\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\\n#else\\ncolor.rgb*=ao_shade;\\n#endif\\n#else\\ncolor.rgb*=ao_shade;\\n#endif\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nfloat flood_radiance=0.0;\\n#ifdef FLOOD_LIGHT\\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\\n#endif\\n#ifdef RENDER_SHADOWS\\n#ifdef FLOOD_LIGHT\\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\\n#else\\nfloat shadowed_lighting_factor;\\n#ifdef RENDER_CUTOFF\\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\\n#else\\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\\n#endif\\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\\n#endif\\n#else\\ncolor.rgb=apply_lighting(color.rgb,normal);\\n#ifdef FLOOD_LIGHT\\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\\n#endif\\n#endif\\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\\n#endif\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color,h);\\n#endif\\n#ifdef FEATURE_CUTOUT\\ncolor=apply_feature_cutout(color,gl_FragCoord);\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef RENDER_WALL_MODE\\nin vec3 a_join_normal_inside;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\n#ifdef TERRAIN\\nuniform int u_height_type;uniform int u_base_type;\\n#endif\\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nout vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nout highp vec3 v_normal;\\n#endif\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;out vec2 v_ao;\\n#endif\\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\\nout float v_flood_radius;out float v_has_floodlight;\\n#endif\\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define highp float flood_light_wall_radius\\n#pragma mapbox: define highp float line_width\\n#pragma mapbox: define highp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize highp float flood_light_wall_radius\\n#pragma mapbox: initialize highp float line_width\\n#pragma mapbox: initialize highp float emissive_strength\\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nv_normal=normal;\\n#endif\\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\\n#ifdef TERRAIN\\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\\n#else\\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat cutoff=1.0;vec3 scaled_pos=pos;\\n#ifdef RENDER_CUTOFF\\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);\\n#ifdef CLIP_ZERO_TO_ONE\\ncutoff=cutoff_opacity(u_cutoff_params,ground.z*2.0-ground.w);\\n#else\\ncutoff=cutoff_opacity(u_cutoff_params,ground.z);\\n#endif\\nif (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\\n#ifdef RENDER_WALL_MODE\\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\\n#endif\\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\\n#endif\\nfloat NdotL=0.0;float colorvalue=0.0;\\n#ifndef LIGHTING_3D_MODE\\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#endif\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\n#ifdef FLOOD_LIGHT\\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\\n#endif\\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\\n#else\\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      fillExtrusionDepth: Zo(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", '#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\\n#ifdef TERRAIN\\nuniform int u_height_type;uniform int u_base_type;\\n#endif\\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef RENDER_WALL_MODE\\nin vec3 a_join_normal_inside;\\n#endif\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp float line_width\\n#pragma mapbox: define highp vec4 color\\nout highp float v_depth;void main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp float line_width\\n#pragma mapbox: initialize highp vec4 color\\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nvec3 pos;\\n#ifdef TERRAIN\\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\\n#else\\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\\n#endif\\n#ifdef RENDER_WALL_MODE\\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),\n      fillExtrusionPattern: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;\\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\\nuniform float u_pattern_transition;\\n#endif\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;in vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nin vec3 v_normal;\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define mediump vec4 pattern\\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: define highp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: initialize highp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef APPLY_LUT_ON_GPU\\nout_color=applyLUT(u_lutTexture,out_color);\\n#endif\\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\\n#else\\nout_color=out_color*v_lighting;\\n#endif\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,height);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef RENDER_WALL_MODE\\nin vec3 a_join_normal_inside;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\n#ifdef TERRAIN\\nuniform int u_height_type;uniform int u_base_type;\\n#endif\\nout highp vec2 v_pos;out vec4 v_lighting;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;out vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout vec3 v_normal;\\n#endif\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump vec4 pattern\\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: define highp float pixel_ratio\\n#pragma mapbox: define highp float line_width\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: initialize highp float pixel_ratio\\n#pragma mapbox: initialize highp float line_width\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\\n#ifdef TERRAIN\\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\\n#else\\np=vec3(pos_nx.xy,z);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\n#ifdef RENDER_WALL_MODE\\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\\n? pos_nx.xy\\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\\n#ifdef LIGHTING_3D_MODE\\nNdotL=calculate_NdotL(normal);\\n#else\\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\\n#endif\\nif (normal.y !=0.0) {float r=0.84;\\n#ifndef LIGHTING_3D_MODE\\nr=mix(0.7,0.98,1.0-u_lightintensity);\\n#endif\\nNdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nv_normal=normal;\\n#else\\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(p);\\n#endif\\n}'),\n      groundShadow: Zo('#include \"_prelude_shadow.fragment.glsl\"\\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\\n#ifdef FOG\\nin float v_fog_opacity;\\n#endif\\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#ifdef RENDER_CUTOFF\\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\\n#endif\\n#ifdef FOG\\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\\n#endif\\nglFragColor=vec4(shadow,1.0);}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\\n#ifdef FOG\\nout float v_fog_opacity;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\\n#endif\\n}'),\n      fillExtrusionGroundEffect: Zo(\"uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\\n#ifdef SDF_SUBPASS\\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\\n#ifdef FOG\\nin highp float v_fog;\\n#endif\\n#endif\\nvoid main() {\\n#ifdef CLEAR_SUBPASS\\nvec4 color=vec4(1.0);\\n#ifdef CLEAR_FROM_TEXTURE\\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\\n#endif\\nglFragColor=color;\\n#else\\n#ifdef SDF_SUBPASS\\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\\n#ifdef FOG\\nfog=v_fog;\\n#endif\\n#ifdef RENDER_CUTOFF\\nfog*=v_cutoff_opacity;\\n#endif\\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\\n#else\\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\\n#ifdef OVERDRAW_INSPECTOR\\ncolor=vec4(1.0);\\n#endif\\nglFragColor=color;\\n#endif\\nHANDLE_WIREFRAME_DEBUG;\\n#endif\\n}\", '#include \"_prelude_fog.vertex.glsl\"\\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\\n#ifdef SDF_SUBPASS\\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\\n#ifdef FOG\\nout highp float v_fog;\\n#endif\\n#endif\\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\\n#pragma mapbox: define highp float flood_light_ground_radius\\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\\n#pragma mapbox: initialize highp float flood_light_ground_radius\\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\\n#ifdef SDF_SUBPASS\\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\\n#endif\\n#endif\\nfloat hidden_by_landmark=0.0;\\n#ifdef HAS_CENTROID\\nhidden_by_landmark=a_hidden_by_landmark;\\n#endif\\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\\n#ifdef RENDER_CUTOFF\\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\\n#endif\\n}'),\n      hillshadePrepare: Zo(\"precision highp float;uniform highp sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}\", \"uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}\"),\n      hillshade: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef LIGHTING_3D_MODE\\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      line: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\\n#ifdef ELEVATED_ROADS\\nin highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nuniform sampler2D u_dash_image;in vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform sampler2D u_gradient_image;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float border_width\\n#pragma mapbox: define lowp vec4 border_color\\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float border_width\\n#pragma mapbox: initialize lowp vec4 border_color\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\\n#ifdef RENDER_LINE_DASH\\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\\n#endif\\nhighp vec4 out_color;\\n#ifdef RENDER_LINE_GRADIENT\\nout_color=texture(u_gradient_image,v_uv.xy);\\n#else\\nout_color=color;\\n#endif\\nfloat trim_alpha=1.0;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\\n#endif\\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\\n#ifdef RENDER_LINE_BORDER\\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#ifdef ELEVATED_ROADS\\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\\n#else\\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nout_color*=(alpha*opacity);\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,v_z_offset);\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define EXTRUDE_SCALE 0.015873016\\nin vec2 a_pos_normal;in vec4 a_data;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\\nin vec3 a_z_offset_width;\\n#endif\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nin highp vec3 a_packed;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nin float a_linesofar;\\n#endif\\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\\n#ifdef ELEVATED\\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\\n#ifdef ELEVATION_REFERENCE_SEA\\nreturn 0.0;\\n#else\\nreturn elevation(apos);\\n#endif\\n}\\n#endif\\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\\n#ifdef ELEVATED_ROADS\\nout highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform float u_image_height;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float border_width\\n#pragma mapbox: define lowp vec4 border_color\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float border_width\\n#pragma mapbox: initialize lowp vec4 border_color\\nfloat a_z_offset;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\\na_z_offset=a_z_offset_width.x;\\n#endif\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\\n#ifdef VARIABLE_LINE_WIDTH\\nfloat left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;\\n#else\\nhalfwidth=(u_width_scale*width)/2.0;\\n#endif\\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\\n#ifdef ELEVATED_ROADS\\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\\n#else\\n#ifdef ELEVATED\\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\\n#ifdef CROSS_SLOPE_VERTICAL\\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\\n#else\\n#ifdef CROSS_SLOPE_HORIZONTAL\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\\n#else\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\\n#endif\\n#endif\\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\\n#else\\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\\n#endif\\n#endif\\n#ifdef ELEVATED_ROADS\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\\n#ifdef NORMAL_OFFSET\\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#endif\\n#ifndef RENDER_TO_TEXTURE\\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\\n#ifdef RENDER_LINE_GRADIENT\\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\\n#else\\nv_uv=vec3(a_uv_x,0.0,line_progress);\\n#endif\\n#endif\\n#ifdef RENDER_LINE_DASH\\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\\n#endif\\nv_width2=vec2(outset,inset);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=a_z_offset;\\n#endif\\n}'),\n      linePattern: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\n#ifdef LINE_PATTERN_TRANSITION\\nuniform float u_pattern_transition;\\n#endif\\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nin highp vec3 v_uv;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin highp float v_road_z_offset;\\n#endif\\n#ifdef LINE_JOIN_NONE\\nin vec2 v_pattern_data;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\nuniform float u_emissive_strength;\\n#pragma mapbox: define mediump vec4 pattern\\n#ifdef LINE_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: define mediump float pixel_ratio\\n#pragma mapbox: define mediump float blur\\n#pragma mapbox: define mediump float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef LINE_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: initialize mediump float pixel_ratio\\n#pragma mapbox: initialize mediump float blur\\n#pragma mapbox: initialize mediump float opacity\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef APPLY_LUT_ON_GPU\\ncolor=applyLUT(u_lutTexture,color);\\n#endif\\n#ifdef LINE_PATTERN_TRANSITION\\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\\n#endif\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\\n#endif\\n#ifdef LINE_JOIN_NONE\\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#ifdef ELEVATED_ROADS\\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\\n#else\\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color,v_z_offset);\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define scale 0.015873016\\nin vec2 a_pos_normal;in vec4 a_data;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\\nin vec3 a_z_offset_width;\\n#endif\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nin highp vec3 a_packed;\\n#endif\\nin highp float a_linesofar;\\n#ifdef LINE_JOIN_NONE\\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\\n#ifdef ELEVATED\\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\\n#ifdef ELEVATION_REFERENCE_SEA\\nreturn 0.0;\\n#else\\nreturn elevation(apos);\\n#endif\\n}\\n#endif\\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nout highp vec3 v_uv;\\n#endif\\n#ifdef ELEVATED_ROADS\\nout highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#pragma mapbox: define mediump float blur\\n#pragma mapbox: define mediump float opacity\\n#pragma mapbox: define mediump float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define mediump float floorwidth\\n#pragma mapbox: define mediump vec4 pattern\\n#ifdef LINE_PATTERN_TRANSITION\\n#pragma mapbox: define mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: define mediump float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize mediump float blur\\n#pragma mapbox: initialize mediump float opacity\\n#pragma mapbox: initialize mediump float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize mediump float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern\\n#ifdef LINE_PATTERN_TRANSITION\\n#pragma mapbox: initialize mediump vec4 pattern_b\\n#endif\\n#pragma mapbox: initialize mediump float pixel_ratio\\nfloat a_z_offset;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\\na_z_offset=a_z_offset_width.x;\\n#endif\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\\n#ifdef ELEVATED_ROADS\\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\\n#else\\n#ifdef ELEVATED\\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\\n#ifdef CROSS_SLOPE_VERTICAL\\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\\n#else\\n#ifdef CROSS_SLOPE_HORIZONTAL\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\\n#else\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\\n#endif\\n#endif\\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\\n#else\\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\\n#endif\\n#endif\\n#ifdef ELEVATED_ROADS\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\\n#ifdef NORMAL_OFFSET\\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#endif\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\\n#endif\\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\\n#ifdef LINE_JOIN_NONE\\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=a_z_offset;\\n#endif\\n}'),\n      raster: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_raster_array.glsl\"\\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin float v_split_fade;\\n#endif\\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\\n#ifndef RASTER_ARRAY\\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\\n#endif\\n#ifdef RASTER_COLOR\\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\\n#endif\\nvoid main() {vec4 color0,color1,color;vec2 value;\\n#ifdef RASTER_COLOR\\n#ifdef RASTER_ARRAY\\n#ifdef RASTER_ARRAY_LINEAR\\nvalue=mix(\\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\\n);\\n#else\\nvalue=mix(\\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\\n);\\n#endif\\nif (value.y > 0.0) value.x/=value.y;\\n#else\\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\\n#endif\\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\\n#else\\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\\n#endif\\ncolor.a*=u_opacity;\\n#ifdef GLOBE_POLES\\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\\n#endif\\nvec3 rgb=color.rgb;rgb=vec3(\\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\\n#endif\\n#ifdef FOG\\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\\n#endif\\nglFragColor=vec4(out_color*color.a,color.a);\\n#ifdef PROJECTION_GLOBE_VIEW\\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\\n#endif\\n#ifdef RENDER_CUTOFF\\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\\n#ifdef GLOBE_POLES\\nin vec3 a_globe_pos;in vec2 a_uv;\\n#else\\nin vec2 a_pos;in vec2 a_texture_pos;\\n#endif\\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\\n#ifdef PROJECTION_GLOBE_VIEW\\nout float v_split_fade;\\n#endif\\nvoid main() {vec2 uv;\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\\n#endif\\n#else\\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \\nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n#else\\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#endif\\n#endif\\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\\n#ifdef RENDER_CUTOFF\\nv_depth=gl_Position.z;\\n#endif\\n}'),\n      rasterParticle: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\\n#endif\\n#ifdef FOG\\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\\n#endif\\nglFragColor=vec4(out_color*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n#else\\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#endif\\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),\n      rasterParticleDraw: Zo(\"uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}\", '#include \"_prelude_raster_particle.glsl\"\\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),\n      rasterParticleTexture: Zo(\"uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}\", \"in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}\"),\n      rasterParticleUpdate: Zo('#include \"_prelude_raster_particle.glsl\"\\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', \"in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}\"),\n      symbol: Zo('#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\\n#ifdef ICON_TRANSITION\\nuniform float u_icon_transition;\\n#endif\\n#ifdef COLOR_ADJUSTMENT\\nuniform mat4 u_color_adj_mat;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#else\\n#ifdef RENDER_SHADOWS\\nin highp float v_z_offset;\\n#endif\\n#endif\\nin vec2 v_tex_a;\\n#ifdef ICON_TRANSITION\\nin vec2 v_tex_b;\\n#endif\\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nin float is_sdf;in vec2 v_tex_a_icon;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nreturn;}\\n#endif\\n#ifdef RENDER_SDF\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\\n#else\\n#ifdef ICON_TRANSITION\\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\\n#else\\nout_color=texture(u_texture,v_tex_a);\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nout_color=applyLUT(u_lutTexture,out_color);\\n#endif\\n#ifdef COLOR_ADJUSTMENT\\nout_color=u_color_adj_mat*out_color;\\n#endif\\n#endif\\nout_color*=opacity*fade_opacity;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#ifdef TERRAIN\\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#else\\nout_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\\n#endif\\n#endif\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,v_z_offset);\\n#endif\\n#ifdef FEATURE_CUTOUT\\nout_color=apply_feature_cutout(out_color,gl_FragCoord);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\\n#ifdef Z_OFFSET\\nin float a_auto_z_offset;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\\n#endif\\n#ifdef ICON_TRANSITION\\nin vec2 a_texb;\\n#endif\\n#ifdef OCCLUSION_QUERIES\\nin float a_occlusion_query_opacity;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#else\\n#ifdef RENDER_SHADOWS\\nout highp float v_z_offset;\\n#endif\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nout vec2 v_tex_a;\\n#ifdef ICON_TRANSITION\\nout vec2 v_tex_b;\\n#endif\\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nout float is_sdf;out vec2 v_tex_a_icon;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\n#pragma mapbox: define lowp float occlusion_opacity\\n#pragma mapbox: define lowp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\n#pragma mapbox: initialize lowp float occlusion_opacity\\n#pragma mapbox: initialize lowp float z_offset\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\\n#ifdef Z_OFFSET\\ne+=a_auto_z_offset;\\n#endif\\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\\n#else\\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\\n#endif\\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\n#ifdef PROJECTED_POS_ON_VIEWPORT\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\\n#else\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \\n#endif\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\n#ifdef Z_OFFSET\\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\\n#else\\nz+=u_pitch_with_map ? z_offset : 0.0;\\n#endif\\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\\n#ifdef DEPTH_OCCLUSION\\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\\n#endif\\n#ifdef OCCLUSION_QUERIES\\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\\n#endif\\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\\n#else\\n#ifdef ELEVATED_ROADS\\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\\n#else\\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\\n#endif\\n#endif\\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\\n#endif\\n#ifdef ICON_TRANSITION\\nv_tex_b=a_texb/u_texsize;\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\\n#ifdef NORMAL_OFFSET\\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=e;\\n#else\\n#ifdef RENDER_SHADOWS\\nv_z_offset=e;\\n#endif\\n#endif\\n}'),\n      terrainRaster: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image0;in vec2 v_pos0;\\n#ifdef FOG\\nin float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\\n#endif\\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\\n#ifdef LIGHTING_3D_MODE\\nconst vec3 normal=vec3(0.0,0.0,1.0);\\n#ifdef RENDER_SHADOWS\\nfloat cutoffOpacity=1.0;\\n#ifdef RENDER_CUTOFF\\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\\n#endif\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\\n#else\\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\\n#endif\\n#else\\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\\n#endif\\n#endif\\n#else\\ncolor=image_color;\\n#endif\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#else\\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\\n#endif\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\\n#ifdef FOG\\nout float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\\n#endif\\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\nv_fog_pos=fog_position(decodedPos);\\n#else\\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\\n#endif\\n}'),\n      terrainDepth: Zo(\"precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}\", '#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),\n      skybox: Zo('#include \"_prelude_fog.fragment.glsl\"\\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\\n#ifdef FOG\\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\\n#endif\\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', Lo),\n      skyboxGradient: Zo('#include \"_prelude_fog.fragment.glsl\"\\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\\n#ifdef FOG\\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\\n#endif\\ncolor*=u_opacity;glFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', Lo),\n      skyboxCapture: Zo(\"\\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\\n#define MIE_G                   0.76\\n#define DENSITY_HEIGHT_SCALE_R  8000.0\\n#define DENSITY_HEIGHT_SCALE_M  1200.0\\n#define PLANET_RADIUS           6360e3\\n#define ATMOSPHERE_RADIUS       6420e3\\n#define SAMPLE_STEPS            10\\n#define DENSITY_STEPS           4\\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}\", \"in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}\"),\n      globeRaster: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\\n#ifndef FOG\\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\\n#endif\\nvoid main() {vec4 color;\\n#ifdef CUSTOM_ANTIALIASING\\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;\\n#ifdef FLIP_Y\\nuv.y=1.0-uv.y;\\n#endif\\nhighp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\\n#else\\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\\n#endif\\n#else\\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\\n#endif\\n#else\\ncolor=texture(u_image0,v_pos0);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\\n#else\\ncolor=apply_lighting_ground(color);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\\n#ifdef GLOBE_POLES\\nin vec3 a_globe_pos;in vec2 a_uv;\\n#else\\nin vec2 a_pos;\\n#endif\\nout vec2 v_pos0;void main() {\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\\n#else\\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\\n#endif\\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\\n#ifdef GLOBE_POLES\\nvec3 up_vector=globe_derived_up_vector;\\n#else\\nvec3 up_vector=elevationVector(tile_pos);\\n#endif\\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\\n#ifndef GLOBE_POLES\\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\\n#endif\\n#ifdef GLOBE_POLES\\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\\n#else\\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\\n#endif\\ngl_Position=u_proj_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n}'),\n      globeAtmosphere: Zo('#include \"_prelude_fog.fragment.glsl\"\\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_atmosphere_fog_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\\n#ifdef PROJECTION_GLOBE_VIEW\\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\\n#ifdef ALPHA_PASS\\nglFragColor=vec4(0,0,0,0);return;\\n#else\\n#ifdef NATIVE\\nglFragColor=vec4(1,1,1,1);\\n#else\\nglFragColor=vec4(0,0,0,1);\\n#endif\\nreturn;\\n#endif\\n}\\n#endif\\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\\n#ifdef PROJECTION_GLOBE_VIEW\\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\\n#else\\nhorizon_angle=horizon_angle_mercator;\\n#endif\\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_atmosphere_fog_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_atmosphere_fog_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\\n#ifdef ALPHA_PASS\\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\\n#else\\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\\n#endif\\n}', \"in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}\"),\n      model: Zo('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\\n#endif\\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\\nuniform vec4 u_occlusionTextureTransform;\\n#endif\\n#pragma mapbox: define-attribute highp vec3 normal_3f\\n#pragma mapbox: define-attribute highp vec3 color_3f\\n#pragma mapbox: define-attribute highp vec4 color_4f\\n#pragma mapbox: define-attribute highp vec2 uv_2f\\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\\n#pragma mapbox: initialize-attribute highp vec3 color_3f\\n#pragma mapbox: initialize-attribute highp vec4 color_4f\\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\\n#endif\\n#ifdef HAS_TEXTURE_u_baseColorTexture\\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\\n#endif\\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\\nuniform sampler2D u_metallicRoughnessTexture;\\n#endif\\n#ifdef HAS_TEXTURE_u_occlusionTexture\\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\\n#endif\\n#ifdef HAS_TEXTURE_u_normalTexture\\nuniform sampler2D u_normalTexture;\\n#endif\\n#ifdef HAS_TEXTURE_u_emissionTexture\\nuniform sampler2D u_emissionTexture;\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\\n#ifdef DEPTH_D24\\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\\n#else\\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\\n#endif\\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\\n#ifdef DEPTH_D24\\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\\n#else\\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\\n#endif\\nreturn v_depth > depth+0.0005;}\\n#endif\\n#define saturate(_x) clamp(_x,0.,1.)\\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\\n{\\n#ifdef LIGHTING_3D_MODE\\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\\n#ifdef RENDER_SHADOWS\\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\\n#endif\\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\\n#else\\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\\n#endif\\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\\n#ifdef HAS_ATTRIBUTE_a_color_3f\\nalbedo*=vec4(color_3f,1.0);\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\n#else\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nalbedo*=color_4f;\\n#endif\\n#endif\\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\\n#endif\\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\\n#endif\\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\\n#ifdef APPLY_LUT_ON_GPU\\ncolor=applyLUT(u_lutTexture,color);\\n#endif\\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\\n#ifdef HAS_TEXTURE_u_normalTexture\\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;\\n#ifdef FLIP_Y\\nT=-T;B=-B;\\n#endif\\nhighp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\\n#else\\nreturn mat3(1.0);\\n#endif\\n}highp vec3 getNormal(){highp vec3 n;\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\nn=normalize(normal_3f);\\n#else\\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));\\n#ifdef FLIP_Y\\nn=normalize(cross(fdx,fdy));\\n#else\\nn=normalize(cross(fdx,fdy))*-1.0;\\n#endif\\n#endif\\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\\n#endif\\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\\n#endif\\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \\nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\\n#endif\\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\\n{\\n#ifdef LIGHTING_3D_MODE\\nreturn mat.diffuseColor;\\n#else\\nreturn mat.diffuseColor/PI;\\n#endif\\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\\n{vec3 env_light=vec3(0.65,0.65,0.65);\\n#ifdef LIGHTING_3D_MODE\\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\\n#endif\\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\\n#ifdef RENDER_SHADOWS\\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nlighting_factor=NdotL;\\n#endif\\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\\n#if !defined(LIGHTING_3D_MODE)\\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\\n#endif\\ncolor*=intensityFactor;return color;}void main() {\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nif (isOccluded()) {discard;}\\n#endif\\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\\n#ifdef LIGHTING_3D_MODE\\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\\n#endif\\nvec4 finalColor;\\n#ifdef DIFFUSE_SHADED\\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\\n#ifdef HAS_TEXTURE_u_occlusionTexture\\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\\n#endif\\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\\n#else\\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\\n#else\\nvec2 uv=uv_2f;\\n#endif\\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\\n#endif\\nvec4 emissive=u_emissiveFactor;\\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\\n#endif\\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\\n#ifdef APPLY_LUT_ON_GPU\\ncolor_mix=applyLUT(u_lutTexture,color_mix);\\n#endif\\ncolor=mix(color,color_mix,min(1.0,resEmission));\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\\n#endif\\n#endif\\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\\n#endif\\n#ifdef FOG\\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\\n#endif\\n#ifdef RENDER_CUTOFF\\nfinalColor*=v_cutoff_opacity;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nfinalColor=applyCutout(finalColor,v_position_height.w);\\n#endif\\n#ifdef FEATURE_CUTOUT\\nfinalColor=apply_feature_cutout(finalColor,gl_FragCoord);\\n#endif\\nglFragColor=finalColor;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec3 a_pos_3f;\\n#pragma mapbox: define-attribute highp vec3 normal_3f\\n#pragma mapbox: define-attribute highp vec2 uv_2f\\n#pragma mapbox: define-attribute highp vec3 color_3f\\n#pragma mapbox: define-attribute highp vec4 color_4f\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\\n#else\\nuniform highp mat4 u_normal_matrix;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\\n#endif\\nout vec4 v_position_height;out lowp vec4 v_color_mix;\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nout highp float v_depth;\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\\n#endif\\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\\n#pragma mapbox: initialize-attribute highp vec3 color_3f\\n#pragma mapbox: initialize-attribute highp vec4 color_4f\\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\\nhighp mat4 normal_matrix;\\n#ifdef INSTANCED_ARRAYS\\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\\n#else\\nnormal_matrix=u_normal_matrix;\\n#endif\\nvec3 local_pos;mat3 rs;\\n#ifdef MODEL_POSITION_ON_GPU\\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\\n#else\\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\\n#endif\\nv_position_height.w=a_pos_3f.z;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(local_pos);\\n#endif\\n#ifdef RENDER_CUTOFF\\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\\n#endif\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nv_depth=gl_Position.z/gl_Position.w;\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\n#ifdef MODEL_POSITION_ON_GPU\\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\\n#else\\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\\n#endif\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\\n#ifdef NORMAL_OFFSET\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\n#ifdef MODEL_POSITION_ON_GPU\\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\\n#else\\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\\n#endif\\n#endif\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\\n#endif\\n}'),\n      modelDepth: Zo(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", \"in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\\n#ifdef MODEL_POSITION_ON_GPU\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\\n#else\\nuniform highp mat4 u_instance;\\n#endif\\nuniform highp mat4 u_node_matrix;\\n#endif\\nvoid main() {\\n#ifdef MODEL_POSITION_ON_GPU\\nhighp mat4 instance;\\n#ifdef INSTANCED_ARRAYS\\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\\n#else\\ninstance=u_instance;\\n#endif\\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\\n#else\\ngl_Position=u_matrix*vec4(a_pos_3f,1);\\n#endif\\nv_depth=gl_Position.z/gl_Position.w;}\"),\n      stars: Zo(\"in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}\", \"\\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}\"),\n      snowParticle: Zo(\"in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}\", \"\\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \\nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \\nuniform float u_horizontalOscillationRate; \\nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}\"),\n      rainParticle: Zo(\"in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}\", \"\\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \\nuniform float u_velocity; \\nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \\npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}\"),\n      vignette: Zo(\"uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}\", \"in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}\"),\n      occlusion: Zo(\"uniform vec4 u_color;void main() {glFragColor=u_color;}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\\n#ifdef TERRAIN\\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')\n    };\n    function qo(e, t) {\n      const i = e.replace(/\\s*\\/\\/[^\\n]*\\n/g, \"\\n\").split(\"\\n\");\n      for (let e of i) if (e = e.trim(), \"#\" === e[0] && e.includes(\"if\") && !e.includes(\"endif\")) {\n        e = e.replace(\"#\", \"\").replace(/ifdef|ifndef|elif|if/g, \"\").replace(/!|defined|\\(|\\)|\\|\\||&&/g, \"\").replace(/\\s+/g, \" \").trim();\n        const i = e.split(\" \");\n        for (const e of i) t.includes(e) || t.push(e);\n      }\n    }\n    function Zo(e, t) {\n      const i = /#include\\s+\"([^\"]+)\"/g,\n        o = /#pragma mapbox: ([\\w\\-]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n        s = {},\n        r = [],\n        n = [];\n      if (e = e.replace(i, (e, t) => (n.push(t), \"\")), (t = t.replace(i, (e, t) => (r.push(t), \"\"))).includes(\"flat out\")) return void console.error('The usage of \"flat\" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');\n      let a = [...No];\n      qo(e, a), qo(t, a);\n      for (const e of [...r, ...n]) Uo[e] || console.error(\"Undefined include: \".concat(e)), jo[e] || (jo[e] = [], qo(Uo[e], jo[e])), a = [...a, ...jo[e]];\n      return {\n        fragmentSource: e = e.replace(o, (e, t, i, o, r) => (s[r] = !0, \"define\" === t ? \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\nin \").concat(i, \" \").concat(o, \" \").concat(r, \";\\n#else\\nuniform \").concat(i, \" \").concat(o, \" u_\").concat(r, \";\\n#endif\\n\") : \"initialize\" === t ? \"\\n#ifdef HAS_UNIFORM_u_\".concat(r, \"\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = u_\").concat(r, \";\\n#endif\\n\") : \"define-attribute\" === t ? \"\\n#ifdef HAS_ATTRIBUTE_a_\".concat(r, \"\\n    in \").concat(i, \" \").concat(o, \" \").concat(r, \";\\n#endif\\n\") : \"initialize-attribute\" === t ? \"\" : void 0)),\n        vertexSource: t = t.replace(o, (e, t, i, o, r) => {\n          const n = \"float\" === o ? \"vec2\" : o,\n            a = r.match(/color/) ? \"color\" : n;\n          return \"define-attribute-vertex-shader-only\" === t ? \"\\n#ifdef HAS_ATTRIBUTE_a_\".concat(r, \"\\nin \").concat(i, \" \").concat(o, \" a_\").concat(r, \";\\n#endif\\n\") : s[r] ? \"define\" === t ? \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\nuniform lowp float u_\").concat(r, \"_t;\\nin \").concat(i, \" \").concat(n, \" a_\").concat(r, \";\\nout \").concat(i, \" \").concat(o, \" \").concat(r, \";\\n#else\\nuniform \").concat(i, \" \").concat(o, \" u_\").concat(r, \";\\n#endif\\n\") : \"initialize\" === t ? \"vec4\" === a ? \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\n    \").concat(r, \" = a_\").concat(r, \";\\n#else\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = u_\").concat(r, \";\\n#endif\\n\") : \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\n    \").concat(r, \" = unpack_mix_\").concat(a, \"(a_\").concat(r, \", u_\").concat(r, \"_t);\\n#else\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = u_\").concat(r, \";\\n#endif\\n\") : \"define-attribute\" === t ? \"\\n#ifdef HAS_ATTRIBUTE_a_\".concat(r, \"\\n    in \").concat(i, \" \").concat(o, \" a_\").concat(r, \";\\n    out \").concat(i, \" \").concat(o, \" \").concat(r, \";\\n#endif\\n\") : \"initialize-attribute\" === t ? \"\\n#ifdef HAS_ATTRIBUTE_a_\".concat(r, \"\\n    \").concat(r, \" = a_\").concat(r, \";\\n#endif\\n\") : void 0 : \"define\" === t ? \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\nuniform lowp float u_\").concat(r, \"_t;\\nin \").concat(i, \" \").concat(n, \" a_\").concat(r, \";\\n#else\\nuniform \").concat(i, \" \").concat(o, \" u_\").concat(r, \";\\n#endif\\n\") : \"define-instanced\" === t ? \"mat4\" === a ? \"\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_\".concat(r, \"0;\\nin vec4 a_\").concat(r, \"1;\\nin vec4 a_\").concat(r, \"2;\\nin vec4 a_\").concat(r, \"3;\\n#else\\nuniform \").concat(i, \" \").concat(o, \" u_\").concat(r, \";\\n#endif\\n\") : \"\\n#ifdef INSTANCED_ARRAYS\\nin \".concat(i, \" \").concat(n, \" a_\").concat(r, \";\\n#else\\nuniform \").concat(i, \" \").concat(o, \" u_\").concat(r, \";\\n#endif\\n\") : \"initialize-attribute-custom\" === t ? \"\\n#ifdef HAS_ATTRIBUTE_a_\".concat(r, \"\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = a_\").concat(r, \";\\n#endif\\n\") : \"vec4\" === a ? \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = a_\").concat(r, \";\\n#else\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = u_\").concat(r, \";\\n#endif\\n\") : \"\\n#ifndef HAS_UNIFORM_u_\".concat(r, \"\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = unpack_mix_\").concat(a, \"(a_\").concat(r, \", u_\").concat(r, \"_t);\\n#else\\n    \").concat(i, \" \").concat(o, \" \").concat(r, \" = u_\").concat(r, \";\\n#endif\\n\");\n        }),\n        usedDefines: a,\n        vertexIncludes: r,\n        fragmentIncludes: n\n      };\n    }\n    class Wo {\n      constructor() {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;\n      }\n      bind(e, t, i, o, s, r, n, a) {\n        this.context = e;\n        let l = this.boundPaintVertexBuffers.length !== o.length;\n        for (let e = 0; !l && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);\n        let c = this.boundDynamicVertexBuffers.length !== n.length;\n        for (let e = 0; !c && e < n.length; e++) this.boundDynamicVertexBuffers[e] !== n[e] && (c = !0);\n        if (!this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== s || this.boundVertexOffset !== r) this.freshBind(t, i, o, s, r, n, a);else {\n          e.bindVertexArrayOES.set(this.vao);\n          for (const i of n) i && (i.bind(), a && i.instanceCount && i.setVertexAttribDivisor(e.gl, t, a));\n          s && s.dynamicDraw && s.bind();\n        }\n      }\n      freshBind(e, t, i, o, s, r, n) {\n        const a = this.context,\n          l = a.gl;\n        this.vao && this.destroy(), this.vao = a.gl.createVertexArray(), a.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = s, this.boundDynamicVertexBuffers = r, t.enableAttributes(l, e), t.bind(), t.setVertexAttribPointers(l, e, s);\n        for (const t of i) t.enableAttributes(l, e), t.bind(), t.setVertexAttribPointers(l, e, s);\n        for (const t of r) t && (t.enableAttributes(l, e), t.bind(), t.setVertexAttribPointers(l, e, s), n && t.instanceCount && t.setVertexAttribDivisor(l, e, n));\n        o && o.bind();\n      }\n      destroy() {\n        this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);\n      }\n    }\n    function $o(t, i) {\n      const o = Math.pow(2, i.canonical.z),\n        s = i.canonical.y;\n      return [new e.ae(0, s / o).toLngLat().lat, new e.ae(0, (s + 1) / o).toLngLat().lat];\n    }\n    function Xo(t, i, o, s, r, n, a) {\n      const l = t.context,\n        c = l.gl,\n        h = o.hillshadeFBO;\n      if (!h) return;\n      t.prepareDrawTile();\n      const d = t.isTileAffectedByFog(i),\n        u = t.getOrCreateProgram(\"hillshade\", {\n          overrideFog: d\n        });\n      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());\n      const _ = ((t, i, o, s) => {\n        const r = o.paint.get(\"hillshade-shadow-color\"),\n          n = \"none\" === o.paint.get(\"hillshade-shadow-color-use-theme\").constantOr(\"default\"),\n          a = o.paint.get(\"hillshade-highlight-color\"),\n          l = \"none\" === o.paint.get(\"hillshade-highlight-color-use-theme\").constantOr(\"default\"),\n          c = o.paint.get(\"hillshade-accent-color\"),\n          h = \"none\" === o.paint.get(\"hillshade-accent-color-use-theme\").constantOr(\"default\"),\n          d = o.paint.get(\"hillshade-emissive-strength\");\n        let u = e.an(o.paint.get(\"hillshade-illumination-direction\"));\n        if (\"viewport\" === o.paint.get(\"hillshade-illumination-anchor\")) u -= t.transform.angle;else if (t.style && t.style.enable3dLights() && t.style.directionalLight) {\n          const i = t.style.directionalLight.properties.get(\"direction\"),\n            o = e.d3(i.x, i.y, i.z);\n          u = e.an(o[1]);\n        }\n        const _ = !t.options.moving;\n        return {\n          u_matrix: s || t.transform.calculateProjMatrix(i.tileID.toUnwrapped(), _),\n          u_image: 0,\n          u_latrange: $o(0, i.tileID),\n          u_light: [o.paint.get(\"hillshade-exaggeration\"), u],\n          u_shadow: r.toPremultipliedRenderColor(n ? null : o.lut),\n          u_highlight: a.toPremultipliedRenderColor(l ? null : o.lut),\n          u_emissive_strength: d,\n          u_accent: c.toPremultipliedRenderColor(h ? null : o.lut)\n        };\n      })(t, o, s, t.terrain ? i.projMatrix : null);\n      t.uploadCommonUniforms(l, u, i.toUnwrapped());\n      const {\n        tileBoundsBuffer: p,\n        tileBoundsIndexBuffer: f,\n        tileBoundsSegments: m\n      } = t.getTileBoundsBuffers(o);\n      u.draw(t, c.TRIANGLES, r, n, a, Zi.disabled, _, s.id, p, f, m);\n    }\n    function Yo(t, i, o) {\n      if (!i.needsDEMTextureUpload) return;\n      const s = t.context,\n        r = s.gl;\n      s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);\n      const n = o.getPixels();\n      i.demTexture ? i.demTexture.update(n, {\n        premultiply: !1\n      }) : i.demTexture = new e.T(s, n, r.R32F, {\n        premultiply: !1\n      }), i.needsDEMTextureUpload = !1;\n    }\n    function Ko(t, i, o) {\n      const s = t.context,\n        r = s.gl;\n      if (!i.dem) return;\n      const n = i.dem;\n      if (s.activeTexture.set(r.TEXTURE1), Yo(t, i, n), !i.demTexture) return;\n      i.demTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE);\n      const a = n.dim;\n      s.activeTexture.set(r.TEXTURE0);\n      let l = i.hillshadeFBO;\n      if (!l) {\n        const t = new e.T(s, {\n          width: a,\n          height: a,\n          data: null\n        }, r.RGBA8);\n        t.bind(r.LINEAR, r.CLAMP_TO_EDGE), l = i.hillshadeFBO = s.createFramebuffer(a, a, !0, \"renderbuffer\"), l.colorAttachment.set(t.texture);\n      }\n      s.bindFramebuffer.set(l.framebuffer), s.viewport.set([0, 0, a, a]);\n      const {\n          tileBoundsBuffer: c,\n          tileBoundsIndexBuffer: h,\n          tileBoundsSegments: d\n        } = t.getMercatorTileBoundsBuffers(),\n        u = [];\n      t.linearFloatFilteringSupported() && u.push(\"TERRAIN_DEM_FLOAT_FORMAT\"), t.getOrCreateProgram(\"hillshadePrepare\", {\n        defines: u\n      }).draw(t, r.TRIANGLES, ji.disabled, Gi.disabled, Ui.unblended, Zi.disabled, ((t, i) => {\n        const o = i.stride,\n          s = e.bC();\n        return e.cd(s, 0, e.al, -e.al, 0, 0, 1), e.br(s, s, [0, -e.al, 0]), {\n          u_matrix: s,\n          u_image: 1,\n          u_dimension: [o, o],\n          u_zoom: t.overscaledZ\n        };\n      })(i.tileID, n), o.id, c, h, d), i.needsHillshadePrepare = !1;\n    }\n    class Jo {\n      constructor(e) {\n        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n      }\n      get() {\n        return this.current;\n      }\n      set(e) {}\n      getDefault() {\n        return this.default;\n      }\n      setDefault() {\n        this.set(this.default);\n      }\n    }\n    class Qo extends Jo {\n      getDefault() {\n        return e.ao.transparent.toNonPremultipliedRenderColor(null);\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class es extends Jo {\n      getDefault() {\n        return 1;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ts extends Jo {\n      getDefault() {\n        return 0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class is extends Jo {\n      getDefault() {\n        return [!0, !0, !0, !0];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class os extends Jo {\n      getDefault() {\n        return !0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ss extends Jo {\n      getDefault() {\n        return 255;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class rs extends Jo {\n      getDefault() {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }\n      set(e) {\n        const t = this.current;\n        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);\n      }\n    }\n    class ns extends Jo {\n      getDefault() {\n        const e = this.gl;\n        return [e.KEEP, e.KEEP, e.KEEP];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);\n      }\n    }\n    class as extends Jo {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class ls extends Jo {\n      getDefault() {\n        return [0, 1];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n    }\n    class cs extends Jo {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class hs extends Jo {\n      getDefault() {\n        return this.gl.LESS;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ds extends Jo {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;\n      }\n    }\n    class us extends Jo {\n      getDefault() {\n        const e = this.gl;\n        return [e.ONE, e.ZERO, e.ONE, e.ZERO];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class _s extends Jo {\n      getDefault() {\n        return e.ao.transparent.toNonPremultipliedRenderColor(null);\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class ps extends Jo {\n      getDefault() {\n        return this.gl.FUNC_ADD;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);\n      }\n    }\n    class fs extends Jo {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;\n      }\n    }\n    class ms extends Jo {\n      getDefault() {\n        return this.gl.BACK;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class gs extends Jo {\n      getDefault() {\n        return this.gl.CCW;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    let vs = class extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);\n      }\n    };\n    class ys extends Jo {\n      getDefault() {\n        return this.gl.TEXTURE0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class xs extends Jo {\n      getDefault() {\n        const e = this.gl;\n        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class bs extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ws extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ts extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Es extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ss extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        const t = this.gl;\n        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Is extends Jo {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Cs extends Jo {\n      getDefault() {\n        return 4;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Rs extends Jo {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class As extends Jo {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ds extends Jo {\n      constructor(e, t) {\n        super(e), this.context = e, this.parent = t;\n      }\n      getDefault() {\n        return null;\n      }\n    }\n    class Ls extends Ds {\n      setDirty() {\n        this.dirty = !0;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ps extends Ds {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class zs extends Ds {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, this.attachment(), t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class Os extends Ps {\n      attachment() {\n        return this.gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    const Ms = (e, t, i) => ({\n        u_matrix: e,\n        u_image0: 0,\n        u_skirt_height: t,\n        u_ground_shadow_factor: i\n      }),\n      Fs = (e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f) => ({\n        u_proj_matrix: Float32Array.from(e),\n        u_globe_matrix: t,\n        u_normalize_matrix: Float32Array.from(o),\n        u_merc_matrix: i,\n        u_zoom_transition: s,\n        u_merc_center: r,\n        u_image0: 0,\n        u_frustum_tl: n,\n        u_frustum_tr: a,\n        u_frustum_br: l,\n        u_frustum_bl: c,\n        u_globe_pos: h,\n        u_globe_radius: d,\n        u_viewport: u,\n        u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),\n        u_skirt_height: _,\n        u_far_z_cutoff: p\n      });\n    function Bs(e, t) {\n      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;\n    }\n    const ks = new class {\n        constructor() {\n          this.operations = {};\n        }\n        newMorphing(e, t, i, o, s) {\n          if (e in this.operations) {\n            const t = this.operations[e];\n            t.to.tileID.key !== i.tileID.key && (t.queued = i);\n          } else this.operations[e] = {\n            startTime: o,\n            phase: 0,\n            duration: s,\n            from: t,\n            to: i,\n            queued: null\n          };\n        }\n        getMorphValuesForProxy(e) {\n          if (!(e in this.operations)) return null;\n          const t = this.operations[e];\n          return {\n            from: t.from,\n            to: t.to,\n            phase: t.phase\n          };\n        }\n        update(e) {\n          for (const t in this.operations) {\n            const i = this.operations[t];\n            for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {\n              delete this.operations[t];\n              break;\n            }\n          }\n        }\n        _nextOp(e, t) {\n          return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);\n        }\n        _validOp(e) {\n          return e.from.hasData() && e.to.hasData();\n        }\n      }(),\n      Ns = {\n        0: null,\n        1: \"TERRAIN_VERTEX_MORPHING\"\n      };\n    function Us(e, t, i) {\n      if (0 === t) return 0;\n      const o = t < 1 && 514 === i ? .25 / t : 1;\n      return 6 * Math.pow(1.5, 22 - e) * Math.max(t, 1) * o;\n    }\n    function js(e, t) {\n      const i = 1 << e.z;\n      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;\n    }\n    const Vs = e => ({\n      u_matrix: e\n    });\n    function Gs(t, i, o, s, r) {\n      if (r > 0) {\n        const n = e.o.now(),\n          a = (n - t.timeAdded) / r,\n          l = i ? (n - i.timeAdded) / r : -1,\n          c = o.getSource(),\n          h = s.coveringZoomLevel({\n            tileSize: c.tileSize,\n            roundZoom: c.roundZoom\n          }),\n          d = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),\n          u = d && t.refreshedUponExpiration ? 1 : e.aA(d ? a : 1 - l, 0, 1);\n        return i ? {\n          opacity: 1,\n          mix: 1 - u,\n          isFading: a < 1\n        } : {\n          opacity: u,\n          mix: 0,\n          isFading: a < 1\n        };\n      }\n      return {\n        opacity: 1,\n        mix: 0,\n        isFading: !1\n      };\n    }\n    class Hs extends Rt {\n      constructor(e) {\n        const t = lt(\"mock-dem\", {\n          type: \"raster-dem\",\n          maxzoom: e.transform.maxZoom\n        }, e.style.dispatcher, e.style);\n        super(\"mock-dem\", t, !1), t.setEventedParent(this), this._sourceLoaded = !0;\n      }\n      _loadTile(e, t) {\n        e.state = \"loaded\", t(null);\n      }\n    }\n    class qs extends Rt {\n      constructor(e) {\n        const t = lt(\"proxy\", {\n          type: \"geojson\",\n          maxzoom: e.transform.maxZoom\n        }, e.style.dispatcher, e.style);\n        super(\"proxy\", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n      update(e, t, i) {\n        if (e.freezeTileCoverage) return;\n        this.transform = e;\n        const o = e.coveringTiles({\n          tileSize: this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom,\n          reparseOverscaled: this._source.reparseOverscaled\n        }).reduce((t, i) => {\n          if (t[i.key] = \"\", !this._tiles[i.key]) {\n            const t = new Et(i, this._source.tileSize * i.overscaleFactor(), e.tileZoom, void 0, void 0, this._source.worldview);\n            t.state = \"loaded\", this._tiles[i.key] = t;\n          }\n          return t;\n        }, {});\n        for (const e in this._tiles) e in o || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);\n      }\n      freeFBO(e) {\n        const t = this.proxyCachedFBO[e];\n        if (void 0 !== t) {\n          const i = Object.values(t);\n          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];\n        }\n      }\n      deallocRenderCache() {\n        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n    }\n    class Zs extends e.aO {\n      constructor(e, t, i) {\n        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;\n      }\n    }\n    class Ws extends e.dH {\n      constructor(t, i) {\n        super(), this._debugParams = {\n          sortTilesHiZFirst: !0,\n          disableRenderCache: !1\n        }, t.tp.registerParameter(this._debugParams, [\"Terrain\"], \"sortTilesHiZFirst\", {}, () => {\n          this._style.map.triggerRepaint();\n        }), t.tp.registerParameter(this._debugParams, [\"Terrain\"], \"disableRenderCache\", {}, () => {\n          this._style.map.triggerRepaint();\n        }), t.tp.registerButton([\"Terrain\"], \"Invalidate Render Cache\", () => {\n          this.invalidateRenderCache = !0, this._style.map.triggerRepaint();\n        }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};\n        const [o, s, r] = function (t) {\n            const i = new e.bd(),\n              o = new e.b1(),\n              s = 131;\n            i.reserve(17161), o.reserve(33800);\n            const r = e.al / 128,\n              n = e.al + r / 2,\n              a = n + r;\n            for (let t = -r; t < a; t += r) for (let o = -r; o < a; o += r) {\n              const s = o < 0 || o > n || t < 0 || t > n ? 24575 : 0,\n                r = e.aA(Math.round(o), 0, e.al),\n                a = e.aA(Math.round(t), 0, e.al);\n              i.emplaceBack(r + s, a);\n            }\n            const l = (e, t) => {\n              const i = t * s + e;\n              o.emplaceBack(i + 1, i, i + s), o.emplaceBack(i + s, i + s + 1, i + 1);\n            };\n            for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);\n            return [0, 129].forEach(e => {\n              for (let t = 0; t < 130; t++) l(t, e), l(e, t);\n            }), [i, o, 32768];\n          }(),\n          n = t.context;\n        this.gridBuffer = n.createVertexBuffer(o, e.bf.members), this.gridIndexBuffer = n.createIndexBuffer(s), this.gridSegments = e.bg.simpleSegment(0, 0, o.length, s.length), this.gridNoSkirtSegments = e.bg.simpleSegment(0, 0, o.length, r), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new qs(i.map), this.orthoMatrix = e.bC(), e.cd(this.orthoMatrix, \"globe\" === this.painter.transform.projection.name ? .015 : 0, e.al, 0, e.al, 0, 1);\n        const a = n.gl;\n        this._overlapStencilMode = new Gi({\n          func: a.GEQUAL,\n          mask: 255\n        }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Hs(i.map), this._pendingGroundEffectLayers = [];\n      }\n      set style(e) {\n        e.on(\"data\", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on(\"moveend\", () => {\n          this._clearLineLayersFromRenderCache();\n        });\n      }\n      update(t, i, o) {\n        if (t && t.terrain) {\n          this._style !== t && (this.style = t, this._evaluationZoom = void 0);\n          const s = t.terrain.properties,\n            r = 0 === t.terrain.drapeRenderMode,\n            n = t.terrain.isZoomDependent();\n          this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.o.now();\n          const a = t.terrain && t.terrain.scope,\n            l = s.get(\"source\"),\n            c = r ? this._mockSourceCache : t.getSourceCache(l, a);\n          if (!c) return void e.w(\"Couldn't find terrain source \\\"\".concat(l, \"\\\".\"));\n          if (this.sourceCache = c, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = n ? this.calculateExaggeration(i) : s.get(\"exaggeration\"), !i.projection.requiresDraping && n && 0 === this._exaggeration) return void this._disable();\n          this.enabled = !0;\n          const h = () => {\n            this.sourceCache.used && e.w(\"Raster DEM source '\".concat(this.sourceCache.id, \"' is used both for terrain and as layer source.\\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.\"));\n            const t = this.getScaledDemTileSize();\n            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);\n          };\n          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;\n        } else this._disable();\n      }\n      calculateExaggeration(t) {\n        if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t.zoom);\n        const i = this._previousCameraAltitude,\n          o = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;\n        this._previousCameraAltitude = o;\n        const s = null != i ? o - i : Number.MAX_VALUE;\n        if (Math.abs(s) < 2) return this._exaggeration;\n        const r = t.zoom,\n          n = this._style.terrain;\n        if (!this._previousUpdateTimestamp) return n.getExaggeration(r);\n        let a = r - this._previousZoom;\n        const l = this._previousUpdateTimestamp;\n        let c = r;\n        null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(r - c) > .5 && (a = .5 * (r - c + a)), a * s < 0 && (c += a)), this._evaluationZoom = c;\n        const h = n.getExaggeration(c),\n          d = h === n.getExaggeration(Math.max(0, c - .1));\n        if (d && Math.abs(h - this._exaggeration) < .01) return h;\n        let u = Math.min(.1, .00375 * (this._updateTimestamp - l));\n        return (d || h < .1 || Math.abs(a) < 1e-4) && (u = Math.min(.2, 4 * u)), e.ak(this._exaggeration, h, u);\n      }\n      resetTileLookupCache(e) {\n        this._findCoveringTileCache[e] = {};\n      }\n      attenuationRange() {\n        return this._attenuationRange;\n      }\n      getDemUpscale() {\n        return this.proxySourceCache.getSource().tileSize / 128;\n      }\n      getScaledDemTileSize() {\n        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;\n      }\n      _onStyleDataEvent(e) {\n        \"source\" === e.dataType && e.coord ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : \"style\" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);\n      }\n      _disable() {\n        if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e].usedForTerrain = !1;\n      }\n      destroy() {\n        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();\n      }\n      _source() {\n        return this.enabled ? this.sourceCache : null;\n      }\n      isUsingMockSource() {\n        return this.sourceCache === this._mockSourceCache;\n      }\n      exaggeration() {\n        return this.enabled ? this._exaggeration : 0;\n      }\n      get visibleDemTiles() {\n        return this._visibleDemTiles;\n      }\n      get drapeBufferSize() {\n        const e = 2 * this.proxySourceCache.getSource().tileSize;\n        return [e, e];\n      }\n      set useVertexMorphing(e) {\n        this._useVertexMorphing = e;\n      }\n      updateTileBinding(t) {\n        if (!this.enabled) return;\n        this.prevTerrainTileForTile = this.terrainTileForTile;\n        const i = this.proxySourceCache,\n          o = this.painter.transform;\n        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.ae.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);\n        const s = this.proxyCoords = i.getIds().map(e => {\n          const t = i.getTileByID(e).tileID;\n          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;\n        });\n        !function (t, i) {\n          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),\n            s = new e.P(o.x, o.y);\n          t.sort((t, i) => {\n            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;\n            const o = new e.P(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),\n              r = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),\n              n = s.mult(1 << t.canonical.z);\n            return n.x -= .5, n.y -= .5, n.distSqr(o) - n.distSqr(r);\n          });\n        }(s, this.painter);\n        const r = this.proxyToSource || {};\n        this.proxyToSource = {}, s.forEach(e => {\n          this.proxyToSource[e.key] = {};\n        }), this.terrainTileForTile = {};\n        const n = this._style._mergedSourceCaches;\n        for (const e in n) {\n          const i = n[e];\n          if (!i.used) continue;\n          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], r), i.usedForTerrain) continue;\n          const o = t[e];\n          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);\n        }\n        this.proxiedCoords[i.id] = s.map(e => new Zs(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(s), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r), this.renderingToTexture = !1;\n        const a = {};\n        this._visibleDemTiles = [];\n        for (const e of this.proxyCoords) {\n          const t = this.terrainTileForTile[e.key];\n          if (!t) continue;\n          const i = t.tileID.key;\n          i in a || (this._visibleDemTiles.push(t), a[i] = i);\n        }\n      }\n      _assignTerrainTiles(e) {\n        this._initializing || e.forEach(e => {\n          if (this.terrainTileForTile[e.key]) return;\n          const t = this._findTileCoveringTileID(e, this.sourceCache);\n          t && (this.terrainTileForTile[e.key] = t);\n        });\n      }\n      _prepareDEMTextures() {\n        const e = this.painter.context,\n          t = e.gl;\n        for (const i in this.terrainTileForTile) {\n          const o = this.terrainTileForTile[i],\n            s = o.dem;\n          !s || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), Yo(this.painter, o, s));\n        }\n      }\n      _prepareDemTileUniforms(e, t, i, o) {\n        if (!t || null == t.demTexture) return !1;\n        const s = e.tileID.canonical,\n          r = Math.pow(2, t.tileID.canonical.z - s.z),\n          n = o || \"\";\n        return i[\"u_dem_tl\".concat(n)] = [s.x * r % 1, s.y * r % 1], i[\"u_dem_scale\".concat(n)] = r, !0;\n      }\n      get emptyDEMTexture() {\n        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();\n      }\n      _getLoadedAreaMinimum() {\n        if (!this.enabled) return 0;\n        let e = 0;\n        const t = this._visibleDemTiles.reduce((t, i) => {\n          if (!i.dem) return t;\n          const o = i.dem.tree.minimums[0];\n          return o > 0 && e++, t + o;\n        }, 0);\n        return e ? t / e : 0;\n      }\n      _updateEmptyDEMTexture() {\n        const t = this.painter.context,\n          i = t.gl;\n        t.activeTexture.set(i.TEXTURE2);\n        const o = this._getLoadedAreaMinimum(),\n          s = new e.dI({\n            width: 1,\n            height: 1\n          }, new Float32Array([o]));\n        this._emptyDEMTextureDirty = !1;\n        let r = this._emptyDEMTexture;\n        return r ? r.update(s, {\n          premultiply: !1\n        }) : r = this._emptyDEMTexture = new e.T(t, s, i.R32F, {\n          premultiply: !1\n        }), r;\n      }\n      setupElevationDraw(t, i, o) {\n        const s = this.painter.context,\n          r = s.gl,\n          n = {\n            u_dem: 2,\n            u_dem_prev: 4,\n            u_dem_tl: [0, 0],\n            u_dem_tl_prev: [0, 0],\n            u_dem_scale: 0,\n            u_dem_scale_prev: 0,\n            u_dem_size: 0,\n            u_dem_lerp: 1,\n            u_depth: 3,\n            u_depth_size_inv: [0, 0],\n            u_depth_range_unpack: [0, 1],\n            u_occluder_half_size: 16,\n            u_occlusion_depth_offset: -1e-4,\n            u_exaggeration: 0\n          };\n        n.u_exaggeration = this.exaggeration();\n        let a = null,\n          l = null,\n          c = 1;\n        if (o && o.morphing && this._useVertexMorphing) {\n          const e = o.morphing.srcDemTile,\n            i = o.morphing.dstDemTile;\n          c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, n, \"_prev\") && (l = e), this._prepareDemTileUniforms(t, i, n) && (a = i));\n        }\n        const h = e => e && e.demTexture && this.painter.linearFloatFilteringSupported() ? r.LINEAR : r.NEAREST;\n        let d = null;\n        var u;\n        if (this.enabled ? l && a ? (d = a.demTexture, s.activeTexture.set(r.TEXTURE4), l.demTexture.bind(h(l), r.CLAMP_TO_EDGE), n.u_dem_lerp = c) : (a = this.terrainTileForTile[t.tileID.key], d = this._prepareDemTileUniforms(t, a, n) ? a.demTexture : this.emptyDEMTexture) : d = this.emptyDEMTexture, s.activeTexture.set(r.TEXTURE2), d && (n.u_dem_size = 1 === (u = d).size[0] ? 1 : u.size[0] - 2, d.bind(h(a), r.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o && o.useDepthForOcclusion, i, n), o && o.useMeterToDem && a) {\n          const t = (1 << a.tileID.canonical.z) * e.ce(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;\n          n.u_meter_to_dem = t;\n        }\n        if (o && o.labelPlaneMatrixInv && (n.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(s, n), \"globe\" === this.painter.transform.projection.name) {\n          const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);\n          i.setGlobeUniformValues(s, e);\n        }\n      }\n      globeUniformValues(t, i, o) {\n        const s = t.projection;\n        return {\n          u_tile_tl_up: s.upVector(i, 0, 0),\n          u_tile_tr_up: s.upVector(i, e.al, 0),\n          u_tile_br_up: s.upVector(i, e.al, e.al),\n          u_tile_bl_up: s.upVector(i, 0, e.al),\n          u_tile_up_scale: o ? e.dJ(1) : s.upVectorScale(i, t.center.lat, t.worldSize).metersToTile\n        };\n      }\n      renderToBackBuffer(t) {\n        const i = this.painter,\n          o = this.painter.context;\n        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, i, o, s, r) {\n          if (\"globe\" === t.transform.projection.name) !function (t, i, o, s, r) {\n            const n = t.context,\n              a = n.gl;\n            let l, c;\n            const h = t.transform,\n              d = e.dA(t, n, h),\n              u = (e, i) => {\n                if (c === i) return;\n                const o = [Ns[i], \"PROJECTION_GLOBE_VIEW\"];\n                d && o.push(\"CUSTOM_ANTIALIASING\");\n                const s = t.isTileAffectedByFog(e);\n                l = t.getOrCreateProgram(\"globeRaster\", {\n                  defines: o,\n                  overrideFog: s\n                }), c = i;\n              },\n              _ = t.colorModeForRenderPass(),\n              p = new ji(a.LEQUAL, ji.ReadWrite, t.depthRangeFor3D);\n            ks.update(r);\n            const f = e.dB(h),\n              m = [e.aF(h.center.lng), e.aJ(h.center.lat)],\n              g = t.globeSharedBuffers,\n              v = [h.width * e.o.devicePixelRatio, h.height * e.o.devicePixelRatio],\n              y = Float32Array.from(h.globeMatrix),\n              x = {\n                useDenormalizedUpVectorScale: !0\n              };\n            {\n              const h = t.transform,\n                d = Us(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);\n              c = -1;\n              const b = a.TRIANGLES;\n              for (const c of s) {\n                const s = o.getTile(c),\n                  w = Gi.disabled,\n                  T = i.prevTerrainTileForTile[c.key],\n                  E = i.terrainTileForTile[c.key];\n                Bs(T, E) && ks.newMorphing(c.key, T, E, r, 250), n.activeTexture.set(a.TEXTURE0), s.texture && s.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const S = ks.getMorphValuesForProxy(c.key),\n                  I = S ? 1 : 0;\n                S && Object.assign(x, {\n                  morphing: {\n                    srcDemTile: S.from,\n                    dstDemTile: S.to,\n                    phase: e.dz(S.phase)\n                  }\n                });\n                const C = e.dC(c.canonical),\n                  R = e.dD(C.getCenter().lat),\n                  A = e.dE(c.canonical, C, R, h.worldSize / h._pixelsPerMercatorPixel),\n                  D = e.bk(e.dF(c.canonical)),\n                  L = Fs(h.expandedFarZProjMatrix, y, f, D, e.aj(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, d, h._farZ, A);\n                if (u(c, I), l && (i.setupElevationDraw(s, l, x), t.uploadCommonUniforms(n, l, c.toUnwrapped()), g)) {\n                  const [e, i, o] = g.getGridBuffers(R, 0 !== d);\n                  l.draw(t, b, p, w, _, Zi.backCCW, L, \"globe_raster\", e, i, o);\n                }\n              }\n            }\n            if (g && (t.renderDefaultNorthPole || t.renderDefaultSouthPole)) {\n              const r = [\"GLOBE_POLES\", \"PROJECTION_GLOBE_VIEW\"];\n              d && r.push(\"CUSTOM_ANTIALIASING\"), l = t.getOrCreateProgram(\"globeRaster\", {\n                defines: r\n              });\n              for (const r of s) {\n                const {\n                    x: s,\n                    y: c,\n                    z: d\n                  } = r.canonical,\n                  u = 0 === c,\n                  f = c === (1 << d) - 1,\n                  [y, b, w, T] = g.getPoleBuffers(d, !1);\n                if (T && (u || f)) {\n                  const c = o.getTile(r);\n                  n.activeTexture.set(a.TEXTURE0), c.texture && c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                  let g = e.dG(d, s, h);\n                  const E = e.bk(e.dF(r.canonical)),\n                    S = (e, i) => e.draw(t, a.TRIANGLES, p, Gi.disabled, _, Zi.disabled, Fs(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ), \"globe_pole_raster\", i, w, T);\n                  i.setupElevationDraw(c, l, x), t.uploadCommonUniforms(n, l, r.toUnwrapped()), u && t.renderDefaultNorthPole && S(l, y), f && t.renderDefaultSouthPole && (g = e.cR(e.bC(), g, [1, -1, 1]), S(l, b));\n                }\n              }\n            }\n          }(t, i, o, s, r);else {\n            const n = t.context,\n              a = n.gl;\n            let l, c;\n            const h = t.shadowRenderer,\n              d = io(t, t.longestCutoffRange),\n              u = e => {\n                if (c === e) return;\n                const i = [];\n                i.push(Ns[e]), d.shouldRenderCutoff && i.push(\"RENDER_CUTOFF\"), h && (i.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), h.useNormalOffset && i.push(\"NORMAL_OFFSET\")), l = t.getOrCreateProgram(\"terrainRaster\", {\n                  defines: i\n                }), c = e;\n              },\n              _ = t.colorModeForRenderPass(),\n              p = new ji(a.LEQUAL, ji.ReadWrite, t.depthRangeFor3D);\n            ks.update(r);\n            const f = t.transform,\n              m = Us(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);\n            let g = [0, 0, 0];\n            if (h) {\n              const e = t.style.directionalLight,\n                i = t.style.ambientLight;\n              e && i && (g = co(t.style, e, i));\n            }\n            {\n              c = -1;\n              const v = a.TRIANGLES,\n                [y, x] = [i.gridIndexBuffer, i.gridSegments];\n              for (const c of s) {\n                const s = o.getTile(c),\n                  b = Gi.disabled,\n                  w = i.prevTerrainTileForTile[c.key],\n                  T = i.terrainTileForTile[c.key];\n                Bs(w, T) && ks.newMorphing(c.key, w, T, r, 250), n.activeTexture.set(a.TEXTURE0), s.texture && s.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const E = ks.getMorphValuesForProxy(c.key),\n                  S = E ? 1 : 0;\n                let I;\n                E && (I = {\n                  morphing: {\n                    srcDemTile: E.from,\n                    dstDemTile: E.to,\n                    phase: e.dz(E.phase)\n                  }\n                });\n                const C = Ms(c.projMatrix, js(c.canonical, f.renderWorldCopies) ? m / 10 : m, g);\n                if (u(S), !l) continue;\n                i.setupElevationDraw(s, l, I);\n                const R = c.toUnwrapped();\n                h && h.setupShadows(R, l), t.uploadCommonUniforms(n, l, R, null, d), l.draw(t, v, p, b, _, Zi.backCCW, C, \"terrain_raster\", i.gridBuffer, y, x);\n              }\n            }\n          }\n        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));\n      }\n      renderBatch(t) {\n        if (0 === this._drapedRenderBatches.length) return t + 1;\n        this.renderingToTexture = !0;\n        const i = this.painter,\n          o = this.painter.context,\n          s = this.proxySourceCache,\n          r = this.proxiedCoords[s.id],\n          n = this._drapedRenderBatches.shift(),\n          a = i.style.order,\n          l = [];\n        let c = 0;\n        for (const h of r) {\n          const r = s.getTileByID(h.proxyTileKey),\n            d = s.proxyCachedFBO[h.key] ? s.proxyCachedFBO[h.key][t] : void 0,\n            u = void 0 !== d ? s.renderCache[d] : this.pool[c++],\n            _ = void 0 !== d;\n          if (r.texture = u.tex, _ && !u.dirty) {\n            l.push(r.tileID);\n            continue;\n          }\n          let p;\n          o.bindFramebuffer.set(u.fb.framebuffer), this.renderedToTile = !1, u.dirty && (o.clear({\n            color: e.ao.transparent,\n            stencil: 0\n          }), u.dirty = !1);\n          for (let e = n.start; e <= n.end; ++e) {\n            const t = i.style._mergedLayers[a[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const s = i.style.getLayerSourceCache(t),\n              r = s ? this.proxyToSource[h.key][s.id] : [h];\n            if (!r) continue;\n            const n = r;\n            o.viewport.set([0, 0, u.fb.width, u.fb.height]), p !== (s ? s.id : null) && (this._setupStencil(u, r, t, s), p = s ? s.id : null), i.renderLayer(i, s, t, n);\n          }\n          if (0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers) {\n            const t = i.style._mergedLayers[a[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const s = i.style.getLayerSourceCache(t),\n              r = s ? this.proxyToSource[h.key][s.id] : [h];\n            if (!r) continue;\n            const n = r;\n            o.viewport.set([0, 0, u.fb.width, u.fb.height]), p !== (s ? s.id : null) && (this._setupStencil(u, r, t, s), p = s ? s.id : null), i.renderLayer(i, s, t, n);\n          }\n          this.renderedToTile ? (u.dirty = !0, l.push(r.tileID)) : _ || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));\n        }\n        return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), n.end + 1;\n      }\n      postRender() {}\n      isLayerOrderingCorrect(e) {\n        const t = e.order.length;\n        let i = -1,\n          o = t;\n        for (let s = 0; s < t; ++s) this._style.isLayerDraped(e._mergedLayers[e.order[s]]) ? i = Math.max(i, s) : o = Math.min(o, s);\n        return o > i;\n      }\n      getMinElevationBelowMSL() {\n        let e = 0;\n        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {\n          e = Math.min(e, t.dem.tree.minimums[0]);\n        }), 0 === e ? e : (e - 30) * this._exaggeration;\n      }\n      raycast(e, t, i) {\n        if (!this._visibleDemTiles) return null;\n        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {\n          const s = o.tileID,\n            r = 1 << s.overscaledZ,\n            {\n              x: n,\n              y: a\n            } = s.canonical,\n            l = n / r,\n            c = (n + 1) / r,\n            h = a / r,\n            d = (a + 1) / r;\n          return {\n            minx: l,\n            miny: h,\n            maxx: c,\n            maxy: d,\n            t: o.dem.tree.raycastRoot(l, h, c, d, e, t, i),\n            tile: o\n          };\n        });\n        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));\n        for (const s of o) {\n          if (null == s.t) return null;\n          const o = s.tile.dem.tree.raycast(s.minx, s.miny, s.maxx, s.maxy, e, t, i);\n          if (null != o) return o;\n        }\n        return null;\n      }\n      _createFBO() {\n        const t = this.painter.context,\n          i = t.gl,\n          o = this.drapeBufferSize;\n        t.activeTexture.set(i.TEXTURE0);\n        const s = new e.T(t, {\n          width: o[0],\n          height: o[1],\n          data: null\n        }, i.RGBA8);\n        s.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n        const r = t.createFramebuffer(o[0], o[1], !0, null);\n        return r.colorAttachment.set(s.texture), r.depthAttachment = new Os(t, r.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, r.depthAttachment.set(this._sharedDepthStencil), t.clear({\n          stencil: 0\n        })) : r.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {\n          fb: r,\n          tex: s,\n          dirty: !1\n        };\n      }\n      _initFBOPool() {\n        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());\n      }\n      _shouldDisableRenderCache() {\n        if (this._debugParams.disableRenderCache) return !0;\n        if (this._style.hasLightTransitions()) return !0;\n        for (const e in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e].hasTransition()) return !0;\n        return this._style.order.some(e => {\n          const t = this._style._mergedLayers[e],\n            i = t.isHidden(this.painter.transform.zoom);\n          return \"hillshade\" === t.type || \"custom\" === t.type ? !i && t.shouldRedrape() : !i && t.hasTransition();\n        });\n      }\n      _clearLineLayersFromRenderCache() {\n        let t = !1;\n        for (const e of this._style.getSources()) if (e instanceof ot) {\n          t = !0;\n          break;\n        }\n        if (!t) return;\n        const i = {};\n        for (let t = 0; t < this._style.order.length; ++t) {\n          const o = this._style._mergedLayers[this._style.order[t]],\n            s = this._style.getLayerSourceCache(o);\n          if (s && !i[s.id] && !o.isHidden(this.painter.transform.zoom) && \"line\" === o.type && o.widthExpression() instanceof e.ad) {\n            i[s.id] = !0;\n            for (const e of this.proxyCoords) {\n              const t = this.proxyToSource[e.key][s.id];\n              if (t) for (const e of t) this._clearRenderCacheForTile(s.id, e);\n            }\n          }\n        }\n      }\n      _clearRasterLayersFromRenderCache() {\n        let e = !1;\n        for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t]._source instanceof st) {\n          e = !0;\n          break;\n        }\n        if (!e) return;\n        const t = {};\n        for (let e = 0; e < this._style.order.length; ++e) {\n          const i = this._style._mergedLayers[this._style.order[e]],\n            o = this._style.getLayerSourceCache(i);\n          if (!o || t[o.id]) continue;\n          if (i.isHidden(this.painter.transform.zoom) || \"raster\" !== i.type) continue;\n          const s = i.paint.get(\"raster-fade-duration\");\n          for (const e of this.proxyCoords) {\n            const t = this.proxyToSource[e.key][o.id];\n            if (t) for (const e of t) {\n              const t = Gs(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, s);\n              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);\n            }\n          }\n        }\n      }\n      _setupDrapedRenderBatches() {\n        this._style.updateDrapeFirstLayers();\n        const t = this._style.order,\n          i = t.length;\n        if (0 === i) return;\n        const o = [];\n        this._pendingGroundEffectLayers = [];\n        let s,\n          r = 0,\n          n = this._style._mergedLayers[t[r]];\n        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < i;) n = this._style._mergedLayers[t[r]];\n        for (; r < i; ++r) {\n          const e = this._style._mergedLayers[t[r]];\n          e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === s && (s = r) : (\"fill-extrusion\" === e.type && this._pendingGroundEffectLayers.push(r), void 0 !== s && (o.push({\n            start: s,\n            end: r - 1\n          }), s = void 0)));\n        }\n        if (void 0 !== s && o.push({\n          start: s,\n          end: r - 1\n        }), 0 !== o.length) {\n          const t = o[o.length - 1];\n          this._pendingGroundEffectLayers.every(e => e > t.end) || e.w(\"fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.\");\n        }\n        this._drapedRenderBatches = o;\n      }\n      _setupRenderCache(e) {\n        const t = this.proxySourceCache;\n        if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {\n          if (this.invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {\n            const e = Object.values(t.proxyCachedFBO);\n            t.proxyCachedFBO = {};\n            for (let i = 0; i < e.length; ++i) {\n              const o = Object.values(e[i]);\n              t.renderCachePool.push(...o);\n            }\n          }\n          return;\n        }\n        this._clearRasterLayersFromRenderCache();\n        const i = this.proxyCoords,\n          o = this._tilesDirty;\n        for (let s = i.length - 1; s >= 0; s--) {\n          const r = i[s];\n          if (t.getTileByID(r.key), void 0 !== t.proxyCachedFBO[r.key]) {\n            const i = e[r.key],\n              s = this.proxyToSource[r.key];\n            let n = 0;\n            for (const e in s) {\n              const t = s[e],\n                r = i[e];\n              if (!r || r.length !== t.length || t.some((t, i) => t !== r[i] || o[e] && o[e].hasOwnProperty(t.key))) {\n                n = -1;\n                break;\n              }\n              ++n;\n            }\n            for (const e in t.proxyCachedFBO[r.key]) t.renderCache[t.proxyCachedFBO[r.key][e]].dirty = n < 0 || n !== Object.values(i).length;\n          }\n        }\n        const s = [...this._drapedRenderBatches];\n        s.sort((e, t) => t.end - t.start - (e.end - e.start));\n        for (const e of s) for (const o of i) {\n          if (t.proxyCachedFBO[o.key]) continue;\n          let i = t.renderCachePool.pop();\n          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);\n        }\n        this._tilesDirty = {};\n      }\n      _setupStencil(e, t, i, o) {\n        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));\n        const s = this.painter.context,\n          r = s.gl;\n        if (t.length <= 1) return void (this._overlapStencilType = !1);\n        let n;\n        if (i.isTileClipped()) n = t.length, this._overlapStencilMode.test = {\n          func: r.EQUAL,\n          mask: 255\n        }, this._overlapStencilType = \"Clip\";else {\n          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);\n          n = 1, this._overlapStencilMode.test = {\n            func: r.GREATER,\n            mask: 255\n          }, this._overlapStencilType = \"Mask\";\n        }\n        this._stencilRef + n > 255 && (s.clear({\n          stencil: 0\n        }), this._stencilRef = 0), this._stencilRef += n, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);\n      }\n      clipOrMaskOverlapStencilType() {\n        return \"Clip\" === this._overlapStencilType || \"Mask\" === this._overlapStencilType;\n      }\n      stencilModeForRTTOverlap(e) {\n        return this.renderingToTexture && this._overlapStencilType ? (\"Clip\" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]), this._overlapStencilMode) : Gi.disabled;\n      }\n      _renderTileClippingMasks(e, t) {\n        const i = this.painter,\n          o = this.painter.context,\n          s = o.gl;\n        i._tileClippingMaskIDs = {}, o.setColorMode(Ui.disabled), o.setDepthMode(ji.disabled);\n        const r = i.getOrCreateProgram(\"clippingMask\");\n        for (const o of e) {\n          const e = i._tileClippingMaskIDs[o.key] = --t;\n          r.draw(i, s.TRIANGLES, ji.disabled, new Gi({\n            func: s.ALWAYS,\n            mask: 0\n          }, e, 255, s.KEEP, s.KEEP, s.REPLACE), Ui.disabled, Zi.disabled, Vs(o.projMatrix), \"$clipping\", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments);\n        }\n      }\n      pointCoordinate(t) {\n        const i = this.painter.transform;\n        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;\n        const o = [t.x, t.y, 1, 1];\n        e.aC(o, o, i.pixelMatrixInverse), e.cJ(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;\n        const s = i._camera.position,\n          r = e.ce(1, i.center.lat),\n          n = [s[0], s[1], s[2] / r, 0],\n          a = e.d9([], o.slice(0, 3), n);\n        e.aw(a, a);\n        const l = this.raycast(n, a, this._exaggeration);\n        return null !== l && l ? (e.bH(n, n, a, l), n[3] = n[2], n[2] *= r, n) : null;\n      }\n      _setupProxiedCoordsForOrtho(t, i, o) {\n        if (t.getSource() instanceof e.aS) return this._setupProxiedCoordsForImageSource(t, i, o);\n        this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};\n        const s = this.proxiedCoords[t.id] = [],\n          r = this.proxyCoords;\n        for (let e = 0; e < r.length; e++) {\n          const i = r[e],\n            n = this._findTileCoveringTileID(i, t);\n          if (n) {\n            const e = this._createProxiedId(i, n, o[i.key] && o[i.key][t.id]);\n            s.push(e), this.proxyToSource[i.key][t.id] = [e];\n          }\n        }\n        let n = !1;\n        const a = new Set();\n        for (let e = 0; e < i.length; e++) {\n          const r = t.getTile(i[e]);\n          if (!r || !r.hasData()) continue;\n          const l = this._findTileCoveringTileID(r.tileID, this.proxySourceCache);\n          if (l && l.tileID.canonical.z !== r.tileID.canonical.z) {\n            const e = this.proxyToSource[l.tileID.key][t.id],\n              i = this._createProxiedId(l.tileID, r, o[l.tileID.key] && o[l.tileID.key][t.id]);\n            e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t.id] = [i];\n            const c = this.proxyToSource[l.tileID.key][t.id];\n            a.has(c) || a.add(c), s.push(i), n = !0;\n          }\n        }\n        if (this._sourceTilesOverlap[t.id] = n, n && this._debugParams.sortTilesHiZFirst) for (const e of a) e.sort((e, t) => t.overscaledZ - e.overscaledZ);\n      }\n      _setupProxiedCoordsForImageSource(t, i, o) {\n        if (!t.getSource().loaded()) return;\n        const s = this.proxiedCoords[t.id] = [],\n          r = this.proxyCoords,\n          n = t.getSource(),\n          a = n.tileID;\n        if (!a) return;\n        const l = new e.P(a.x, a.y)._div(1 << a.z),\n          c = n.coordinates.map(e.ae.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - l.x), e.min.y = Math.min(e.min.y, t.y - l.y), e.max.x = Math.max(e.max.x, t.x - l.x), e.max.y = Math.max(e.max.y, t.y - l.y), e), {\n            min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)\n          }),\n          h = (t, i) => {\n            const o = t.wrap + t.canonical.x / (1 << t.canonical.z),\n              s = t.canonical.y / (1 << t.canonical.z),\n              r = e.al / (1 << t.canonical.z),\n              n = i.wrap + i.canonical.x / (1 << i.canonical.z),\n              a = i.canonical.y / (1 << i.canonical.z);\n            return o + r < n + c.min.x || o > n + c.max.x || s + r < a + c.min.y || s > a + c.max.y;\n          };\n        for (let e = 0; e < r.length; e++) {\n          const n = r[e];\n          for (let e = 0; e < i.length; e++) {\n            const r = t.getTile(i[e]);\n            if (!r || !r.hasData()) continue;\n            if (h(n, r.tileID)) continue;\n            const a = this._createProxiedId(n, r, o[n.key] && o[n.key][t.id]),\n              l = this.proxyToSource[n.key][t.id];\n            l ? l.push(a) : this.proxyToSource[n.key][t.id] = [a], s.push(a);\n          }\n        }\n      }\n      _createProxiedId(t, i, o) {\n        let s = this.orthoMatrix;\n        if (o) {\n          const e = o.find(e => e.key === i.tileID.key);\n          if (e) return e;\n        }\n        if (i.tileID.key !== t.key) {\n          const o = t.canonical.z - i.tileID.canonical.z;\n          let r, n, a;\n          s = e.bC();\n          const l = i.tileID.wrap - t.wrap << t.overscaledZ;\n          o > 0 ? (r = e.al >> o, n = r * ((i.tileID.canonical.x << o) - t.canonical.x + l), a = r * ((i.tileID.canonical.y << o) - t.canonical.y)) : (r = e.al << -o, n = e.al * (i.tileID.canonical.x - (t.canonical.x + l << -o)), a = e.al * (i.tileID.canonical.y - (t.canonical.y << -o))), e.cd(s, 0, r, 0, r, 0, 1), e.br(s, s, [n, a, 0]);\n        }\n        return new Zs(i.tileID, t.key, s);\n      }\n      _findTileCoveringTileID(t, i) {\n        let o = i.getTile(t);\n        if (o && o.hasData()) return o;\n        const s = this._findCoveringTileCache[i.id],\n          r = s[t.key];\n        if (o = r ? i.getTileByID(r) : null, o && o.hasData() || null === r) return o;\n        let n = o ? o.tileID : t,\n          a = n.overscaledZ;\n        const l = i.getSource().minzoom,\n          c = [];\n        if (!r) {\n          const s = i.getSource().maxzoom;\n          if (t.canonical.z >= s) {\n            const o = t.canonical.z - s;\n            i.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, i.transform.tileZoom), n = new e.aO(a, t.wrap, s, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (a = s, n = new e.aO(a, t.wrap, s, t.canonical.x >> o, t.canonical.y >> o));\n          }\n          n.key !== t.key && (c.push(n.key), o = i.getTile(n));\n        }\n        const h = e => {\n          c.forEach(t => {\n            s[t] = e;\n          }), c.length = 0;\n        };\n        for (a -= 1; a >= l && (!o || !o.hasData()); a--) {\n          o && h(o.tileID.key);\n          const e = n.calculateScaledKey(a);\n          if (o = i.getTileByID(e), o && o.hasData()) break;\n          const t = s[e];\n          if (null === t) break;\n          void 0 === t ? c.push(e) : o = i.getTileByID(t);\n        }\n        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;\n      }\n      findDEMTileFor(e) {\n        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;\n      }\n      prepareDrawTile() {\n        this.renderedToTile = !0;\n      }\n      _clearRenderCacheForTile(e, t) {\n        let i = this._tilesDirty[e];\n        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;\n      }\n    }\n    function $s(t, i, o) {\n      const s = function (t, i, o) {\n          const s = e.bJ(i, t),\n            r = e.bJ(o, [.2126, .7152, .0722]),\n            n = (e, t, i) => (1 - i) * e + i * t,\n            a = n(1 - .3 * Math.min(r, 1), 1, Math.min(s + 1, 1));\n          return n(.92, 1, Math.asin(e.aA(i[2], -1, 1)) / Math.PI + .5) * a;\n        }(t, [0, 0, 1], i),\n        r = [0, 0, 0];\n      e.c4(r, o.slice(0, 3), s);\n      const n = [0, 0, 0];\n      e.c4(n, i.slice(0, 3), t[2]);\n      const a = [0, 0, 0];\n      return e.d7(a, r, n), e.da(a);\n    }\n    const Xs = [\"fill\", \"fillOutline\", \"fillPattern\", \"line\", \"linePattern\", \"background\", \"backgroundPattern\", \"hillshade\", \"raster\"],\n      Ys = [\"stars\", \"rainParticle\", \"snowParticle\", \"fillExtrusion\", \"fillExtrusionGroundEffect\", \"elevatedStructures\", \"model\", \"symbol\"];\n    class Ks {\n      static cacheKey(e, t, i, o) {\n        let s = \"\".concat(t).concat(o ? o.cacheKey : \"\");\n        for (const t of i) e.usedDefines.includes(t) && (s += \"/\".concat(t));\n        return s;\n      }\n      constructor(t, i, o, s, r, n) {\n        const a = t.gl;\n        this.program = a.createProgram(), this.configuration = s, this.name = i, this.fixedDefines = [...n];\n        let l = s ? s.defines() : [];\n        l = l.concat(n.map(e => \"#define \".concat(e)));\n        const c = \"#version 300 es\\n\";\n        let h = c + l.concat(\"precision mediump float;\", Go, Vo.fragmentSource).join(\"\\n\");\n        for (const e of o.fragmentIncludes) h += \"\\n\".concat(Uo[e]);\n        h += \"\\n\".concat(o.fragmentSource);\n        let d = c + l.concat(\"precision highp float;\", Go, Vo.vertexSource).join(\"\\n\");\n        for (const e of o.vertexIncludes) d += \"\\n\".concat(Uo[e]);\n        this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && -1 !== o.vertexSource.indexOf(\"gl_InstanceID\"), this.forceManualRenderingForInstanceIDShaders && (d += \"\\nuniform int u_instanceID;\\n\"), d += \"\\n\".concat(o.vertexSource), this.forceManualRenderingForInstanceIDShaders && (d = d.replaceAll(\"gl_InstanceID\", \"u_instanceID\"));\n        const u = a.createShader(a.FRAGMENT_SHADER);\n        if (a.isContextLost()) return void (this.failedToCreate = !0);\n        a.shaderSource(u, h), a.compileShader(u), a.attachShader(this.program, u);\n        const _ = a.createShader(a.VERTEX_SHADER);\n        a.isContextLost() ? this.failedToCreate = !0 : (a.shaderSource(_, d), a.compileShader(_), a.attachShader(this.program, _), this.attributes = {}, a.linkProgram(this.program), a.deleteShader(_), a.deleteShader(u), this.fixedUniforms = r(t), this.binderUniforms = s ? s.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = (t => ({\n          u_instanceID: new e.cg(t)\n        }))(t)), (n.includes(\"TERRAIN\") || -1 !== i.indexOf(\"symbol\") || -1 !== i.indexOf(\"circle\")) && (this.terrainUniforms = (t => ({\n          u_dem: new e.cg(t),\n          u_dem_prev: new e.cg(t),\n          u_dem_tl: new e.cj(t),\n          u_dem_scale: new e.ci(t),\n          u_dem_tl_prev: new e.cj(t),\n          u_dem_scale_prev: new e.ci(t),\n          u_dem_size: new e.ci(t),\n          u_dem_lerp: new e.ci(t),\n          u_exaggeration: new e.ci(t),\n          u_depth: new e.cg(t),\n          u_depth_size_inv: new e.cj(t),\n          u_depth_range_unpack: new e.cj(t),\n          u_occluder_half_size: new e.ci(t),\n          u_occlusion_depth_offset: new e.ci(t),\n          u_meter_to_dem: new e.ci(t),\n          u_label_plane_matrix_inv: new e.ck(t)\n        }))(t)), n.includes(\"GLOBE\") && (this.globeUniforms = (t => ({\n          u_tile_tl_up: new e.ch(t),\n          u_tile_tr_up: new e.ch(t),\n          u_tile_br_up: new e.ch(t),\n          u_tile_bl_up: new e.ch(t),\n          u_tile_up_scale: new e.ci(t)\n        }))(t)), n.includes(\"FOG\") && (this.fogUniforms = (t => ({\n          u_fog_matrix: new e.ck(t),\n          u_fog_range: new e.cj(t),\n          u_fog_color: new e.d2(t),\n          u_fog_horizon_blend: new e.ci(t),\n          u_fog_vertical_limit: new e.cj(t),\n          u_fog_temporal_offset: new e.ci(t),\n          u_frustum_tl: new e.ch(t),\n          u_frustum_tr: new e.ch(t),\n          u_frustum_br: new e.ch(t),\n          u_frustum_bl: new e.ch(t),\n          u_globe_pos: new e.ch(t),\n          u_globe_radius: new e.ci(t),\n          u_globe_transition: new e.ci(t),\n          u_is_globe: new e.cg(t),\n          u_viewport: new e.cj(t)\n        }))(t)), n.includes(\"RENDER_CUTOFF\") && (this.cutoffUniforms = (t => ({\n          u_cutoff_params: new e.d2(t)\n        }))(t)), n.includes(\"LIGHTING_3D_MODE\") && (this.lightsUniforms = (t => ({\n          u_lighting_ambient_color: new e.ch(t),\n          u_lighting_directional_dir: new e.ch(t),\n          u_lighting_directional_color: new e.ch(t),\n          u_ground_radiance: new e.ch(t)\n        }))(t)), n.includes(\"RENDER_SHADOWS\") && (this.shadowUniforms = (t => ({\n          u_light_matrix_0: new e.ck(t),\n          u_light_matrix_1: new e.ck(t),\n          u_fade_range: new e.cj(t),\n          u_shadow_normal_offset: new e.ch(t),\n          u_shadow_intensity: new e.ci(t),\n          u_shadow_texel_size: new e.ci(t),\n          u_shadow_map_resolution: new e.ci(t),\n          u_shadow_direction: new e.ch(t),\n          u_shadow_bias: new e.ch(t),\n          u_shadowmap_0: new e.cg(t),\n          u_shadowmap_1: new e.cg(t)\n        }))(t)));\n      }\n      getAttributeLocation(e, t) {\n        let i = this.attributes[t];\n        return void 0 === i && (i = this.attributes[t] = e.getAttribLocation(this.program, t)), i;\n      }\n      setTerrainUniformValues(e, t) {\n        if (!this.terrainUniforms) return;\n        const i = this.terrainUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setGlobeUniformValues(e, t) {\n        if (!this.globeUniforms) return;\n        const i = this.globeUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setFogUniformValues(e, t) {\n        if (!this.fogUniforms) return;\n        const i = this.fogUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setCutoffUniformValues(e, t) {\n        if (!this.cutoffUniforms) return;\n        const i = this.cutoffUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setLightsUniformValues(e, t) {\n        if (!this.lightsUniforms) return;\n        const i = this.lightsUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setShadowUniformValues(e, t) {\n        if (this.failedToCreate || !this.shadowUniforms) return;\n        const i = this.shadowUniforms;\n        e.program.set(this.program);\n        for (const e in t) i[e].set(this.program, e, t[e]);\n      }\n      _drawDebugWireframe(t, i, o, s, r, n, a, l, c, h) {\n        const d = t.options.wireframe;\n        if (!1 === d.terrain && !1 === d.layers2D && !1 === d.layers3D) return;\n        const u = t.context;\n        if (!(() => !(!d.terrain || \"terrainRaster\" !== this.name && \"globeRaster\" !== this.name) || !(!d.layers2D || t._terrain && t._terrain.renderingToTexture || !Xs.includes(this.name)) || !(!d.layers3D || !Ys.includes(this.name)))()) return;\n        const _ = u.gl,\n          p = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, r, u);\n        if (!p) return;\n        const f = [...this.fixedDefines];\n        f.push(\"DEBUG_WIREFRAME\");\n        const m = t.getOrCreateProgram(this.name, {\n          config: this.configuration,\n          defines: f\n        });\n        u.program.set(m.program);\n        const g = (e, t, i) => {\n          if (t[e] && i[e]) for (const o in t[e]) i[e][o] && i[e][o].set(i.program, o, t[e][o].current);\n        };\n        c && c.setUniforms(m.program, u, m.binderUniforms, a, {\n          zoom: l\n        }), g(\"fixedUniforms\", this, m), g(\"terrainUniforms\", this, m), g(\"globeUniforms\", this, m), g(\"fogUniforms\", this, m), g(\"lightsUniforms\", this, m), g(\"shadowUniforms\", this, m), p.bind(), u.setColorMode(new Ui([_.ONE, _.ONE_MINUS_SRC_ALPHA, _.ZERO, _.ONE], e.ao.transparent, [!0, !0, !0, !1])), u.setDepthMode(new ji(i.func === _.LESS ? _.LEQUAL : i.func, ji.ReadOnly, i.range)), u.setStencilMode(Gi.disabled);\n        const v = 3 * n.primitiveLength * 2,\n          y = 3 * n.primitiveOffset * 2 * 2;\n        if (this.forceManualRenderingForInstanceIDShaders) {\n          const e = h || 1;\n          for (let t = 0; t < e; ++t) m.instancingUniforms.u_instanceID.set(this.program, \"u_instanceID\", t), _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);\n        } else h && h > 1 ? _.drawElementsInstanced(_.LINES, v, _.UNSIGNED_SHORT, y, h) : _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);\n        r.bind(), u.program.set(this.program), u.setDepthMode(i), u.setStencilMode(o), u.setColorMode(s);\n      }\n      checkUniforms(e, t, i) {\n        if (this.fixedDefines.includes(t)) for (const o of Object.keys(i)) if (!i[o].initialized) throw new Error(\"Program '\".concat(this.name, \"', from draw '\").concat(e, \"': uniform \").concat(o, \" not set but required by \").concat(t, \" being defined\"));\n      }\n      draw(e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f) {\n        const m = e.context,\n          g = m.gl;\n        if (this.failedToCreate) return;\n        m.program.set(this.program), m.setDepthMode(i), m.setStencilMode(o), m.setColorMode(s), m.setCullFace(r);\n        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(this.program, e, n[e]);\n        _ && _.setUniforms(this.program, m, this.binderUniforms, d, {\n          zoom: u\n        });\n        const v = {\n          [g.POINTS]: 1,\n          [g.LINES]: 2,\n          [g.TRIANGLES]: 3,\n          [g.LINE_STRIP]: 1\n        }[t];\n        this.checkUniforms(a, \"RENDER_SHADOWS\", this.shadowUniforms);\n        const y = f && f > 0 ? 1 : void 0;\n        for (const r of h.get()) {\n          const n = r.vaos || (r.vaos = {});\n          if ((n[a] || (n[a] = new Wo())).bind(m, this, l, _ ? _.getPaintVertexBuffers() : [], c, r.vertexOffset, p || [], y), this.forceManualRenderingForInstanceIDShaders) {\n            const e = f || 1;\n            for (let i = 0; i < e; ++i) this.instancingUniforms.u_instanceID.set(this.program, \"u_instanceID\", i), c ? g.drawElements(t, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t, r.vertexOffset, r.vertexLength);\n          } else f && f > 1 ? g.drawElementsInstanced(t, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2, f) : c ? g.drawElements(t, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t, r.vertexOffset, r.vertexLength);\n          t === g.TRIANGLES && c && this._drawDebugWireframe(e, i, o, s, c, r, d, u, _, f);\n        }\n      }\n    }\n    function Js(t, i) {\n      let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      const s = Math.pow(2, i.tileID.overscaledZ),\n        r = i.tileSize * Math.pow(2, t.transform.tileZoom) / s,\n        n = r * (i.tileID.canonical.x + i.tileID.wrap * s),\n        a = r * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [0, 0],\n        u_tile_units_to_pixels: 1 / e.ay(i, 1, t.transform.tileZoom),\n        u_pixel_coord_upper: [n >> 16, a >> 16],\n        u_pixel_coord_lower: [65535 & n, 65535 & a],\n        u_pattern_transition: o\n      };\n    }\n    const Qs = {\n        terrain: 0,\n        flat: 1\n      },\n      er = e.bC(),\n      tr = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v) => {\n        const y = i.style.light,\n          x = y.properties.get(\"position\"),\n          b = [x.x, x.y, x.z],\n          w = e.dL();\n        \"viewport\" === y.properties.get(\"anchor\") && (e.dM(w, -i.transform.angle), e.dN(b, b, w));\n        const T = y.properties.get(\"color\").toPremultipliedRenderColor(null),\n          E = i.transform,\n          S = {\n            u_matrix: t,\n            u_lightpos: b,\n            u_lightintensity: y.properties.get(\"intensity\"),\n            u_lightcolor: [T.r, T.g, T.b],\n            u_vertical_gradient: +o,\n            u_opacity: s,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: er,\n            u_merc_center: [0, 0],\n            u_up_dir: [0, 0, 0],\n            u_height_lift: 0,\n            u_height_type: Qs[h],\n            u_base_type: Qs[d],\n            u_ao: r,\n            u_edge_radius: n,\n            u_width_scale: a,\n            u_flood_light_color: f,\n            u_vertical_scale: m,\n            u_flood_light_intensity: g,\n            u_ground_shadow_factor: v\n          };\n        return \"globe\" === E.projection.name && (S.u_tile_id = [l.canonical.x, l.canonical.y, 1 << l.canonical.z], S.u_zoom_transition = u, S.u_inv_rot_matrix = p, S.u_merc_center = _, S.u_up_dir = E.projection.upVector(new e.cC(0, 0, 0), _[0] * e.al, _[1] * e.al), S.u_height_lift = c), S;\n      },\n      ir = (e, t, i, o, s, r) => ({\n        u_matrix: e,\n        u_edge_radius: t,\n        u_width_scale: i,\n        u_vertical_scale: o,\n        u_height_type: Qs[s],\n        u_base_type: Qs[r]\n      }),\n      or = (e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g) => {\n        const v = tr(e, t, i, o, s, r, n, a, c, h, d, u, _, p, f, m, 1, [0, 0, 0]),\n          y = {\n            u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8\n          };\n        return Object.assign(v, Js(t, l, g), y);\n      },\n      sr = (e, t, i) => ({\n        u_matrix: e,\n        u_emissive_strength: t,\n        u_ground_shadow_factor: i\n      }),\n      rr = function (e, t, i, o, s) {\n        let r = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n        return Object.assign(sr(e, t, s), Js(i, o, r));\n      },\n      nr = (e, t, i, o) => ({\n        u_matrix: e,\n        u_world: i,\n        u_emissive_strength: t,\n        u_ground_shadow_factor: o\n      }),\n      ar = function (e, t, i, o, s, r) {\n        let n = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n        return Object.assign(rr(e, t, i, o, r, n), {\n          u_world: s\n        });\n      },\n      lr = (e, t) => ({\n        u_matrix: e,\n        u_ground_shadow_factor: t\n      }),\n      cr = (e, t, i, o, s) => ({\n        u_matrix: e,\n        u_camera_pos: [t[0], t[1], t[2]],\n        u_depth_bias: i,\n        u_height_scale: o,\n        u_reset_depth: s\n      }),\n      hr = (e, t, i, o, s, r, n) => ({\n        u_matrix: e,\n        u_normal_matrix: t,\n        u_opacity: i,\n        u_faux_facade_ao_intensity: o,\n        u_camera_pos: s,\n        u_tile_to_meter: r,\n        u_facade_emissive_chance: n\n      }),\n      dr = e => ({\n        u_matrix: e\n      }),\n      ur = e => ({\n        u_matrix: e\n      }),\n      _r = (t, i, o, s, r, n, a, l) => {\n        const c = e.al / n.tileSize;\n        return {\n          u_matrix: t,\n          u_inv_rot_matrix: i,\n          u_camera_to_center_distance: o.getCameraToCenterDistance(l),\n          u_extrude_scale: [o.pixelsToGLUnits[0] / c, o.pixelsToGLUnits[1] / c],\n          u_zoom_transition: s,\n          u_tile_id: a,\n          u_merc_center: r\n        };\n      },\n      pr = function (e, t) {\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        return {\n          u_matrix: e,\n          u_color: t,\n          u_overlay: 0,\n          u_overlay_scale: i\n        };\n      },\n      fr = e.bC(),\n      mr = (t, i, o, s, r, n, a) => {\n        const l = t.transform,\n          c = \"globe\" === l.projection.name,\n          h = c ? e.dO(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.ay(o, 1, n),\n          d = {\n            u_matrix: i.projMatrix,\n            u_extrude_scale: h,\n            u_intensity: a,\n            u_inv_rot_matrix: fr,\n            u_merc_center: [0, 0],\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_up_dir: [0, 0, 0]\n          };\n        if (c) {\n          d.u_inv_rot_matrix = s, d.u_merc_center = r, d.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], d.u_zoom_transition = e.aj(l.zoom);\n          const t = r[0] * e.al,\n            o = r[1] * e.al;\n          d.u_up_dir = l.projection.upVector(new e.cC(0, 0, 0), t, o);\n        }\n        return d;\n      };\n    function gr(e, _ref98, _ref99) {\n      let [t, i, o, s] = _ref98;\n      let [r, n] = _ref99;\n      if (r === n) return [0, 0, 0, 0];\n      const a = 255 * (e - 1) / (e * (n - r));\n      return [t * a, i * a, o * a, s * a];\n    }\n    function vr(e, t, _ref100) {\n      let [i, o] = _ref100;\n      return i === o ? 0 : .5 / e + (t - i) * (e - 1) / (e * (o - i));\n    }\n    const yr = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b) => ({\n      u_matrix: t,\n      u_normalize_matrix: i,\n      u_globe_matrix: o,\n      u_merc_matrix: s,\n      u_grid_matrix: r,\n      u_tl_parent: n,\n      u_scale_parent: h,\n      u_fade_t: d.mix,\n      u_opacity: d.opacity * u.paint.get(\"raster-opacity\"),\n      u_image0: 0,\n      u_image1: 1,\n      u_brightness_low: u.paint.get(\"raster-brightness-min\"),\n      u_brightness_high: u.paint.get(\"raster-brightness-max\"),\n      u_saturation_factor: e.dQ(u.paint.get(\"raster-saturation\")),\n      u_contrast_factor: e.dP(u.paint.get(\"raster-contrast\")),\n      u_spin_weights: xr(u.paint.get(\"raster-hue-rotate\")),\n      u_perspective_transform: _,\n      u_raster_elevation: p,\n      u_zoom_transition: a,\n      u_merc_center: l,\n      u_cutoff_params: c,\n      u_colorization_mix: gr(e.dR, m, v),\n      u_colorization_offset: vr(e.dR, g, v),\n      u_color_ramp: f,\n      u_texture_offset: [x / (y + 2 * x), y / (y + 2 * x)],\n      u_texture_res: [y + 2 * x, y + 2 * x],\n      u_emissive_strength: b\n    });\n    function xr(e) {\n      e *= Math.PI / 180;\n      const t = Math.sin(e),\n        i = Math.cos(e);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];\n    }\n    const br = .05,\n      wr = (e, t, i, o, s, r, n, a, l, c, h, d) => ({\n        u_matrix: e,\n        u_normalize_matrix: t,\n        u_globe_matrix: i,\n        u_merc_matrix: o,\n        u_grid_matrix: s,\n        u_tl_parent: r,\n        u_scale_parent: c,\n        u_fade_t: h.mix,\n        u_opacity: h.opacity,\n        u_image0: 0,\n        u_image1: 1,\n        u_raster_elevation: d,\n        u_zoom_transition: n,\n        u_merc_center: a,\n        u_cutoff_params: l\n      }),\n      Tr = (e, t, i, o, s, r, n, a, l, c) => ({\n        u_particle_texture: e,\n        u_particle_texture_side_len: t,\n        u_tile_offset: i,\n        u_velocity: o,\n        u_color_ramp: r,\n        u_velocity_res: s,\n        u_max_speed: n,\n        u_uv_offset: a,\n        u_data_scale: [255 * l[0], 255 * l[1]],\n        u_data_offset: c,\n        u_particle_pos_scale: 1.1,\n        u_particle_pos_offset: [br, br]\n      }),\n      Er = (e, t, i, o, s, r, n, a, l, c) => ({\n        u_particle_texture: e,\n        u_particle_texture_side_len: t,\n        u_velocity: i,\n        u_velocity_res: o,\n        u_max_speed: s,\n        u_speed_factor: r,\n        u_reset_rate: n,\n        u_rand_seed: Math.random(),\n        u_uv_offset: a,\n        u_data_scale: [255 * l[0], 255 * l[1]],\n        u_data_offset: c,\n        u_particle_pos_scale: 1.1,\n        u_particle_pos_offset: [br, br]\n      }),\n      Sr = e.bC(),\n      Ir = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b, w, T, E) => {\n        const S = r.transform,\n          I = {\n            u_is_size_zoom_constant: +(\"constant\" === t || \"source\" === t),\n            u_is_size_feature_constant: +(\"constant\" === t || \"camera\" === t),\n            u_size_t: i ? i.uSizeT : 0,\n            u_size: i ? i.uSize : 0,\n            u_camera_to_center_distance: S.getCameraToCenterDistance(y),\n            u_rotate_symbol: +o,\n            u_aspect_ratio: S.width / S.height,\n            u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,\n            u_matrix: n,\n            u_label_plane_matrix: a,\n            u_coord_matrix: l,\n            u_is_text: +h,\n            u_elevation_from_sea: c ? 1 : 0,\n            u_pitch_with_map: +s,\n            u_texsize: d,\n            u_texsize_icon: u,\n            u_texture: 0,\n            u_texture_icon: 1,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: Sr,\n            u_merc_center: [0, 0],\n            u_camera_forward: [0, 0, 0],\n            u_ecef_origin: [0, 0, 0],\n            u_tile_matrix: Sr,\n            u_up_vector: [0, -1, 0],\n            u_color_adj_mat: w,\n            u_icon_transition: T || 0,\n            u_gamma_scale: s ? r.transform.getCameraToCenterDistance(y) * Math.cos(r.terrain ? 0 : r.transform._pitch) : 1,\n            u_device_pixel_ratio: e.o.devicePixelRatio,\n            u_is_halo: 1,\n            u_scale_factor: E || 1,\n            u_ground_shadow_factor: x,\n            u_inv_matrix: e.bl(e.bC(), a),\n            u_normal_scale: b,\n            u_lutTexture: Ji.LUT\n          };\n        return \"globe\" === y.name && (I.u_tile_id = [p.canonical.x, p.canonical.y, 1 << p.canonical.z], I.u_zoom_transition = f, I.u_inv_rot_matrix = g, I.u_merc_center = m, I.u_camera_forward = S._camera.forward(), I.u_ecef_origin = e.dS(S.globeMatrix, p.toUnwrapped()), I.u_tile_matrix = Float32Array.from(S.globeMatrix), I.u_up_vector = v), I;\n      },\n      Cr = (e, t, i, o) => ({\n        u_matrix: e,\n        u_emissive_strength: t,\n        u_opacity: i,\n        u_color: o\n      }),\n      Rr = (t, i, o, s, r, n, a, l, c) => Object.assign(function (t, i, o, s, r, n) {\n        const {\n            width: a,\n            height: l\n          } = s.imageManager.getPixelSize(i),\n          c = Math.pow(2, n.tileID.overscaledZ),\n          h = n.tileSize * Math.pow(2, s.transform.tileZoom) / c,\n          d = h * (n.tileID.canonical.x + n.tileID.wrap * c),\n          u = h * n.tileID.canonical.y;\n        return {\n          u_image: 0,\n          u_pattern_tl: o.tl,\n          u_pattern_br: o.br,\n          u_texsize: [a, l],\n          u_pattern_size: o.displaySize,\n          u_pattern_units_to_pixels: r ? [s.transform.width, -1 * s.transform.height] : [1 / e.ay(n, 1, s.transform.tileZoom), 1 / e.ay(n, 1, s.transform.tileZoom)],\n          u_pixel_coord_upper: [d >> 16, u >> 16],\n          u_pixel_coord_lower: [65535 & d, 65535 & u]\n        };\n      }(0, n, a, s, l, c), {\n        u_matrix: t,\n        u_emissive_strength: i,\n        u_opacity: o\n      }),\n      Ar = new Float32Array(e.bA([])),\n      Dr = function (t, i, o, s, r, n, a, l, c, h, d, u, _) {\n        let p = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : [0, 0, 0];\n        let f = arguments.length > 14 ? arguments[14] : undefined;\n        const m = r.style.light,\n          g = m.properties.get(\"position\"),\n          v = [-g.x, -g.y, g.z],\n          y = e.dL();\n        \"viewport\" === m.properties.get(\"anchor\") && (e.dM(y, -r.transform.angle), e.dN(v, v, y));\n        const x = \"MASK\" === d.alphaMode,\n          b = m.properties.get(\"color\").toNonPremultipliedRenderColor(null),\n          w = _.paint.get(\"model-ambient-occlusion-intensity\"),\n          T = _.paint.get(\"model-color\").constantOr(e.ao.white).toNonPremultipliedRenderColor(null);\n        return T.a = _.paint.get(\"model-color-mix-intensity\").constantOr(0), {\n          u_matrix: t,\n          u_lighting_matrix: i,\n          u_normal_matrix: o,\n          u_node_matrix: s || Ar,\n          u_lightpos: v,\n          u_lightintensity: m.properties.get(\"intensity\"),\n          u_lightcolor: [b.r, b.g, b.b],\n          u_camera_pos: p,\n          u_opacity: n,\n          u_baseTextureIsAlpha: 0,\n          u_alphaMask: +x,\n          u_alphaCutoff: d.alphaCutoff,\n          u_baseColorFactor: a.toNonPremultipliedRenderColor(null).toArray01(),\n          u_emissiveFactor: l.toNonPremultipliedRenderColor(null).toArray01(),\n          u_metallicFactor: c,\n          u_roughnessFactor: h,\n          u_baseColorTexture: Ji.BaseColor,\n          u_metallicRoughnessTexture: Ji.MetallicRoughness,\n          u_normalTexture: Ji.Normal,\n          u_occlusionTexture: Ji.Occlusion,\n          u_emissionTexture: Ji.Emission,\n          u_lutTexture: Ji.LUT,\n          u_color_mix: T.toArray01(),\n          u_aoIntensity: w,\n          u_emissive_strength: u,\n          u_occlusionTextureTransform: f || [0, 0, 0, 0]\n        };\n      },\n      Lr = function (e) {\n        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Ar;\n        let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Ar;\n        return {\n          u_matrix: e,\n          u_instance: t,\n          u_node_matrix: i\n        };\n      },\n      Pr = {\n        fillExtrusion: t => ({\n          u_matrix: new e.ck(t),\n          u_lightpos: new e.ch(t),\n          u_lightintensity: new e.ci(t),\n          u_lightcolor: new e.ch(t),\n          u_vertical_gradient: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_edge_radius: new e.ci(t),\n          u_width_scale: new e.ci(t),\n          u_ao: new e.cj(t),\n          u_height_type: new e.cg(t),\n          u_base_type: new e.cg(t),\n          u_tile_id: new e.ch(t),\n          u_zoom_transition: new e.ci(t),\n          u_inv_rot_matrix: new e.ck(t),\n          u_merc_center: new e.cj(t),\n          u_up_dir: new e.ch(t),\n          u_height_lift: new e.ci(t),\n          u_flood_light_color: new e.ch(t),\n          u_vertical_scale: new e.ci(t),\n          u_flood_light_intensity: new e.ci(t),\n          u_ground_shadow_factor: new e.ch(t)\n        }),\n        fillExtrusionDepth: t => ({\n          u_matrix: new e.ck(t),\n          u_edge_radius: new e.ci(t),\n          u_width_scale: new e.ci(t),\n          u_vertical_scale: new e.ci(t),\n          u_height_type: new e.cg(t),\n          u_base_type: new e.cg(t)\n        }),\n        fillExtrusionPattern: t => ({\n          u_matrix: new e.ck(t),\n          u_lightpos: new e.ch(t),\n          u_lightintensity: new e.ci(t),\n          u_lightcolor: new e.ch(t),\n          u_vertical_gradient: new e.ci(t),\n          u_height_factor: new e.ci(t),\n          u_edge_radius: new e.ci(t),\n          u_width_scale: new e.ci(t),\n          u_ao: new e.cj(t),\n          u_height_type: new e.cg(t),\n          u_base_type: new e.cg(t),\n          u_tile_id: new e.ch(t),\n          u_zoom_transition: new e.ci(t),\n          u_inv_rot_matrix: new e.ck(t),\n          u_merc_center: new e.cj(t),\n          u_up_dir: new e.ch(t),\n          u_height_lift: new e.ci(t),\n          u_image: new e.cg(t),\n          u_texsize: new e.cj(t),\n          u_pixel_coord_upper: new e.cj(t),\n          u_pixel_coord_lower: new e.cj(t),\n          u_tile_units_to_pixels: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_pattern_transition: new e.ci(t)\n        }),\n        fillExtrusionGroundEffect: t => ({\n          u_matrix: new e.ck(t),\n          u_opacity: new e.ci(t),\n          u_ao_pass: new e.ci(t),\n          u_meter_to_tile: new e.ci(t),\n          u_ao: new e.cj(t),\n          u_flood_light_intensity: new e.ci(t),\n          u_flood_light_color: new e.ch(t),\n          u_attenuation: new e.ci(t),\n          u_edge_radius: new e.ci(t),\n          u_fb: new e.cg(t),\n          u_fb_size: new e.ci(t),\n          u_dynamic_offset: new e.ci(t)\n        }),\n        fill: t => ({\n          u_matrix: new e.ck(t),\n          u_emissive_strength: new e.ci(t),\n          u_ground_shadow_factor: new e.ch(t)\n        }),\n        fillPattern: t => ({\n          u_matrix: new e.ck(t),\n          u_emissive_strength: new e.ci(t),\n          u_image: new e.cg(t),\n          u_texsize: new e.cj(t),\n          u_pixel_coord_upper: new e.cj(t),\n          u_pixel_coord_lower: new e.cj(t),\n          u_tile_units_to_pixels: new e.ci(t),\n          u_ground_shadow_factor: new e.ch(t),\n          u_pattern_transition: new e.ci(t)\n        }),\n        fillOutline: t => ({\n          u_matrix: new e.ck(t),\n          u_emissive_strength: new e.ci(t),\n          u_world: new e.cj(t),\n          u_ground_shadow_factor: new e.ch(t)\n        }),\n        fillOutlinePattern: t => ({\n          u_matrix: new e.ck(t),\n          u_emissive_strength: new e.ci(t),\n          u_world: new e.cj(t),\n          u_image: new e.cg(t),\n          u_texsize: new e.cj(t),\n          u_pixel_coord_upper: new e.cj(t),\n          u_pixel_coord_lower: new e.cj(t),\n          u_tile_units_to_pixels: new e.ci(t),\n          u_ground_shadow_factor: new e.ch(t),\n          u_pattern_transition: new e.ci(t)\n        }),\n        building: t => ({\n          u_matrix: new e.ck(t),\n          u_normal_matrix: new e.ck(t),\n          u_opacity: new e.ci(t),\n          u_faux_facade_ao_intensity: new e.ci(t),\n          u_camera_pos: new e.ch(t),\n          u_tile_to_meter: new e.ci(t),\n          u_facade_emissive_chance: new e.ci(t)\n        }),\n        buildingBloom: t => ({\n          u_matrix: new e.ck(t)\n        }),\n        buildingDepth: t => ({\n          u_matrix: new e.ck(t)\n        }),\n        elevatedStructuresDepth: t => ({\n          u_matrix: new e.ck(t),\n          u_depth_bias: new e.ci(t)\n        }),\n        elevatedStructures: t => ({\n          u_matrix: new e.ck(t),\n          u_ground_shadow_factor: new e.ch(t)\n        }),\n        elevatedStructuresDepthReconstruct: t => ({\n          u_matrix: new e.ck(t),\n          u_camera_pos: new e.ch(t),\n          u_depth_bias: new e.ci(t),\n          u_height_scale: new e.ci(t),\n          u_reset_depth: new e.ci(t)\n        }),\n        circle: e.dV,\n        collisionBox: t => ({\n          u_matrix: new e.ck(t),\n          u_inv_rot_matrix: new e.ck(t),\n          u_camera_to_center_distance: new e.ci(t),\n          u_extrude_scale: new e.cj(t),\n          u_zoom_transition: new e.ci(t),\n          u_merc_center: new e.cj(t),\n          u_tile_id: new e.ch(t)\n        }),\n        collisionCircle: t => ({\n          u_matrix: new e.ck(t),\n          u_inv_matrix: new e.ck(t),\n          u_camera_to_center_distance: new e.ci(t),\n          u_viewport_size: new e.cj(t)\n        }),\n        debug: t => ({\n          u_color: new e.dx(t),\n          u_matrix: new e.ck(t),\n          u_overlay: new e.cg(t),\n          u_overlay_scale: new e.ci(t)\n        }),\n        clippingMask: t => ({\n          u_matrix: new e.ck(t)\n        }),\n        heatmap: t => ({\n          u_extrude_scale: new e.ci(t),\n          u_intensity: new e.ci(t),\n          u_matrix: new e.ck(t),\n          u_inv_rot_matrix: new e.ck(t),\n          u_merc_center: new e.cj(t),\n          u_tile_id: new e.ch(t),\n          u_zoom_transition: new e.ci(t),\n          u_up_dir: new e.ch(t)\n        }),\n        heatmapTexture: t => ({\n          u_image: new e.cg(t),\n          u_color_ramp: new e.cg(t),\n          u_opacity: new e.ci(t)\n        }),\n        hillshade: t => ({\n          u_matrix: new e.ck(t),\n          u_image: new e.cg(t),\n          u_latrange: new e.cj(t),\n          u_light: new e.cj(t),\n          u_shadow: new e.dx(t),\n          u_highlight: new e.dx(t),\n          u_emissive_strength: new e.ci(t),\n          u_accent: new e.dx(t)\n        }),\n        hillshadePrepare: t => ({\n          u_matrix: new e.ck(t),\n          u_image: new e.cg(t),\n          u_dimension: new e.cj(t),\n          u_zoom: new e.ci(t)\n        }),\n        line: e.dU,\n        linePattern: e.dT,\n        raster: t => ({\n          u_matrix: new e.ck(t),\n          u_normalize_matrix: new e.ck(t),\n          u_globe_matrix: new e.ck(t),\n          u_merc_matrix: new e.ck(t),\n          u_grid_matrix: new e.dy(t),\n          u_tl_parent: new e.cj(t),\n          u_scale_parent: new e.ci(t),\n          u_fade_t: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_image0: new e.cg(t),\n          u_image1: new e.cg(t),\n          u_brightness_low: new e.ci(t),\n          u_brightness_high: new e.ci(t),\n          u_saturation_factor: new e.ci(t),\n          u_contrast_factor: new e.ci(t),\n          u_spin_weights: new e.ch(t),\n          u_perspective_transform: new e.cj(t),\n          u_raster_elevation: new e.ci(t),\n          u_zoom_transition: new e.ci(t),\n          u_merc_center: new e.cj(t),\n          u_cutoff_params: new e.d2(t),\n          u_colorization_mix: new e.d2(t),\n          u_colorization_offset: new e.ci(t),\n          u_color_ramp: new e.cg(t),\n          u_texture_offset: new e.cj(t),\n          u_texture_res: new e.cj(t),\n          u_emissive_strength: new e.ci(t)\n        }),\n        rasterParticle: t => ({\n          u_matrix: new e.ck(t),\n          u_normalize_matrix: new e.ck(t),\n          u_globe_matrix: new e.ck(t),\n          u_merc_matrix: new e.ck(t),\n          u_grid_matrix: new e.dy(t),\n          u_tl_parent: new e.cj(t),\n          u_scale_parent: new e.ci(t),\n          u_fade_t: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_image0: new e.cg(t),\n          u_image1: new e.cg(t),\n          u_raster_elevation: new e.ci(t),\n          u_zoom_transition: new e.ci(t),\n          u_merc_center: new e.cj(t),\n          u_cutoff_params: new e.d2(t)\n        }),\n        rasterParticleTexture: t => ({\n          u_texture: new e.cg(t),\n          u_opacity: new e.ci(t)\n        }),\n        rasterParticleDraw: t => ({\n          u_particle_texture: new e.cg(t),\n          u_particle_texture_side_len: new e.ci(t),\n          u_tile_offset: new e.cj(t),\n          u_velocity: new e.cg(t),\n          u_color_ramp: new e.cg(t),\n          u_velocity_res: new e.cj(t),\n          u_max_speed: new e.ci(t),\n          u_uv_offset: new e.cj(t),\n          u_data_scale: new e.cj(t),\n          u_data_offset: new e.ci(t),\n          u_particle_pos_scale: new e.ci(t),\n          u_particle_pos_offset: new e.cj(t)\n        }),\n        rasterParticleUpdate: t => ({\n          u_particle_texture: new e.cg(t),\n          u_particle_texture_side_len: new e.ci(t),\n          u_velocity: new e.cg(t),\n          u_velocity_res: new e.cj(t),\n          u_max_speed: new e.ci(t),\n          u_speed_factor: new e.ci(t),\n          u_reset_rate: new e.ci(t),\n          u_rand_seed: new e.ci(t),\n          u_uv_offset: new e.cj(t),\n          u_data_scale: new e.cj(t),\n          u_data_offset: new e.ci(t),\n          u_particle_pos_scale: new e.ci(t),\n          u_particle_pos_offset: new e.cj(t)\n        }),\n        symbol: t => ({\n          u_is_size_zoom_constant: new e.cg(t),\n          u_is_size_feature_constant: new e.cg(t),\n          u_size_t: new e.ci(t),\n          u_size: new e.ci(t),\n          u_camera_to_center_distance: new e.ci(t),\n          u_rotate_symbol: new e.cg(t),\n          u_aspect_ratio: new e.ci(t),\n          u_fade_change: new e.ci(t),\n          u_matrix: new e.ck(t),\n          u_label_plane_matrix: new e.ck(t),\n          u_coord_matrix: new e.ck(t),\n          u_is_text: new e.cg(t),\n          u_elevation_from_sea: new e.cg(t),\n          u_pitch_with_map: new e.cg(t),\n          u_texsize: new e.cj(t),\n          u_texsize_icon: new e.cj(t),\n          u_texture: new e.cg(t),\n          u_texture_icon: new e.cg(t),\n          u_gamma_scale: new e.ci(t),\n          u_device_pixel_ratio: new e.ci(t),\n          u_tile_id: new e.ch(t),\n          u_zoom_transition: new e.ci(t),\n          u_inv_rot_matrix: new e.ck(t),\n          u_merc_center: new e.cj(t),\n          u_camera_forward: new e.ch(t),\n          u_tile_matrix: new e.ck(t),\n          u_up_vector: new e.ch(t),\n          u_ecef_origin: new e.ch(t),\n          u_is_halo: new e.cg(t),\n          u_icon_transition: new e.ci(t),\n          u_color_adj_mat: new e.ck(t),\n          u_scale_factor: new e.ci(t),\n          u_ground_shadow_factor: new e.ch(t),\n          u_inv_matrix: new e.ck(t),\n          u_normal_scale: new e.ci(t),\n          u_lutTexture: new e.cg(t)\n        }),\n        background: t => ({\n          u_matrix: new e.ck(t),\n          u_emissive_strength: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_color: new e.dx(t)\n        }),\n        backgroundPattern: t => ({\n          u_matrix: new e.ck(t),\n          u_emissive_strength: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_image: new e.cg(t),\n          u_pattern_tl: new e.cj(t),\n          u_pattern_br: new e.cj(t),\n          u_texsize: new e.cj(t),\n          u_pattern_size: new e.cj(t),\n          u_pixel_coord_upper: new e.cj(t),\n          u_pixel_coord_lower: new e.cj(t),\n          u_pattern_units_to_pixels: new e.cj(t)\n        }),\n        terrainRaster: t => ({\n          u_matrix: new e.ck(t),\n          u_image0: new e.cg(t),\n          u_skirt_height: new e.ci(t),\n          u_ground_shadow_factor: new e.ch(t)\n        }),\n        skybox: t => ({\n          u_matrix: new e.ck(t),\n          u_sun_direction: new e.ch(t),\n          u_cubemap: new e.cg(t),\n          u_opacity: new e.ci(t),\n          u_temporal_offset: new e.ci(t)\n        }),\n        skyboxGradient: t => ({\n          u_matrix: new e.ck(t),\n          u_color_ramp: new e.cg(t),\n          u_center_direction: new e.ch(t),\n          u_radius: new e.ci(t),\n          u_opacity: new e.ci(t),\n          u_temporal_offset: new e.ci(t)\n        }),\n        skyboxCapture: t => ({\n          u_matrix_3f: new e.dy(t),\n          u_sun_direction: new e.ch(t),\n          u_sun_intensity: new e.ci(t),\n          u_color_tint_r: new e.d2(t),\n          u_color_tint_m: new e.d2(t),\n          u_luminance: new e.ci(t)\n        }),\n        globeRaster: t => ({\n          u_proj_matrix: new e.ck(t),\n          u_globe_matrix: new e.ck(t),\n          u_normalize_matrix: new e.ck(t),\n          u_merc_matrix: new e.ck(t),\n          u_zoom_transition: new e.ci(t),\n          u_merc_center: new e.cj(t),\n          u_image0: new e.cg(t),\n          u_grid_matrix: new e.dy(t),\n          u_skirt_height: new e.ci(t),\n          u_far_z_cutoff: new e.ci(t),\n          u_frustum_tl: new e.ch(t),\n          u_frustum_tr: new e.ch(t),\n          u_frustum_br: new e.ch(t),\n          u_frustum_bl: new e.ch(t),\n          u_globe_pos: new e.ch(t),\n          u_globe_radius: new e.ci(t),\n          u_viewport: new e.cj(t)\n        }),\n        globeAtmosphere: t => ({\n          u_frustum_tl: new e.ch(t),\n          u_frustum_tr: new e.ch(t),\n          u_frustum_br: new e.ch(t),\n          u_frustum_bl: new e.ch(t),\n          u_horizon: new e.ci(t),\n          u_transition: new e.ci(t),\n          u_fadeout_range: new e.ci(t),\n          u_atmosphere_fog_color: new e.d2(t),\n          u_high_color: new e.d2(t),\n          u_space_color: new e.d2(t),\n          u_temporal_offset: new e.ci(t),\n          u_horizon_angle: new e.ci(t)\n        }),\n        model: t => ({\n          u_matrix: new e.ck(t),\n          u_lighting_matrix: new e.ck(t),\n          u_normal_matrix: new e.ck(t),\n          u_node_matrix: new e.ck(t),\n          u_lightpos: new e.ch(t),\n          u_lightintensity: new e.ci(t),\n          u_lightcolor: new e.ch(t),\n          u_camera_pos: new e.ch(t),\n          u_opacity: new e.ci(t),\n          u_baseColorFactor: new e.d2(t),\n          u_emissiveFactor: new e.d2(t),\n          u_metallicFactor: new e.ci(t),\n          u_roughnessFactor: new e.ci(t),\n          u_baseTextureIsAlpha: new e.cg(t),\n          u_alphaMask: new e.cg(t),\n          u_alphaCutoff: new e.ci(t),\n          u_baseColorTexture: new e.cg(t),\n          u_metallicRoughnessTexture: new e.cg(t),\n          u_normalTexture: new e.cg(t),\n          u_occlusionTexture: new e.cg(t),\n          u_emissionTexture: new e.cg(t),\n          u_lutTexture: new e.cg(t),\n          u_color_mix: new e.d2(t),\n          u_aoIntensity: new e.ci(t),\n          u_emissive_strength: new e.ci(t),\n          u_occlusionTextureTransform: new e.d2(t)\n        }),\n        modelDepth: t => ({\n          u_matrix: new e.ck(t),\n          u_instance: new e.ck(t),\n          u_node_matrix: new e.ck(t)\n        }),\n        groundShadow: t => ({\n          u_matrix: new e.ck(t),\n          u_ground_shadow_factor: new e.ch(t)\n        }),\n        stars: t => ({\n          u_matrix: new e.ck(t),\n          u_up: new e.ch(t),\n          u_right: new e.ch(t),\n          u_intensity_multiplier: new e.ci(t)\n        }),\n        snowParticle: t => ({\n          u_modelview: new e.ck(t),\n          u_projection: new e.ck(t),\n          u_time: new e.ci(t),\n          u_cam_pos: new e.ch(t),\n          u_velocityConeAperture: new e.ci(t),\n          u_velocity: new e.ci(t),\n          u_horizontalOscillationRadius: new e.ci(t),\n          u_horizontalOscillationRate: new e.ci(t),\n          u_boxSize: new e.ci(t),\n          u_billboardSize: new e.ci(t),\n          u_simpleShapeParameters: new e.cj(t),\n          u_screenSize: new e.cj(t),\n          u_thinningCenterPos: new e.cj(t),\n          u_thinningShape: new e.ch(t),\n          u_thinningAffectedRatio: new e.ci(t),\n          u_thinningParticleOffset: new e.ci(t),\n          u_particleColor: new e.d2(t),\n          u_direction: new e.ch(t)\n        }),\n        rainParticle: t => ({\n          u_modelview: new e.ck(t),\n          u_projection: new e.ck(t),\n          u_time: new e.ci(t),\n          u_cam_pos: new e.ch(t),\n          u_texScreen: new e.cg(t),\n          u_velocityConeAperture: new e.ci(t),\n          u_velocity: new e.ci(t),\n          u_boxSize: new e.ci(t),\n          u_rainDropletSize: new e.cj(t),\n          u_distortionStrength: new e.ci(t),\n          u_rainDirection: new e.ch(t),\n          u_color: new e.d2(t),\n          u_screenSize: new e.cj(t),\n          u_thinningCenterPos: new e.cj(t),\n          u_thinningShape: new e.ch(t),\n          u_thinningAffectedRatio: new e.ci(t),\n          u_thinningParticleOffset: new e.ci(t),\n          u_shapeDirectionalPower: new e.ci(t),\n          u_shapeNormalPower: new e.ci(t),\n          u_mode: new e.ci(t)\n        }),\n        vignette: t => ({\n          u_vignetteShape: new e.ch(t),\n          u_vignetteColor: new e.d2(t)\n        }),\n        occlusion: t => ({\n          u_matrix: new e.ck(t),\n          u_anchorPos: new e.ch(t),\n          u_screenSizePx: new e.cj(t),\n          u_occluderSizePx: new e.cj(t),\n          u_color: new e.d2(t)\n        })\n      };\n    class zr {\n      constructor(e, t, i, o) {\n        this.id = zr.uniqueIdxCounter, zr.uniqueIdxCounter++, this.context = e;\n        const s = e.gl;\n        this.buffer = s.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), s.bufferData(s.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? s.DYNAMIC_DRAW : s.STATIC_DRAW), this.dynamicDraw || o || t.destroy();\n      }\n      bind() {\n        this.context.bindElementBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        this.id = zr.uniqueIdxCounter, zr.uniqueIdxCounter++;\n        const t = this.context.gl;\n        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    zr.uniqueIdxCounter = 0;\n    const Or = {\n      Int8: \"BYTE\",\n      Uint8: \"UNSIGNED_BYTE\",\n      Int16: \"SHORT\",\n      Uint16: \"UNSIGNED_SHORT\",\n      Int32: \"INT\",\n      Uint32: \"UNSIGNED_INT\",\n      Float32: \"FLOAT\"\n    };\n    class Mr {\n      constructor(e, t, i, o, s, r) {\n        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.instanceCount = r, this.context = e;\n        const n = e.gl;\n        this.buffer = n.createBuffer(), e.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || s || t.destroy();\n      }\n      bind() {\n        this.context.bindVertexBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        const t = this.context.gl;\n        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      enableAttributes(e, t) {\n        for (let i = 0; i < this.attributes.length; i++) {\n          const o = t.getAttributeLocation(e, this.attributes[i].name);\n          -1 !== o && e.enableVertexAttribArray(o);\n        }\n      }\n      setVertexAttribPointers(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const s = this.attributes[o],\n            r = t.getAttributeLocation(e, s.name);\n          -1 !== r && e.vertexAttribPointer(r, s.components, e[Or[s.type]], !1, this.itemSize, s.offset + this.itemSize * (i || 0));\n        }\n      }\n      setVertexAttribDivisor(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const s = t.getAttributeLocation(e, this.attributes[o].name);\n          -1 !== s && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(s, i);\n        }\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    class Fr {\n      constructor(e, t, i, o, s) {\n        this.context = e, this.width = t, this.height = i;\n        const r = this.framebuffer = e.gl.createFramebuffer();\n        o && (this.colorAttachment = new Ls(e, r)), s && (this.depthAttachmentType = s, this.depthAttachment = \"renderbuffer\" === s ? new Ps(e, r) : new zs(e, r));\n      }\n      destroy() {\n        const e = this.context.gl;\n        if (this.colorAttachment) {\n          const t = this.colorAttachment.get();\n          t && e.deleteTexture(t);\n        }\n        if (this.depthAttachment && this.depthAttachmentType) if (\"renderbuffer\" === this.depthAttachmentType) {\n          const t = this.depthAttachment.get();\n          t && e.deleteRenderbuffer(t);\n        } else {\n          const t = this.depthAttachment.get();\n          t && e.deleteTexture(t);\n        }\n        e.deleteFramebuffer(this.framebuffer);\n      }\n    }\n    class Br {\n      constructor(e, t) {\n        this.gl = e, this.clearColor = new Qo(this), this.clearDepth = new es(this), this.clearStencil = new ts(this), this.colorMask = new is(this), this.depthMask = new os(this), this.stencilMask = new ss(this), this.stencilFunc = new rs(this), this.stencilOp = new ns(this), this.stencilTest = new as(this), this.depthRange = new ls(this), this.depthTest = new cs(this), this.depthFunc = new hs(this), this.blend = new ds(this), this.blendFunc = new us(this), this.blendColor = new _s(this), this.blendEquation = new ps(this), this.cullFace = new fs(this), this.cullFaceSide = new ms(this), this.frontFace = new gs(this), this.program = new vs(this), this.activeTexture = new ys(this), this.viewport = new xs(this), this.bindFramebuffer = new bs(this), this.bindRenderbuffer = new ws(this), this.bindTexture = new Ts(this), this.bindVertexBuffer = new Es(this), this.bindElementBuffer = new Ss(this), this.bindVertexArrayOES = new Is(this), this.pixelStoreUnpack = new Cs(this), this.pixelStoreUnpackPremultiplyAlpha = new Rs(this), this.pixelStoreUnpackFlipY = new As(this), this.options = t ? Object.assign({}, t) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension(\"EXT_texture_filter_anisotropic\") || e.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || e.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension(\"WEBGL_debug_renderer_info\"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t && !!t.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf(\"PowerVR\"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension(\"OES_texture_float_linear\")), this.extRenderToTextureHalfFloat = e.getExtension(\"EXT_color_buffer_half_float\"), this.extTimerQuery = e.getExtension(\"EXT_disjoint_timer_query_webgl2\"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxPointSize = e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];\n      }\n      setDefault() {\n        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n      }\n      setDirty() {\n        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n      }\n      createIndexBuffer(e, t, i) {\n        return new zr(this, e, t, i);\n      }\n      createVertexBuffer(e, t, i, o, s) {\n        return new Mr(this, e, t, i, o, s);\n      }\n      createRenderbuffer(e, t, i) {\n        const o = this.gl,\n          s = o.createRenderbuffer();\n        return this.bindRenderbuffer.set(s), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), s;\n      }\n      createFramebuffer(e, t, i, o) {\n        return new Fr(this, e, t, i, o);\n      }\n      clear(_ref101) {\n        let {\n          color: e,\n          depth: t,\n          stencil: i,\n          colorMask: o\n        } = _ref101;\n        const s = this.gl;\n        let r = 0;\n        e && (r |= s.COLOR_BUFFER_BIT, this.clearColor.set(e.toNonPremultipliedRenderColor(null)), this.colorMask.set(o || [!0, !0, !0, !0])), void 0 !== t && (r |= s.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= s.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), s.clear(r);\n      }\n      setCullFace(e) {\n        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));\n      }\n      setDepthMode(e) {\n        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);\n      }\n      setStencilMode(e) {\n        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({\n          func: e.test.func,\n          ref: e.ref,\n          mask: e.test.mask\n        })) : this.stencilTest.set(!1);\n      }\n      setColorMode(t) {\n        e.by(t.blendFunction, Ui.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);\n      }\n      unbindVAO() {\n        this.bindVertexArrayOES.set(null);\n      }\n    }\n    let kr;\n    function Nr(t, i, o, s, r, n, a) {\n      const l = t.context,\n        c = l.gl,\n        h = t.transform,\n        d = [e.aF(h.center.lng), e.aJ(h.center.lat)],\n        u = o.layout.get(\"symbol-placement\"),\n        _ = o.layout.get(\"text-variable-anchor\"),\n        p = \"map\" === o.layout.get(\"icon-rotation-alignment\"),\n        f = \"map\" === o.layout.get(\"text-rotation-alignment\"),\n        m = \"point\" !== u,\n        g = [];\n      let v = 0,\n        y = 0;\n      for (let l = 0; l < s.length; l++) {\n        const u = s[l],\n          x = i.getTile(u),\n          b = x.getBucket(o);\n        if (!b) continue;\n        const w = b.getProjection().createInversionMatrix(h, u.canonical),\n          T = [],\n          E = Ht(u, b, h),\n          S = !a && p && m,\n          I = a && f && m,\n          C = _ && b.hasTextData(),\n          R = b.hasIconTextFit() && C && b.hasIconData(),\n          A = S || I || a && C || R,\n          D = \"globe\" === b.projection.name,\n          L = D ? e.aj(h.zoom) : 0;\n        D && (T.push(\"PROJECTION_GLOBE_VIEW\"), A && T.push(\"PROJECTED_POS_ON_VIEWPORT\"));\n        const P = t.getOrCreateProgram(\"collisionBox\", {\n          defines: T\n        });\n        let z = E;\n        0 === r[0] && 0 === r[1] || (z = t.translatePosMatrix(E, x, r, n));\n        const O = a ? b.textCollisionBox : b.iconCollisionBox,\n          M = b.collisionCircleArray;\n        if (M.length > 0) {\n          const t = e.bC(),\n            i = z;\n          e.cO(t, b.placementInvProjMatrix, h.glCoordMatrix), e.cO(t, t, b.placementViewportMatrix), g.push({\n            circleArray: M,\n            circleOffset: y,\n            transform: i,\n            invTransform: t,\n            projection: b.getProjection()\n          }), v += M.length / 4, y = v;\n        }\n        if (!O) continue;\n        t.terrain && t.terrain.setupElevationDraw(x, P);\n        const F = D ? [u.canonical.x, u.canonical.y, 1 << u.canonical.z] : [0, 0, 0];\n        P.draw(t, c.LINES, ji.disabled, Gi.disabled, t.colorModeForRenderPass(), Zi.disabled, _r(z, w, h, L, d, x, F, b.getProjection()), o.id, O.layoutVertexBuffer, O.indexBuffer, O.segments, null, h.zoom, null, [O.collisionVertexBuffer, O.collisionVertexBufferExt]);\n      }\n      if (!a || !g.length) return;\n      const x = t.getOrCreateProgram(\"collisionCircle\"),\n        b = new e.dW();\n      b.resize(4 * v), b._trim();\n      let w = 0;\n      for (const e of g) for (let t = 0; t < e.circleArray.length / 4; t++) {\n        const i = 4 * t,\n          o = e.circleArray[i + 0],\n          s = e.circleArray[i + 1],\n          r = e.circleArray[i + 2],\n          n = e.circleArray[i + 3];\n        b.emplace(w++, o, s, r, n, 0), b.emplace(w++, o, s, r, n, 1), b.emplace(w++, o, s, r, n, 2), b.emplace(w++, o, s, r, n, 3);\n      }\n      (!kr || kr.length < 2 * v) && (kr = function (t) {\n        const i = 2 * t,\n          o = new e.b1();\n        o.resize(i), o._trim();\n        for (let e = 0; e < i; e++) {\n          const t = 6 * e;\n          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;\n        }\n        return o;\n      }(v));\n      const T = l.createIndexBuffer(kr, !0),\n        E = l.createVertexBuffer(b, e.dX.members, !0);\n      for (const i of g) {\n        const s = {\n          u_matrix: i.transform,\n          u_inv_matrix: i.invTransform,\n          u_camera_to_center_distance: (S = h).getCameraToCenterDistance(i.projection),\n          u_viewport_size: [S.width, S.height]\n        };\n        x.draw(t, c.TRIANGLES, ji.disabled, Gi.disabled, t.colorModeForRenderPass(), Zi.disabled, s, o.id, E, T, e.bg.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);\n      }\n      var S;\n      E.destroy(), T.destroy();\n    }\n    const Ur = e.bC();\n    function jr(t) {\n      const i = t._camera.getWorldToCamera(t.worldSize, 1),\n        o = e.aB([], i, t.globeMatrix);\n      e.bl(o, o);\n      const s = [0, 0, 0],\n        r = [0, 1, 0, 0];\n      return e.aC(r, r, o), s[0] = r[0], s[1] = r[1], s[2] = r[2], e.aw(s, s), s;\n    }\n    function Vr(_ref102, n) {\n      let {\n        width: t,\n        height: i,\n        anchor: o,\n        textOffset: s,\n        textScale: r\n      } = _ref102;\n      const {\n          horizontalAlign: a,\n          verticalAlign: l\n        } = e.c0(o),\n        c = -(a - .5) * t,\n        h = -(l - .5) * i,\n        d = e.c1(o, s);\n      return new e.P((c / r + d[0]) * n, (h / r + d[1]) * n);\n    }\n    function Gr(t, i, o, s, r, n, a, l, c, h) {\n      const d = t.text.placedSymbolArray,\n        u = t.text.dynamicLayoutVertexArray,\n        _ = t.icon.dynamicLayoutVertexArray,\n        p = {},\n        f = t.getProjection(),\n        m = qt(a, f, r),\n        g = r.elevation,\n        v = f.upVectorScale(a.canonical, r.center.lat, r.worldSize).metersToTile;\n      u.clear();\n      for (let _ = 0; _ < d.length; _++) {\n        const y = d.get(_),\n          {\n            tileAnchorX: x,\n            tileAnchorY: b,\n            numGlyphs: w\n          } = y,\n          T = y.hidden || !y.crossTileID || t.allowVerticalPlacement && !y.placedOrientation ? null : s[y.crossTileID];\n        if (T) {\n          let s = 0,\n            d = 0,\n            _ = 0;\n          if (g) {\n            const e = g ? g.getAtTileOffset(a, x, b) : 0,\n              [t, i, o] = f.upVector(a.canonical, x, b);\n            s = e * t * v, d = e * i * v, _ = e * o * v;\n          }\n          let [E, S, I, C] = Qt(y.projectedAnchorX + s, y.projectedAnchorY + d, y.projectedAnchorZ + _, o ? m : n);\n          const R = ei(r.getCameraToCenterDistance(f), C);\n          let A = e.bM(t.textSizeData, c, y) * R / e.bX;\n          o && (A *= t.tilePixelRatio / l);\n          const D = Vr(T, A);\n          o ? ({\n            x: E,\n            y: S,\n            z: I\n          } = f.projectTilePoint(x + D.x, b + D.y, a.canonical), [E, S, I] = Qt(E + s, S + d, I + _, n)) : (i && D._rotate(-r.angle), E += D.x, S += D.y, I = 0);\n          const L = t.allowVerticalPlacement && y.placedOrientation === e.bL.vertical ? Math.PI / 2 : 0;\n          for (let t = 0; t < w; t++) e.bO(u, E, S, I, L);\n          h && y.associatedIconIndex >= 0 && (p[y.associatedIconIndex] = {\n            x: E,\n            y: S,\n            z: I,\n            angle: L\n          });\n        } else ci(w, u);\n      }\n      if (h) {\n        _.clear();\n        const i = t.icon.placedSymbolArray;\n        for (let t = 0; t < i.length; t++) {\n          const o = i.get(t),\n            {\n              numGlyphs: s\n            } = o,\n            r = p[t];\n          if (o.hidden || !r) ci(s, _);else {\n            const {\n              x: t,\n              y: i,\n              z: o,\n              angle: n\n            } = r;\n            for (let r = 0; r < s; r++) e.bO(_, t, i, o, n);\n          }\n        }\n        t.icon.dynamicLayoutVertexBuffer.updateData(_);\n      }\n      t.text.dynamicLayoutVertexBuffer.updateData(u);\n    }\n    function Hr(t, i, o, s, r, n) {\n      let a = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n      const l = o.paint.get(\"icon-translate\"),\n        c = o.paint.get(\"text-translate\"),\n        h = o.paint.get(\"icon-translate-anchor\"),\n        d = o.paint.get(\"text-translate-anchor\"),\n        u = o.layout.get(\"icon-rotation-alignment\"),\n        _ = o.layout.get(\"text-rotation-alignment\"),\n        p = o.layout.get(\"icon-pitch-alignment\"),\n        f = o.layout.get(\"text-pitch-alignment\"),\n        m = o.layout.get(\"icon-keep-upright\"),\n        g = o.layout.get(\"text-keep-upright\"),\n        v = o.paint.get(\"icon-color-saturation\"),\n        y = o.paint.get(\"icon-color-contrast\"),\n        x = o.paint.get(\"icon-color-brightness-min\"),\n        b = o.paint.get(\"icon-color-brightness-max\"),\n        w = \"sea\" === o.layout.get(\"symbol-elevation-reference\"),\n        T = \"none\" === o.layout.get(\"icon-image-use-theme\"),\n        E = t.context,\n        S = E.gl,\n        I = t.transform,\n        C = \"map\" === u,\n        R = \"map\" === _,\n        A = \"map\" === p,\n        D = \"map\" === f,\n        L = void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1);\n      let P = !1;\n      const z = t.depthModeForSublayer(0, ji.ReadOnly),\n        O = new ji(t.context.gl.LEQUAL, ji.ReadOnly, t.depthRangeFor3D),\n        M = [e.aF(I.center.lng), e.aJ(I.center.lat)],\n        F = o.layout.get(\"text-variable-anchor\"),\n        B = \"globe\" === I.projection.name,\n        k = [],\n        N = [0, -1, 0];\n      for (const r of s) {\n        const s = i.getTile(r),\n          n = s.getBucket(o);\n        if (!n) continue;\n        if (\"mercator\" === n.projection.name && B) continue;\n        if (n.fullyClipped) continue;\n        const u = \"globe\" === n.projection.name,\n          _ = u ? e.aj(I.zoom) : 0,\n          p = qt(r, n.getProjection(), I),\n          f = I.calculatePixelsToTileUnitsMatrix(s),\n          U = F && n.hasTextData(),\n          j = n.hasIconTextFit() && U && n.hasIconData(),\n          V = n.getProjection().createInversionMatrix(I, r.canonical),\n          G = (1 << s.tileID.canonical.z) * e.al / t.transform.worldSize,\n          H = e => {\n            let i = [0, 0, 0];\n            if (e) {\n              const e = t.style.directionalLight,\n                o = t.style.ambientLight;\n              e && o && (i = co(t.style, e, o));\n            }\n            return i;\n          },\n          q = e => {\n            I.depthOcclusionForSymbolsAndCircles && (o.hasOcclusionOpacityProperties || t.terrain) && (e.push(\"DEPTH_D24\"), e.push(\"DEPTH_OCCLUSION\"));\n          },\n          Z = i => {\n            o.lut && !T && (o.lut.texture || (o.lut.texture = new e.dY(t.context, o.lut.image, [o.lut.image.height, o.lut.image.height, o.lut.image.height], E.gl.RGBA8)), E.activeTexture.set(E.gl.TEXTURE0 + Ji.LUT), o.lut.texture && o.lut.texture.bind(E.gl.LINEAR, E.gl.CLAMP_TO_EDGE), i.push(\"APPLY_LUT_ON_GPU\"));\n          },\n          W = () => {\n            const i = C && \"point\" !== o.layout.get(\"symbol-placement\"),\n              a = [];\n            q(a), Z(a);\n            const c = i || j,\n              d = \"road\" === n.elevationType,\n              g = t.shadowRenderer,\n              T = d && A && !!g && g.enabled,\n              E = H(T),\n              R = d && A && !t.terrain ? O : z,\n              D = o.paint.get(\"icon-image-cross-fade\");\n            t.terrainRenderModeElevated() && A && a.push(\"PITCH_WITH_MAP_TERRAIN\"), u && (a.push(\"PROJECTION_GLOBE_VIEW\"), c && a.push(\"PROJECTED_POS_ON_VIEWPORT\")), D > 0 && n.hasAnySecondaryIcon && a.push(\"ICON_TRANSITION\"), !n.icon.zOffsetVertexBuffer || d && t.terrain || a.push(\"Z_OFFSET\"), 0 === v && 0 === y && 0 === x && 1 === b || a.push(\"COLOR_ADJUSTMENT\"), n.sdfIcons && a.push(\"RENDER_SDF\"), T && a.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\", \"NORMAL_OFFSET\"), d && A && !t.terrain && n.icon.orientationVertexBuffer && a.push(\"ELEVATED_ROADS\");\n            const L = n.icon.programConfigurations.get(o.id),\n              P = t.getOrCreateProgram(\"symbol\", {\n                config: L,\n                defines: a\n              }),\n              F = s.imageAtlasTexture ? s.imageAtlasTexture.size : [0, 0],\n              k = n.iconSizeData,\n              U = e.bK(k, I.zoom),\n              W = A || !I.isOrthographic,\n              $ = Yt(p, s.tileID.canonical, A, C, I, n.getProjection(), f),\n              X = Jt(p, s.tileID.canonical, A, C, I, n.getProjection(), f),\n              Y = t.translatePosMatrix(X, s, l, h, !0),\n              K = t.translatePosMatrix(p, s, l, h),\n              J = c ? Ur : $,\n              Q = C && !A && !i;\n            let ee = N;\n            !B && !I.mercatorFromTransition || C || (ee = jr(I));\n            const te = u ? ee : N,\n              ie = o.getColorAdjustmentMatrix(v, y, x, b),\n              oe = Ir(k.kind, U, Q, A, t, K, J, Y, w, !1, F, [0, 0], 0, r, _, M, V, te, n.getProjection(), E, G, ie, D, null),\n              se = s.imageAtlasTexture ? s.imageAtlasTexture : null,\n              re = 1 !== o.layout.get(\"icon-size\").constantOr(0) || n.iconsNeedLinear,\n              ne = n.sdfIcons || t.options.rotating || t.options.zooming || re || W ? S.LINEAR : S.NEAREST,\n              ae = n.sdfIcons && 0 !== o.paint.get(\"icon-halo-width\").constantOr(1),\n              le = t.terrain && A && i ? e.bl(e.bC(), $) : Ur;\n            if (i && n.icon) {\n              const e = I.elevation,\n                i = e ? e.getAtTileOffsetFunc(r, I.center.lat, I.worldSize, n.getProjection()) : null,\n                o = Kt(p, s.tileID.canonical, A, C, I, n.getProjection(), f);\n              ii(n, p, t, !1, o, X, A, m, i, r);\n            }\n            return {\n              program: P,\n              buffers: n.icon,\n              uniformValues: oe,\n              atlasTexture: se,\n              atlasTextureIcon: null,\n              atlasInterpolation: ne,\n              atlasInterpolationIcon: null,\n              isSDF: n.sdfIcons,\n              hasHalo: ae,\n              depthMode: R,\n              tile: s,\n              renderWithShadows: T,\n              labelPlaneMatrixInv: le\n            };\n          },\n          $ = () => {\n            const i = R && \"point\" !== o.layout.get(\"symbol-placement\"),\n              a = [],\n              l = i || F || j,\n              h = \"road\" === n.elevationType,\n              m = t.shadowRenderer,\n              v = h && D && !!m && m.enabled,\n              y = H(v),\n              x = h && D && !t.terrain ? O : z;\n            t.terrainRenderModeElevated() && D && a.push(\"PITCH_WITH_MAP_TERRAIN\"), u && (a.push(\"PROJECTION_GLOBE_VIEW\"), l && a.push(\"PROJECTED_POS_ON_VIEWPORT\")), !n.text.zOffsetVertexBuffer || h && t.terrain || a.push(\"Z_OFFSET\"), n.iconsInText && a.push(\"RENDER_TEXT_AND_SYMBOL\"), a.push(\"RENDER_SDF\"), v && a.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\", \"NORMAL_OFFSET\"), h && D && !t.terrain && n.text.orientationVertexBuffer && a.push(\"ELEVATED_ROADS\"), q(a);\n            const b = n.text.programConfigurations.get(o.id),\n              T = t.getOrCreateProgram(\"symbol\", {\n                config: b,\n                defines: a\n              });\n            let E,\n              C = [0, 0],\n              A = null;\n            const L = n.textSizeData;\n            n.iconsInText && (C = s.imageAtlasTexture ? s.imageAtlasTexture.size : [0, 0], A = s.imageAtlasTexture ? s.imageAtlasTexture : null, E = D || !I.isOrthographic || t.options.rotating || t.options.zooming || \"composite\" === L.kind || \"camera\" === L.kind ? S.LINEAR : S.NEAREST);\n            const P = s.glyphAtlasTexture ? s.glyphAtlasTexture.size : [0, 0],\n              k = o.layout.get(\"text-size-scale-range\"),\n              U = e.aA(t.scaleFactor, k[0], k[1]),\n              Z = e.bK(L, I.zoom, U),\n              W = Yt(p, s.tileID.canonical, D, R, I, n.getProjection(), f),\n              $ = Jt(p, s.tileID.canonical, D, R, I, n.getProjection(), f),\n              X = t.translatePosMatrix($, s, c, d, !0),\n              Y = t.translatePosMatrix(p, s, c, d),\n              K = l ? Ur : W,\n              J = R && !D && !i;\n            let Q = N;\n            !B && !I.mercatorFromTransition || R || (Q = jr(I));\n            const ee = Ir(L.kind, Z, J, D, t, Y, K, X, w, !0, P, C, 0, r, _, M, V, u ? Q : N, n.getProjection(), y, G, null, null, U),\n              te = s.glyphAtlasTexture ? s.glyphAtlasTexture : null,\n              ie = S.LINEAR,\n              oe = 0 !== o.paint.get(\"text-halo-width\").constantOr(1),\n              se = t.terrain && D && i ? e.bl(e.bC(), W) : Ur;\n            if (i && n.text) {\n              const e = I.elevation,\n                i = e ? e.getAtTileOffsetFunc(r, I.center.lat, I.worldSize, n.getProjection()) : null,\n                o = Kt(p, s.tileID.canonical, D, R, I, n.getProjection(), f);\n              ii(n, p, t, !0, o, $, D, g, i, r);\n            }\n            return {\n              program: T,\n              buffers: n.text,\n              uniformValues: ee,\n              atlasTexture: te,\n              atlasTextureIcon: A,\n              atlasInterpolation: ie,\n              atlasInterpolationIcon: E,\n              isSDF: !0,\n              hasHalo: oe,\n              depthMode: x,\n              tile: s,\n              renderWithShadows: v,\n              labelPlaneMatrixInv: se\n            };\n          },\n          X = n.icon.segments.get().length,\n          Y = n.text.segments.get().length,\n          K = X && !a.onlyText ? W() : null,\n          J = Y && !a.onlyIcons ? $() : null,\n          Q = o.paint.get(\"icon-opacity\").constantOr(1),\n          ee = o.paint.get(\"text-opacity\").constantOr(1);\n        if (L && n.canOverlap) {\n          P = !0;\n          const t = Q && !a.onlyText ? n.icon.segments.get() : [],\n            i = ee && !a.onlyIcons ? n.text.segments.get() : [];\n          for (const i of t) k.push({\n            segments: new e.bg([i]),\n            sortKey: i.sortKey,\n            state: K\n          });\n          for (const t of i) k.push({\n            segments: new e.bg([t]),\n            sortKey: t.sortKey,\n            state: J\n          });\n        } else a.onlyText || k.push({\n          segments: Q ? n.icon.segments : new e.bg([]),\n          sortKey: 0,\n          state: K\n        }), a.onlyIcons || k.push({\n          segments: ee ? n.text.segments : new e.bg([]),\n          sortKey: 0,\n          state: J\n        });\n      }\n      P && k.sort((e, t) => e.sortKey - t.sortKey);\n      for (const e of k) {\n        const i = e.state;\n        if (i) if (t.terrain ? t.terrain.setupElevationDraw(i.tile, i.program, {\n          useDepthForOcclusion: I.depthOcclusionForSymbolsAndCircles,\n          labelPlaneMatrixInv: i.labelPlaneMatrixInv\n        }) : t.setupDepthForOcclusion(I.depthOcclusionForSymbolsAndCircles, i.program), E.activeTexture.set(S.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, S.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (E.activeTexture.set(S.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, S.CLAMP_TO_EDGE, !0)), i.renderWithShadows && t.shadowRenderer.setupShadows(i.tile.tileID.toUnwrapped(), i.program, \"vector-tile\"), t.uploadCommonLightUniforms(t.context, i.program), i.hasHalo) {\n          const s = i.uniformValues;\n          s.u_is_halo = 1, qr(i.buffers, e.segments, o, t, i.program, i.depthMode, r, n, s, 2), s.u_is_halo = 0;\n        } else {\n          if (i.isSDF) {\n            const s = i.uniformValues;\n            i.hasHalo && (s.u_is_halo = 1, qr(i.buffers, e.segments, o, t, i.program, i.depthMode, r, n, s, 1)), s.u_is_halo = 0;\n          }\n          qr(i.buffers, e.segments, o, t, i.program, i.depthMode, r, n, i.uniformValues, 1);\n        }\n      }\n    }\n    function qr(e, t, i, o, s, r, n, a, l, c) {\n      const h = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.iconTransitioningVertexBuffer, e.globeExtVertexBuffer, e.zOffsetVertexBuffer, e.orientationVertexBuffer];\n      s.draw(o, o.context.gl.TRIANGLES, r, n, a, Zi.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t, i.paint, o.transform.zoom, e.programConfigurations.get(i.id), h, c);\n    }\n    function Zr(t, i) {\n      const o = 1 << t.canonical.z,\n        s = (i.x * o - t.canonical.x - t.wrap * o) * e.al,\n        r = (i.y * o - t.canonical.y) * e.al,\n        n = e.e5(i.z, i.y);\n      return e.d4(s, r, n);\n    }\n    function Wr(t, i, o, s, r) {\n      if (!o.layout || \"none\" === o.layout.get(\"fill-elevation-reference\")) return;\n      const n = t.context.gl,\n        a = new ji(t.context.gl.LEQUAL, ji.ReadWrite, t.depthRangeFor3D),\n        l = new ji(t.context.gl.GREATER, ji.ReadWrite, t.depthRangeFor3D),\n        c = function (t) {\n          let i = .01;\n          return t.isOrthographic && (i = e.ak(1e-4, i, e.c$(t.pitch >= eo ? 1 : t.pitch / eo))), 2 * i;\n        }(t.transform),\n        h = t.transform.getFreeCameraOptions().position,\n        d = \"elevatedStructuresDepthReconstruct\",\n        u = t.getOrCreateProgram(d, {\n          defines: [\"DEPTH_RECONSTRUCTION\"]\n        }),\n        _ = t.getOrCreateProgram(d);\n      for (const e of s) {\n        const s = i.getTile(e),\n          d = s.getBucket(o);\n        if (!d) continue;\n        const p = d.elevatedStructures;\n        if (!p) continue;\n        const f = d.elevationBufferData.heightRange,\n          m = Zr(e.toUnwrapped(), h),\n          g = t.translatePosMatrix(e.projMatrix, s, o.paint.get(\"fill-translate\"), o.paint.get(\"fill-translate-anchor\"));\n        let v, y, x, b;\n        if (\"initialize\" === r) {\n          if (!f || f.min >= 1 || 0 === p.depthSegments.segments[0].primitiveLength) continue;\n          v = cr(g, m, c, 1, 0), y = a, x = p.depthSegments, b = u;\n        } else if (\"reset\" === r) {\n          if (!f || f.min >= 0 || 0 === p.maskSegments.segments[0].primitiveLength) continue;\n          v = cr(g, m, 0, 0, 1), y = l, x = p.maskSegments, b = u;\n        } else if (\"geometry\" === r) {\n          if (0 === p.depthSegments.segments[0].primitiveLength) continue;\n          v = cr(g, m, c, 1, 0), y = a, x = p.depthSegments, b = _;\n        }\n        b.draw(t, n.TRIANGLES, y, Gi.disabled, Ui.disabled, Zi.disabled, v, o.id, p.vertexBuffer, p.indexBuffer, x, o.paint, t.transform.zoom);\n      }\n    }\n    function $r(t, i, o) {\n      const {\n          painter: s,\n          sourceCache: r,\n          layer: n,\n          coords: a,\n          colorMode: l,\n          elevationType: c,\n          terrainEnabled: h,\n          pass: d\n        } = t,\n        u = s.context.gl,\n        _ = n.paint.get(\"fill-pattern\"),\n        p = n.paint.get(\"fill-pattern-cross-fade\"),\n        f = _.constantOr(null);\n      let m = c;\n      \"road\" !== c || i && !h || (m = \"none\");\n      const g = \"road\" === m,\n        v = t.painter.shadowRenderer,\n        y = g && !!v && v.enabled,\n        x = new ji(s.context.gl.LEQUAL, ji.ReadOnly, s.depthRangeFor3D);\n      let b = [0, 0, 0];\n      if (y) {\n        const e = s.style.directionalLight,\n          t = s.style.ambientLight;\n        e && t && (b = co(s.style, e, t));\n      }\n      const w = _ && _.constantOr(1),\n        T = (t, d) => {\n          let _, m, T, E, S;\n          d ? (_ = w && !n.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\", T = u.LINES) : (_ = w ? \"fillPattern\" : \"fill\", T = u.TRIANGLES);\n          for (const I of a) {\n            const a = r.getTile(I);\n            if (w && !a.patternsLoaded()) continue;\n            const C = a.getBucket(n);\n            if (!C) continue;\n            const R = i ? C.elevationBufferData : C.bufferData;\n            if (R.isEmpty()) continue;\n            s.prepareDrawTile();\n            const A = R.programConfigurations.get(n.id),\n              D = s.isTileAffectedByFog(I),\n              L = [],\n              P = [];\n            g && (L.push(\"ELEVATED_ROADS\"), P.push(R.elevatedLayoutVertexBuffer)), y && L.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\", \"NORMAL_OFFSET\"), w && (s.context.activeTexture.set(u.TEXTURE0), a.imageAtlasTexture && a.imageAtlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE), A.updatePaintBuffers());\n            let z = !1;\n            if (f && a.imageAtlas) {\n              const t = a.imageAtlas,\n                i = e.e0.from(f),\n                o = i.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(),\n                s = i.getSecondary(),\n                r = t.patternPositions.get(o),\n                n = s ? t.patternPositions.get(s.scaleSelf(e.o.devicePixelRatio).toString()) : null;\n              z = !!r && !!n, r && A.setConstantPatternPositions(r, n);\n            }\n            p > 0 && (z || A.getPatternTransitionVertexBuffer(\"fill-pattern\")) && L.push(\"FILL_PATTERN_TRANSITION\");\n            const O = s.getOrCreateProgram(_, {\n                config: A,\n                overrideFog: D,\n                defines: L\n              }),\n              M = s.translatePosMatrix(I.projMatrix, a, n.paint.get(\"fill-translate\"), n.paint.get(\"fill-translate-anchor\"));\n            y && v.setupShadows(a.tileID.toUnwrapped(), O, \"vector-tile\");\n            const F = n.paint.get(\"fill-emissive-strength\");\n            if (d) {\n              E = R.lineIndexBuffer, S = R.lineSegments;\n              const e = s.terrain && s.terrain.renderingToTexture ? s.terrain.drapeBufferSize : [u.drawingBufferWidth, u.drawingBufferHeight];\n              m = \"fillOutlinePattern\" === _ && w ? ar(M, F, s, a, e, b, p) : nr(M, F, e, b);\n            } else E = R.indexBuffer, S = R.triangleSegments, m = w ? rr(M, F, s, a, b, p) : sr(M, F, b);\n            s.uploadCommonUniforms(s.context, O, I.toUnwrapped());\n            let B = t;\n            (\"road\" === c && !h || \"offset\" === c) && (B = x), O.draw(s, T, B, o || s.stencilModeForClipping(I), l, Zi.disabled, m, n.id, R.layoutVertexBuffer, E, S, n.paint, s.transform.zoom, A, P);\n          }\n        };\n      s.renderPass === d && T(s.depthModeForSublayer(1, \"opaque\" === s.renderPass ? ji.ReadWrite : ji.ReadOnly), !1), \"none\" === m && \"translucent\" === s.renderPass && n.paint.get(\"fill-antialias\") && T(s.depthModeForSublayer(n.getPaintProperty(\"fill-outline-color\") ? 2 : 0, ji.ReadOnly), !0);\n    }\n    function Xr(t, i, o, s, r, n, a, l) {\n      o.resetLayerRenderingStats(t);\n      const c = t.context,\n        h = c.gl,\n        d = t.transform,\n        u = o.paint.get(\"fill-extrusion-pattern\"),\n        _ = o.paint.get(\"fill-extrusion-pattern-cross-fade\"),\n        p = u.constantOr(null),\n        f = u.constantOr(1),\n        m = o.paint.get(\"fill-extrusion-opacity\"),\n        g = t.style.enable3dLights(),\n        v = o.paint.get(g && !f ? \"fill-extrusion-ambient-occlusion-wall-radius\" : \"fill-extrusion-ambient-occlusion-radius\"),\n        y = [o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"), v],\n        x = o.layout.get(\"fill-extrusion-edge-radius\"),\n        b = x > 0 && !o.paint.get(\"fill-extrusion-rounded-roof\"),\n        w = b ? 0 : x,\n        T = \"globe\" === d.projection.name ? e.e8() : 0,\n        E = \"globe\" === d.projection.name,\n        S = E ? e.aj(d.zoom) : 0,\n        I = [e.aF(d.center.lng), e.aJ(d.center.lat)],\n        C = \"none\" === o.paint.get(\"fill-extrusion-flood-light-color-use-theme\").constantOr(\"default\"),\n        R = o.paint.get(\"fill-extrusion-flood-light-color\").toNonPremultipliedRenderColor(C ? null : o.lut).toArray01().slice(0, 3),\n        A = o.paint.get(\"fill-extrusion-flood-light-intensity\"),\n        D = o.paint.get(\"fill-extrusion-vertical-scale\"),\n        L = 0 !== o.paint.get(\"fill-extrusion-line-width\").constantOr(1),\n        P = o.paint.get(\"fill-extrusion-height-alignment\"),\n        z = o.paint.get(\"fill-extrusion-base-alignment\"),\n        O = io(t, o.paint.get(\"fill-extrusion-cutoff-fade-range\")),\n        M = [];\n      let F;\n      E && M.push(\"PROJECTION_GLOBE_VIEW\"), y[0] > 0 && M.push(\"FAUX_AO\"), b && M.push(\"ZERO_ROOF_RADIUS\"), l && M.push(\"HAS_CENTROID\"), A > 0 && M.push(\"FLOOD_LIGHT\"), O.shouldRenderCutoff && M.push(\"RENDER_CUTOFF\"), L && M.push(\"RENDER_WALL_MODE\");\n      const B = \"shadow\" === t.renderPass,\n        k = t.shadowRenderer,\n        N = B && !!k,\n        U = B ? Zi.disabled : Zi.backCCW;\n      t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !0);\n      let j = [0, 0, 0];\n      if (k) {\n        const e = t.style.directionalLight,\n          i = t.style.ambientLight;\n        e && i && (j = co(t.style, e, i)), B || (M.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), k.useNormalOffset && M.push(\"NORMAL_OFFSET\")), F = M.concat([\"SHADOWS_SINGLE_CASCADE\"]);\n      }\n      const V = N ? \"fillExtrusionDepth\" : f ? \"fillExtrusionPattern\" : \"fillExtrusion\",\n        G = o.getLayerRenderingStats();\n      for (const u of s) {\n        const s = i.getTile(u),\n          g = s.getBucket(o);\n        if (!g || g.projection.name !== d.projection.name) continue;\n        let v = !1;\n        k && (v = 0 === k.getMaxCascadeForTile(u.toUnwrapped()));\n        const x = t.isTileAffectedByFog(u),\n          b = g.programConfigurations.get(o.id);\n        let C = !1;\n        if (p && s.imageAtlas) {\n          const t = s.imageAtlas,\n            i = e.e0.from(p),\n            o = i.getPrimary().scaleSelf(e.o.devicePixelRatio).toString(),\n            r = i.getSecondary(),\n            n = t.patternPositions.get(o),\n            a = r ? t.patternPositions.get(r.scaleSelf(e.o.devicePixelRatio).toString()) : null;\n          C = !!n && !!a, n && b.setConstantPatternPositions(n, a);\n        }\n        _ > 0 && (C || b.getPatternTransitionVertexBuffer(\"fill-extrusion-pattern\")) && M.push(\"FILL_EXTRUSION_PATTERN_TRANSITION\");\n        const N = t.getOrCreateProgram(V, {\n          config: b,\n          defines: v ? F : M,\n          overrideFog: x\n        });\n        if (t.terrain && t.terrain.setupElevationDraw(s, N, {\n          useMeterToDem: !0\n        }), !g.centroidVertexBuffer) {\n          const e = N.getAttributeLocation(h, \"a_centroid_pos\");\n          -1 !== e && h.vertexAttrib2f(e, 0, 0);\n        }\n        !B && k && k.setupShadows(s.tileID.toUnwrapped(), N, \"vector-tile\"), f && (t.context.activeTexture.set(h.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), b.updatePaintBuffers());\n        const H = o.paint.get(\"fill-extrusion-vertical-gradient\"),\n          q = 1 / g.tileToMeter;\n        let Z;\n        if (B && k) {\n          if (on(s.tileID, g.maxHeight, t)) continue;\n          const e = k.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());\n          Z = ir(e, w, q, D, P, z);\n        } else {\n          const e = t.translatePosMatrix(u.expandedProjMatrix, s, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n            i = d.projection.createInversionMatrix(d, u.canonical);\n          Z = f ? or(e, t, H, m, y, w, q, u, s, T, P, z, S, I, i, R, D, _) : tr(e, t, H, m, y, w, q, u, T, P, z, S, I, i, R, D, A, j);\n        }\n        t.uploadCommonUniforms(c, N, u.toUnwrapped(), null, O);\n        let W = g.segments;\n        if (\"mercator\" === d.projection.name && !B && (W = g.getVisibleSegments(s.tileID, t.terrain, t.transform.getFrustum(0)), !W.get().length)) continue;\n        if (G) if (B) for (const e of W.get()) G.numRenderedVerticesInShadowPass += e.primitiveLength;else for (const e of W.get()) G.numRenderedVerticesInTransparentPass += e.primitiveLength;\n        const $ = [];\n        (t.terrain || l) && $.push(g.centroidVertexBuffer), E && $.push(g.layoutVertexExtBuffer), L && $.push(g.wallVertexBuffer), N.draw(t, c.gl.TRIANGLES, r, n, a, U, Z, o.id, g.layoutVertexBuffer, g.indexBuffer, W, o.paint, t.transform.zoom, b, $);\n      }\n      t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !1);\n    }\n    class Yr {\n      constructor() {\n        this.translate = [0, 0], this.translateAnchor = \"map\", this.edgeRadius = 0, this.cutoffFadeRange = 0;\n      }\n    }\n    function Kr(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {\n      const b = i.context,\n        w = b.gl,\n        T = i.transform,\n        E = i.transform.zoom,\n        S = [],\n        I = t.translate,\n        C = t.translateAnchor,\n        R = t.edgeRadius,\n        A = io(i, t.cutoffFadeRange);\n      \"clear\" === d ? (S.push(\"CLEAR_SUBPASS\"), x && (S.push(\"CLEAR_FROM_TEXTURE\"), b.activeTexture.set(w.TEXTURE0), x.bind(w.LINEAR, w.CLAMP_TO_EDGE))) : \"sdf\" === d && S.push(\"SDF_SUBPASS\"), v && S.push(\"HAS_CENTROID\"), A.shouldRenderCutoff && S.push(\"RENDER_CUTOFF\");\n      const D = (e, t, o, r, d) => {\n        const y = t.programConfigurations.get(s.id),\n          w = i.isTileAffectedByFog(e),\n          T = i.getOrCreateProgram(\"fillExtrusionGroundEffect\", {\n            config: y,\n            defines: S,\n            overrideFog: w\n          }),\n          I = ((e, t, i, o, s, r, n, a, l, c, h) => ({\n            u_matrix: t,\n            u_opacity: i,\n            u_ao_pass: o ? 1 : 0,\n            u_meter_to_tile: s,\n            u_ao: r,\n            u_flood_light_intensity: n,\n            u_flood_light_color: a,\n            u_attenuation: l,\n            u_edge_radius: c,\n            u_fb: 0,\n            u_fb_size: h,\n            u_dynamic_offset: 1\n          }))(0, r, u, h, d, [_, p * d], f, m, g, E >= 17 ? 0 : R * d, x ? x.size[0] : 0),\n          C = [];\n        v && C.push(t.hiddenByLandmarkVertexBuffer), i.uploadCommonUniforms(b, T, e.toUnwrapped(), null, A), T.draw(i, b.gl.TRIANGLES, n, a, l, c, I, s.id, t.vertexBuffer, t.indexBuffer, o, s.paint, E, y, C);\n      };\n      for (const t of r) {\n        const r = o.getTile(t),\n          n = r.getBucket(s);\n        if (!n || n.projection.name !== T.projection.name || !n.groundEffect || n.groundEffect && !n.groundEffect.hasData()) continue;\n        const a = n.groundEffect,\n          l = 1 / n.tileToMeter;\n        {\n          const e = i.translatePosMatrix(t.projMatrix, r, I, C),\n            o = a.getDefaultSegment();\n          D(t, a, o, e, l);\n        }\n        if (y) for (let n = 0; n < 4; n++) {\n          const a = e.e6[n](t),\n            c = o.getTile(a);\n          if (!c) continue;\n          const h = c.getBucket(s);\n          if (!h || h.projection.name !== T.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;\n          const d = h.groundEffect;\n          let u, _;\n          0 === n ? (u = [-e.al, 0, 0], _ = 1) : 1 === n ? (u = [e.al, 0, 0], _ = 0) : 2 === n ? (u = [0, -e.al, 0], _ = 3) : (u = [0, e.al, 0], _ = 2);\n          const p = d.regionSegments[_];\n          if (!p) continue;\n          const f = new Float32Array(16);\n          e.br(f, t.projMatrix, u), D(t, d, p, i.translatePosMatrix(f, r, I, C), l);\n        }\n      }\n    }\n    function Jr(t, i, o, s, r, n, a) {\n      0 === s.centroidVertexArray.length && s.createCentroidsBuffer();\n      const l = n ? n.findDEMTileFor(o) : null;\n      if (!(l && l.dem || a)) return;\n      n && l && l.dem && s.selfDEMTileTimestamp !== l.dem._timestamp && (s.borderDoneWithNeighborZ = [-1, -1, -1, -1], s.selfDEMTileTimestamp = l.dem._timestamp);\n      const c = t => new e.P(Math.ceil((t + e.ea) * e.eb), 0),\n        h = e => {\n          const t = i.getSource().minzoom,\n            o = e => {\n              const t = i.getTileByID(e);\n              if (t && t.hasData()) return t.getBucket(r);\n            },\n            s = [0, -1, 1];\n          for (const i of s) {\n            if (e.overscaledZ + i < t) continue;\n            const s = o(e.calculateScaledKey(e.overscaledZ + i));\n            if (s) return s;\n          }\n        },\n        d = [0, 0, 0],\n        u = (t, i) => (d[0] = Math.min(t.min.y, i.min.y), d[1] = Math.max(t.max.y, i.max.y), d[2] = e.al - i.min.x > t.max.x ? i.min.x - e.al : t.max.x, d),\n        _ = (t, i) => (d[0] = Math.min(t.min.x, i.min.x), d[1] = Math.max(t.max.x, i.max.x), d[2] = e.al - i.min.y > t.max.y ? i.min.y - e.al : t.max.y, d),\n        p = [(e, t) => u(e, t), (e, t) => u(t, e), (e, t) => _(e, t), (e, t) => _(t, e)],\n        f = (t, i, s, r, a, c, h) => {\n          if (!n) return 0;\n          const d = [[c ? s : t, c ? t : s, 0], [c ? s : i, c ? i : s, 0]],\n            u = h < 0 ? e.al + h : h,\n            _ = [c ? u : (t + i) / 2, c ? (t + i) / 2 : u, 0];\n          return 0 === s && h < 0 || 0 !== s && h > 0 ? n.getForTilePoints(a, [_], !0, r) : d.push(_), n.getForTilePoints(o, d, !0, l), Math.max(d[0][2], d[1][2], _[2]) / n.exaggeration();\n        };\n      for (let t = 0; t < 4; t++) {\n        const i = s.borderFeatureIndices[t];\n        if (0 === i.length) continue;\n        const r = e.e6[t](o),\n          l = h(r);\n        if (!(l && l instanceof e.e7)) continue;\n        const d = n ? n.findDEMTileFor(r) : null;\n        if (!(d && d.dem || a)) continue;\n        if (n && d && d.dem && s.borderDEMTileTimestamp[t] !== d.dem._timestamp && (s.borderDoneWithNeighborZ[t] = -1, s.borderDEMTileTimestamp[t] = d.dem._timestamp), s.borderDoneWithNeighborZ[t] === l.canonical.z) continue;\n        0 === l.centroidVertexArray.length && l.createCentroidsBuffer();\n        const u = (t < 2 ? 1 : 5) - t,\n          _ = l.borderDoneWithNeighborZ[u] !== s.canonical.z,\n          v = l.borderFeatureIndices[u];\n        let y = 0;\n        if (s.canonical.z !== l.canonical.z) {\n          for (const e of i) s.showCentroid(s.featuresOnBorder[e]);\n          if (_) for (const e of v) l.showCentroid(l.featuresOnBorder[e]);\n          s.borderDoneWithNeighborZ[t] = l.canonical.z, l.borderDoneWithNeighborZ[u] = s.canonical.z;\n        }\n        for (const o of i) {\n          const i = s.featuresOnBorder[o],\n            n = s.centroidData[i.centroidDataIndex],\n            h = i.borders[t];\n          let _;\n          for (; y < v.length;) {\n            _ = l.featuresOnBorder[v[y]];\n            const e = _.borders[u];\n            if (e[1] > h[0] + 3 || e[0] > h[0] - 3) break;\n            l.showCentroid(_), y++;\n          }\n          if (_ && y < v.length) {\n            const o = y;\n            let x = 0;\n            for (; !(_.borders[u][0] > h[1] - 3) && (x++, ++y !== v.length);) _ = l.featuresOnBorder[v[y]];\n            _ = l.featuresOnBorder[v[o]];\n            let b = !1;\n            if (x >= 1) {\n              const e = _.borders[u];\n              Math.abs(h[0] - e[0]) < 3 && Math.abs(h[1] - e[1]) < 3 && (x = 1, b = !0, y = o + 1);\n            } else if (0 === x) {\n              s.showCentroid(i);\n              continue;\n            }\n            const w = l.centroidData[_.centroidDataIndex];\n            a && b && (((m = n).flags | (g = w).flags) & e.e9 ? (m.flags |= e.e9, g.flags |= e.e9) : (m.flags &= ~e.e9, g.flags &= ~e.e9));\n            const T = i.intersectsCount() > 1 || _.intersectsCount() > 1;\n            if (x > 1) y = o, n.centroidXY = w.centroidXY = new e.P(0, 0);else if (d && d.dem && !T) {\n              const i = p[t](n, w),\n                o = t % 2 ? e.al - 1 : 0,\n                s = f(i[0], Math.min(e.al - 1, i[1]), o, d, r, t < 2, i[2]);\n              n.centroidXY = w.centroidXY = c(s);\n            } else T ? n.centroidXY = w.centroidXY = new e.P(0, 0) : (n.centroidXY = s.encodeBorderCentroid(i), w.centroidXY = l.encodeBorderCentroid(_));\n            s.writeCentroidToBuffer(n), l.writeCentroidToBuffer(w);\n          } else s.showCentroid(i);\n        }\n        s.borderDoneWithNeighborZ[t] = l.canonical.z, l.borderDoneWithNeighborZ[u] = s.canonical.z;\n      }\n      var m, g;\n      (s.needsCentroidUpdate || !s.centroidVertexBuffer && 0 !== s.centroidVertexArray.length) && s.uploadCentroid(t);\n    }\n    const Qr = [1, 0, 0],\n      en = [0, 1, 0],\n      tn = [0, 0, 1];\n    function on(t, i, o) {\n      const s = o.transform,\n        r = o.shadowRenderer;\n      if (!r) return !0;\n      const n = t.toUnwrapped(),\n        a = s.tileSize * r._cascades[o.currentShadowCascade].scale;\n      let l = i;\n      if (s.elevation) {\n        const e = s.elevation.getMinMaxForTile(t);\n        e && (l += e.max);\n      }\n      const c = [...r.shadowDirection];\n      c[2] = -c[2];\n      const h = r.computeSimplifiedTileShadowVolume(n, l, a, c);\n      if (!h) return !1;\n      const d = [Qr, en, tn, c, [c[0], 0, c[2]], [0, c[1], c[2]]],\n        u = \"globe\" === s.projection.name,\n        _ = s.scaleZoom(a),\n        p = e.cA.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, _, !u),\n        f = r.getCurrentCascadeFrustum();\n      return 0 === p.intersectsPrecise(h.vertices, h.planes, d) || 0 === f.intersectsPrecise(h.vertices, h.planes, d);\n    }\n    function sn(t) {\n      const {\n        painter: i,\n        source: o,\n        layer: s,\n        coords: r\n      } = t;\n      let n = t.defines;\n      const a = i.context,\n        l = \"shadow\" === i.renderPass,\n        c = \"light-beam\" === i.renderPass,\n        h = i.shadowRenderer,\n        d = e.ec(i.transform.center.lat, i.transform.zoom),\n        u = io(i, s.paint.get(\"building-cutoff-fade-range\"));\n      u.shouldRenderCutoff && (n = n.concat(\"RENDER_CUTOFF\"));\n      for (const _ of r) {\n        const r = o.getTile(_),\n          p = r.getBucket(s);\n        if (!p) continue;\n        h && 0 === h.getMaxCascadeForTile(_.toUnwrapped()) && (n = n.concat(\"SHADOWS_SINGLE_CASCADE\"));\n        const f = p.programConfigurations.get(s.id);\n        let m,\n          g,\n          v,\n          y = i.translatePosMatrix(_.expandedProjMatrix, r, [0, 0], \"map\");\n        if (y = e.cR(e.bC(), y, [1, 1, t.verticalScale]), l && h) {\n          if (on(r.tileID, p.maxHeight * d, i)) continue;\n          let o = h.calculateShadowPassMatrixFromTile(r.tileID.toUnwrapped());\n          o = e.cR(e.bC(), o, [1, 1, t.verticalScale]), v = ur(o), m = g = i.getOrCreateProgram(\"buildingDepth\", {\n            config: f,\n            defines: n,\n            overrideFog: !1\n          });\n        } else if (c) m = g = i.getOrCreateProgram(\"buildingBloom\", {\n          config: f,\n          defines: n,\n          overrideFog: !1\n        }), v = dr(y);else {\n          const o = i.transform.calculatePosMatrix(_.toUnwrapped(), i.transform.worldSize);\n          e.cR(o, o, [1, 1, t.verticalScale]);\n          const s = e.bC();\n          e.cR(s, o, [1, -1, 1 / d]), e.bl(s, s), e.ed(s, s);\n          const r = i.transform.getFreeCameraOptions().position,\n            a = 1 << _.canonical.z;\n          v = hr(y, s, t.opacity, t.facadeAOIntensity, [((r.x - _.wrap) * a - _.canonical.x) * e.al, (r.y * a - _.canonical.y) * e.al, r.z * a * e.al], p.tileToMeter, t.facadeEmissiveChance), g = i.getOrCreateProgram(\"building\", {\n            config: f,\n            defines: n,\n            overrideFog: !1\n          });\n          const l = n.concat([\"BUILDING_FAUX_FACADE\", \"HAS_ATTRIBUTE_a_faux_facade_color_emissive\"]);\n          m = i.getOrCreateProgram(\"building\", {\n            config: f,\n            defines: l,\n            overrideFog: !1\n          }), h && (h.setupShadowsFromMatrix(o, g, !0), h.setupShadowsFromMatrix(o, m, !0));\n        }\n        const x = (e, o) => {\n          if (c) {\n            const r = e.entranceBloom;\n            o.draw(i, a.gl.TRIANGLES, t.depthMode, Gi.disabled, t.blendMode, Zi.disabled, v, s.id, r.layoutVertexBuffer, r.indexBuffer, r.segmentsBucket, s.paint, i.transform.zoom, f, [r.layoutAttenuationBuffer, r.layoutColorBuffer]);\n          } else {\n            const r = e.segmentsBucket;\n            let n = [e.layoutNormalBuffer, e.layoutCentroidBuffer, e.layoutColorBuffer];\n            e.layoutFacadePaintBuffer && (n = n.concat([e.layoutFacadeDataBuffer, e.layoutFacadeVerticalRangeBuffer, e.layoutFacadePaintBuffer])), o.draw(i, a.gl.TRIANGLES, t.depthMode, Gi.disabled, t.blendMode, l ? Zi.disabled : Zi.backCW, v, s.id, e.layoutVertexBuffer, e.indexBuffer, r, s.paint, i.transform.zoom, f, n);\n          }\n        };\n        i.uploadCommonUniforms(a, g, _.toUnwrapped(), null, u), p.buildingWithoutFacade && x(p.buildingWithoutFacade, g), m !== g && i.uploadCommonUniforms(a, m, _.toUnwrapped(), null, u), p.buildingWithFacade && x(p.buildingWithFacade, m);\n      }\n    }\n    function rn(t) {\n      return [t[0] * e.ee, t[1] * e.ee, t[2] * e.ee, 0];\n    }\n    function nn(t, i, o, s, r, n, a, l, c) {\n      const h = s.getSource(),\n        d = o.globeSharedBuffers;\n      if (!d) return;\n      let u, _, p;\n      if (i && (u = s.getTile(i)), h instanceof e.aS ? (_ = h.texture, p = e.dG(0, 0, o.transform)) : u && i && (_ = u.texture, p = e.dG(i.canonical.z, i.canonical.x, o.transform)), !_ || !p) return;\n      t || (p = e.cR(e.bC(), p, [1, -1, 1]));\n      const f = o.context,\n        m = f.gl,\n        g = \"nearest\" === r.paint.get(\"raster-resampling\") ? m.NEAREST : m.LINEAR,\n        v = o.colorModeForDrapableLayerRenderPass(n),\n        y = a.defines;\n      y.push(\"GLOBE_POLES\");\n      const x = new ji(m.LEQUAL, ji.ReadWrite, o.depthRangeFor3D),\n        b = Float32Array.from(o.transform.expandedFarZProjMatrix),\n        w = Float32Array.from(e.bk(e.dF(new e.cC(0, 0, 0))));\n      o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), _.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), _.bind(g, m.CLAMP_TO_EDGE), \"useMipmap\" in _ && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);\n      const [T, E, S, I] = i ? d.getPoleBuffers(i.canonical.z, !1) : d.getPoleBuffers(0, !0),\n        C = r.paint.get(\"raster-elevation\");\n      let R;\n      t ? (R = T, o.renderDefaultNorthPole = 0 !== C) : (R = E, o.renderDefaultSouthPole = 0 !== C);\n      const A = rn(a.mix),\n        D = ((e, t, i, o, s, r, n, a, l, c, h, d, u) => yr(e, t, i, new Float32Array(16), new Float32Array(9), [0, 0], o, [0, 0], [0, 0, 0, 0], 1, {\n          opacity: 1,\n          mix: 0\n        }, r, [0, 0] || [0, 0], a, 2, c, h, d, 1, 0, u))(b, w, p, e.aj(o.transform.zoom), 0, r, 0, C, 0, A, a.offset, a.range, n),\n        L = o.getOrCreateProgram(\"raster\", {\n          defines: y\n        });\n      o.uploadCommonUniforms(f, L, null), L.draw(o, m.TRIANGLES, x, c, v, l, D, r.id, R, S, I);\n    }\n    function an(e) {\n      const t = e._nearZ,\n        i = e.projection.farthestPixelDistance(e),\n        o = i - t,\n        s = .2 * e.height,\n        r = t + s;\n      return [t, i, (r - s - t) / o, (r - t) / o];\n    }\n    function ln(e, t, i, o) {\n      if (e) return t instanceof nt && e instanceof St ? t.getTextureDescriptor(e, i, !0) : {\n        texture: e.texture,\n        mix: rn(o.mix),\n        offset: o.offset,\n        buffer: 0,\n        tileSize: 1\n      };\n    }\n    var cn = e.ef([{\n      name: \"a_index\",\n      type: \"Int16\",\n      components: 1\n    }]);\n    class hn {\n      constructor(t, i, o, s) {\n        const r = {\n            width: o[0],\n            height: o[1],\n            data: null\n          },\n          n = t.gl;\n        this.targetColorTexture = new e.T(t, r, n.RGBA8, {\n          useMipmap: !1\n        }), this.backgroundColorTexture = new e.T(t, r, n.RGBA8, {\n          useMipmap: !1\n        }), this.context = t, this.updateParticleTexture(i, s), this.lastInvalidatedAt = 0;\n      }\n      updateParticleTexture(t, i) {\n        if (this.particleTextureDimension === i.width) return;\n        (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());\n        const o = this.context.gl,\n          s = i.width * i.height;\n        this.particleTexture0 = new e.T(this.context, i, o.RGBA8, {\n          premultiply: !1,\n          useMipmap: !1\n        }), this.particleTexture1 = new e.T(this.context, i, o.RGBA8, {\n          premultiply: !1,\n          useMipmap: !1\n        });\n        const r = new e.eg();\n        r.reserve(s);\n        for (let e = 0; e < s; e++) r.emplaceBack(e);\n        this.particleIndexBuffer = this.context.createVertexBuffer(r, cn.members, !0), this.particleSegment = e.bg.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i.width;\n      }\n      update(t) {\n        return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = e.o.now(), 1));\n      }\n      destroy() {\n        this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();\n      }\n    }\n    function dn(t, i, o) {\n      if (!t) return null;\n      const s = i.getTextureDescriptor(t, o, !0);\n      if (!s) return null;\n      let {\n        texture: r,\n        mix: n,\n        offset: a,\n        tileSize: l,\n        buffer: c,\n        format: h\n      } = s;\n      if (!r || !h) return null;\n      let d = !1;\n      return \"uint32\" === h && (d = !0, n[3] = 0, n = gr(e.eh, n, [0, o.paint.get(\"raster-particle-max-speed\")]), a = vr(e.eh, a, [0, o.paint.get(\"raster-particle-max-speed\")])), {\n        texture: r,\n        textureOffset: [c / (l + 2 * c), l / (l + 2 * c)],\n        tileSize: l,\n        scalarData: d,\n        scale: n,\n        offset: a,\n        defines: [\"RASTER_ARRAY\", {\n          uint8: \"DATA_FORMAT_UINT8\",\n          uint16: \"DATA_FORMAT_UINT16\",\n          uint32: \"DATA_FORMAT_UINT32\"\n        }[h]]\n      };\n    }\n    function un(e) {\n      const t = e._nearZ,\n        i = e.projection.farthestPixelDistance(e),\n        o = i - t,\n        s = .2 * e.height,\n        r = t + s;\n      return [t, i, (r - s - t) / o, (r - t) / o];\n    }\n    const _n = new e.ao(1, 0, 0, 1),\n      pn = new e.ao(0, 1, 0, 1),\n      fn = new e.ao(0, 0, 1, 1),\n      mn = new e.ao(1, 0, 1, 1),\n      gn = new e.ao(0, 1, 1, 1);\n    function vn(t, i, o, s, r, n) {\n      for (let a = 0; a < o.length; a++) if (r) {\n        const r = 1,\n          l = .8,\n          c = new e.ao(s.r * l, s.g * l, s.b * l, 1);\n        yn(t, i, o[a], s, -r, -r, n), yn(t, i, o[a], s, -r, r, n), yn(t, i, o[a], s, r, r, n), yn(t, i, o[a], s, r, -r, n), yn(t, i, o[a], c, 0, 0, n);\n      } else yn(t, i, o[a], s, 0, 0, n);\n    }\n    function yn(t, i, o, s, r, n, a) {\n      const l = t.context,\n        c = t.transform,\n        h = l.gl,\n        d = \"globe\" === c.projection.name,\n        u = d ? [\"PROJECTION_GLOBE_VIEW\"] : [];\n      let _ = e.bz(o.projMatrix);\n      if (d && e.aj(c.zoom) > 0) {\n        const t = e.bj(o.canonical, c),\n          i = e.ei(t);\n        _ = e.aB(new Float32Array(16), c.globeMatrix, i), e.aB(_, c.projMatrix, _);\n      }\n      const p = e.bC();\n      p[12] += 2 * r / (e.o.devicePixelRatio * c.width), p[13] += 2 * n / (e.o.devicePixelRatio * c.height), e.aB(_, p, _);\n      const f = t.getOrCreateProgram(\"debug\", {\n          defines: u\n        }),\n        m = i.getTileByID(o.key);\n      t.terrain && t.terrain.setupElevationDraw(m, f);\n      const g = ji.disabled,\n        v = Gi.disabled,\n        y = t.colorModeForRenderPass(),\n        x = \"$debug\";\n      l.activeTexture.set(h.TEXTURE0), t.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), d ? m._makeGlobeTileDebugBuffers(t.context, c) : m._makeDebugTileBoundsBuffers(t.context, c.projection);\n      const b = m._tileDebugBuffer || t.debugBuffer,\n        w = m._tileDebugIndexBuffer || t.debugIndexBuffer,\n        T = m._tileDebugSegments || t.debugSegments;\n      if (f.draw(t, h.LINE_STRIP, g, v, y, Zi.disabled, pr(_, s.toPremultipliedRenderColor(null)), x, b, w, T, null, null, null, [m._globeTileDebugBorderBuffer]), a) {\n        const e = m.latestRawTileData,\n          i = Math.floor((e && e.byteLength || 0) / 1024);\n        let s = o.canonical.toString();\n        o.overscaledZ !== o.canonical.z && (s += \" => \".concat(o.overscaledZ)), s += \" \".concat(m.state), s += \" \".concat(i, \"kb\"), function (e, t) {\n          e.initDebugOverlayCanvas();\n          const i = e.debugOverlayCanvas,\n            o = e.context.gl,\n            s = e.debugOverlayCanvas.getContext(\"2d\");\n          s.clearRect(0, 0, i.width, i.height), s.shadowColor = \"white\", s.shadowBlur = 2, s.lineWidth = 1.5, s.strokeStyle = \"white\", s.textBaseline = \"top\", s.font = \"bold 36px Open Sans, sans-serif\", s.fillText(t, 5, 5), s.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n        }(t, s);\n      }\n      const E = i.getTile(o).tileSize,\n        S = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5,\n        I = m._tileDebugTextBuffer || t.debugBuffer,\n        C = m._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,\n        R = m._tileDebugTextSegments || t.debugSegments;\n      f.draw(t, h.TRIANGLES, g, v, Ui.alphaBlended, Zi.disabled, pr(_, e.ao.transparent.toPremultipliedRenderColor(null), S), x, I, C, R, null, null, null, [m._globeTileDebugTextBuffer]);\n    }\n    function xn(e, t, i, o) {\n      wn(e, 0, t + i / 2, e.transform.width, i, o);\n    }\n    function bn(e, t, i, o) {\n      wn(e, t - i / 2, 0, i, e.transform.height, o);\n    }\n    function wn(t, i, o, s, r, n) {\n      const a = t.context,\n        l = a.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * e.o.devicePixelRatio, o * e.o.devicePixelRatio, s * e.o.devicePixelRatio, r * e.o.devicePixelRatio), a.clear({\n        color: n\n      }), l.disable(l.SCISSOR_TEST);\n    }\n    const Tn = e.ef([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: En\n      } = Tn;\n    function Sn(e, t, i, o) {\n      e.emplaceBack(t, i, o);\n    }\n    class In {\n      constructor(t) {\n        this.vertexArray = new e.ej(), this.indices = new e.b1(), Sn(this.vertexArray, -1, -1, 1), Sn(this.vertexArray, 1, -1, 1), Sn(this.vertexArray, -1, 1, 1), Sn(this.vertexArray, 1, 1, 1), Sn(this.vertexArray, -1, -1, -1), Sn(this.vertexArray, 1, -1, -1), Sn(this.vertexArray, -1, 1, -1), Sn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, En), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.bg.simpleSegment(0, 0, 36, 12);\n      }\n    }\n    function Cn(t, i, o, s, r, n) {\n      const a = t.context.gl,\n        l = i.paint.get(\"sky-atmosphere-color\"),\n        c = i.paint.get(\"sky-atmosphere-halo-color\"),\n        h = i.paint.get(\"sky-atmosphere-sun-intensity\"),\n        d = ((e, t, i, o, s) => ({\n          u_matrix_3f: e,\n          u_sun_direction: t,\n          u_sun_intensity: i,\n          u_color_tint_r: [o.r, o.g, o.b, o.a],\n          u_color_tint_m: [s.r, s.g, s.b, s.a],\n          u_luminance: 5e-5\n        }))(e.el(e.dL(), s), r, h, l.toPremultipliedRenderColor(null), c.toPremultipliedRenderColor(null));\n      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + n, i.skyboxTexture, 0), o.draw(t, a.TRIANGLES, ji.disabled, Gi.disabled, Ui.unblended, Zi.frontCW, d, \"skyboxCapture\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n    }\n    const Rn = e.ef([{\n      type: \"Float32\",\n      name: \"a_pos\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }]);\n    class An {\n      constructor(t) {\n        const i = new e.em();\n        i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);\n        const o = new e.b1();\n        o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(i, Rn.members), this.indexBuffer = t.createIndexBuffer(o), this.segments = e.bg.simpleSegment(0, 0, 4, 2);\n      }\n      destroy() {\n        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();\n      }\n    }\n    const Dn = e.ef([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_size_scale\",\n      components: 1\n    }, {\n      type: \"Float32\",\n      name: \"a_fade_opacity\",\n      components: 1\n    }]);\n    class Ln {\n      constructor() {\n        this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;\n      }\n    }\n    class Pn {\n      constructor(t) {\n        this.colorModeAlphaBlendedWriteRGB = new Ui([1, Ni, 1, Ni], e.ao.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new Ui([1, 0, 1, 0], e.ao.transparent, [!1, !1, !1, !0]), this.params = new Ln(), this.updateNeeded = !0, t.tp.registerParameter(this.params, [\"Stars\"], \"starsCount\", {\n          min: 100,\n          max: 16e3,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"sizeMultiplier\", {\n          min: .01,\n          max: 2,\n          step: .01\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"sizeRange\", {\n          min: 0,\n          max: 200,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"intensityRange\", {\n          min: 0,\n          max: 200,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        });\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.atmosphereBuffer || this.updateNeeded) {\n          this.updateNeeded = !1, this.atmosphereBuffer = new An(i);\n          const t = this.params.sizeRange,\n            o = this.params.intensityRange,\n            s = function (t) {\n              const i = e.eo(30),\n                o = [];\n              for (let s = 0; s < t; ++s) {\n                const t = 2 * Math.PI * i(),\n                  s = Math.acos(1 - 2 * i()) - .5 * Math.PI;\n                o.push(e.d4(Math.cos(s) * Math.cos(t), Math.cos(s) * Math.sin(t), Math.sin(s)));\n              }\n              return o;\n            }(this.params.starsCount),\n            r = e.eo(300),\n            n = new e.en(),\n            a = new e.b1();\n          let l = 0;\n          for (let i = 0; i < s.length; ++i) {\n            const c = e.c4([], s[i], 200),\n              h = Math.max(0, 1 + .01 * t * (1 * r() - .5)),\n              d = Math.max(0, 1 + .01 * o * (1 * r() - .5));\n            n.emplaceBack(c[0], c[1], c[2], -1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, 1, h, d), n.emplaceBack(c[0], c[1], c[2], -1, 1, h, d), a.emplaceBack(l + 0, l + 1, l + 2), a.emplaceBack(l + 0, l + 2, l + 3), l += 4;\n          }\n          this.starsVx = i.createVertexBuffer(n, Dn.members), this.starsIdx = i.createIndexBuffer(a), this.starsSegments = e.bg.simpleSegment(0, 0, n.length, a.length);\n        }\n      }\n      destroy() {\n        this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();\n      }\n      drawAtmosphereGlow(t, i) {\n        const o = t.context,\n          s = o.gl,\n          r = t.transform,\n          n = new ji(s.LEQUAL, ji.ReadOnly, [0, 1]),\n          a = e.aj(r.zoom),\n          l = t.style.getLut(i.scope),\n          c = \"none\" === i.properties.get(\"color-use-theme\"),\n          h = i.properties.get(\"color\").toNonPremultipliedRenderColor(c ? null : l),\n          d = \"none\" === i.properties.get(\"high-color-use-theme\"),\n          u = i.properties.get(\"high-color\").toNonPremultipliedRenderColor(d ? null : l),\n          _ = \"none\" === i.properties.get(\"space-color-use-theme\"),\n          p = i.properties.get(\"space-color\").toNonPremultipliedRenderColor(_ ? null : l),\n          f = 5e-4,\n          m = e.ep(i.properties.get(\"horizon-blend\"), 0, 1, f, .25),\n          g = e.dA(t, o, r) && m === f ? r.worldSize / (2 * Math.PI * 1.025) - 1 : r.globeRadius,\n          v = t.frameCounter / 1e3 % 1,\n          y = e.ag(r.globeCenterInViewSpace),\n          x = Math.sqrt(Math.pow(y, 2) - Math.pow(g, 2)),\n          b = Math.acos(x / y),\n          w = e => {\n            const i = \"globe\" === r.projection.name ? [\"PROJECTION_GLOBE_VIEW\", \"FOG\"] : [\"FOG\"];\n            e && i.push(\"ALPHA_PASS\");\n            const l = t.getOrCreateProgram(\"globeAtmosphere\", {\n                defines: i\n              }),\n              c = ((e, t, i, o, s, r, n, a, l, c, h, d) => ({\n                u_frustum_tl: e,\n                u_frustum_tr: t,\n                u_frustum_br: i,\n                u_frustum_bl: o,\n                u_horizon: s,\n                u_transition: r,\n                u_fadeout_range: n,\n                u_atmosphere_fog_color: a.toArray01(),\n                u_high_color: l.toArray01(),\n                u_space_color: c.toArray01(),\n                u_temporal_offset: h,\n                u_horizon_angle: d\n              }))(r.frustumCorners.TL, r.frustumCorners.TR, r.frustumCorners.BR, r.frustumCorners.BL, r.frustumCorners.horizon, a, m, h, u, p, v, b);\n            t.uploadCommonUniforms(o, l);\n            const d = this.atmosphereBuffer;\n            d && l.draw(t, s.TRIANGLES, n, Gi.disabled, e ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Zi.backCW, c, e ? \"atmosphere_glow_alpha\" : \"atmosphere_glow\", d.vertexBuffer, d.indexBuffer, d.segments);\n          };\n        w(!1), w(!0);\n      }\n      drawStars(t, i) {\n        const o = e.aA(i.properties.get(\"star-intensity\"), 0, 1);\n        if (0 === o) return;\n        const s = t.context,\n          r = s.gl,\n          n = t.transform,\n          a = t.getOrCreateProgram(\"stars\"),\n          l = e.c6([]);\n        e.c8(l, l, -n._pitch), e.c7(l, l, -n.angle), e.c8(l, l, e.an(n._center.lat)), e.eq(l, l, -e.an(n._center.lng));\n        const c = e.cb(new Float32Array(16), l),\n          h = e.aB([], n.starsProjMatrix, c),\n          d = e.el([], c),\n          u = e.er([], d),\n          _ = [0, 1, 0];\n        e.dN(_, _, u), e.c4(_, _, this.params.sizeMultiplier);\n        const p = [1, 0, 0];\n        e.dN(p, p, u), e.c4(p, p, this.params.sizeMultiplier);\n        const f = (m = _, g = p, v = o, {\n          u_matrix: Float32Array.from(h),\n          u_up: m,\n          u_right: g,\n          u_intensity_multiplier: v\n        });\n        var m, g, v;\n        t.uploadCommonUniforms(s, a), this.starsVx && this.starsIdx && a.draw(t, r.TRIANGLES, ji.disabled, Gi.disabled, this.colorModeAlphaBlendedWriteRGB, Zi.disabled, f, \"atmosphere_stars\", this.starsVx, this.starsIdx, this.starsSegments);\n      }\n    }\n    class zn {\n      constructor() {\n        this.visibleTiles = [];\n      }\n      updateBorders(t, i) {\n        const o = [],\n          s = [],\n          r = t._getRenderableCoordinates(!1, !0);\n        for (const e of r) {\n          const r = t.getTile(e);\n          if (!r.hasData()) continue;\n          const n = r.getBucket(i);\n          n && (n.isEmpty() || (o.push(e.key), s.push({\n            bucket: n,\n            tileID: e.canonical\n          })));\n        }\n        let n = o.length !== this.visibleTiles.length;\n        if (!n) {\n          o.sort();\n          for (let e = 0; e < o.length; e++) if (o[e] !== this.visibleTiles[e]) {\n            n = !0;\n            break;\n          }\n        }\n        if (!n) return;\n        const a = new Set();\n        this.visibleTiles = o, s.sort((e, t) => e.tileID.z - t.tileID.z || e.tileID.x - t.tileID.x || e.tileID.y - t.tileID.y);\n        for (const t of s) {\n          const i = new Array(),\n            o = new Array(),\n            s = t.bucket;\n          for (const e of s.featuresOnBorder) a.has(e.featureId) ? o.push(e.footprintIndex) : (a.add(e.featureId), i.push(e.footprintIndex));\n          s.updateFootprintHiddenFlags(i, e.es, !1), s.updateFootprintHiddenFlags(o, e.es, !0);\n        }\n      }\n    }\n    function On(t, i) {\n      const o = [...t],\n        s = i.cameraWorldSizeForFog / i.worldSize,\n        r = e.bA([]);\n      return e.cR(r, r, [s, s, 1]), e.aB(o, r, o), e.aB(o, i.worldToFogMatrix, o), o;\n    }\n    function Mn(t, i, o, s, r) {\n      const n = o.material,\n        a = s.context,\n        {\n          baseColorTexture: l,\n          metallicRoughnessTexture: c\n        } = n.pbrMetallicRoughness,\n        {\n          normalTexture: h,\n          occlusionTexture: d,\n          emissionTexture: u\n        } = n;\n      function _(e, i, o) {\n        if (e && (t.push(i), a.activeTexture.set(a.gl.TEXTURE0 + o), e.gfxTexture)) {\n          const {\n            minFilter: t,\n            magFilter: i,\n            wrapS: o,\n            wrapT: s\n          } = e.sampler;\n          e.gfxTexture.bindExtraParam(t, i, o, s);\n        }\n      }\n      _(l, \"HAS_TEXTURE_u_baseColorTexture\", Ji.BaseColor), _(c, \"HAS_TEXTURE_u_metallicRoughnessTexture\", Ji.MetallicRoughness), _(h, \"HAS_TEXTURE_u_normalTexture\", Ji.Normal), _(d, \"HAS_TEXTURE_u_occlusionTexture\", Ji.Occlusion), _(u, \"HAS_TEXTURE_u_emissionTexture\", Ji.Emission), r && (r.texture || (r.texture = new e.dY(s.context, r.image, [r.image.height, r.image.height, r.image.height], a.gl.RGBA8)), a.activeTexture.set(a.gl.TEXTURE0 + Ji.LUT), r.texture && r.texture.bind(a.gl.LINEAR, a.gl.CLAMP_TO_EDGE), t.push(\"APPLY_LUT_ON_GPU\")), o.texcoordBuffer && (t.push(\"HAS_ATTRIBUTE_a_uv_2f\"), i.push(o.texcoordBuffer)), o.colorBuffer && (t.push(12 === o.colorBuffer.itemSize ? \"HAS_ATTRIBUTE_a_color_3f\" : \"HAS_ATTRIBUTE_a_color_4f\"), i.push(o.colorBuffer)), o.normalBuffer && (t.push(\"HAS_ATTRIBUTE_a_normal_3f\"), i.push(o.normalBuffer)), o.pbrBuffer && (t.push(\"HAS_ATTRIBUTE_a_pbr\"), t.push(\"HAS_ATTRIBUTE_a_heightBasedEmissiveStrength\"), i.push(o.pbrBuffer)), \"OPAQUE\" !== n.alphaMode && \"MASK\" !== n.alphaMode || t.push(\"UNPREMULT_TEXTURE_IN_SHADER\"), n.defined || t.push(\"DIFFUSE_SHADED\");\n      const p = s.shadowRenderer;\n      p && (t.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), p.useNormalOffset && t.push(\"NORMAL_OFFSET\"));\n    }\n    function Fn(t, i, o, s, r, n) {\n      const a = o.paint.get(\"model-opacity\").constantOr(1),\n        l = i.context,\n        c = new ji(i.context.gl.LEQUAL, ji.ReadWrite, i.depthRangeFor3D),\n        h = i.transform,\n        d = t.mesh,\n        u = d.material,\n        _ = u.pbrMetallicRoughness,\n        p = i.style.fog;\n      let f;\n      f = \"pixels\" === i.transform.projection.zAxisUnit ? [...t.nodeModelMatrix] : e.aB([], s.zScaleMatrix, t.nodeModelMatrix), e.aB(f, s.negCameraPosMatrix, f);\n      const m = e.bl([], f);\n      e.ed(m, m);\n      const g = \"none\" === o.paint.get(\"model-color-use-theme\").constantOr(\"default\"),\n        v = o.paint.get(\"model-emissive-strength\").constantOr(0),\n        y = Dr(new Float32Array(t.worldViewProjection), new Float32Array(f), new Float32Array(m), null, i, a, _.baseColorFactor, u.emissiveFactor, _.metallicFactor, _.roughnessFactor, u, v, o),\n        x = {\n          defines: []\n        },\n        b = [],\n        w = i.shadowRenderer;\n      w && (w.useNormalOffset = !1), Mn(x.defines, b, d, i, g ? null : o.lut);\n      let T = null;\n      if (p) {\n        const e = On(t.nodeModelMatrix, i.transform);\n        if (T = new Float32Array(e), \"globe\" !== h.projection.name) {\n          const t = d.aabb.min,\n            i = d.aabb.max,\n            [o, s] = p.getOpacityForBounds(e, t[0], t[1], i[0], i[1]);\n          x.overrideFog = o >= Be || s >= Be;\n        }\n      }\n      const E = io(i, o.paint.get(\"model-cutoff-fade-range\"));\n      E.shouldRenderCutoff && x.defines.push(\"RENDER_CUTOFF\");\n      const S = i.getOrCreateProgram(\"model\", x);\n      i.uploadCommonUniforms(l, S, null, T, E), \"shadow\" !== i.renderPass && w && w.setupShadowsFromMatrix(t.nodeModelMatrix, S), S.draw(i, l.gl.TRIANGLES, c, r, n, d.material.doubleSided ? Zi.disabled : Zi.backCCW, y, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, i.transform.zoom, void 0, b);\n    }\n    function Bn(t, i, o, s, r, n, a) {\n      let l;\n      l = \"globe\" === t.projection.name ? e.eu(o, t) : [...o], e.aB(l, l, i.matrix);\n      const c = e.aB([], s, l);\n      if (i.meshes) for (const o of i.meshes) {\n        if (\"BLEND\" !== o.material.alphaMode) {\n          a.push({\n            mesh: o,\n            depth: 0,\n            modelIndex: r,\n            worldViewProjection: c,\n            nodeModelMatrix: l\n          });\n          continue;\n        }\n        const i = e.af([], o.centroid, c);\n        !t.isOrthographic && i[2] <= 0 || n.push({\n          mesh: o,\n          depth: i[2],\n          modelIndex: r,\n          worldViewProjection: c,\n          nodeModelMatrix: l\n        });\n      }\n      if (i.children) for (const e of i.children) Bn(t, e, o, s, r, n, a);\n    }\n    function kn(e, t, i, o) {\n      const s = i.shadowRenderer;\n      if (!s) return;\n      const r = s.getShadowPassDepthMode(),\n        n = s.getShadowPassColorMode(),\n        a = s.calculateShadowPassMatrixFromMatrix(t),\n        l = Lr(a);\n      i.getOrCreateProgram(\"modelDepth\", {\n        defines: i._shadowMapDebug ? [] : [\"DEPTH_TEXTURE\"]\n      }).draw(i, i.context.gl.TRIANGLES, r, Gi.disabled, n, Zi.backCCW, l, o.id, e.vertexBuffer, e.indexBuffer, e.segments, o.paint, i.transform.zoom, void 0, void 0);\n    }\n    function Nn(t, i, o) {\n      const s = i.updateZoomBasedPaintProperties(),\n        r = function (t, i, o) {\n          let s,\n            r,\n            n,\n            a = t.terrain ? t.terrain.exaggeration() : 0;\n          if (t.terrain && a > 0) {\n            const i = t.terrain,\n              r = i.findDEMTileFor(o);\n            r && r.dem ? s = e.ew.create(i, o, r) : a = 0;\n          }\n          if (0 === a && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), a === i.validForExaggeration && (0 === a || s && s._demTile && s._demTile.tileID === i.validForDEMTile.id && s._dem._timestamp === i.validForDEMTile.timestamp)) return !1;\n          for (const e in i.instancesPerModel) {\n            const t = i.instancesPerModel[e];\n            for (let e = 0; e < t.instancedDataArray.length; ++e) {\n              const o = (s ? a * s.getElevationAt(0 | t.instancedDataArray.float32[16 * e], 0 | t.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t.instancesEvaluatedElevation[e];\n              t.instancedDataArray.float32[16 * e + 6] = o, r = r ? Math.min(i.terrainElevationMin, o) : o, n = n ? Math.max(i.terrainElevationMax, o) : o;\n            }\n          }\n          return i.terrainElevationMin = r || 0, i.terrainElevationMax = n || 0, i.validForExaggeration = a, i.validForDEMTile = s && s._demTile ? {\n            id: s._demTile.tileID,\n            timestamp: s._dem._timestamp\n          } : {\n            id: void 0,\n            timestamp: 0\n          }, !0;\n        }(t, i, o);\n      (s || r) && (i.uploaded = !1, i.upload(t.context));\n    }\n    const Un = {\n      shadowUniformsInitialized: !1,\n      useSingleShadowCascade: !1,\n      tileMatrix: new Float64Array(16),\n      shadowTileMatrix: new Float32Array(16),\n      aabb: new e.d8([0, 0, 0], [e.al, e.al, 0])\n    };\n    function jn(t, i) {\n      const o = 1 << t.canonical.z,\n        s = i.getFreeCameraOptions().position,\n        r = i.elevation,\n        n = t.canonical.x / o,\n        a = (t.canonical.x + 1) / o,\n        l = t.canonical.y / o,\n        c = (t.canonical.y + 1) / o;\n      let h = i._centerAltitude;\n      if (r) {\n        const e = r.getMinMaxForTile(t);\n        e && e.max > h && (h = e.max);\n      }\n      const d = e.aA(s.x, n, a) - s.x,\n        u = e.aA(s.y, l, c) - s.y,\n        _ = e.ce(h, i.center.lat) - s.z;\n      return i._zoomFromMercatorZ(Math.sqrt(d * d + u * u + _ * _));\n    }\n    function Vn(e, t, i, o, s, r, n) {\n      const a = e.context,\n        l = \"shadow\" === e.renderPass,\n        c = e.shadowRenderer,\n        h = l && c ? c.getShadowPassDepthMode() : new ji(a.gl.LEQUAL, ji.ReadWrite, e.depthRangeFor3D),\n        d = e.isTileAffectedByFog(r);\n      if (i.meshes) for (const u of i.meshes) {\n        const _ = [\"MODEL_POSITION_ON_GPU\"],\n          p = [];\n        let f, m, g;\n        o.instancedDataArray.length > 20 && _.push(\"INSTANCED_ARRAYS\");\n        const v = io(e, t.paint.get(\"model-cutoff-fade-range\"));\n        if (v.shouldRenderCutoff && _.push(\"RENDER_CUTOFF\"), l && c) f = e.getOrCreateProgram(\"modelDepth\", {\n          defines: _\n        }), m = Lr(n.shadowTileMatrix, n.shadowTileMatrix, Float32Array.from(i.matrix)), g = c.getShadowPassColorMode();else {\n          Mn(_, p, u, e, \"none\" === t.paint.get(\"model-color-use-theme\").constantOr(\"default\") ? null : t.lut), f = e.getOrCreateProgram(\"model\", {\n            defines: _,\n            overrideFog: d\n          });\n          const o = u.material,\n            l = o.pbrMetallicRoughness,\n            h = t.paint.get(\"model-opacity\").constantOr(1),\n            y = t.paint.get(\"model-emissive-strength\").constantOr(0);\n          m = Dr(r.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), null, e, h, l.baseColorFactor, o.emissiveFactor, l.metallicFactor, l.roughnessFactor, o, y, t, s), c && (n.shadowUniformsInitialized ? f.setShadowUniformValues(a, c.getShadowUniformValues()) : (c.setupShadows(r.toUnwrapped(), f, \"model-tile\"), n.shadowUniformsInitialized = !0)), g = v.shouldRenderCutoff || h < 1 || \"OPAQUE\" !== o.alphaMode ? Ui.alphaBlended : Ui.unblended;\n        }\n        e.uploadCommonUniforms(a, f, r.toUnwrapped(), null, v);\n        const y = u.material.doubleSided ? Zi.disabled : Zi.backCCW;\n        if (o.instancedDataArray.length > 20) p.push(o.instancedDataBuffer), f.draw(e, a.gl.TRIANGLES, h, Gi.disabled, g, y, m, t.id, u.vertexBuffer, u.indexBuffer, u.segments, t.paint, e.transform.zoom, void 0, p, o.instancedDataArray.length);else {\n          const i = l ? \"u_instance\" : \"u_normal_matrix\";\n          for (let s = 0; s < o.instancedDataArray.length; ++s) m[i] = new Float32Array(o.instancedDataArray.arrayBuffer, 64 * s, 16), f.draw(e, a.gl.TRIANGLES, h, Gi.disabled, g, y, m, t.id, u.vertexBuffer, u.indexBuffer, u.segments, t.paint, e.transform.zoom, void 0, p);\n        }\n      }\n      if (i.children) for (const a of i.children) Vn(e, t, a, o, s, r, n);\n    }\n    const Gn = [1, -1, 1];\n    function Hn(t, i, o, s) {\n      if (!o.modelManager) return !0;\n      const r = o.modelManager;\n      if (!o.shadowRenderer) return !0;\n      const n = o.shadowRenderer,\n        a = i.aabb;\n      let l = !0,\n        c = t.maxHeight;\n      if (0 === c) {\n        let e = 0;\n        for (const i in t.instancesPerModel) {\n          const t = r.getModel(i, s);\n          t ? e = Math.max(e, Math.max(Math.max(t.aabb.max[0], t.aabb.max[1]), t.aabb.max[2])) : l = !1;\n        }\n        c = t.maxScale * e * 1.41 + t.maxVerticalOffset, l && (t.maxHeight = c);\n      }\n      a.max[2] = c, a.min[2] += t.terrainElevationMin, a.max[2] += t.terrainElevationMax, e.af(a.min, a.min, i.tileMatrix), e.af(a.max, a.max, i.tileMatrix);\n      const h = a.intersects(n.getCurrentCascadeFrustum());\n      return 0 === o.currentShadowCascade && (t.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;\n    }\n    function qn(t, i) {\n      const o = t.uniformValues.u_cutoff_params[0],\n        s = t.uniformValues.u_cutoff_params[1],\n        r = t.uniformValues.u_cutoff_params[2],\n        n = t.uniformValues.u_cutoff_params[3];\n      return s === o || n === r ? 1 : e.aA(((i - o) / (s - o) - r) / (n - r), 0, 1);\n    }\n    function Zn(t, i, o, s) {\n      if (i.pitch < 20) return 1;\n      const r = i.getWorldToCameraMatrix();\n      e.aB(r, r, t);\n      const n = e.bU(o.min[0], o.min[1], o.min[2], 1);\n      let a = e.aC(e.ex(), n, r),\n        l = a,\n        c = a;\n      n[1] = o.max[1], a = e.aC(e.ex(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[0] = o.max[0], a = e.aC(e.ex(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[1] = o.min[1], a = e.aC(e.ex(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c;\n      const h = e.aA(s[0], 0, 1),\n        d = 100 * i.pixelsPerMeter * e.aA(s[1], 0, 1),\n        u = e.aA(s[2], 0, 1),\n        _ = e.ey(e.ex(), l, c, h),\n        p = Math.tan(.5 * i.fovX),\n        f = -_[2] * p;\n      if (0 === d) return _[1] < -Math.abs(f) ? u : 1;\n      const m = (-Math.abs(f) - _[1]) / d,\n        g = (e, t, i) => (1 - i) * e + i * t,\n        v = e.aA(g(1, u, m), u, 1);\n      return g(1, v, e.aA((i.pitch - 20) / 20, 0, 1));\n    }\n    class Wn {}\n    class $n {\n      constructor() {\n        this._storage = new Map();\n      }\n      getLinesFromTrianglesBuffer(t, i, o) {\n        {\n          const e = this._storage.get(i.id);\n          if (e) return e.lastUsedFrameIdx = t, e.buf;\n        }\n        const s = o.gl,\n          r = s.getBufferParameter(s.ELEMENT_ARRAY_BUFFER, s.BUFFER_SIZE),\n          n = new ArrayBuffer(r),\n          a = new Int16Array(n);\n        s.getBufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n));\n        const l = new e.eA();\n        for (let e = 0; e < r / 2; e += 3) {\n          const t = a[e],\n            i = a[e + 1],\n            o = a[e + 2];\n          l.emplaceBack(t, i), l.emplaceBack(i, o), l.emplaceBack(o, t);\n        }\n        const c = o.bindVertexArrayOES.current,\n          h = new Wn();\n        return h.buf = new zr(o, l), h.lastUsedFrameIdx = t, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;\n      }\n      update(e) {\n        for (const [t, i] of this._storage) e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t));\n      }\n      destroy() {\n        for (const [e, t] of this._storage) t.buf.destroy(), this._storage.delete(e);\n      }\n    }\n    class Xn {\n      constructor(e) {\n        this.occluderSize = 30, this.depthOffset = -1e-4, e.registerParameter(this, [\"Occlusion\"], \"occluderSize\", {\n          min: 1,\n          max: 100,\n          step: 1\n        }), e.registerParameter(this, [\"Occlusion\"], \"depthOffset\", {\n          min: -.05,\n          max: 0,\n          step: 1e-5\n        });\n      }\n    }\n    const Yn = e.ef([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_rainParticleData\",\n      components: 4\n    }]);\n    class Kn {\n      registerParameter() {}\n      registerButton() {}\n      registerBinding() {}\n      refreshUI() {}\n    }\n    class Jn {\n      constructor(e, t) {\n        this.revealStart = 11, this.revealRange = 2, e.registerParameter(this, [...t, \"Reveal\"], \"revealStart\", {\n          min: 0,\n          max: 17,\n          step: .05\n        }), e.registerParameter(this, [...t, \"Reveal\"], \"revealRange\", {\n          min: .1,\n          max: 5.1,\n          step: .05\n        });\n      }\n    }\n    const Qn = e.ef([{\n      type: \"Float32\",\n      name: \"a_pos_2f\",\n      components: 2\n    }]);\n    class ea {\n      destroy() {\n        this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();\n      }\n      draw(t, i) {\n        const o = t.getOrCreateProgram(\"vignette\");\n        if (!this.vignetteVx || !this.vignetteIdx) {\n          const i = new e.eB(),\n            o = new e.b1();\n          i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1), o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(i, Qn.members), this.vignetteIdx = t.context.createIndexBuffer(o);\n        }\n        const s = e.bg.simpleSegment(0, 0, 4, 6);\n        if (this.vignetteVx && this.vignetteIdx) {\n          t.uploadCommonUniforms(t.context, o);\n          const e = {\n            u_vignetteShape: (r = {\n              vignetteShape: [i.start, i.range, Math.pow(10, i.fadePower)],\n              vignetteColor: [i.color.r, i.color.g, i.color.b, i.color.a * i.strength]\n            }).vignetteShape,\n            u_vignetteColor: r.vignetteColor\n          };\n          o.draw(t, t.context.gl.TRIANGLES, ji.disabled, Gi.disabled, Ui.alphaBlended, Zi.disabled, e, \"vignette\", this.vignetteVx, this.vignetteIdx, s);\n        }\n        var r;\n      }\n    }\n    class ta {\n      constructor() {\n        this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;\n      }\n      update(t, i) {\n        const o = t.getFreeCameraOptions().position,\n          s = o.toAltitude(),\n          r = o.toLngLat(),\n          n = e.an(r.lng),\n          a = e.an(r.lat),\n          l = t.pixelsPerMeter / i,\n          c = n * e.eD,\n          h = e.eD * Math.log(Math.tan(Math.PI / 4 + a / 2));\n        if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;else {\n          const e = -this._offsetYPrev + h,\n            t = -this._elevationPrev + s;\n          this._accumulatedOffsetX += (-this._offsetXPrev + c) * l, this._accumulatedOffsetY += e * l, this._accumulatedElevation += t * l, this._offsetXPrev = c, this._offsetYPrev = h, this._elevationPrev = s;\n        }\n      }\n      getPosition() {\n        return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];\n      }\n    }\n    function ia(e, t) {\n      return [-(e[0] - Math.floor(e[0] / t) * t), -(e[1] - Math.floor(e[1] / t) * t), -(e[2] - Math.floor(e[2] / t) * t)];\n    }\n    function oa(t) {\n      const i = e.eo(1323123451230),\n        o = [];\n      for (let s = 0; s < t; ++s) {\n        const t = 2 * i() - 1,\n          s = 2 * i() - 1,\n          r = 2 * i() - 1;\n        o.push(e.d4(t, s, r));\n      }\n      return o;\n    }\n    function sa(t, i, o, s, r) {\n      const n = e.aA((r - o) / (s - o), 0, 1);\n      return (1 - n) * t + n * i;\n    }\n    class ra {\n      constructor(e) {\n        this._movement = new ta(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new ea(), this._ppmScaleFactor = e;\n      }\n      destroy() {\n        this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();\n      }\n      updateOnRender(t, i) {\n        const o = t.transform;\n        this._movement.update(o, this._ppmScaleFactor);\n        const s = o.starsProjMatrix,\n          r = e.c6([]);\n        e.c8(r, r, e.an(90) - o._pitch), e.c7(r, r, -o.angle);\n        const n = e.cb(new Float32Array(16), r),\n          a = e.eC(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1),\n          l = e.ed([], a),\n          c = e.aB([], l, n),\n          h = Date.now() / 1e3;\n        return this._accumulatedTimeFromStart += (h - this._prevTime) * i, this._prevTime = h, {\n          projectionMatrix: s,\n          modelviewMatrix: c\n        };\n      }\n    }\n    class na extends ra {\n      constructor(e) {\n        super(4.25), this._params = {\n          overrideStyleParameters: !1,\n          intensity: .5,\n          timeFactor: 1,\n          velocityConeAperture: 0,\n          velocity: 300,\n          boxSize: 2500,\n          dropletSizeX: 1,\n          dropletSizeYScale: 10,\n          distortionStrength: 70,\n          screenThinning: {\n            intensity: .57,\n            start: .46,\n            range: 1.17,\n            fadePower: .17,\n            affectedRatio: 1,\n            particleOffset: -.2\n          },\n          color: {\n            r: .66,\n            g: .68,\n            b: .74,\n            a: .7\n          },\n          direction: {\n            x: -50,\n            y: -35\n          },\n          shapeDirPower: 2,\n          shapeNormalPower: 1\n        }, this._revealParams = new Jn(e.tp, [\"Precipitation\", \"Rain\"]), this._vignetteParams = {\n          strength: 1,\n          start: .7,\n          range: 1,\n          fadePower: .4,\n          color: {\n            r: .27,\n            g: .27,\n            b: .27,\n            a: 1\n          }\n        }, this.particlesCount = 16e3;\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.particlesVx) {\n          const t = oa(this.particlesCount),\n            o = new e.eE(),\n            s = new e.b1();\n          let r = 0;\n          const n = e.eo(1323123451230);\n          for (let e = 0; e < t.length; ++e) {\n            const i = t[e],\n              a = [2 * n() - 1, n(), n(), n()];\n            o.emplaceBack(i[0], i[1], i[2], -1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...a), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...a), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;\n          }\n          this.particlesVx = i.createVertexBuffer(o, Yn.members), this.particlesIdx = i.createIndexBuffer(s);\n        }\n      }\n      draw(t) {\n        if (!this._params.overrideStyleParameters && !t.style.rain) return;\n        const i = this._params.overrideStyleParameters ? this._revealParams : {\n            revealStart: 0,\n            revealRange: .01\n          },\n          o = t.transform.zoom;\n        if (i.revealStart > o) return;\n        const s = sa(0, 1, i.revealStart, i.revealStart + i.revealRange, o);\n        if (!this.particlesVx || !this.particlesIdx) return;\n        const r = structuredClone(this._params);\n        let n = [-r.direction.x, r.direction.y, -100];\n        e.aw(n, n);\n        const a = structuredClone(this._vignetteParams);\n        a.strength *= s, r.overrideStyleParameters || (r.intensity = t.style.rain.state.density, r.timeFactor = t.style.rain.state.intensity, r.color = structuredClone(t.style.rain.state.color), n = structuredClone(t.style.rain.state.direction), r.screenThinning.intensity = t.style.rain.state.centerThinning, r.dropletSizeX = t.style.rain.state.dropletSize[0], r.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], r.distortionStrength = 100 * t.style.rain.state.distortionStrength, a.strength = 1, a.color = structuredClone(t.style.rain.state.vignetteColor));\n        const l = this.updateOnRender(t, r.timeFactor),\n          c = t.context,\n          h = c.gl,\n          d = t.transform;\n        this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new e.T(c, {\n          width: t.width,\n          height: t.height,\n          data: null\n        }, h.RGBA8)), r.distortionStrength > 0 && (c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));\n        const u = t.getOrCreateProgram(\"rainParticle\");\n        t.uploadCommonUniforms(c, u), c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);\n        const _ = [r.color.r, r.color.g, r.color.b, r.color.a],\n          p = (i, o) => {\n            const s = ia(this._movement.getPosition(), i),\n              a = r.dropletSizeX,\n              c = r.dropletSizeX * r.dropletSizeYScale,\n              p = t.width / 2,\n              f = t.height / 2,\n              m = sa(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity),\n              g = sa(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity),\n              v = sa(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity),\n              y = (x = {\n                modelview: l.modelviewMatrix,\n                projection: l.projectionMatrix,\n                time: this._accumulatedTimeFromStart,\n                camPos: s,\n                velocityConeAperture: r.velocityConeAperture,\n                velocity: r.velocity,\n                boxSize: i,\n                rainDropletSize: [a, c],\n                distortionStrength: r.distortionStrength,\n                rainDirection: n,\n                color: _,\n                screenSize: [d.width, d.height],\n                thinningCenterPos: [p, f],\n                thinningShape: [m, g, Math.pow(10, r.screenThinning.fadePower)],\n                thinningAffectedRatio: r.screenThinning.affectedRatio,\n                thinningParticleOffset: v,\n                shapeDirectionalPower: r.shapeDirPower,\n                shapeNormalPower: r.shapeNormalPower,\n                mode: o ? 0 : 1\n              }, {\n                u_modelview: Float32Array.from(x.modelview),\n                u_projection: Float32Array.from(x.projection),\n                u_time: x.time,\n                u_cam_pos: x.camPos,\n                u_texScreen: 0,\n                u_velocityConeAperture: x.velocityConeAperture,\n                u_velocity: x.velocity,\n                u_boxSize: x.boxSize,\n                u_rainDropletSize: x.rainDropletSize,\n                u_distortionStrength: x.distortionStrength,\n                u_rainDirection: x.rainDirection,\n                u_color: x.color,\n                u_screenSize: x.screenSize,\n                u_thinningCenterPos: x.thinningCenterPos,\n                u_thinningShape: x.thinningShape,\n                u_thinningAffectedRatio: x.thinningAffectedRatio,\n                u_thinningParticleOffset: x.thinningParticleOffset,\n                u_shapeDirectionalPower: x.shapeDirectionalPower,\n                u_shapeNormalPower: x.shapeNormalPower,\n                u_mode: x.mode\n              });\n            var x;\n            const b = Math.round(r.intensity * this.particlesCount),\n              w = e.bg.simpleSegment(0, 0, 4 * b, 2 * b);\n            u.draw(t, h.TRIANGLES, ji.disabled, Gi.disabled, Ui.alphaBlended, Zi.disabled, y, \"rain_particles\", this.particlesVx, this.particlesIdx, w);\n          };\n        r.distortionStrength > 0 && p(r.boxSize, !0), p(r.boxSize, !1), this._vignette.draw(t, a);\n      }\n    }\n    const aa = e.ef([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_snowParticleData\",\n      components: 4\n    }, {\n      type: \"Float32\",\n      name: \"a_snowParticleDataHorizontalOscillation\",\n      components: 2\n    }]);\n    class la extends ra {\n      constructor(e) {\n        super(2.25), this._params = {\n          overrideStyleParameters: !1,\n          intensity: .85,\n          timeFactor: .75,\n          velocityConeAperture: 70,\n          velocity: 40,\n          horizontalOscillationRadius: 4,\n          horizontalOscillationRate: 1.5,\n          boxSize: 2e3,\n          billboardSize: 2,\n          shapeFadeStart: .27,\n          shapeFadePower: .21,\n          screenThinning: {\n            intensity: .4,\n            start: .15,\n            range: 1.4,\n            fadePower: .24,\n            affectedRatio: 1,\n            particleOffset: -.2\n          },\n          color: {\n            r: 1,\n            g: 1,\n            b: 1,\n            a: 1\n          },\n          direction: {\n            x: -50,\n            y: -35\n          }\n        }, this._revealParams = new Jn(e.tp, [\"Precipitation\", \"Snow\"]), this._vignetteParams = {\n          strength: .3,\n          start: .78,\n          range: .46,\n          fadePower: .2,\n          color: {\n            r: 1,\n            g: 1,\n            b: 1,\n            a: 1\n          }\n        }, this.particlesCount = 16e3;\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.particlesVx) {\n          const t = oa(this.particlesCount),\n            o = new e.eF(),\n            s = new e.b1();\n          let r = 0;\n          const n = e.eo(1323123451230);\n          for (let e = 0; e < t.length; ++e) {\n            const i = t[e],\n              a = n(),\n              l = n(),\n              c = n(),\n              h = [e / t.length, a, l, c],\n              d = [n(), n()];\n            o.emplaceBack(i[0], i[1], i[2], -1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...h, ...d), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;\n          }\n          this.particlesVx = i.createVertexBuffer(o, aa.members), this.particlesIdx = i.createIndexBuffer(s);\n        }\n      }\n      draw(t) {\n        if (!this._params.overrideStyleParameters && !t.style.snow) return;\n        const i = structuredClone(this._params);\n        let o = [-i.direction.x, i.direction.y, -100];\n        e.aw(o, o);\n        const s = structuredClone(this._vignetteParams),\n          r = i.overrideStyleParameters ? this._revealParams : {\n            revealStart: 0,\n            revealRange: .01\n          },\n          n = t.transform.zoom;\n        if (r.revealStart > n) return;\n        const a = sa(0, 1, r.revealStart, r.revealStart + r.revealRange, n);\n        s.strength *= a, i.overrideStyleParameters || (i.intensity = t.style.snow.state.density, i.timeFactor = t.style.snow.state.intensity, i.color = structuredClone(t.style.snow.state.color), o = structuredClone(t.style.snow.state.direction), i.screenThinning.intensity = t.style.snow.state.centerThinning, i.billboardSize = 2.79 * t.style.snow.state.flakeSize, s.strength = 1, s.color = structuredClone(t.style.snow.state.vignetteColor));\n        const l = this.updateOnRender(t, i.timeFactor);\n        if (!this.particlesVx || !this.particlesIdx) return;\n        const c = t.context,\n          h = c.gl,\n          d = t.transform,\n          u = t.getOrCreateProgram(\"snowParticle\");\n        t.uploadCommonUniforms(c, u), ((i, s, r) => {\n          const n = ia(this._movement.getPosition(), i),\n            a = d.width / 2,\n            c = d.height / 2,\n            _ = sa(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity),\n            p = sa(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity),\n            f = sa(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity),\n            m = (g = {\n              modelview: l.modelviewMatrix,\n              projection: l.projectionMatrix,\n              time: this._accumulatedTimeFromStart,\n              camPos: n,\n              velocityConeAperture: r.velocityConeAperture,\n              velocity: r.velocity,\n              horizontalOscillationRadius: r.horizontalOscillationRadius,\n              horizontalOscillationRate: r.horizontalOscillationRate,\n              boxSize: i,\n              billboardSize: 1 * r.billboardSize,\n              simpleShapeParameters: [r.shapeFadeStart, r.shapeFadePower],\n              screenSize: [d.width, d.height],\n              thinningCenterPos: [a, c],\n              thinningShape: [_, p, Math.pow(10, r.screenThinning.fadePower)],\n              thinningAffectedRatio: r.screenThinning.affectedRatio,\n              thinningParticleOffset: f,\n              color: [r.color.r, r.color.g, r.color.b, r.color.a],\n              direction: o\n            }, {\n              u_modelview: Float32Array.from(g.modelview),\n              u_projection: Float32Array.from(g.projection),\n              u_time: g.time,\n              u_cam_pos: g.camPos,\n              u_velocityConeAperture: g.velocityConeAperture,\n              u_velocity: g.velocity,\n              u_horizontalOscillationRadius: g.horizontalOscillationRadius,\n              u_horizontalOscillationRate: g.horizontalOscillationRate,\n              u_boxSize: g.boxSize,\n              u_billboardSize: g.billboardSize,\n              u_simpleShapeParameters: g.simpleShapeParameters,\n              u_screenSize: g.screenSize,\n              u_thinningCenterPos: g.thinningCenterPos,\n              u_thinningShape: g.thinningShape,\n              u_thinningAffectedRatio: g.thinningAffectedRatio,\n              u_thinningParticleOffset: g.thinningParticleOffset,\n              u_particleColor: g.color,\n              u_direction: g.direction\n            });\n          var g;\n          const v = Math.round(r.intensity * this.particlesCount),\n            y = e.bg.simpleSegment(0, 0, 4 * v, 2 * v);\n          this.particlesVx && this.particlesIdx && u.draw(t, h.TRIANGLES, ji.disabled, Gi.disabled, Ui.alphaBlended, Zi.disabled, m, \"snow_particles\", this.particlesVx, this.particlesIdx, y);\n        })(i.boxSize, 0, i), this._vignette.draw(t, s);\n      }\n    }\n    const ca = {\n        symbol: function (t, i, o, s, r) {\n          if (\"translucent\" !== t.renderPass) return;\n          const n = Gi.disabled,\n            a = t.colorModeForRenderPass(),\n            l = o.layout.get(\"text-variable-anchor\"),\n            c = o.layout.get(\"text-size-scale-range\"),\n            h = e.aA(t.scaleFactor, c[0], c[1]);\n          l && function (t, i, o, s, r, n, a, l) {\n            const c = i.transform,\n              h = \"map\" === r,\n              d = \"map\" === n;\n            for (const i of t) {\n              const t = s.getTile(i),\n                r = t.getBucket(o);\n              if (!r || !r.text || !r.text.segments.get().length) continue;\n              const n = e.bK(r.textSizeData, c.zoom, l),\n                u = qt(i, r.getProjection(), c),\n                _ = c.calculatePixelsToTileUnitsMatrix(t),\n                p = Yt(u, t.tileID.canonical, d, h, c, r.getProjection(), _),\n                f = r.hasIconTextFit() && r.hasIconData();\n              n && Gr(r, h, d, a, c, p, i, Math.pow(2, c.zoom - t.tileID.overscaledZ), n, f);\n            }\n          }(s, t, o, i, o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), r, h);\n          const d = 0 !== o.paint.get(\"icon-opacity\").constantOr(1),\n            u = 0 !== o.paint.get(\"text-opacity\").constantOr(1);\n          void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1) && (d || u) ? Hr(t, i, o, s, n, a) : (d && Hr(t, i, o, s, n, a, {\n            onlyIcons: !0\n          }), u && Hr(t, i, o, s, n, a, {\n            onlyText: !0\n          })), i.map.showCollisionBoxes && (Nr(t, i, o, s, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), !0), Nr(t, i, o, s, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), !1));\n        },\n        circle: function (t, i, o, s) {\n          if (\"translucent\" !== t.renderPass) return;\n          const r = o.paint.get(\"circle-opacity\"),\n            n = o.paint.get(\"circle-stroke-width\"),\n            a = o.paint.get(\"circle-stroke-opacity\"),\n            l = void 0 !== o.layout.get(\"circle-sort-key\").constantOr(1),\n            c = o.paint.get(\"circle-emissive-strength\");\n          if (0 === r.constantOr(1) && (0 === n.constantOr(1) || 0 === a.constantOr(1))) return;\n          const h = t.context,\n            d = h.gl,\n            u = t.transform,\n            _ = !(!t.terrain || !t.terrain.enabled),\n            p = o.layout.get(\"circle-elevation-reference\"),\n            f = t.depthModeForSublayer(0, ji.ReadOnly),\n            m = new ji(t.context.gl.LEQUAL, ji.ReadOnly, t.depthRangeFor3D),\n            g = \"none\" === p || _ ? f : m,\n            v = Gi.disabled,\n            y = t.colorModeForDrapableLayerRenderPass(c),\n            x = \"globe\" === u.projection.name,\n            b = [e.aF(u.center.lng), e.aJ(u.center.lat)],\n            w = [];\n          for (let r = 0; r < s.length; r++) {\n            const n = s[r],\n              a = i.getTile(n),\n              c = a.getBucket(o);\n            if (!c || c.projection.name !== u.projection.name) continue;\n            const h = c.programConfigurations.get(o.id),\n              d = c.layoutVertexBuffer,\n              _ = c.globeExtVertexBuffer,\n              p = c.indexBuffer,\n              f = e.dZ(o),\n              m = [_],\n              g = t.isTileAffectedByFog(n);\n            x && f.push(\"PROJECTION_GLOBE_VIEW\"), f.push(\"DEPTH_D24\"), t.terrain && u.depthOcclusionForSymbolsAndCircles && f.push(\"DEPTH_OCCLUSION\"), c.hasElevation && !t.terrain && (f.push(\"ELEVATED_ROADS\"), m.push(c.elevatedLayoutVertexBuffer));\n            const v = t.getOrCreateProgram(\"circle\", {\n                config: h,\n                defines: f,\n                overrideFog: g\n              }),\n              y = u.projection.createInversionMatrix(u, n.canonical),\n              T = {\n                programConfiguration: h,\n                program: v,\n                layoutVertexBuffer: d,\n                dynamicBuffers: m,\n                indexBuffer: p,\n                uniformValues: e.d_(t, n, a, y, b, o),\n                tile: a\n              };\n            if (l) {\n              const t = c.segments.get();\n              for (const i of t) w.push({\n                segments: new e.bg([i]),\n                sortKey: i.sortKey,\n                state: T\n              });\n            } else w.push({\n              segments: c.segments,\n              sortKey: 0,\n              state: T\n            });\n          }\n          l && w.sort((e, t) => e.sortKey - t.sortKey);\n          const T = {\n            useDepthForOcclusion: u.depthOcclusionForSymbolsAndCircles\n          };\n          for (const e of w) {\n            const {\n                programConfiguration: i,\n                program: s,\n                layoutVertexBuffer: r,\n                dynamicBuffers: n,\n                indexBuffer: a,\n                uniformValues: l,\n                tile: c\n              } = e.state,\n              _ = e.segments;\n            t.terrain && t.terrain.setupElevationDraw(c, s, T), t.uploadCommonUniforms(h, s, c.tileID.toUnwrapped()), s.draw(t, d.TRIANGLES, g, v, y, Zi.disabled, l, o.id, r, a, _, o.paint, u.zoom, i, n);\n          }\n        },\n        heatmap: function (t, i, o, s) {\n          if (0 !== o.paint.get(\"heatmap-opacity\")) if (\"offscreen\" === t.renderPass) {\n            const r = t.context,\n              n = r.gl,\n              a = Gi.disabled,\n              l = new Ui([n.ONE, n.ONE, n.ONE, n.ONE], e.ao.transparent, [!0, !0, !0, !0]);\n            !function (e, t, i, o) {\n              const s = e.gl,\n                r = t.width * o,\n                n = t.height * o;\n              e.activeTexture.set(s.TEXTURE1), e.viewport.set([0, 0, r, n]);\n              let a = i.heatmapFbo;\n              if (!a || a && (a.width !== r || a.height !== n)) {\n                a && a.destroy();\n                const t = s.createTexture();\n                s.bindTexture(s.TEXTURE_2D, t), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), a = i.heatmapFbo = e.createFramebuffer(r, n, !0, null), function (e, t, i, o, s, r) {\n                  const n = e.gl;\n                  n.texImage2D(n.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? n.RGBA16F : n.RGBA, s, r, 0, n.RGBA, e.extRenderToTextureHalfFloat ? n.HALF_FLOAT : n.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n                }(e, 0, t, a, r, n);\n              } else s.bindTexture(s.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);\n            }(r, t, o, \"globe\" === t.transform.projection.name ? .5 : .25), r.clear({\n              color: e.ao.transparent\n            });\n            const c = t.transform,\n              h = \"globe\" === c.projection.name,\n              d = h ? [\"PROJECTION_GLOBE_VIEW\"] : [],\n              u = h ? Zi.frontCCW : Zi.disabled,\n              _ = [e.aF(c.center.lng), e.aJ(c.center.lat)];\n            for (let e = 0; e < s.length; e++) {\n              const p = s[e];\n              if (i.hasRenderableParent(p)) continue;\n              const f = i.getTile(p),\n                m = f.getBucket(o);\n              if (!m || m.projection.name !== c.projection.name) continue;\n              const g = t.isTileAffectedByFog(p),\n                v = m.programConfigurations.get(o.id),\n                y = t.getOrCreateProgram(\"heatmap\", {\n                  config: v,\n                  defines: d,\n                  overrideFog: g\n                }),\n                {\n                  zoom: x\n                } = t.transform;\n              t.terrain && t.terrain.setupElevationDraw(f, y), t.uploadCommonUniforms(r, y, p.toUnwrapped());\n              const b = c.projection.createInversionMatrix(c, p.canonical);\n              y.draw(t, n.TRIANGLES, ji.disabled, a, l, u, mr(t, p, f, b, _, x, o.paint.get(\"heatmap-intensity\")), o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t.transform.zoom, v, h ? [m.globeExtVertexBuffer] : null);\n            }\n            r.viewport.set([0, 0, t.width, t.height]);\n          } else \"translucent\" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {\n            const o = t.context,\n              s = o.gl,\n              r = i.heatmapFbo;\n            if (!r) return;\n            o.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, r.colorAttachment.get()), o.activeTexture.set(s.TEXTURE1);\n            let n = i.colorRampTexture;\n            n || (n = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), n.bind(s.LINEAR, s.CLAMP_TO_EDGE), t.getOrCreateProgram(\"heatmapTexture\").draw(t, s.TRIANGLES, ji.disabled, Gi.disabled, t.colorModeForRenderPass(), Zi.disabled, ((e, t, i, o) => ({\n              u_image: 0,\n              u_color_ramp: 1,\n              u_opacity: t.paint.get(\"heatmap-opacity\")\n            }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);\n          }(t, o));\n        },\n        line: function (t, i, o, s) {\n          if (\"translucent\" !== t.renderPass) return;\n          const r = o.paint.get(\"line-opacity\"),\n            n = o.paint.get(\"line-width\");\n          if (0 === r.constantOr(1) || 0 === n.constantOr(1)) return;\n          const a = o.paint.get(\"line-emissive-strength\"),\n            l = o.paint.get(\"line-occlusion-opacity\"),\n            c = o.layout.get(\"line-elevation-reference\"),\n            h = \"meters\" === o.layout.get(\"line-width-unit\"),\n            d = \"sea\" === c,\n            u = !(!t.terrain || !t.terrain.enabled),\n            _ = t.context,\n            p = _.gl;\n          if (o.hasElevatedBuckets && \"globe\" === t.transform.projection.name) return;\n          const f = o.layout.get(\"line-cross-slope\"),\n            m = void 0 !== f,\n            g = f < 1,\n            v = t.colorModeForDrapableLayerRenderPass(a),\n            y = t.terrain && t.terrain.renderingToTexture,\n            x = y ? 1 : e.o.devicePixelRatio,\n            b = o.paint.get(\"line-dasharray\"),\n            w = b.constantOr(1),\n            T = o.layout.get(\"line-cap\"),\n            E = b.constantOr(null),\n            S = T.constantOr(null),\n            I = o.paint.get(\"line-pattern\"),\n            C = I.constantOr(1),\n            R = o.paint.get(\"line-pattern-cross-fade\"),\n            A = I.constantOr(null),\n            D = o.paint.get(\"line-opacity\").constantOr(1);\n          let L = !C && 1 !== D || t.depthOcclusion && l > 0 && l < 1;\n          const P = o.paint.get(\"line-gradient\"),\n            z = C ? \"linePattern\" : \"line\",\n            O = e.d$(o);\n          let M;\n          if (y && t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (L = !1), 0 !== l && t.depthOcclusion) {\n            const t = o.paint._values[\"line-opacity\"];\n            t && t.value && \"constant\" === t.value.kind ? M = t.value : e.w(\"Occlusion opacity for layer \".concat(o.id, \" is supported only when line-opacity isn't data-driven.\"));\n          }\n          \"constant\" !== n.value.kind && !1 === n.value.isLineProgressConstant && O.push(\"VARIABLE_LINE_WIDTH\");\n          const F = (s, r, n, a, c, u) => {\n            for (const f of s) {\n              const s = i.getTile(f);\n              if (C && !s.patternsLoaded()) continue;\n              const m = s.getBucket(o);\n              if (!m) continue;\n              if (\"none\" !== m.elevationType && !c || \"none\" === m.elevationType && c) continue;\n              t.prepareDrawTile();\n              const g = [...r],\n                b = t.shadowRenderer,\n                T = \"road\" === m.elevationType && !!b && b.enabled;\n              let I = [0, 0, 0];\n              if (T) {\n                const e = t.style.directionalLight,\n                  i = t.style.ambientLight;\n                e && i && (I = co(t.style, e, i)), g.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\", \"NORMAL_OFFSET\");\n              }\n              const O = m.programConfigurations.get(o.id);\n              let F = !1;\n              if (A && s.imageAtlas) {\n                const t = e.e0.from(A),\n                  i = t.getPrimary().scaleSelf(x).toString(),\n                  o = s.imageAtlas.patternPositions.get(i),\n                  r = t.getSecondary(),\n                  n = r ? s.imageAtlas.patternPositions.get(r.scaleSelf(x).toString()) : null;\n                F = !!o && !!n, o && O.setConstantPatternPositions(o, n);\n              }\n              R > 0 && (F || O.getPatternTransitionVertexBuffer(\"line-pattern\")) && g.push(\"LINE_PATTERN_TRANSITION\");\n              const B = t.isTileAffectedByFog(f),\n                k = t.getOrCreateProgram(z, {\n                  config: O,\n                  defines: g,\n                  overrideFog: B\n                });\n              if (!C && E && S && s.lineAtlas) {\n                const e = s.lineAtlas.getDash(E, S);\n                e && O.setConstantPatternPositions(e);\n              }\n              T && b.setupShadows(s.tileID.toUnwrapped(), k, \"vector-tile\");\n              let [N, U] = o.paint.get(\"line-trim-offset\");\n              if (\"round\" === S || \"square\" === S) {\n                const e = 1;\n                N !== U && (0 === N && (N -= e), 1 === U && (U += e));\n              }\n              const j = y ? f.projMatrix : null,\n                V = h ? 1 / m.tileToMeter / e.ay(s, 1, t.transform.zoom) : 1,\n                G = h ? 1 / m.tileToMeter / e.ay(s, 1, Math.floor(t.transform.zoom)) : 1,\n                H = C ? e.e1(t, s, o, j, x, V, G, [N, U], I, R) : e.e2(t, s, o, j, m.lineClipsArray.length, x, V, G, [N, U], I);\n              if (P) {\n                const s = m.gradients[o.id];\n                let r = s.texture;\n                if (o.gradientVersion !== s.version) {\n                  let n = 256;\n                  if (o.stepInterpolant) {\n                    const o = i.getSource().maxzoom,\n                      s = f.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - f.canonical.z) : 1;\n                    n = e.aA(e.e3(m.maxLineLength / e.al * 1024 * s), 256, _.maxTextureSize);\n                  }\n                  s.gradient = e.e4({\n                    expression: o.gradientExpression(),\n                    evaluationKey: \"lineProgress\",\n                    resolution: n,\n                    image: s.gradient || void 0,\n                    clips: m.lineClipsArray\n                  }), s.texture ? s.texture.update(s.gradient) : s.texture = new e.T(_, s.gradient, p.RGBA8), s.version = o.gradientVersion, r = s.texture;\n                }\n                _.activeTexture.set(p.TEXTURE1), r.bind(o.stepInterpolant ? p.NEAREST : p.LINEAR, p.CLAMP_TO_EDGE);\n              }\n              w && (_.activeTexture.set(p.TEXTURE0), s.lineAtlasTexture && s.lineAtlasTexture.bind(p.LINEAR, p.REPEAT), O.updatePaintBuffers()), C && (_.activeTexture.set(p.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), O.updatePaintBuffers()), c && !d && t.terrain.setupElevationDraw(s, k), t.uploadCommonUniforms(_, k, f.toUnwrapped());\n              const q = e => {\n                null != M && (M.value = D * l), k.draw(t, p.TRIANGLES, n, e, v, Zi.disabled, H, o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t.transform.zoom, O, [m.layoutVertexBuffer2, m.patternVertexBuffer, m.zOffsetVertexBuffer]), null != M && (M.value = D);\n              };\n              if (L && !c) {\n                const e = t.stencilModeForClipping(f).ref;\n                0 === e && y && _.clear({\n                  stencil: 0\n                });\n                const i = {\n                  func: p.EQUAL,\n                  mask: 255\n                };\n                H.u_alpha_discard_threshold = .8, q(new Gi(i, e, 255, p.KEEP, p.KEEP, p.INVERT)), H.u_alpha_discard_threshold = 0, q(new Gi(i, e, 255, p.KEEP, p.KEEP, p.KEEP));\n              } else H.u_alpha_discard_threshold = L && c && u ? .8 : 0, q(c ? a : t.stencilModeForClipping(f));\n            }\n          };\n          let B = t.depthModeForSublayer(0, ji.ReadOnly);\n          const k = new ji(t.depthOcclusion ? p.GREATER : p.LEQUAL, ji.ReadOnly, t.depthRangeFor3D);\n          if (o.hasNonElevatedBuckets) {\n            const i = !y && t.terrain;\n            0 !== l && i ? e.w(\"Occlusion opacity for layer \".concat(o.id, \" is supported on terrain only if the layer has line-z-offset enabled.\")) : i ? e.w(\"Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: \".concat(o.id, \".\")) : F(s, O, B, Gi.disabled, !1, !0);\n          }\n          if (o.hasElevatedBuckets) {\n            \"hd-road-markup\" === c ? u || (B = k, O.push(\"ELEVATED_ROADS\")) : (O.push(\"ELEVATED\"), B = k, m && O.push(g ? \"CROSS_SLOPE_HORIZONTAL\" : \"CROSS_SLOPE_VERTICAL\"), d && O.push(\"ELEVATION_REFERENCE_SEA\"));\n            const e = L ? t.stencilModeFor3D() : Gi.disabled;\n            t.forceTerrainMode = !0, F(s, O, B, e, !0, !0), L && F(s, O, B, e, !0, !1), t.forceTerrainMode = !1;\n          }\n          L && (t.resetStencilClippingMasks(), y && _.clear({\n            stencil: 0\n          })), 0 === l || t.depthOcclusion || y || t.layersWithOcclusionOpacity.push(t.currentLayer);\n        },\n        fill: function (t, i, o, s) {\n          const r = o.paint.get(\"fill-color\"),\n            n = o.paint.get(\"fill-opacity\");\n          if (0 === n.constantOr(1)) return;\n          const a = o.paint.get(\"fill-emissive-strength\"),\n            l = t.colorModeForDrapableLayerRenderPass(a),\n            c = o.paint.get(\"fill-pattern\"),\n            h = t.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === r.constantOr(e.ao.transparent).a && 1 === n.constantOr(0) ? \"opaque\" : \"translucent\";\n          let d = \"none\";\n          \"none\" !== o.layout.get(\"fill-elevation-reference\") ? d = \"road\" : 0 !== o.paint.get(\"fill-z-offset\").constantOr(1) && (d = \"offset\");\n          const u = !(!t.terrain || !t.terrain.enabled),\n            _ = {\n              painter: t,\n              sourceCache: i,\n              layer: o,\n              coords: s,\n              colorMode: l,\n              elevationType: d,\n              terrainEnabled: u,\n              pass: h\n            };\n          if (\"shadow\" !== t.renderPass) {\n            if (\"offset\" !== d) {\n              if ($r(_, !1), \"road\" === d) {\n                const e = !u && \"translucent\" === t.renderPass;\n                e && Wr(t, i, o, s, \"geometry\"), $r(_, !0, Gi.disabled), e && function (e) {\n                  const {\n                      painter: t,\n                      sourceCache: i,\n                      layer: o,\n                      coords: s,\n                      colorMode: r\n                    } = e,\n                    n = t.context.gl,\n                    a = e.painter.shadowRenderer,\n                    l = !!a && a.enabled,\n                    c = new ji(t.context.gl.LEQUAL, ji.ReadOnly, t.depthRangeFor3D);\n                  let h = [0, 0, 0];\n                  if (l) {\n                    const e = t.style.directionalLight,\n                      i = t.style.ambientLight;\n                    e && i && (h = co(t.style, e, i));\n                  }\n                  const d = e => {\n                    for (const d of s) {\n                      const s = i.getTile(d),\n                        u = s.getBucket(o);\n                      if (!u) continue;\n                      const _ = u.elevatedStructures;\n                      if (!_) continue;\n                      let p, f;\n                      if (e ? (p = _.renderableBridgeSegments, f = _.bridgeProgramConfigurations.get(o.id)) : (p = _.renderableTunnelSegments, f = _.tunnelProgramConfigurations.get(o.id)), !p || 0 === p.segments[0].primitiveLength) continue;\n                      f.updatePaintBuffers(), t.prepareDrawTile();\n                      const m = t.isTileAffectedByFog(d),\n                        g = [];\n                      l && g.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\", \"NORMAL_OFFSET\");\n                      const v = t.getOrCreateProgram(\"elevatedStructures\", {\n                          config: f,\n                          overrideFog: m,\n                          defines: g\n                        }),\n                        y = t.translatePosMatrix(d.projMatrix, s, o.paint.get(\"fill-translate\"), o.paint.get(\"fill-translate-anchor\"));\n                      l && a.setupShadows(s.tileID.toUnwrapped(), v, \"vector-tile\");\n                      const x = lr(y, h);\n                      t.uploadCommonUniforms(t.context, v, d.toUnwrapped()), v.draw(t, n.TRIANGLES, c, Gi.disabled, r, Zi.backCCW, x, o.id, _.vertexBuffer, _.indexBuffer, p, o.paint, t.transform.zoom, f, [_.vertexBufferNormal]);\n                    }\n                  };\n                  d(!0), d(!1);\n                }(_);\n              }\n            } else $r(_, !1, t.stencilModeFor3D());\n          } else t.shadowRenderer && \"road\" === d && !u && function (e) {\n            const {\n                painter: t,\n                sourceCache: i,\n                layer: o,\n                coords: s\n              } = e,\n              r = t.context.gl,\n              n = e.painter.shadowRenderer;\n            for (const e of s) {\n              const s = i.getTile(e),\n                a = s.getBucket(o);\n              if (!a) continue;\n              const l = a.elevatedStructures;\n              if (!l) continue;\n              if (!l.shadowCasterSegments || 0 === l.shadowCasterSegments.segments[0].primitiveLength) continue;\n              t.prepareDrawTile();\n              const c = a.bufferData.programConfigurations.get(o.id),\n                h = t.isTileAffectedByFog(e),\n                d = t.getOrCreateProgram(\"elevatedStructuresDepth\", {\n                  config: c,\n                  overrideFog: h\n                }),\n                u = n.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());\n              t.uploadCommonUniforms(t.context, d, e.toUnwrapped());\n              const _ = {\n                u_matrix: u,\n                u_depth_bias: 0\n              };\n              d.draw(t, r.TRIANGLES, n.getShadowPassDepthMode(), Gi.disabled, n.getShadowPassColorMode(), Zi.disabled, _, o.id, l.vertexBuffer, l.indexBuffer, l.shadowCasterSegments, o.paint, t.transform.zoom, c);\n            }\n          }(_);\n        },\n        \"fill-extrusion\": function (t, i, o, s) {\n          const r = o.paint.get(\"fill-extrusion-opacity\"),\n            n = t.context,\n            a = n.gl,\n            l = t.terrain,\n            c = l && l.renderingToTexture;\n          if (0 === r) return;\n          const h = t.conflationActive && t.style.isLayerClipped(o, i.getSource()),\n            d = t.style.order.indexOf(o.fqid);\n          if (h && function (e, t, i, o, s) {\n            for (const r of o) {\n              const o = t.getTile(r).getBucket(i);\n              o && (o.updateReplacement(r, e.replacementSource, s), o.uploadCentroid(e.context));\n            }\n          }(t, i, o, s, d), l || h) for (const e of s) {\n            const s = i.getTile(e).getBucket(o);\n            s && Jr(t.context, i, e, s, o, l, h);\n          }\n          if (\"shadow\" === t.renderPass && t.shadowRenderer) {\n            const n = t.shadowRenderer;\n            if (l && r < .65 && o._transitionablePaint._values[\"fill-extrusion-opacity\"].value.expression instanceof e.ad) return;\n            const a = n.getShadowPassDepthMode(),\n              c = n.getShadowPassColorMode();\n            Xr(t, i, o, s, a, Gi.disabled, c, h);\n          } else if (\"translucent\" === t.renderPass) {\n            const d = !o.paint.get(\"fill-extrusion-pattern\").constantOr(1),\n              u = o.paint.get(\"fill-extrusion-color\").constantOr(e.ao.white);\n            if (!c && 0 !== u.a) {\n              const e = new ji(t.context.gl.LEQUAL, ji.ReadWrite, t.depthRangeFor3D);\n              1 === r && d ? Xr(t, i, o, s, e, Gi.disabled, Ui.unblended, h) : (Xr(t, i, o, s, e, Gi.disabled, Ui.disabled, h), Xr(t, i, o, s, e, t.stencilModeFor3D(), t.colorModeForRenderPass(), h), t.resetStencilClippingMasks());\n            }\n            if (t.style.enable3dLights() && d && (!l && \"globe\" !== t.transform.projection.name || c)) {\n              const r = o.paint.get(\"fill-extrusion-opacity\"),\n                d = o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"),\n                u = o.paint.get(\"fill-extrusion-ambient-occlusion-ground-radius\"),\n                _ = o.paint.get(\"fill-extrusion-flood-light-intensity\"),\n                p = \"none\" === o.paint.get(\"fill-extrusion-flood-light-color-use-theme\").constantOr(\"default\"),\n                f = o.paint.get(\"fill-extrusion-flood-light-color\").toNonPremultipliedRenderColor(p ? null : o.lut).toArray01().slice(0, 3),\n                m = d > 0 && u > 0,\n                g = _ > 0,\n                v = (e, t, i) => (1 - i) * e + i * t,\n                y = new Yr();\n              y.translate = o.paint.get(\"fill-extrusion-translate\"), y.translateAnchor = o.paint.get(\"fill-extrusion-translate-anchor\"), y.edgeRadius = o.layout.get(\"fill-extrusion-edge-radius\"), y.cutoffFadeRange = o.paint.get(\"fill-extrusion-cutoff-fade-range\");\n              const x = n => {\n                const l = t.depthModeForSublayer(1, ji.ReadOnly, a.LEQUAL, !0),\n                  c = o.paint.get(n ? \"fill-extrusion-ambient-occlusion-ground-attenuation\" : \"fill-extrusion-flood-light-ground-attenuation\"),\n                  p = v(.1, 3, c),\n                  m = t._showOverdrawInspector;\n                if (!m) {\n                  const c = new Gi({\n                      func: a.ALWAYS,\n                      mask: 255\n                    }, 255, 255, a.KEEP, a.KEEP, a.REPLACE),\n                    m = new Ui([a.ONE, a.ONE, a.ONE, a.ONE], e.ao.transparent, [!1, !1, !1, !0], a.MIN);\n                  Kr(y, t, i, o, s, l, c, m, Zi.disabled, n, \"sdf\", r, d, u, _, f, p, h, !1);\n                }\n                {\n                  const c = m ? Gi.disabled : new Gi({\n                      func: a.EQUAL,\n                      mask: 255\n                    }, 255, 255, a.KEEP, a.DECR, a.DECR),\n                    g = m ? t.colorModeForRenderPass() : new Ui([a.ONE_MINUS_DST_ALPHA, a.DST_ALPHA, a.ONE, a.ONE], e.ao.transparent, [!0, !0, !0, !0]);\n                  Kr(y, t, i, o, s, l, c, g, Zi.disabled, n, \"color\", r, d, u, _, f, p, h, !1);\n                }\n              };\n              if (c) {\n                const c = (n, l, c) => {\n                  const p = t.depthModeForSublayer(1, ji.ReadOnly, a.LEQUAL, !1),\n                    m = o.paint.get(n ? \"fill-extrusion-ambient-occlusion-ground-attenuation\" : \"fill-extrusion-flood-light-ground-attenuation\"),\n                    g = v(.1, 3, m);\n                  {\n                    const c = new Ui([a.ONE, a.ONE, a.ONE, a.ONE], e.ao.transparent, [!1, !1, !1, !0]);\n                    Kr(y, t, i, o, s, p, Gi.disabled, c, Zi.disabled, n, \"clear\", r, d, u, _, f, g, h, l);\n                  }\n                  {\n                    const c = new Gi({\n                        func: a.ALWAYS,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.KEEP, a.REPLACE),\n                      m = new Ui([a.ONE, a.ONE, a.ONE, a.ONE], e.ao.transparent, [!1, !1, !1, !0], a.MIN);\n                    Kr(y, t, i, o, s, p, c, m, Zi.disabled, n, \"sdf\", r, d, u, _, f, g, h, l);\n                  }\n                  {\n                    const c = n ? a.ZERO : a.ONE_MINUS_DST_ALPHA,\n                      m = new Gi({\n                        func: a.EQUAL,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.DECR, a.DECR),\n                      v = new Ui([c, a.DST_ALPHA, a.ONE_MINUS_DST_ALPHA, a.ZERO], e.ao.transparent, [!0, !0, !0, !0]);\n                    Kr(y, t, i, o, s, p, m, v, Zi.disabled, n, \"color\", r, d, u, _, f, g, h, l);\n                  }\n                  {\n                    const m = new Ui([a.ONE, a.ONE, a.ONE, n ? a.ZERO : a.ONE], e.ao.transparent, [!1, !1, !1, !0], n ? a.FUNC_ADD : a.MAX);\n                    Kr(y, t, i, o, s, p, Gi.disabled, m, Zi.disabled, n, \"clear\", r, d, u, _, f, g, h, l, c);\n                  }\n                };\n                if (m || g) {\n                  let i;\n                  if (t.prepareDrawTile(), l) {\n                    const t = l.drapeBufferSize[0],\n                      o = l.drapeBufferSize[1];\n                    i = l.framebufferCopyTexture, i && (!i || i.size[0] === t && i.size[1] === o) || (i && i.destroy(), i = l.framebufferCopyTexture = new e.T(n, new e.q({\n                      width: t,\n                      height: o\n                    }), a.RGBA8)), i.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.copyTexSubImage2D(a.TEXTURE_2D, 0, 0, 0, 0, 0, t, o);\n                  }\n                  m && c(!0, !1, i), g && c(!1, !0, i);\n                }\n              } else m && x(!0), g && x(!1), (m || g) && t.resetStencilClippingMasks();\n            }\n          }\n        },\n        building: function (t, i, o, s) {\n          t.currentLayer < t.firstLightBeamLayer && (t.firstLightBeamLayer = t.currentLayer);\n          const r = o.paint.get(\"building-ambient-occlusion-ground-intensity\"),\n            n = o.paint.get(\"building-ambient-occlusion-ground-radius\"),\n            a = o.paint.get(\"building-ambient-occlusion-ground-attenuation\"),\n            l = o.paint.get(\"building-opacity\");\n          if (l <= 0) return;\n          let c = r > 0 && n > 0,\n            h = !0;\n          const d = o.paint.get(\"building-vertical-scale\");\n          (!t.shadowRenderer || d < 1) && (h = !1);\n          const u = t.conflationActive && t.style.isLayerClipped(o, i.getSource()),\n            _ = t.style.order.indexOf(o.fqid);\n          if (function (e, t, i, o, s, r) {\n            for (const n of r) {\n              const r = t.getTile(n).getBucket(i);\n              r && (s && r.updateReplacement(n, e.replacementSource, o), r.uploadUpdatedIndexBuffer(e.context));\n            }\n          }(t, i, o, _, u, s), function (e, t, i, o) {\n            for (const s of o) {\n              const o = t.getTile(s).getBucket(i);\n              o && o.needsEvaluation() && o.uploadUpdatedColorBuffer(e.context);\n            }\n          }(t, i, o, s), o.resetLayerRenderingStats(t), t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !0), \"shadow\" === t.renderPass && t.shadowRenderer) {\n            const e = t.shadowRenderer,\n              r = [],\n              n = e.getShadowPassDepthMode();\n            sn({\n              painter: t,\n              source: i,\n              layer: o,\n              coords: s,\n              defines: r,\n              blendMode: e.getShadowPassColorMode(),\n              depthMode: n,\n              opacity: l,\n              verticalScale: d,\n              facadeEmissiveChance: 0,\n              facadeAOIntensity: 0\n            });\n          } else if (\"translucent\" === t.renderPass) {\n            let _ = [\"HAS_ATTRIBUTE_a_part_color_emissive\", \"LIGHTING_3D_MODE\"];\n            h && (_ = _.concat(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\")), t.shadowRenderer && t.shadowRenderer.useNormalOffset && (_ = _.concat(\"NORMAL_OFFSET\"));\n            const p = o.paint.get(\"building-facade-emissive-chance\"),\n              f = o.paint.get(\"building-ambient-occlusion-intensity\"),\n              m = new ji(t.context.gl.LEQUAL, ji.ReadWrite, t.depthRangeFor3D);\n            l < 1 && sn({\n              painter: t,\n              source: i,\n              layer: o,\n              coords: s,\n              defines: _,\n              blendMode: Ui.disabled,\n              depthMode: m,\n              opacity: l,\n              verticalScale: d,\n              facadeEmissiveChance: p,\n              facadeAOIntensity: f\n            });\n            const g = t.colorModeForRenderPass();\n            sn({\n              painter: t,\n              source: i,\n              layer: o,\n              coords: s,\n              defines: _,\n              blendMode: g,\n              depthMode: m,\n              opacity: l,\n              verticalScale: d,\n              facadeEmissiveChance: p,\n              facadeAOIntensity: f\n            }), c && function (t, i, o, s, r, n, a, l, c, h, d, u, _) {\n              const p = t.context.gl,\n                f = t.depthModeForSublayer(1, ji.ReadOnly, p.LEQUAL, !0),\n                m = .1 * (1 - (g = d)) + 3 * g;\n              var g;\n              const v = t._showOverdrawInspector,\n                y = u,\n                x = new Yr();\n              v || Kr(x, t, i, o, s, f, new Gi({\n                func: p.ALWAYS,\n                mask: 255\n              }, 255, 255, p.KEEP, p.KEEP, p.REPLACE), new Ui([p.ONE, p.ONE, p.ONE, p.ONE], e.ao.transparent, [!1, !1, !1, !0], p.MIN), Zi.disabled, r, \"sdf\", n, a, l, 0, h, m, y, !1);\n              {\n                const c = v ? Gi.disabled : new Gi({\n                    func: p.EQUAL,\n                    mask: 255\n                  }, 255, 255, p.KEEP, p.DECR, p.DECR),\n                  d = v ? t.colorModeForRenderPass() : new Ui([p.ONE_MINUS_DST_ALPHA, p.DST_ALPHA, p.ONE, p.ONE], e.ao.transparent, [!0, !0, !0, !0]);\n                Kr(x, t, i, o, s, f, c, d, Zi.disabled, r, \"color\", n, a, l, 0, h, m, y, !1);\n              }\n            }(t, i, o, s, !0, l, r, n, 0, [0, 0, 0], a, u);\n          } else if (\"light-beam\" === t.renderPass) {\n            const e = [\"HAS_ATTRIBUTE_a_part_color_emissive\", \"HAS_ATTRIBUTE_a_bloom_attenuation\"],\n              r = new ji(t.context.gl.LEQUAL, ji.ReadOnly, t.depthRangeFor3D);\n            sn({\n              painter: t,\n              source: i,\n              layer: o,\n              coords: s,\n              defines: e,\n              blendMode: Ui.alphaBlended,\n              depthMode: r,\n              opacity: l,\n              verticalScale: d,\n              facadeEmissiveChance: 0,\n              facadeAOIntensity: 0\n            });\n          }\n          t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !1), t.resetStencilClippingMasks();\n        },\n        hillshade: function (e, t, i, o) {\n          if (\"offscreen\" !== e.renderPass && \"translucent\" !== e.renderPass) return;\n          if (e.style.disableElevatedTerrain) return;\n          const s = e.context,\n            r = e.terrain && e.terrain.renderingToTexture,\n            [n, a] = \"translucent\" !== e.renderPass || r ? [{}, o] : e.stencilConfigForOverlap(o);\n          for (const o of a) {\n            const s = t.getTile(o);\n            if (s.needsHillshadePrepare && \"offscreen\" === e.renderPass) Ko(e, s, i);else if (\"translucent\" === e.renderPass) {\n              const t = e.depthModeForSublayer(0, ji.ReadOnly),\n                a = i.paint.get(\"hillshade-emissive-strength\"),\n                l = e.colorModeForDrapableLayerRenderPass(a),\n                c = r && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : n[o.overscaledZ];\n              Xo(e, o, s, i, t, c, l);\n            }\n          }\n          s.viewport.set([0, 0, e.width, e.height]), e.resetStencilClippingMasks();\n        },\n        raster: function (t, i, o, s, r, n) {\n          if (\"translucent\" !== t.renderPass) return;\n          if (0 === o.paint.get(\"raster-opacity\")) return;\n          const a = \"globe\" === t.transform.projection.name,\n            l = 0 !== o.paint.get(\"raster-elevation\"),\n            c = l && a;\n          if (t.renderElevatedRasterBackface && !c) return;\n          const h = t.context,\n            d = h.gl,\n            u = i.getSource(),\n            _ = function (t, i, o, s) {\n              const r = i.paint.get(\"raster-color\"),\n                n = \"raster-array\" === t.type,\n                a = [],\n                l = i.paint.get(\"raster-resampling\"),\n                c = i.paint.get(\"raster-color-mix\");\n              let h = i.paint.get(\"raster-color-range\");\n              const d = [c[0], c[1], c[2], 0],\n                u = c[3];\n              let _ = \"nearest\" === l ? s.NEAREST : s.LINEAR;\n              if (n && (a.push(\"RASTER_ARRAY\"), r || a.push(\"RASTER_COLOR\"), \"linear\" === l && a.push(\"RASTER_ARRAY_LINEAR\"), _ = s.NEAREST, !h && t.rasterLayers)) {\n                const e = t.rasterLayers.find(_ref103 => {\n                  let {\n                    id: e\n                  } = _ref103;\n                  return e === i.sourceLayer;\n                });\n                e && e.fields && e.fields.range && (h = e.fields.range);\n              }\n              if (h = h || [0, 1], r) {\n                a.push(\"RASTER_COLOR\"), o.activeTexture.set(s.TEXTURE2), i.updateColorRamp(h);\n                let t = i.colorRampTexture;\n                t || (t = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), t.bind(s.LINEAR, s.CLAMP_TO_EDGE);\n              }\n              return {\n                mix: d,\n                range: h,\n                offset: u,\n                defines: a,\n                resampling: _\n              };\n            }(u, o, h, d);\n          if (u instanceof e.aS && !s.length && !a) return;\n          const p = o.paint.get(\"raster-emissive-strength\"),\n            f = t.colorModeForDrapableLayerRenderPass(p),\n            m = t.terrain && t.terrain.renderingToTexture,\n            g = !t.options.moving,\n            v = \"nearest\" === o.paint.get(\"raster-resampling\") ? d.NEAREST : d.LINEAR;\n          if (u instanceof e.aS && !s.length && (u.onNorthPole || u.onSouthPole)) {\n            const e = l ? t.stencilModeFor3D() : Gi.disabled;\n            return void nn(!!u.onNorthPole, null, t, i, o, p, _, Zi.disabled, e);\n          }\n          if (!s.length) return;\n          const [y, x] = u instanceof e.aS || m ? [{}, s] : t.stencilConfigForOverlap(s),\n            b = x[x.length - 1].overscaledZ;\n          c && _.defines.push(\"PROJECTION_GLOBE_VIEW\"), l && _.defines.push(\"RENDER_CUTOFF\");\n          const w = (s, r, x) => {\n            for (const w of s) {\n              const s = w.toUnwrapped(),\n                T = i.getTile(w);\n              if (m && (!T || !T.hasData())) continue;\n              h.activeTexture.set(d.TEXTURE0);\n              const E = ln(T, u, o, _);\n              if (!E || !E.texture) continue;\n              const {\n                texture: S,\n                mix: I,\n                offset: C,\n                tileSize: R,\n                buffer: A\n              } = E;\n              let D, L;\n              m ? (D = ji.disabled, L = w.projMatrix) : l ? (D = new ji(d.LEQUAL, ji.ReadWrite, t.depthRangeFor3D), L = a ? Float32Array.from(t.transform.expandedFarZProjMatrix) : t.transform.calculateProjMatrix(s, g)) : (D = t.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get(\"raster-opacity\") ? ji.ReadWrite : ji.ReadOnly, d.LESS), L = t.transform.calculateProjMatrix(s, g));\n              const P = t.terrain && m ? t.terrain.stencilModeForRTTOverlap(w) : y[w.overscaledZ],\n                z = n ? 0 : o.paint.get(\"raster-fade-duration\");\n              T.registerFadeDuration(z);\n              const O = i.findLoadedParent(w, 0),\n                M = Gs(T, O, i, t.transform, z);\n              let F, B;\n              !M.isFading && T.refreshedUponExpiration && (T.refreshedUponExpiration = !1), t.terrain && t.terrain.prepareDrawTile(), h.activeTexture.set(d.TEXTURE0), S.bind(v, d.CLAMP_TO_EDGE), h.activeTexture.set(d.TEXTURE1), O ? (O.texture && O.texture.bind(v, d.CLAMP_TO_EDGE), F = Math.pow(2, O.tileID.overscaledZ - T.tileID.overscaledZ), B = [T.tileID.canonical.x * F % 1, T.tileID.canonical.y * F % 1]) : S.bind(v, d.CLAMP_TO_EDGE), \"useMipmap\" in S && h.extTextureFilterAnisotropic && t.transform.pitch > 20 && d.texParameterf(d.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);\n              const k = t.transform;\n              let N;\n              const U = l ? an(k) : [0, 0, 0, 0];\n              let j,\n                V,\n                G,\n                H,\n                q,\n                Z = 0;\n              if (c && u instanceof e.aS && u.coordinates.length > 3) j = Float32Array.from(e.bk(e.dF(new e.cC(0, 0, 0)))), V = Float32Array.from(k.globeMatrix), G = Float32Array.from(e.dB(k)), H = [e.aF(k.center.lng), e.aJ(k.center.lat)], N = u.elevatedGlobePerspectiveTransform, q = u.elevatedGlobeGridMatrix || new Float32Array(9);else if (c) {\n                const t = e.dC(w.canonical);\n                Z = e.dD(t.getCenter().lat), j = Float32Array.from(e.bk(e.dF(w.canonical))), V = Float32Array.from(k.globeMatrix), G = Float32Array.from(e.dB(k)), H = [e.aF(k.center.lng), e.aJ(k.center.lat)], N = [0, 0], q = Float32Array.from(e.dE(w.canonical, t, Z, k.worldSize / k._pixelsPerMercatorPixel));\n              } else N = u instanceof e.aS ? u.perspectiveTransform : [0, 0], j = new Float32Array(16), V = new Float32Array(9), G = new Float32Array(16), H = [0, 0], q = new Float32Array(9);\n              const W = yr(L, j, V, G, q, B || [0, 0], e.aj(t.transform.zoom), H, U, F || 1, M, o, N, l ? o.paint.get(\"raster-elevation\") : 0, 2, I, C, _.range, R, A, p),\n                $ = t.isTileAffectedByFog(w),\n                X = t.getOrCreateProgram(\"raster\", {\n                  defines: _.defines,\n                  overrideFog: $\n                });\n              if (t.uploadCommonUniforms(h, X, s), u instanceof e.aS) {\n                const i = u.elevatedGlobeVertexBuffer,\n                  s = u.elevatedGlobeIndexBuffer;\n                if (m || !a) u.boundsBuffer && u.boundsSegments && X.draw(t, d.TRIANGLES, D, Gi.disabled, f, Zi.disabled, W, o.id, u.boundsBuffer, t.quadTriangleIndexBuffer, u.boundsSegments);else if (i && s) {\n                  const n = k.zoom <= e.cZ ? u.elevatedGlobeSegments : u.getSegmentsForLongitude(k.center.lng);\n                  n && X.draw(t, d.TRIANGLES, D, Gi.disabled, f, r, W, o.id, i, s, n);\n                }\n              } else if (c) {\n                D = new ji(d.LEQUAL, ji.ReadOnly, t.depthRangeFor3D);\n                const e = t.globeSharedBuffers;\n                if (e) {\n                  const [i, s, n] = e.getGridBuffers(Z, !1);\n                  X.draw(t, d.TRIANGLES, D, x || P, t.colorModeForRenderPass(), r, W, o.id, i, s, n);\n                }\n              } else {\n                const {\n                  tileBoundsBuffer: e,\n                  tileBoundsIndexBuffer: i,\n                  tileBoundsSegments: s\n                } = t.getTileBoundsBuffers(T);\n                X.draw(t, d.TRIANGLES, D, P, f, Zi.disabled, W, o.id, e, i, s);\n              }\n            }\n            if (!(u instanceof e.aS) && c) for (const e of s) {\n              const s = e.canonical.y === (1 << e.canonical.z) - 1;\n              0 === e.canonical.y && nn(!0, e, t, i, o, p, _, r, x || Gi.disabled), s && nn(!1, e, t, i, o, p, _, r === Zi.frontCW ? Zi.backCW : Zi.frontCW, x || Gi.disabled);\n            }\n          };\n          c ? w(x, t.renderElevatedRasterBackface ? Zi.backCW : Zi.frontCW, t.stencilModeFor3D()) : w(x, Zi.disabled, void 0), t.resetStencilClippingMasks();\n        },\n        \"raster-particle\": function (t, i, o, s, r, n) {\n          \"offscreen\" === t.renderPass && function (t, i, o, s) {\n            if (!s.length) return;\n            const r = t.context,\n              n = r.gl,\n              a = i.getSource();\n            if (!(a instanceof nt)) return;\n            const l = Math.ceil(Math.sqrt(o.paint.get(\"raster-particle-count\")));\n            let c = o.particlePositionRGBAImage;\n            if (!c || c.width !== l) {\n              const t = function (e) {\n                const t = e * e,\n                  i = new Uint8Array(4 * t),\n                  o = function (e) {\n                    return e |= 0, e = Math.imul(2747636419 ^ e, 2654435769), e = Math.imul(e ^ e >>> 16, 2654435769), ((e = Math.imul(e ^ e >>> 16, 2654435769)) >>> 0) / 4294967296;\n                  },\n                  s = 1 / 1.1;\n                for (let e = 0; e < t; e++) {\n                  const t = s * (o(2 * e + 0) + br),\n                    r = s * (o(2 * e + 1) + br),\n                    n = 255 * t % 1,\n                    a = 255 * r % 1,\n                    l = n,\n                    c = r - a / 255,\n                    h = a;\n                  i[4 * e + 0] = 255 * (t - n / 255), i[4 * e + 1] = 255 * l, i[4 * e + 2] = 255 * c, i[4 * e + 3] = 255 * h;\n                }\n                return i;\n              }(l);\n              c = o.particlePositionRGBAImage = new e.q({\n                width: l,\n                height: l\n              }, t);\n            }\n            let h = o.particleFramebuffer;\n            h ? h.width !== l && (h.destroy(), h = o.particleFramebuffer = r.createFramebuffer(l, l, !0, null)) : h = o.particleFramebuffer = r.createFramebuffer(l, l, !0, null);\n            const d = [];\n            for (const e of s) {\n              const t = i.getTile(e);\n              if (!(t instanceof St)) continue;\n              const s = dn(t, a, o);\n              if (!s) continue;\n              const n = [t.tileSize, t.tileSize];\n              let h = o.tileFramebuffer;\n              h || (h = o.tileFramebuffer = r.createFramebuffer(n[0], n[1], !0, null));\n              let u = t.rasterParticleState;\n              u || (u = t.rasterParticleState = new hn(r, e, n, c));\n              const _ = u.update(o.lastInvalidatedAt);\n              u.particleTextureDimension !== l && u.updateParticleTexture(e, c);\n              const p = u.targetColorTexture;\n              u.targetColorTexture = u.backgroundColorTexture, u.backgroundColorTexture = p;\n              const f = u.particleTexture0;\n              u.particleTexture0 = u.particleTexture1, u.particleTexture1 = f, d.push([e, s, u, _]);\n            }\n            if (0 === d.length) return;\n            const u = e.o.now(),\n              _ = o.previousDrawTimestamp ? .001 * (u - o.previousDrawTimestamp) : .0167;\n            if (o.previousDrawTimestamp = u, o.hasColorMap()) {\n              r.activeTexture.set(n.TEXTURE0 + 2);\n              let t = o.colorRampTexture;\n              t || (t = o.colorRampTexture = new e.T(r, o.colorRamp, n.RGBA8)), t.bind(n.LINEAR, n.CLAMP_TO_EDGE);\n            }\n            r.bindFramebuffer.set(o.tileFramebuffer.framebuffer), function (t, i, o) {\n              const s = t.context,\n                r = s.gl,\n                n = i.tileFramebuffer;\n              s.activeTexture.set(r.TEXTURE0);\n              const a = {\n                  u_texture: 0,\n                  u_opacity: 1.05 * (c = i.paint.get(\"raster-particle-fade-opacity-factor\")) / (c + .05)\n                },\n                l = t.getOrCreateProgram(\"rasterParticleTexture\", {\n                  defines: [],\n                  overrideFog: !1\n                });\n              var c;\n              for (const c of o) {\n                const [,, o, h] = c;\n                n.colorAttachment.set(o.targetColorTexture.texture), s.viewport.set([0, 0, n.width, n.height]), s.clear({\n                  color: e.ao.transparent\n                }), h && (o.backgroundColorTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE), l.draw(t, r.TRIANGLES, ji.disabled, Gi.disabled, Ui.alphaBlended, Zi.disabled, a, i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments));\n              }\n            }(t, o, d), function (t, i, o, s) {\n              const r = t.context,\n                n = r.gl,\n                a = o.tileFramebuffer,\n                l = \"globe\" === t.transform.projection.name,\n                c = o.paint.get(\"raster-particle-max-speed\");\n              for (const h of s) {\n                const [s, d, u] = h;\n                r.activeTexture.set(n.TEXTURE0 + 0), d.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a.colorAttachment.set(u.targetColorTexture.texture);\n                const _ = t.getOrCreateProgram(\"rasterParticleDraw\", {\n                  defines: d.defines,\n                  overrideFog: !1\n                });\n                r.activeTexture.set(n.TEXTURE0 + 1);\n                const p = d.scalarData ? [] : [0, 1, 2, 3].map(t => e.e6[t](s));\n                p.push(s);\n                const f = s.canonical.x,\n                  m = s.canonical.y;\n                for (const e of p) {\n                  const r = i.getTile(l ? e.wrapped() : e);\n                  if (!r) continue;\n                  const a = r.rasterParticleState;\n                  if (!a) continue;\n                  const h = e.canonical.x + (1 << e.canonical.z) * (e.wrap - s.wrap),\n                    u = e.canonical.y;\n                  a.particleTexture0.bind(n.NEAREST, n.CLAMP_TO_EDGE);\n                  const p = Tr(1, a.particleTexture0.size[0], [h - f, u - m], 0, d.texture.size, 2, c, d.textureOffset, d.scale, d.offset);\n                  _.draw(t, n.POINTS, ji.disabled, Gi.disabled, Ui.alphaBlended, Zi.disabled, p, o.id, a.particleIndexBuffer, void 0, a.particleSegment);\n                }\n              }\n            }(t, i, o, d), r.bindFramebuffer.set(o.particleFramebuffer.framebuffer), function (t, i, o, s) {\n              const r = t.context,\n                n = r.gl,\n                a = i.paint.get(\"raster-particle-max-speed\"),\n                l = s * i.paint.get(\"raster-particle-speed-factor\") * .15,\n                c = function (e) {\n                  return Math.pow(e, 6);\n                }(.01 + 1 * i.paint.get(\"raster-particle-reset-rate-factor\")),\n                h = i.particleFramebuffer;\n              r.viewport.set([0, 0, h.width, h.height]);\n              for (const s of o) {\n                const [, o, d] = s;\n                r.activeTexture.set(n.TEXTURE0 + 0), o.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.activeTexture.set(n.TEXTURE0 + 1);\n                const u = d.particleTexture0;\n                u.bind(n.NEAREST, n.CLAMP_TO_EDGE);\n                const _ = Er(1, u.size[0], 0, o.texture.size, a, l, c, o.textureOffset, o.scale, o.offset);\n                h.colorAttachment.set(d.particleTexture1.texture), r.clear({\n                  color: e.ao.transparent\n                }), t.getOrCreateProgram(\"rasterParticleUpdate\", {\n                  defines: o.defines\n                }).draw(t, n.TRIANGLES, ji.disabled, Gi.disabled, Ui.unblended, Zi.disabled, _, i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments);\n              }\n            }(t, o, d, _);\n          }(t, i, o, s), \"translucent\" === t.renderPass && (function (t, i, o, s, r) {\n            const n = t.context,\n              a = n.gl,\n              l = i.getSource().tileSize,\n              c = 5 * (1 - e.ah(e.cK, e.cK + 1, t.transform.zoom)) * l + o.paint.get(\"raster-particle-elevation\"),\n              h = !t.options.moving,\n              d = \"globe\" === t.transform.projection.name;\n            if (!s.length) return;\n            const [u, _] = t.stencilConfigForOverlap(s),\n              p = [];\n            d && p.push(\"PROJECTION_GLOBE_VIEW\");\n            const f = t.stencilModeFor3D();\n            for (const s of _) {\n              const r = s.toUnwrapped(),\n                l = i.getTile(s);\n              if (!l.rasterParticleState) continue;\n              const _ = l.rasterParticleState,\n                m = 100;\n              l.registerFadeDuration(m);\n              const g = i.findLoadedParent(s, 0),\n                v = Gs(l, g, i, t.transform, m);\n              let y, x;\n              t.terrain && t.terrain.prepareDrawTile(), n.activeTexture.set(a.TEXTURE0), _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), n.activeTexture.set(a.TEXTURE1), g && g.rasterParticleState ? (g.rasterParticleState.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), y = Math.pow(2, g.tileID.overscaledZ - l.tileID.overscaledZ), x = [l.tileID.canonical.x * y % 1, l.tileID.canonical.y * y % 1]) : _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n              const b = d ? Float32Array.from(t.transform.expandedFarZProjMatrix) : t.transform.calculateProjMatrix(r, h),\n                w = t.transform,\n                T = un(w),\n                E = e.dC(s.canonical),\n                S = e.dD(E.getCenter().lat);\n              let I, C, R, A, D;\n              d ? (I = Float32Array.from(e.bk(e.dF(s.canonical))), C = Float32Array.from(w.globeMatrix), R = Float32Array.from(e.dB(w)), A = [e.aF(w.center.lng), e.aJ(w.center.lat)], D = Float32Array.from(e.dE(s.canonical, E, S, w.worldSize / w._pixelsPerMercatorPixel))) : (I = new Float32Array(16), C = new Float32Array(9), R = new Float32Array(16), A = [0, 0], D = new Float32Array(9));\n              const L = wr(b, I, C, R, D, x || [0, 0], e.aj(t.transform.zoom), A, T, y || 1, v, c),\n                P = t.isTileAffectedByFog(s),\n                z = t.getOrCreateProgram(\"rasterParticle\", {\n                  defines: p,\n                  overrideFog: P\n                });\n              if (t.uploadCommonUniforms(n, z, r), d) {\n                const e = new ji(a.LEQUAL, ji.ReadOnly, t.depthRangeFor3D),\n                  i = 0,\n                  s = t.globeSharedBuffers;\n                if (s) {\n                  const [r, n, l] = s.getGridBuffers(S, 0 !== i);\n                  z.draw(t, a.TRIANGLES, e, f, Ui.alphaBlended, t.renderElevatedRasterBackface ? Zi.frontCCW : Zi.backCCW, L, o.id, r, n, l);\n                }\n              } else {\n                const e = t.depthModeForSublayer(0, ji.ReadOnly),\n                  i = u[s.overscaledZ],\n                  {\n                    tileBoundsBuffer: r,\n                    tileBoundsIndexBuffer: n,\n                    tileBoundsSegments: c\n                  } = t.getTileBoundsBuffers(l);\n                z.draw(t, a.TRIANGLES, e, i, Ui.alphaBlended, Zi.disabled, L, o.id, r, n, c);\n              }\n            }\n            t.resetStencilClippingMasks();\n          }(t, i, o, s), t.style.map.triggerRepaint());\n        },\n        background: function (t, i, o, s) {\n          const r = o.paint.get(\"background-color\"),\n            n = \"none\" === o.paint.get(\"background-color-use-theme\").constantOr(\"default\"),\n            a = o.paint.get(\"background-opacity\"),\n            l = o.paint.get(\"background-emissive-strength\"),\n            c = \"viewport\" === o.paint.get(\"background-pitch-alignment\");\n          if (0 === a) return;\n          const h = t.context,\n            d = h.gl,\n            u = t.transform,\n            _ = u.tileSize,\n            p = o.paint.get(\"background-pattern\");\n          let f;\n          if (void 0 !== p) {\n            if (null === p) return;\n            if (f = t.imageManager.getPattern(e.I.from(p.toString()), o.scope, t.style.getLut(o.scope)), !f) return;\n          }\n          const m = !p && 1 === r.a && 1 === a && t.opaquePassEnabledForLayer() ? \"opaque\" : \"translucent\";\n          if (t.renderPass !== m) return;\n          const g = Gi.disabled,\n            v = t.depthModeForSublayer(0, \"opaque\" === m ? ji.ReadWrite : ji.ReadOnly),\n            y = t.colorModeForDrapableLayerRenderPass(l),\n            x = p ? \"backgroundPattern\" : \"background\";\n          let b,\n            w = s;\n          if (w || (b = t.getBackgroundTiles(), w = Object.values(b).map(e => e.tileID)), p && (h.activeTexture.set(d.TEXTURE0), t.imageManager.bind(t.context, o.scope)), c) {\n            const i = t.getOrCreateProgram(x, {\n                overrideFog: !1,\n                overrideRtt: !0\n              }),\n              s = new Float32Array(e.bA([])),\n              h = new e.aO(0, 0, 0, 0, 0),\n              u = p ? Rr(s, l, a, t, 0, o.scope, f, c, {\n                tileID: h,\n                tileSize: _\n              }) : Cr(s, l, a, r.toPremultipliedRenderColor(n ? null : o.lut));\n            i.draw(t, d.TRIANGLES, v, g, y, Zi.disabled, u, o.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments);\n          } else for (const e of w) {\n            const m = t.isTileAffectedByFog(e),\n              w = t.getOrCreateProgram(x, {\n                overrideFog: m\n              }),\n              T = e.toUnwrapped(),\n              E = s ? e.projMatrix : t.transform.calculateProjMatrix(T);\n            t.prepareDrawTile();\n            const S = i ? i.getTile(e) : b ? b[e.key] : new Et(e, _, u.zoom, t),\n              I = p ? Rr(E, l, a, t, 0, o.scope, f, c, {\n                tileID: e,\n                tileSize: _\n              }) : Cr(E, l, a, r.toPremultipliedRenderColor(n ? null : o.lut));\n            t.uploadCommonUniforms(h, w, T);\n            const {\n              tileBoundsBuffer: C,\n              tileBoundsIndexBuffer: R,\n              tileBoundsSegments: A\n            } = t.getTileBoundsBuffers(S);\n            w.draw(t, d.TRIANGLES, v, g, y, Zi.disabled, I, o.id, C, R, A);\n          }\n        },\n        sky: function (t, i, o) {\n          const s = t._atmosphere ? e.aj(t.transform.zoom) : 1,\n            r = o.paint.get(\"sky-opacity\") * s;\n          if (0 === r) return;\n          const n = t.context,\n            a = o.paint.get(\"sky-type\"),\n            l = new ji(n.gl.LEQUAL, ji.ReadOnly, [0, 1]),\n            c = t.frameCounter / 1e3 % 1;\n          \"atmosphere\" === a ? \"offscreen\" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, s) {\n            const r = t.context,\n              n = r.gl;\n            let a = i.skyboxFbo;\n            if (!a) {\n              a = i.skyboxFbo = r.createFramebuffer(32, 32, !0, null), i.skyboxGeometry = new In(r), i.skyboxTexture = r.gl.createTexture(), n.bindTexture(n.TEXTURE_CUBE_MAP, i.skyboxTexture), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, n.LINEAR);\n              for (let e = 0; e < 6; ++e) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, n.RGBA, 32, 32, 0, n.RGBA, n.UNSIGNED_BYTE, null);\n            }\n            r.bindFramebuffer.set(a.framebuffer), r.viewport.set([0, 0, 32, 32]);\n            const l = i.getCenter(t, !0),\n              c = t.getOrCreateProgram(\"skyboxCapture\"),\n              h = new Float64Array(16);\n            e.bA(h), e.ek(h, h, .5 * -Math.PI), Cn(t, i, c, h, l, 0), e.bA(h), e.ek(h, h, .5 * Math.PI), Cn(t, i, c, h, l, 1), e.bA(h), e.cT(h, h, .5 * -Math.PI), Cn(t, i, c, h, l, 2), e.bA(h), e.cT(h, h, .5 * Math.PI), Cn(t, i, c, h, l, 3), e.bA(h), Cn(t, i, c, h, l, 4), e.bA(h), e.ek(h, h, Math.PI), Cn(t, i, c, h, l, 5), r.viewport.set([0, 0, t.width, t.height]);\n          }(t, o), o.markSkyboxValid(t)) : \"sky\" === t.renderPass && function (e, t, i, o, s) {\n            const r = e.context,\n              n = r.gl,\n              a = e.transform,\n              l = e.getOrCreateProgram(\"skybox\");\n            r.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_CUBE_MAP, t.skyboxTexture);\n            const c = ((e, t, i, o, s) => ({\n              u_matrix: e,\n              u_sun_direction: t,\n              u_cubemap: 0,\n              u_opacity: o,\n              u_temporal_offset: s\n            }))(a.skyboxMatrix, t.getCenter(e, !1), 0, o, s);\n            e.uploadCommonUniforms(r, l), l.draw(e, n.TRIANGLES, i, Gi.disabled, e.colorModeForRenderPass(), Zi.backCW, c, \"skybox\", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);\n          }(t, o, l, r, c) : \"gradient\" === a && \"sky\" === t.renderPass && function (t, i, o, s, r) {\n            const n = t.context,\n              a = n.gl,\n              l = t.transform,\n              c = t.getOrCreateProgram(\"skyboxGradient\");\n            i.skyboxGeometry || (i.skyboxGeometry = new In(n)), n.activeTexture.set(a.TEXTURE0);\n            let h = i.colorRampTexture;\n            h || (h = i.colorRampTexture = new e.T(n, i.colorRamp, a.RGBA8)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n            const d = ((t, i, o, s, r) => ({\n              u_matrix: t,\n              u_color_ramp: 0,\n              u_center_direction: i,\n              u_radius: e.an(o),\n              u_opacity: s,\n              u_temporal_offset: r\n            }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get(\"sky-gradient-radius\"), s, r);\n            t.uploadCommonUniforms(n, c), c.draw(t, a.TRIANGLES, o, Gi.disabled, t.colorModeForRenderPass(), Zi.backCW, d, \"skyboxGradient\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n          }(t, o, l, r, c);\n        },\n        custom: function (t, i, o, s) {\n          const r = t.context,\n            n = o.implementation;\n          if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(\"custom\") || t.terrain && (t.terrain.renderingToTexture || \"offscreen\" === t.renderPass) && o.isDraped(i)) {\n            if (\"offscreen\" === t.renderPass) {\n              const i = n.prerender;\n              if (i) {\n                if (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), \"globe\" === t.transform.projection.name) {\n                  const o = t.transform.pointMerc;\n                  i.call(n, r.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.aj(t.transform.zoom), [o.x, o.y], t.transform.pixelsPerMeterRatio);\n                } else i.call(n, r.gl, t.transform.customLayerMatrix());\n                r.setDirty(), t.setBaseState();\n              }\n            } else if (\"translucent\" === t.renderPass) {\n              if (t.terrain && t.terrain.renderingToTexture) {\n                const e = n.renderToTile;\n                if (e) {\n                  const i = s[0].canonical,\n                    o = {\n                      x: i.x + s[0].wrap * (n.wrapTileId ? 0 : 1 << i.z),\n                      y: i.y,\n                      z: i.z\n                    };\n                  r.setDepthMode(ji.disabled), r.setStencilMode(Gi.disabled), r.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), e.call(n, r.gl, o), r.setDirty(), t.setBaseState();\n                }\n                return;\n              }\n              t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(Gi.disabled);\n              const i = \"3d\" === n.renderingMode ? new ji(t.context.gl.LEQUAL, ji.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, ji.ReadOnly);\n              if (r.setDepthMode(i), \"globe\" === t.transform.projection.name) {\n                const i = t.transform.pointMerc;\n                n.render(r.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.aj(t.transform.zoom), [i.x, i.y], t.transform.pixelsPerMeterRatio);\n              } else n.render(r.gl, t.transform.customLayerMatrix());\n              r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null);\n            }\n          } else e.w(\"Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.\");\n        },\n        model: function (t, i, o, s) {\n          if (\"opaque\" === t.renderPass) return;\n          const r = o.paint.get(\"model-opacity\").constantOr(1);\n          if (0 === r) return;\n          const n = o.paint.get(\"model-cast-shadows\");\n          if (\"shadow\" === t.renderPass) {\n            if (!n) return;\n            if (t.terrain && r < .65 && o._transitionablePaint._values[\"model-opacity\"].value.expression instanceof e.ad) return;\n          }\n          const a = t.shadowRenderer,\n            l = o.paint.get(\"model-receive-shadows\");\n          a && (a.useNormalOffset = !0, l || (a.enabled = !1));\n          const c = () => {\n              a && (a.useNormalOffset = !0, l || (a.enabled = !0));\n            },\n            h = i.getSource();\n          if (\"light-beam\" === t.renderPass && \"batched-model\" !== h.type) return;\n          if (\"vector\" === h.type || \"geojson\" === h.type) return function (t, i, o, s, r) {\n            const n = t.transform;\n            if (\"mercator\" !== n.projection.name) return void e.w(\"Drawing 3D models for \".concat(n.projection.name, \" projection is not yet implemented\"));\n            const a = n.getFreeCameraOptions().position;\n            if (!t.modelManager) return;\n            const l = t.modelManager;\n            o.modelManager = l;\n            const c = t.shadowRenderer;\n            if (!o._unevaluatedLayout._values.hasOwnProperty(\"model-id\")) return;\n            const h = o._unevaluatedLayout._values[\"model-id\"],\n              d = Object.assign({}, o.layout.get(\"model-id\").parameters),\n              u = t.style.order.indexOf(o.fqid);\n            for (const _ of s) {\n              const s = i.getTile(_).getBucket(o);\n              if (!s || s.projection.name !== n.projection.name) continue;\n              const p = s.getModelUris();\n              p && !s.modelsRequested && (l.addModelsFromBucket(p, r), s.modelsRequested = !0);\n              const f = jn(_, n);\n              d.zoom = f;\n              const m = h.possiblyEvaluate(d);\n              if (Nn(t, s, _), Un.shadowUniformsInitialized = !1, Un.useSingleShadowCascade = !!c && 0 === c.getMaxCascadeForTile(_.toUnwrapped()), \"shadow\" === t.renderPass && c) {\n                if (1 === t.currentShadowCascade && s.isInsideFirstShadowMapFrustum) continue;\n                const i = n.calculatePosMatrix(_.toUnwrapped(), n.worldSize);\n                if (Un.tileMatrix.set(i), Un.shadowTileMatrix = Float32Array.from(c.calculateShadowPassMatrixFromMatrix(i)), Un.aabb.min = [0, 0, 0], Un.aabb.max[0] = Un.aabb.max[1] = e.al, Un.aabb.max[2] = 0, Hn(s, Un, t, o.scope)) continue;\n              }\n              const g = 1 << _.canonical.z,\n                v = [((a.x - _.wrap) * g - _.canonical.x) * e.al, (a.y * g - _.canonical.y) * e.al, a.z * g * e.al];\n              t.conflationActive && Object.keys(s.instancesPerModel).length > 0 && t.style.isLayerClipped(o, i.getSource()) && s.updateReplacement(_, t.replacementSource, u, r) && (s.uploaded = !1, s.upload(t.context));\n              for (let e in s.instancesPerModel) {\n                const i = s.instancesPerModel[e];\n                i.features.length > 0 && (e = m.evaluate(i.features[0].feature, {}));\n                const n = l.getModel(e, r);\n                if (n || l.hasURLBeenRequested(e) || s.modelUris.includes(e) || (s.modelUris.push(e), s.modelsRequested = !1), n && n.uploaded) for (const e of n.nodes) Vn(t, o, e, i, v, _, Un);\n              }\n            }\n          }(t, i, o, s, \"vector\" === h.type ? o.scope : \"\"), void c();\n          if (!h.loaded()) return;\n          if (\"batched-model\" === h.type) return function (t, i, o, s) {\n            o.resetLayerRenderingStats(t);\n            const r = t.context,\n              n = t.transform,\n              a = t.style.fog,\n              l = t.shadowRenderer;\n            if (\"mercator\" !== n.projection.name) return void e.w(\"Drawing 3D landmark models for \".concat(n.projection.name, \" projection is not yet implemented\"));\n            const c = t.transform.getFreeCameraOptions().position,\n              h = e.c4([], [c.x, c.y, c.z], t.transform.worldSize),\n              d = e.et([], h),\n              u = e.bA([]),\n              _ = e.ec(n.center.lat, n.zoom),\n              p = e.bq([], [1, 1, 1 / _]);\n            e.br(u, u, d);\n            const f = o.paint.get(\"model-opacity\").constantOr(1),\n              m = new ji(r.gl.LEQUAL, ji.ReadWrite, t.depthRangeFor3D),\n              g = new ji(r.gl.LEQUAL, ji.ReadOnly, t.depthRangeFor3D),\n              v = new e.d8([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]),\n              y = \"shadow\" === t.renderPass,\n              x = y && l ? l.getCurrentCascadeFrustum() : n.getFrustum(n.scaleZoom(n.worldSize)),\n              b = o.paint.get(\"model-front-cutoff\"),\n              w = b[2] < 1,\n              T = io(t, o.paint.get(\"model-cutoff-fade-range\")),\n              E = o.getLayerRenderingStats();\n            (function (e, t, i, o) {\n              const s = e.terrain ? e.terrain.exaggeration() : 0,\n                r = e.transform.zoom;\n              for (const n of o) {\n                const o = t.getTile(n).getBucket(i);\n                o && (o.setFilter(i.filter), e.conflationActive && o.updateReplacement(n, e.replacementSource), o.evaluateTransform(e, i), e.terrain && s > 0 && o.elevationUpdate(e.terrain, s, n, i.source), o.needsReEvaluation(e, r, i) && o.evaluate(i));\n              }\n            })(t, i, o, s), function () {\n              let c, d, S;\n              w ? (c = s.length - 1, d = -1, S = -1) : (c = 0, d = s.length, S = 1);\n              const I = new Float64Array(16),\n                C = e.cz(),\n                R = new e.P(0, 0);\n              for (let A = c; A !== d; A += S) {\n                const c = s[A],\n                  d = i.getTile(c).getBucket(o);\n                if (!d || !d.uploaded) continue;\n                let S = !1;\n                l && (S = 0 === l.getMaxCascadeForTile(c.toUnwrapped()));\n                const D = n.calculatePosMatrix(c.toUnwrapped(), n.worldSize),\n                  L = d.modelTraits;\n                !y && w && (e.bl(I, D), e.af(C, h, I), R.x = C[0], R.y = C[1]);\n                const P = [];\n                d.setFilter(o.filter);\n                for (const i of d.getNodesInfo()) {\n                  if (i.hiddenByReplacement) continue;\n                  if (!i.node.meshes) continue;\n                  const o = i.node;\n                  let s = 0;\n                  t.terrain && o.elevation && (s = o.elevation * t.terrain.exaggeration());\n                  const r = (() => {\n                      const t = i.aabb;\n                      return v.min = [...t.min], v.max = [...t.max], v.min[2] += s, v.max[2] += s, e.af(v.min, v.min, D), e.af(v.max, v.max, D), v;\n                    })(),\n                    a = i.evaluatedScale;\n                  if (a[0] <= 1 && a[1] <= 1 && a[2] <= 1 && 0 === r.intersects(x)) continue;\n                  if (!y && w) {\n                    const t = 1 / 6;\n                    i.cameraCollisionOpacity = h[0] > r.min[0] && h[0] < r.max[0] && h[1] > r.min[1] && h[1] < r.max[1] && h[2] * _ < r.max[2] && o.footprint && e.b$(R, o.footprint) ? Math.max(i.cameraCollisionOpacity - t, 0) : Math.min(1, i.cameraCollisionOpacity + t);\n                  }\n                  const l = [...D],\n                    d = 1 / e.d6(c.canonical),\n                    u = o.anchor ? o.anchor[0] : 0,\n                    p = o.anchor ? o.anchor[1] : 0;\n                  e.br(l, l, [u * (a[0] - 1) + i.evaluatedTranslation[0] * d, p * (a[1] - 1) + i.evaluatedTranslation[1] * d, s + i.evaluatedTranslation[2]]), e.cp(a, e.ev) || e.cR(l, l, a);\n                  const m = e.aB([], l, o.matrix),\n                    g = e.aB([], n.expandedFarZProjMatrix, m),\n                    E = e.aB([], n.expandedFarZProjMatrix, l),\n                    S = e.aC([], [u, p, s, 1], g)[2];\n                  o.hidden = !1;\n                  let I = f;\n                  y || (w && (I *= i.cameraCollisionOpacity, I *= Zn(l, n, i.aabb, b)), I *= qn(T, S)), 0 !== I ? P.push({\n                    nodeInfo: i,\n                    depth: S,\n                    opacity: I,\n                    wvpForNode: g,\n                    wvpForTile: E,\n                    nodeModelMatrix: m,\n                    tileModelMatrix: l\n                  }) : o.hidden = !0;\n                }\n                y || P.sort((e, t) => !w || 1 === e.opacity && 1 === t.opacity ? e.depth < t.depth ? -1 : 1 : 1 === e.opacity ? -1 : 1 === t.opacity ? 1 : e.depth > t.depth ? -1 : 1);\n                for (const i of P) {\n                  const s = i.nodeInfo,\n                    c = s.node;\n                  let h = e.aB([], p, i.tileModelMatrix);\n                  e.aB(h, u, h);\n                  const d = e.bl([], h);\n                  e.ed(d, d), e.cR(d, d, Gn), h = e.aB(h, h, c.matrix);\n                  const _ = \"light-beam\" === t.renderPass,\n                    f = \"none\" === o.paint.get(\"model-color-use-theme\").constantOr(\"default\"),\n                    v = L & e.ez.HasMapboxMeshFeatures,\n                    x = v ? 0 : s.evaluatedRMEA[0][2];\n                  for (let e = 0; e < c.meshes.length; ++e) {\n                    const u = c.meshes[e],\n                      p = e === c.lightMeshIndex;\n                    let b = i.wvpForNode;\n                    if (p) {\n                      if (!_ && !t.terrain && t.shadowRenderer) {\n                        t.currentLayer < t.firstLightBeamLayer && (t.firstLightBeamLayer = t.currentLayer);\n                        continue;\n                      }\n                      b = i.wvpForTile;\n                    } else if (_) continue;\n                    const w = {\n                        defines: []\n                      },\n                      T = [];\n                    if (!y && l && (l.useNormalOffset = !!u.normalBuffer), Mn(w.defines, T, u, t, f ? null : o.lut), v || w.defines.push(\"DIFFUSE_SHADED\"), S && w.defines.push(\"SHADOWS_SINGLE_CASCADE\"), E && (y ? E.numRenderedVerticesInShadowPass += u.vertexArray.length : E.numRenderedVerticesInTransparentPass += u.vertexArray.length), y) {\n                      kn(u, i.nodeModelMatrix, t, o);\n                      continue;\n                    }\n                    let I = null;\n                    if (a) {\n                      const e = On(i.nodeModelMatrix, t.transform);\n                      if (I = new Float32Array(e), \"globe\" !== n.projection.name) {\n                        const t = u.aabb.min,\n                          i = u.aabb.max,\n                          [o, s] = a.getOpacityForBounds(e, t[0], t[1], i[0], i[1]);\n                        w.overrideFog = o >= Be || s >= Be;\n                      }\n                    }\n                    const C = u.material;\n                    let R;\n                    C.occlusionTexture && C.occlusionTexture.offsetScale && (R = C.occlusionTexture.offsetScale, w.defines.push(\"OCCLUSION_TEXTURE_TRANSFORM\"));\n                    const A = t.getOrCreateProgram(\"model\", w);\n                    !y && l && l.setupShadowsFromMatrix(i.tileModelMatrix, A, l.useNormalOffset), t.uploadCommonUniforms(r, A, null, I);\n                    const D = C.pbrMetallicRoughness;\n                    D.metallicFactor = .9, D.roughnessFactor = .5;\n                    const L = Dr(new Float32Array(b), new Float32Array(h), new Float32Array(d), new Float32Array(c.matrix), t, i.opacity, D.baseColorFactor, C.emissiveFactor, D.metallicFactor, D.roughnessFactor, C, x, o, [0, 0, 0], R);\n                    !p && (s.hasTranslucentParts || i.opacity < 1) && A.draw(t, r.gl.TRIANGLES, m, Gi.disabled, Ui.disabled, Zi.backCCW, L, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t.transform.zoom, void 0, T), A.draw(t, r.gl.TRIANGLES, p ? g : m, Gi.disabled, p || i.opacity < 1 || s.hasTranslucentParts ? Ui.alphaBlended : Ui.unblended, Zi.backCCW, L, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t.transform.zoom, void 0, T);\n                  }\n                }\n              }\n            }();\n          }(t, i, o, s), void c();\n          if (\"model\" !== h.type) return;\n          const d = h.getModels(),\n            u = [],\n            _ = t.transform.getFreeCameraOptions().position,\n            p = e.c4([], [_.x, _.y, _.z], t.transform.worldSize);\n          e.et(p, p);\n          const f = [],\n            m = [];\n          let g = 0;\n          for (const i of d) {\n            const s = o.paint.get(\"model-rotation\").constantOr(null),\n              r = o.paint.get(\"model-scale\").constantOr(null),\n              n = o.paint.get(\"model-translation\").constantOr(null);\n            i.computeModelMatrix(t, s, r, n, !0, !0, !1);\n            const a = e.bA([]),\n              l = e.ec(i.position.lat, t.transform.zoom),\n              c = e.bq([], [1, 1, 1 / l]);\n            e.br(a, a, p), u.push({\n              zScaleMatrix: c,\n              negCameraPosMatrix: a\n            });\n            for (const e of i.nodes) Bn(t.transform, e, i.matrix, t.transform.expandedFarZProjMatrix, g, f, m);\n            g++;\n          }\n          if (f.sort((e, t) => t.depth - e.depth), \"shadow\" !== t.renderPass) {\n            if (1 === r) for (const e of m) Fn(e, t, o, u[e.modelIndex], Gi.disabled, t.colorModeForRenderPass());else {\n              for (const e of m) Fn(e, t, o, u[e.modelIndex], Gi.disabled, Ui.disabled);\n              for (const e of m) Fn(e, t, o, u[e.modelIndex], t.stencilModeFor3D(), t.colorModeForRenderPass());\n              t.resetStencilClippingMasks();\n            }\n            for (const e of f) Fn(e, t, o, u[e.modelIndex], Gi.disabled, t.colorModeForRenderPass());\n            c();\n          } else {\n            for (const e of m) kn(e.mesh, e.nodeModelMatrix, t, o);\n            for (const e of f) kn(e.mesh, e.nodeModelMatrix, t, o);\n            c();\n          }\n        }\n      },\n      ha = {\n        line: function (e, t, i) {\n          if (e.hasElevatedBuckets = !1, e.hasNonElevatedBuckets = !1, void 0 !== e._unevaluatedLayout.getValue(\"line-elevation-reference\") || void 0 !== e._unevaluatedLayout.getValue(\"line-z-offset\")) {\n            if (t) {\n              const i = t.getVisibleCoordinates();\n              for (const o of i) {\n                const i = t.getTile(o).getBucket(e);\n                if (i && (\"none\" !== i.elevationType ? e.hasElevatedBuckets = !0 : e.hasNonElevatedBuckets = !0, e.hasElevatedBuckets && e.hasNonElevatedBuckets)) break;\n              }\n            }\n          } else e.hasNonElevatedBuckets = !0;\n        },\n        model: function (e, t, i) {\n          const o = t.getSource();\n          if (!o.loaded()) return;\n          if (\"vector\" === o.type || \"geojson\" === o.type) return void (i.modelManager && i.modelManager.upload(i, \"vector\" === o.type ? e.scope : \"\"));\n          if (\"batched-model\" === o.type) return;\n          if (\"model\" !== o.type) return;\n          const s = o.getModels();\n          for (const e of s) e.upload(i.context);\n        },\n        raster: function (e, t, i) {\n          const o = t.getSource();\n          if (!(o instanceof nt && o.loaded())) return;\n          const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];\n          if (!s) return;\n          const r = e.paint.get(\"raster-array-band\") || o.getInitialBand(s);\n          if (null == r) return;\n          const n = t.getIds().map(e => t.getTileByID(e));\n          for (const t of n) t.updateNeeded(e.id, r) && o.prepareTile(t, s, e.id, r);\n        },\n        \"raster-particle\": function (e, t, i) {\n          const o = t.getSource();\n          if (!(o instanceof nt && o.loaded())) return;\n          const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];\n          if (!s) return;\n          const r = e.paint.get(\"raster-particle-array-band\") || o.getInitialBand(s);\n          if (null == r) return;\n          const n = t.getIds().map(e => t.getTileByID(e));\n          for (const t of n) t.updateNeeded(e.id, r) && o.prepareTile(t, s, e.id, r);\n        }\n      },\n      da = {\n        fill: Wr\n      },\n      ua = {\n        fill: function (e, t, i, o) {\n          if (!i.layout || \"none\" === i.layout.get(\"fill-elevation-reference\")) return;\n          const s = e.context.gl,\n            r = new ji(s.LEQUAL, ji.ReadOnly, e.depthRangeFor3D),\n            n = new Gi({\n              func: s.ALWAYS,\n              mask: 255\n            }, 255, 255, s.KEEP, s.KEEP, s.REPLACE),\n            a = e.transform.getFreeCameraOptions().position,\n            l = e.getOrCreateProgram(\"elevatedStructuresDepthReconstruct\");\n          for (const c of o) {\n            const o = t.getTile(c),\n              h = o.getBucket(i);\n            if (!h) continue;\n            const d = h.elevatedStructures;\n            if (!d || 0 === d.depthSegments.segments[0].primitiveLength) continue;\n            const u = Zr(c.toUnwrapped(), a),\n              _ = e.translatePosMatrix(c.projMatrix, o, i.paint.get(\"fill-translate\"), i.paint.get(\"fill-translate-anchor\")),\n              p = cr(_, u, 0, 1, 0);\n            l.draw(e, s.TRIANGLES, r, n, Ui.disabled, Zi.disabled, p, i.id, d.vertexBuffer, d.indexBuffer, d.depthSegments, i.paint, e.transform.zoom);\n          }\n        }\n      };\n    class _a {\n      constructor(t, i, o, s, r, n) {\n        this.context = new Br(t, i), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r, this._timeStamp = e.o.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {\n          forceEnablePrecipitation: !1,\n          showTerrainProxyTiles: !1,\n          fpsWindow: 30,\n          continousRedraw: !1,\n          enabledLayers: {}\n        };\n        const a = [\"fill\", \"line\", \"symbol\", \"circle\", \"heatmap\", \"fill-extrusion\", \"building\", \"raster\", \"raster-particle\", \"hillshade\", \"model\", \"background\", \"sky\"];\n        for (const e of a) this._debugParams.enabledLayers[e] = !0;\n        r.registerParameter(this._debugParams, [\"Terrain\"], \"showTerrainProxyTiles\", {}, () => {\n          this.style.map.triggerRepaint();\n        }), r.registerParameter(this._debugParams, [\"Precipitation\"], \"forceEnablePrecipitation\"), r.registerParameter(this._debugParams, [\"FPS\"], \"fpsWindow\", {\n          min: 1,\n          max: 100,\n          step: 1\n        }), r.registerBinding(this._debugParams, [\"FPS\"], \"continousRedraw\", {\n          readonly: !0,\n          label: \"continuous redraw\"\n        }), r.registerBinding(this, [\"FPS\"], \"_averageFPS\", {\n          readonly: !0,\n          label: \"value\"\n        }), r.registerBinding(this, [\"FPS\"], \"_averageFPS\", {\n          readonly: !0,\n          label: \"graph\",\n          view: \"graph\",\n          min: 0,\n          max: 200\n        });\n        for (const e of a) r.registerParameter(this._debugParams.enabledLayers, [\"Debug\", \"Layers\"], e);\n        this.occlusionParams = new Xn(r), this.setup(), this.numSublayers = Rt.maxUnderzooming + Rt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.eG(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new no(this), this._wireframeDebugCache = new $n(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];\n        const l = new e.q({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0));\n        this.emptyDepthTexture = new e.T(this.context, l, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = s, this.worldview = n;\n      }\n      updateTerrain(e, t) {\n        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;\n        if (!(i || this._terrain && this._terrain.enabled)) return;\n        this._terrain || (this._terrain = new Ws(this, e));\n        const o = this._terrain;\n        this.transform.elevation = i ? o : null, o.update(e, this.transform, t), this.transform.elevation && !o.enabled && (this.transform.elevation = null);\n      }\n      _updateFog(e) {\n        const t = e.fog;\n        if (!t || \"globe\" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get(\"horizon-blend\") < .03) return void (this.transform.fogCullDistSq = null);\n        const [i, o] = t.getFovAdjustedRange(this.transform._fov);\n        if (i > o) return void (this.transform.fogCullDistSq = null);\n        const s = i + .78 * (o - i);\n        this.transform.fogCullDistSq = s * s;\n      }\n      get terrain() {\n        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;\n      }\n      get forceTerrainMode() {\n        return this._forceTerrainMode;\n      }\n      set forceTerrainMode(e) {\n        e && !this._terrain && (this._terrain = new Ws(this, this.style)), this._forceTerrainMode = e;\n      }\n      get shadowRenderer() {\n        return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;\n      }\n      get wireframeDebugCache() {\n        return this._wireframeDebugCache;\n      }\n      resize(t, i) {\n        if (this.width = t * e.o.devicePixelRatio, this.height = i * e.o.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._mergedLayers[e].resize();\n      }\n      setup() {\n        const t = this.context,\n          i = new e.bd();\n        i.emplaceBack(0, 0), i.emplaceBack(e.al, 0), i.emplaceBack(0, e.al), i.emplaceBack(e.al, e.al), this.tileExtentBuffer = t.createVertexBuffer(i, e.bf.members), this.tileExtentSegments = e.bg.simpleSegment(0, 0, 4, 2);\n        const o = new e.bd();\n        o.emplaceBack(0, 0), o.emplaceBack(e.al, 0), o.emplaceBack(0, e.al), o.emplaceBack(e.al, e.al), this.debugBuffer = t.createVertexBuffer(o, e.bf.members), this.debugSegments = e.bg.simpleSegment(0, 0, 4, 5);\n        const s = new e.bd();\n        s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(-1, 1), s.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(s, e.bf.members), this.viewportSegments = e.bg.simpleSegment(0, 0, 4, 2);\n        const r = new e.b0();\n        r.emplaceBack(0, 0, 0, 0), r.emplaceBack(e.al, 0, e.al, 0), r.emplaceBack(0, e.al, 0, e.al), r.emplaceBack(e.al, e.al, e.al, e.al), this.mercatorBoundsBuffer = t.createVertexBuffer(r, e.bi.members), this.mercatorBoundsSegments = e.bg.simpleSegment(0, 0, 4, 2);\n        const n = new e.b1();\n        n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(n);\n        const a = new e.be();\n        for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e);\n        this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.T(t, new e.q({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = e.bC();\n        const l = this.context.gl;\n        this.stencilClearMode = new Gi({\n          func: l.ALWAYS,\n          mask: 0\n        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());\n      }\n      getMercatorTileBoundsBuffers() {\n        return {\n          tileBoundsBuffer: this.mercatorBoundsBuffer,\n          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,\n          tileBoundsSegments: this.mercatorBoundsSegments\n        };\n      }\n      getTileBoundsBuffers(e) {\n        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {\n          tileBoundsBuffer: e._tileBoundsBuffer,\n          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,\n          tileBoundsSegments: e._tileBoundsSegments\n        } : this.getMercatorTileBoundsBuffers();\n      }\n      clearStencil() {\n        const e = this.context.gl;\n        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram(\"clippingMask\").draw(this, e.TRIANGLES, ji.disabled, this.stencilClearMode, Ui.disabled, Zi.disabled, Vs(this.identityMat), \"$clipping\", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n      }\n      resetStencilClippingMasks() {\n        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});\n      }\n      _renderTileClippingMasks(e, t, i) {\n        if (!t || this.currentStencilSource === t.id || !e.isTileClipped() || !i || 0 === i.length) return;\n        if (this._tileClippingMaskIDs && !this.terrain) {\n          let e = !1;\n          for (const t of i) if (void 0 === this._tileClippingMaskIDs[t.key]) {\n            e = !0;\n            break;\n          }\n          if (!e) return;\n        }\n        this.currentStencilSource = t.id;\n        const o = this.context,\n          s = o.gl;\n        this.nextStencilID + i.length > 256 && this.clearStencil(), o.setColorMode(Ui.disabled), o.setDepthMode(ji.disabled);\n        const r = this.getOrCreateProgram(\"clippingMask\");\n        this._tileClippingMaskIDs = {};\n        for (const e of i) {\n          const i = t.getTile(e),\n            o = this._tileClippingMaskIDs[e.key] = this.nextStencilID++,\n            {\n              tileBoundsBuffer: n,\n              tileBoundsIndexBuffer: a,\n              tileBoundsSegments: l\n            } = this.getTileBoundsBuffers(i);\n          r.draw(this, s.TRIANGLES, ji.disabled, new Gi({\n            func: s.ALWAYS,\n            mask: 0\n          }, o, 255, s.KEEP, s.KEEP, s.REPLACE), Ui.disabled, Zi.disabled, Vs(e.projMatrix), \"$clipping\", n, a, l);\n        }\n      }\n      stencilModeFor3D() {\n        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n        const e = this.nextStencilID++,\n          t = this.context.gl;\n        return new Gi({\n          func: t.NOTEQUAL,\n          mask: 255\n        }, e, 255, t.KEEP, t.KEEP, t.REPLACE);\n      }\n      stencilModeForClipping(e) {\n        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e);\n        const t = this.context.gl;\n        return new Gi({\n          func: t.EQUAL,\n          mask: 255\n        }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);\n      }\n      stencilConfigForOverlap(e) {\n        const t = this.context.gl,\n          i = e.sort((e, t) => t.overscaledZ - e.overscaledZ),\n          o = i[i.length - 1].overscaledZ,\n          s = i[0].overscaledZ - o + 1;\n        if (s > 1) {\n          this.currentStencilSource = void 0, this.nextStencilID + s > 256 && this.clearStencil();\n          const e = {};\n          for (let i = 0; i < s; i++) e[i + o] = new Gi({\n            func: t.GEQUAL,\n            mask: 255\n          }, i + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);\n          return this.nextStencilID += s, [e, i];\n        }\n        return [{\n          [o]: Gi.disabled\n        }, i];\n      }\n      colorModeForRenderPass() {\n        const t = this.context.gl;\n        if (this._showOverdrawInspector) {\n          const i = 1 / 8;\n          return new Ui([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new e.ao(i, i, i, 0), [!0, !0, !0, !0]);\n        }\n        return \"opaque\" === this.renderPass ? Ui.unblended : Ui.alphaBlended;\n      }\n      colorModeForDrapableLayerRenderPass(t) {\n        const i = this.context.gl;\n        return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && \"translucent\" === this.renderPass ? new Ui([i.ONE, i.ONE_MINUS_SRC_ALPHA, i.CONSTANT_ALPHA, i.ONE_MINUS_SRC_ALPHA], new e.ao(0, 0, 0, void 0 === t ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();\n      }\n      depthModeForSublayer(e, t, i) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n        if (this.depthOcclusion) return new ji(this.context.gl.GREATER, ji.ReadOnly, this.depthRangeFor3D);\n        if (!this.opaquePassEnabledForLayer() && !o) return ji.disabled;\n        const s = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;\n        return new ji(i || this.context.gl.LEQUAL, t, [s, s]);\n      }\n      opaquePassEnabledForLayer() {\n        return this.currentLayer < this.opaquePassCutoff;\n      }\n      blitDepth() {\n        const t = this.context.gl,\n          i = Math.ceil(this.width),\n          o = Math.ceil(this.height),\n          s = this.context.bindFramebuffer.get(),\n          r = t.getParameter(t.TEXTURE_BINDING_2D);\n        this.depthFBO && this.depthFBO.width === i && this.depthFBO.height === o || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i && 0 !== o && (this.depthFBO = new Fr(this.context, i, o, !1, \"texture\"), this.depthTexture = new e.T(this.context, {\n          width: i,\n          height: o,\n          data: null\n        }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s), t.bindTexture(t.TEXTURE_2D, r), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current));\n      }\n      updateAverageFPS() {\n        this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e, t) => e + t / this._fpsHistory.length, 0));\n      }\n      render(t, i) {\n        const o = e.o.now();\n        this._dt = o - this._timeStamp, this._timeStamp = o, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = i;\n        const s = this.style._mergedLayers,\n          r = !(!this.terrain || !this.terrain.enabled),\n          n = () => this.style._getOrder(r).filter(e => {\n            const t = s[e];\n            return !(t.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t.type];\n          });\n        let a = n(),\n          l = !1,\n          c = !1,\n          h = null;\n        for (const e of a) {\n          const t = s[e];\n          \"circle\" === t.type ? l = !0 : \"building\" === t.type ? h = t : \"symbol\" === t.type && (t.hasOcclusionOpacityProperties ? c = !0 : l = !0);\n        }\n        let d = a.map(e => s[e]);\n        const u = this.style._mergedSourceCaches;\n        this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.o.now()), this.imageManager.beginFrame();\n        let _ = 0,\n          p = !1;\n        for (const e in u) {\n          const t = u[e];\n          t.used && (t.prepare(this.context), t.getSource().usedInConflation && ++_);\n        }\n        let f = !1;\n        for (const e of d) e.isHidden(this.transform.zoom) || (\"clip\" === e.type && (f = !0), this.prepareLayer(e));\n        const m = {},\n          g = {},\n          v = {},\n          y = {},\n          x = {};\n        for (const e in u) {\n          const t = u[e];\n          m[e] = t.getVisibleCoordinates(), g[e] = m[e].slice().reverse(), v[e] = t.getVisibleCoordinates(!0).reverse(), y[e] = t.getShadowCasterCoordinates(), x[e] = t.sortCoordinatesByDistance(m[e]);\n        }\n        const b = e => {\n          const t = this.style.getLayerSourceCache(e);\n          return t && t.used ? t.getSource() : null;\n        };\n        if (_ || f || this._clippingActiveLastFrame) {\n          const t = [],\n            i = [];\n          let o = 0;\n          for (const e of d) this.isSourceForClippingOrConflation(e, b(e)) && (t.push(e), i.push(o)), o++;\n          if (t && (f || t.length > 1) || this._clippingActiveLastFrame) {\n            f = !1;\n            const o = [];\n            for (let s = 0; s < t.length; s++) {\n              const r = t[s],\n                n = i[s],\n                a = this.style.getLayerSourceCache(r);\n              if (!a || !a.used || !a.getSource().usedInConflation && \"clip\" !== r.type && \"building\" !== r.type) continue;\n              let l = e.eH,\n                c = e.bZ.None;\n              const h = [];\n              let d = !0;\n              if (\"building\" === r.type) l = e.eJ;else if (\"clip\" === r.type) {\n                l = n;\n                for (const t of r.layout.get(\"clip-layer-types\")) c |= \"model\" === t ? e.bZ.Model : \"symbol\" === t ? e.bZ.Symbol : e.bZ.FillExtrusion;\n                for (const e of r.layout.get(\"clip-layer-scope\")) h.push(e);\n                r.isHidden(this.transform.zoom) ? d = !1 : f = !0;\n              }\n              d && o.push({\n                layer: r.fqid,\n                cache: a,\n                order: l,\n                clipMask: c,\n                clipScope: h\n              });\n            }\n            this.replacementSource.setSources(o), p = !0;\n          }\n        }\n        this._clippingActiveLastFrame = f, p || this.replacementSource.clear(), this.conflationActive = p, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];\n        for (let e = 0; e < d.length; e++) {\n          const t = d[e],\n            i = t.cutoffRange();\n          if (this.longestCutoffRange = Math.max(i, this.longestCutoffRange), i > 0) {\n            const e = b(t);\n            e && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom)), t.minzoom && (this.minCutoffZoom = Math.max(t.minzoom, this.minCutoffZoom));\n          }\n          t.is3D(r) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e), this._lastOcclusionLayer = e);\n        }\n        const w = this.style && this.style.fog;\n        w ? (this._fogVisible = 0 !== w.getOpacity(this.transform.pitch), this._fogVisible && \"globe\" !== this.transform.projection.name && (this._fogVisible = w.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(v), this.opaquePassCutoff = 0, a = n(), d = a.map(e => s[e]));\n        const T = this._shadowRenderer;\n        if (T) {\n          T.updateShadowParameters(this.transform, this.style.directionalLight);\n          for (const e in u) for (const t of m[e]) {\n            let e = {\n              min: 0,\n              max: 0\n            };\n            this.terrain && (e = this.terrain.getMinMaxForTile(t) || e), T.addShadowReceiver(t.toUnwrapped(), e.min, e.max);\n          }\n        }\n        \"globe\" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.eI(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Pn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);\n        const E = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow),\n          S = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);\n        if (E && !this._snow && (this._snow = new la(this)), !E && this._snow && (this._snow.destroy(), delete this._snow), S && !this._rain && (this._rain = new na(this)), !S && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), h) {\n          this.buildingTileBorderManager || (this.buildingTileBorderManager = new zn());\n          const e = this.style.getLayerSourceCache(h);\n          this.buildingTileBorderManager.updateBorders(e, h);\n        }\n        if (!U.has(this.context.gl)) return;\n        this.renderPass = \"offscreen\";\n        for (const e of d) {\n          const i = t.getLayerSourceCache(e);\n          if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;\n          const o = i ? g[i.id] : void 0;\n          (\"custom\" === e.type || \"raster\" === e.type || \"raster-particle\" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);\n        }\n        this.depthRangeFor3D = [0, 1 - (d.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = \"shadow\", this._shadowRenderer.drawShadowPass(this.style, y)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);\n        const I = \"globe\" === this.transform.projection.name || this.transform.isHorizonVisible(),\n          C = (() => {\n            if (i.showOverdrawInspector) return e.ao.black;\n            const t = this.style.fog;\n            if (t && this.transform.projection.supportsFog) {\n              const i = this.style.getLut(t.scope);\n              if (!I) {\n                const o = \"none\" === t.properties.get(\"color-use-theme\"),\n                  s = t.properties.get(\"color\").toNonPremultipliedRenderColor(o ? null : i).toArray01();\n                return new e.ao(...s);\n              }\n              if (I) {\n                const o = \"none\" === t.properties.get(\"space-color-use-theme\"),\n                  s = t.properties.get(\"space-color\").toNonPremultipliedRenderColor(o ? null : i).toArray01();\n                return new e.ao(...s);\n              }\n            }\n            return e.ao.transparent;\n          })();\n        if (this.context.clear({\n          color: C,\n          depth: 1\n        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = \"opaque\", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = a.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n          const e = d[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          if (e.isSky()) continue;\n          const o = i ? (e.is3D(r) ? x : g)[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);\n        }\n        if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && I && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = \"sky\", (!this._atmosphere || e.aj(this.transform.zoom) > 0) && (\"globe\" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < a.length; this.currentLayer++) {\n          const e = d[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          e.isSky() && this.renderLayer(this, i, e, i ? g[i.id] : void 0);\n        }\n        function R(e, t) {\n          let i;\n          return t && (i = (\"symbol\" === e.type ? v : e.is3D(r) ? x : g)[t.id]), i;\n        }\n        if (this.renderPass = \"translucent\", \"globe\" === this.transform.projection.name) {\n          for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < a.length;) {\n            const e = d[this.currentLayer];\n            if (\"raster\" === e.type || \"raster-particle\" === e.type) {\n              const i = t.getLayerSourceCache(e);\n              this.renderLayer(this, i, e, R(e, i));\n            }\n            ++this.currentLayer;\n          }\n          this.renderElevatedRasterBackface = !1;\n        }\n        this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;\n        let A = 0;\n        T && (A = T.getShadowCastingLayerCount());\n        let D = !1,\n          L = -1;\n        for (let e = 0; e < a.length; ++e) {\n          const t = d[e];\n          t.isHidden(this.transform.zoom) || t.is3D(r) && (L = e);\n        }\n        c && -1 === L && (l = !0);\n        let P = !1;\n        for (; this.currentLayer < a.length;) {\n          const e = d[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          if (e.isSky()) ++this.currentLayer;else if (this.terrain && this.style.isLayerDraped(e)) {\n            if (e.isHidden(this.transform.zoom)) {\n              ++this.currentLayer;\n              continue;\n            }\n            this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);\n          } else {\n            if (!P && e.is3D(r) && !r) {\n              const e = this.currentLayer,\n                t = e => {\n                  for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {\n                    const t = d[this.currentLayer];\n                    if (da[t.type]) {\n                      const i = this.style.getLayerSourceCache(t);\n                      da[t.type](this, i, t, R(t, i), e);\n                    }\n                  }\n                };\n              t(\"initialize\"), t(\"reset\"), this.currentLayer = e, P = !0;\n            }\n            if (l && !D && this.terrain && !this.transform.isOrthographic && (D = !0, this.blitDepth()), c && -1 !== L && this.currentLayer === L + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e, i, i ? m[i.id] : void 0), this.renderLayer(this, i, e, R(e, i)), !this.terrain && T && A > 0 && e.hasShadowPass() && 0 == --A) {\n              {\n                this.clearStencil(), this.resetStencilClippingMasks();\n                const e = this.currentLayer;\n                for (this.currentLayer = 0; this.currentLayer < d.length; this.currentLayer++) {\n                  const e = d[this.currentLayer];\n                  if (ua[e.type]) {\n                    const t = this.style.getLayerSourceCache(e);\n                    ua[e.type](this, t, e, R(e, t));\n                  }\n                }\n                this.currentLayer = e;\n              }\n              if (T.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer) {\n                const e = this.currentLayer;\n                for (this.renderPass = \"light-beam\", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++) {\n                  const e = d[this.currentLayer];\n                  if (!e.hasLightBeamPass()) continue;\n                  const i = t.getLayerSourceCache(e);\n                  this.renderLayer(this, i, e, i ? g[i.id] : void 0);\n                }\n                this.currentLayer = e, this.renderPass = \"translucent\";\n              }\n            }\n            if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {\n              const e = this.currentLayer;\n              this.depthOcclusion = !0;\n              for (const e of this.layersWithOcclusionOpacity) {\n                this.currentLayer = e;\n                const i = d[this.currentLayer],\n                  o = t.getLayerSourceCache(i),\n                  s = o ? g[o.id] : void 0;\n                this.terrain || this._renderTileClippingMasks(i, o, o ? m[o.id] : void 0), this.renderLayer(this, o, i, s);\n              }\n              this.depthOcclusion = !1, this.currentLayer = e, this.renderPass = \"translucent\", this.layersWithOcclusionOpacity = [];\n            }\n            ++this.currentLayer;\n          }\n        }\n        if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {\n          let i = null;\n          d.forEach(e => {\n            const o = t.getLayerSourceCache(e);\n            o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);\n          }), i && this.options.showTileBoundaries && vn(this, i, i.getVisibleCoordinates(), e.ao.red, !1, this.options.showParseStatus);\n        }\n        this.terrain && this._debugParams.showTerrainProxyTiles && vn(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.ao(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function (e) {\n          const t = e.transform.padding;\n          xn(e, e.transform.height - (t.top || 0), 3, _n), xn(e, t.bottom || 0, 3, pn), bn(e, t.left || 0, 3, fn), bn(e, e.transform.width - (t.right || 0), 3, mn);\n          const i = e.transform.centerPoint;\n          !function (e, t, i, o) {\n            wn(e, t - 1, i - 10, 2, 20, o), wn(e, t - 10, i - 1, 20, 2, o);\n          }(e, i.x, e.transform.height - i.y, gn);\n        }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), p || (this.conflationActive = !1);\n      }\n      prepareLayer(e) {\n        this.gpuTimingStart(e);\n        const {\n            unsupportedLayers: t\n          } = this.transform.projection,\n          i = !t || !t.includes(e.type);\n        if (ha[e.type] && (i || this.terrain && \"custom\" === e.type)) {\n          const t = this.style.getLayerSourceCache(e);\n          ha[e.type](e, t, this);\n        }\n        this.gpuTimingEnd();\n      }\n      renderLayer(e, t, i, o) {\n        i.isHidden(this.transform.zoom) || (\"background\" === i.type || \"sky\" === i.type || \"custom\" === i.type || \"model\" === i.type || \"raster\" === i.type || \"raster-particle\" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) && (!e.terrain || \"custom\" !== i.type) || \"clip\" === i.type || ca[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());\n      }\n      gpuTimingStart(e) {\n        if (!this.options.gpuTiming) return;\n        const t = this.context.extTimerQuery,\n          i = this.context.gl;\n        let o = this.gpuTimers[e.id];\n        o || (o = this.gpuTimers[e.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: i.createQuery()\n        }), o.calls++, i.beginQuery(t.TIME_ELAPSED_EXT, o.query);\n      }\n      gpuTimingDeferredRenderStart() {\n        if (this.options.gpuTimingDeferredRender) {\n          const e = this.context.extTimerQuery,\n            t = this.context.gl,\n            i = t.createQuery();\n          this.deferredRenderGpuTimeQueries.push(i), t.beginQuery(e.TIME_ELAPSED_EXT, i);\n        }\n      }\n      gpuTimingDeferredRenderEnd() {\n        this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);\n      }\n      gpuTimingEnd() {\n        this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);\n      }\n      collectGpuTimers() {\n        const e = this.gpuTimers;\n        return this.gpuTimers = {}, e;\n      }\n      collectDeferredRenderGpuQueries() {\n        const e = this.deferredRenderGpuTimeQueries;\n        return this.deferredRenderGpuTimeQueries = [], e;\n      }\n      queryGpuTimers(e) {\n        const t = {};\n        for (const i in e) {\n          const o = e[i],\n            s = this.context.extTimerQuery,\n            r = s.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;\n          s.deleteQueryEXT(o.query), t[i] = r;\n        }\n        return t;\n      }\n      queryGpuTimeDeferredRender(e) {\n        if (!this.options.gpuTimingDeferredRender) return 0;\n        const t = this.context.gl;\n        let i = 0;\n        for (const o of e) i += t.getQueryParameter(o, t.QUERY_RESULT) / 1e6, t.deleteQuery(o);\n        return i;\n      }\n      translatePosMatrix(t, i, o, s, r) {\n        if (!o[0] && !o[1]) return t;\n        const n = r ? \"map\" === s ? this.transform.angle : 0 : \"viewport\" === s ? -this.transform.angle : 0;\n        if (n) {\n          const e = Math.sin(n),\n            t = Math.cos(n);\n          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];\n        }\n        const a = [r ? o[0] : e.ay(i, o[0], this.transform.zoom), r ? o[1] : e.ay(i, o[1], this.transform.zoom), 0],\n          l = new Float32Array(16);\n        return e.br(l, t, a), l;\n      }\n      saveTileTexture(e) {\n        if (e.context !== this.context) return;\n        const t = e.size[0],\n          i = this._tileTextures[t];\n        i ? i.push(e) : this._tileTextures[t] = [e];\n      }\n      getTileTexture(e) {\n        const t = this._tileTextures[e];\n        return t && t.length > 0 ? t.pop() : null;\n      }\n      terrainRenderModeElevated() {\n        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;\n      }\n      linearFloatFilteringSupported() {\n        return null != this.context.extTextureFloatLinear;\n      }\n      currentGlobalDefines(e, t, i) {\n        const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i,\n          s = [];\n        return this.style && this.style.enable3dLights() && (\"globeRaster\" === e || \"terrainRaster\" === e ? (s.push(\"LIGHTING_3D_MODE\"), s.push(\"LIGHTING_3D_ALPHA_EMISSIVENESS\")) : o || s.push(\"LIGHTING_3D_MODE\")), \"shadow\" === this.renderPass && (this._shadowMapDebug || s.push(\"DEPTH_TEXTURE\")), this.terrainRenderModeElevated() && (s.push(\"TERRAIN\"), this.linearFloatFilteringSupported() && s.push(\"TERRAIN_DEM_FLOAT_FORMAT\")), \"globe\" === this.transform.projection.name && s.push(\"GLOBE\"), !this._fogVisible || o || void 0 !== t && !t || s.push(\"FOG\", \"FOG_DITHERING\"), o && s.push(\"RENDER_TO_TEXTURE\"), this._showOverdrawInspector && s.push(\"OVERDRAW_INSPECTOR\"), s;\n      }\n      getOrCreateProgram(e, t) {\n        this.cache = this.cache || {};\n        const i = t && t.defines || [],\n          o = t && t.config,\n          s = this.currentGlobalDefines(e, t && t.overrideFog, t && t.overrideRtt).concat(i),\n          r = Ks.cacheKey(Ho[e], e, s, o);\n        return this.cache[r] || (this.cache[r] = new Ks(this.context, e, Ho[e], o, Pr[e], s)), this.cache[r];\n      }\n      setCustomLayerDefaults() {\n        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n      }\n      setBaseState() {\n        const e = this.context.gl;\n        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);\n      }\n      initDebugOverlayCanvas() {\n        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement(\"canvas\"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));\n      }\n      destroy() {\n        this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();\n      }\n      prepareDrawTile() {\n        this.terrain && this.terrain.prepareDrawTile();\n      }\n      uploadCommonLightUniforms(t, i) {\n        if (this.style.enable3dLights()) {\n          const o = this.style.directionalLight,\n            s = this.style.ambientLight;\n          if (o && s) {\n            const r = ((t, i, o) => {\n              const s = t.properties.get(\"direction\"),\n                r = \"none\" === t.properties.get(\"color-use-theme\"),\n                n = t.properties.get(\"color\").toNonPremultipliedRenderColor(r ? null : o.getLut(t.scope)).toArray01(),\n                a = t.properties.get(\"intensity\"),\n                l = \"none\" === i.properties.get(\"color-use-theme\"),\n                c = i.properties.get(\"color\").toNonPremultipliedRenderColor(l ? null : o.getLut(i.scope)).toArray01(),\n                h = i.properties.get(\"intensity\"),\n                d = [s.x, s.y, s.z],\n                u = e.dK(c, h),\n                _ = e.dK(n, a);\n              return {\n                u_lighting_ambient_color: u,\n                u_lighting_directional_dir: d,\n                u_lighting_directional_color: _,\n                u_ground_radiance: $s(d, _, u)\n              };\n            })(o, s, this.style);\n            i.setLightsUniformValues(t, r);\n          }\n        }\n      }\n      uploadCommonUniforms(t, i, o, s, r) {\n        if (this.uploadCommonLightUniforms(t, i), this.terrain && this.terrain.renderingToTexture) return;\n        const n = this.style.fog;\n        if (n) {\n          const r = n.getOpacity(this.transform.pitch),\n            a = ((t, i, o, s, r, n, a, l, c, h, d, u) => {\n              const _ = t.transform,\n                p = \"none\" === i.properties.get(\"color-use-theme\"),\n                f = i.properties.get(\"color\").toNonPremultipliedRenderColor(p ? null : t.style.getLut(i.scope)).toArray01();\n              f[3] = s;\n              const m = t.frameCounter / 1e3 % 1,\n                [g, v] = i.properties.get(\"vertical-range\");\n              return {\n                u_fog_matrix: o ? _.calculateFogTileMatrix(o) : u || t.identityMat,\n                u_fog_range: i.getFovAdjustedRange(_._fov),\n                u_fog_color: f,\n                u_fog_horizon_blend: i.properties.get(\"horizon-blend\"),\n                u_fog_vertical_limit: [Math.min(g, v), v],\n                u_fog_temporal_offset: m,\n                u_frustum_tl: r,\n                u_frustum_tr: n,\n                u_frustum_br: a,\n                u_frustum_bl: l,\n                u_globe_pos: c,\n                u_globe_radius: h,\n                u_viewport: d,\n                u_globe_transition: e.aj(_.zoom),\n                u_is_globe: +(\"globe\" === _.projection.name)\n              };\n            })(this, n, o, r, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.o.devicePixelRatio, this.transform.height * e.o.devicePixelRatio], s);\n          i.setFogUniformValues(t, a);\n        }\n        r && i.setCutoffUniformValues(t, r.uniformValues);\n      }\n      setTileLoadedFlag(e) {\n        this.tileLoaded = e;\n      }\n      saveCanvasCopy() {\n        const e = this.canvasCopy();\n        e && (this.frameCopies.push(e), this.tileLoaded = !1);\n      }\n      canvasCopy() {\n        const e = this.context.gl,\n          t = e.createTexture();\n        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;\n      }\n      getCanvasCopiesAndTimestamps() {\n        return {\n          canvasCopies: this.frameCopies,\n          timeStamps: this.loadTimeStamps\n        };\n      }\n      averageElevationNeedsEasing() {\n        if (!this.transform._elevation) return !1;\n        const e = this.style && this.style.fog;\n        return !!e && 0 !== e.getOpacity(this.transform.pitch);\n      }\n      getBackgroundTiles() {\n        const e = this._backgroundTiles,\n          t = this._backgroundTiles = {},\n          i = this.transform.coveringTiles({\n            tileSize: 512\n          });\n        for (const o of i) t[o.key] = e[o.key] || new Et(o, 512, this.transform.tileZoom, this, void 0, this.worldview);\n        return t;\n      }\n      clearBackgroundTiles() {\n        this._backgroundTiles = {};\n      }\n      isSourceForClippingOrConflation(e, t) {\n        return !(!e.is3D(!(!this.terrain || !this.terrain.enabled)) || \"clip\" !== e.type && \"building\" !== e.type && (e.minzoom && e.minzoom > this.transform.zoom || (this.style._clipLayerPresent || \"building\" !== e.sourceLayer && \"procedural_buildings\" !== e.sourceLayer) && (!t || \"batched-model\" !== t.type)));\n      }\n      isTileAffectedByFog(e) {\n        if (!this.style || !this.style.fog) return !1;\n        if (\"globe\" === this.transform.projection.name) return !0;\n        let t = this._cachedTileFogOpacities[e.key];\n        return t || (this._cachedTileFogOpacities[e.key] = t = this.style.fog.getOpacityForTile(e)), t[0] >= Be || t[1] >= Be;\n      }\n      setupDepthForOcclusion(e, t, i) {\n        const o = this.context,\n          s = o.gl,\n          r = !!i;\n        var n;\n        i || (i = {\n          u_dem: 2,\n          u_dem_prev: 4,\n          u_dem_tl: [0, 0],\n          u_dem_tl_prev: [0, 0],\n          u_dem_scale: 0,\n          u_dem_scale_prev: 0,\n          u_dem_size: 0,\n          u_dem_lerp: 1,\n          u_depth: 3,\n          u_depth_size_inv: [0, 0],\n          u_depth_range_unpack: [0, 1],\n          u_occluder_half_size: 16,\n          u_occlusion_depth_offset: -1e-4,\n          u_exaggeration: 0\n        }), o.activeTexture.set(s.TEXTURE3), e && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), i.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i.u_depth_range_unpack = [2 / ((n = this.depthRangeFor3D)[1] - n[0]), -1 - 2 * n[0] / (n[1] - n[0])], i.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, i.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), o.activeTexture.set(s.TEXTURE0), r || t.setTerrainUniformValues(o, i);\n      }\n    }\n    function pa(e, t) {\n      let i = !1,\n        o = null;\n      const s = () => {\n        o = null, i && (e(), o = setTimeout(s, t), i = !1);\n      };\n      return () => (i = !0, o || s(), o);\n    }\n    class fa {\n      constructor(t) {\n        this._hashName = t && encodeURIComponent(t), e.aY([\"_getCurrentHash\", \"_onHashChange\", \"_updateHash\"], this), this._updateHash = pa(this._updateHashUnthrottled.bind(this), 300);\n      }\n      addTo(e) {\n        return this._map = e, window.addEventListener(\"hashchange\", this._onHashChange, !1), e.on(\"moveend\", this._updateHash), this;\n      }\n      remove() {\n        return this._map ? (this._map.off(\"moveend\", this._updateHash), window.removeEventListener(\"hashchange\", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;\n      }\n      getHashString() {\n        const e = this._map;\n        if (!e) return \"\";\n        const t = ma(e);\n        if (this._hashName) {\n          const e = this._hashName;\n          let i = !1;\n          const o = location.hash.slice(1).split(\"&\").map(o => {\n            const s = o.split(\"=\")[0];\n            return s === e ? (i = !0, \"\".concat(s, \"=\").concat(t)) : o;\n          }).filter(e => e);\n          return i || o.push(\"\".concat(e, \"=\").concat(t)), \"#\".concat(o.join(\"&\"));\n        }\n        return \"#\".concat(t);\n      }\n      _getCurrentHash() {\n        const e = location.hash.replace(\"#\", \"\");\n        if (this._hashName) {\n          let t;\n          return e.split(\"&\").map(e => e.split(\"=\")).forEach(e => {\n            e[0] === this._hashName && (t = e);\n          }), (t && t[1] || \"\").split(\"/\");\n        }\n        return e.split(\"/\");\n      }\n      _onHashChange() {\n        const e = this._map;\n        if (!e) return !1;\n        const t = this._getCurrentHash();\n        if (t.length >= 3 && !t.some(e => isNaN(Number(e)))) {\n          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();\n          return e.jumpTo({\n            center: [+t[2], +t[1]],\n            zoom: +t[0],\n            bearing: i,\n            pitch: +(t[4] || 0)\n          }), !0;\n        }\n        return !1;\n      }\n      _updateHashUnthrottled() {\n        history.replaceState(history.state, \"\", location.href.replace(/(#.+)?$/, this.getHashString()));\n      }\n    }\n    function ma(e, t) {\n      const i = e.getCenter(),\n        o = Math.round(100 * e.getZoom()) / 100,\n        s = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n        r = Math.pow(10, s),\n        n = Math.round(i.lng * r) / r,\n        a = Math.round(i.lat * r) / r,\n        l = e.getBearing(),\n        c = e.getPitch();\n      let h = t ? \"/\".concat(n, \"/\").concat(a, \"/\").concat(o) : \"\".concat(o, \"/\").concat(a, \"/\").concat(n);\n      return (l || c) && (h += \"/\" + Math.round(10 * l) / 10), c && (h += \"/\".concat(Math.round(c))), h;\n    }\n    const ga = {\n        linearity: .3,\n        easing: e.eK(0, 0, .3, 1)\n      },\n      va = Object.assign({\n        deceleration: 2500,\n        maxSpeed: 1400\n      }, ga),\n      ya = Object.assign({\n        deceleration: 20,\n        maxSpeed: 1400\n      }, ga),\n      xa = Object.assign({\n        deceleration: 1e3,\n        maxSpeed: 360\n      }, ga),\n      ba = Object.assign({\n        deceleration: 1e3,\n        maxSpeed: 90\n      }, ga);\n    class wa {\n      constructor(e) {\n        this._map = e, this.clear();\n      }\n      clear() {\n        this._inertiaBuffer = [];\n      }\n      record(t) {\n        this._drainInertiaBuffer(), this._inertiaBuffer.push({\n          time: e.o.now(),\n          settings: t\n        });\n      }\n      _drainInertiaBuffer() {\n        const t = this._inertiaBuffer,\n          i = e.o.now();\n        for (; t.length > 0 && i - t[0].time > 160;) t.shift();\n      }\n      _onMoveEnd(t) {\n        if (this._map._prefersReducedMotion()) return;\n        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;\n        const i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new e.P(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        };\n        for (const {\n          settings: e\n        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);\n        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n          s = {};\n        if (i.pan.mag()) {\n          const e = Ea(i.pan.mag(), o, Object.assign({}, va, t || {}));\n          s.offset = i.pan.mult(e.amount / i.pan.mag()), s.center = this._map.transform.center, Ta(s, e);\n        }\n        if (i.zoom) {\n          const e = Ea(i.zoom, o, ya);\n          s.zoom = this._map.transform.zoom + e.amount, Ta(s, e);\n        }\n        if (i.bearing) {\n          const t = Ea(i.bearing, o, xa);\n          s.bearing = this._map.transform.bearing + e.aA(t.amount, -179, 179), Ta(s, t);\n        }\n        if (i.pitch) {\n          const e = Ea(i.pitch, o, ba);\n          s.pitch = this._map.transform.pitch + e.amount, Ta(s, e);\n        }\n        if (s.zoom || s.bearing) {\n          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          s.around = e ? this._map.unproject(e) : this._map.getCenter();\n        }\n        return this.clear(), s.noMoveStart = !0, s;\n      }\n    }\n    function Ta(e, t) {\n      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);\n    }\n    function Ea(t, i, o) {\n      const {\n          maxSpeed: s,\n          linearity: r,\n          deceleration: n\n        } = o,\n        a = e.aA(t * r / (i / 1e3), -s, s),\n        l = Math.abs(a) / (n * r);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: a * (l / 2)\n      };\n    }\n    class Sa extends e.z {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(e, t, i) {\n        let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const s = g(t.getCanvasContainer(), i),\n          r = t.unproject(s);\n        super(e, Object.assign({\n          point: s,\n          lngLat: r,\n          originalEvent: i\n        }, o)), this._defaultPrevented = !1, this.target = t;\n      }\n    }\n    class Ia extends e.z {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o) {\n        const s = \"touchend\" === t ? o.changedTouches : o.touches,\n          r = v(i.getCanvasContainer(), s),\n          n = r.map(e => i.unproject(e)),\n          a = r.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.P(0, 0));\n        super(t, {\n          points: r,\n          point: a,\n          lngLats: n,\n          lngLat: i.unproject(a),\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class Ca extends e.z {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(e, t) {\n        super(\"wheel\", {\n          originalEvent: t\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class Ra {\n      constructor(e, t) {\n        this._map = e, this._clickTolerance = t.clickTolerance;\n      }\n      reset() {\n        this._mousedownPos = void 0;\n      }\n      wheel(e) {\n        return this._firePreventable(new Ca(this._map, e));\n      }\n      mousedown(e, t) {\n        return this._mousedownPos = t, this._firePreventable(new Sa(e.type, this._map, e));\n      }\n      mouseup(e) {\n        this._map.fire(new Sa(e.type, this._map, e));\n      }\n      preclick(e) {\n        const t = new MouseEvent(\"preclick\", e);\n        this._map.fire(new Sa(t.type, this._map, t));\n      }\n      click(e, t) {\n        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Sa(e.type, this._map, e)));\n      }\n      dblclick(e) {\n        return this._firePreventable(new Sa(e.type, this._map, e));\n      }\n      mouseover(e) {\n        this._map.fire(new Sa(e.type, this._map, e));\n      }\n      mouseout(e) {\n        this._map.fire(new Sa(e.type, this._map, e));\n      }\n      touchstart(e) {\n        return this._firePreventable(new Ia(e.type, this._map, e));\n      }\n      touchmove(e) {\n        this._map.fire(new Ia(e.type, this._map, e));\n      }\n      touchend(e) {\n        this._map.fire(new Ia(e.type, this._map, e));\n      }\n      touchcancel(e) {\n        this._map.fire(new Ia(e.type, this._map, e));\n      }\n      _firePreventable(e) {\n        if (this._map.fire(e), e.defaultPrevented) return {};\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class Aa {\n      constructor(e) {\n        this._map = e;\n      }\n      reset() {\n        this._delayContextMenu = !1, this._contextMenuEvent = void 0;\n      }\n      mousemove(e) {\n        this._map.fire(new Sa(e.type, this._map, e));\n      }\n      mousedown() {\n        this._delayContextMenu = !0;\n      }\n      mouseup() {\n        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Sa(\"contextmenu\", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n      }\n      contextmenu(e) {\n        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Sa(e.type, this._map, e)), this._map.listens(\"contextmenu\") && e.preventDefault();\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class Da {\n      constructor(e, t) {\n        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      enable() {\n        this.isEnabled() || (this._enabled = !0);\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n      mousedown(e, t) {\n        this.isEnabled() && e.shiftKey && 0 === e.button && (_(), this._startPos = this._lastPos = t, this._active = !0);\n      }\n      mousemoveWindow(e, t) {\n        if (!this._active) return;\n        const i = t,\n          o = this._startPos,\n          s = this._lastPos;\n        if (!o || !s || s.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;\n        this._lastPos = i, this._box || (this._box = l(\"div\", \"mapboxgl-boxzoom\", this._container), this._container.classList.add(\"mapboxgl-crosshair\"), this._fireEvent(\"boxzoomstart\", e));\n        const r = Math.min(o.x, i.x),\n          n = Math.max(o.x, i.x),\n          a = Math.min(o.y, i.y),\n          c = Math.max(o.y, i.y);\n        this._map._requestDomTask(() => {\n          this._box && (this._box.style.transform = \"translate(\".concat(r, \"px,\").concat(a, \"px)\"), this._box.style.width = n - r + \"px\", this._box.style.height = c - a + \"px\");\n        });\n      }\n      mouseupWindow(t, i) {\n        if (!this._active) return;\n        const o = this._startPos,\n          s = i;\n        if (o && 0 === t.button) {\n          if (this.reset(), m(), o.x !== s.x || o.y !== s.y) return this._map.fire(new e.z(\"boxzoomend\", {\n            originalEvent: t\n          })), {\n            cameraAnimation: e => e.fitScreenCoordinates(o, s, this._map.getBearing(), {\n              linear: !1\n            })\n          };\n          this._fireEvent(\"boxzoomcancel\", t);\n        }\n      }\n      keydown(e) {\n        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent(\"boxzoomcancel\", e));\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._container.classList.remove(\"mapboxgl-crosshair\"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;\n      }\n      _fireEvent(t, i) {\n        return this._map.fire(new e.z(t, {\n          originalEvent: i\n        }));\n      }\n    }\n    function La(e, t) {\n      const i = {};\n      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];\n      return i;\n    }\n    class Pa {\n      constructor(e) {\n        this.reset(), this.numTouches = e.numTouches;\n      }\n      reset() {\n        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;\n      }\n      touchstart(t, i, o) {\n        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {\n          const i = new e.P(0, 0);\n          for (const e of t) i._add(e);\n          return i.div(t.length);\n        }(i), this.touches = La(o, i)));\n      }\n      touchmove(e, t, i) {\n        if (this.aborted || !this.centroid) return;\n        const o = La(i, t);\n        for (const e in this.touches) {\n          const t = o[e];\n          (!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0);\n        }\n      }\n      touchend(e, t, i) {\n        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n          const e = !this.aborted && this.centroid;\n          if (this.reset(), e) return e;\n        }\n      }\n    }\n    class za {\n      constructor(e) {\n        this.singleTap = new Pa(e), this.numTaps = e.numTaps, this.reset();\n      }\n      reset() {\n        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();\n      }\n      touchstart(e, t, i) {\n        this.singleTap.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this.singleTap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this.singleTap.touchend(e, t, i);\n        if (o) {\n          const t = e.timeStamp - this.lastTime < 500,\n            i = !this.lastTap || this.lastTap.dist(o) < 30;\n          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n        }\n      }\n    }\n    class Oa {\n      constructor() {\n        this._zoomIn = new za({\n          numTouches: 1,\n          numTaps: 2\n        }), this._zoomOut = new za({\n          numTouches: 2,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n      }\n      touchstart(e, t, i) {\n        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this._zoomIn.touchend(e, t, i),\n          s = this._zoomOut.touchend(e, t, i);\n        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() + 1,\n            around: t.unproject(o)\n          }, {\n            originalEvent: e\n          })\n        }) : s ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() - 1,\n            around: t.unproject(s)\n          }, {\n            originalEvent: e\n          })\n        }) : void 0;\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    const Ma = {\n        0: 1,\n        2: 2\n      },\n      Fa = {\n        Control: \"ctrlKey\",\n        Alt: \"altKey\",\n        Shift: \"shiftKey\",\n        Meta: \"metaKey\"\n      };\n    class Ba {\n      constructor(e) {\n        this.reset(), this._clickTolerance = e.clickTolerance || 1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;\n      }\n      _correctButton(e, t) {\n        return !1;\n      }\n      _move(e, t) {\n        return {};\n      }\n      mousedown(e, t) {\n        if (this._lastPoint) return;\n        const i = y(e);\n        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);\n      }\n      mousemoveWindow(e, t) {\n        const i = this._lastPoint;\n        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {\n          const i = Ma[t];\n          return void 0 === e.buttons || (e.buttons & i) !== i;\n        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);\n      }\n      mouseupWindow(e) {\n        this._lastPoint && y(e) === this._eventButton && (this._moved && m(), this.reset());\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class ka extends Ba {\n      mousedown(e, t) {\n        super.mousedown(e, t), this._lastPoint && (this._active = !0);\n      }\n      _correctButton(e, t) {\n        return 0 === t && !e.ctrlKey;\n      }\n      _move(e, t) {\n        return {\n          around: t,\n          panDelta: t.sub(e)\n        };\n      }\n    }\n    class Na extends Ba {\n      constructor(e) {\n        super(e), this._pitchRotateKey = e.pitchRotateKey ? Fa[e.pitchRotateKey] : void 0;\n      }\n      _correctButton(e, t) {\n        return this._pitchRotateKey ? 0 === t && e[this._pitchRotateKey] : 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = .8 * (t.x - e.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }\n      contextmenu(e) {\n        this._pitchRotateKey || e.preventDefault();\n      }\n    }\n    class Ua extends Ba {\n      constructor(e) {\n        super(e), this._pitchRotateKey = e.pitchRotateKey ? Fa[e.pitchRotateKey] : void 0;\n      }\n      _correctButton(e, t) {\n        return this._pitchRotateKey ? 0 === t && e[this._pitchRotateKey] : 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = -.5 * (t.y - e.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }\n      contextmenu(e) {\n        this._pitchRotateKey || e.preventDefault();\n      }\n    }\n    class ja {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.aY([\"_addTouchPanBlocker\", \"_showTouchPanBlockerAlert\"], this);\n      }\n      reset() {\n        this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);\n      }\n      touchstart(e, t, i) {\n        return this._calculateTransform(e, t, i);\n      }\n      touchmove(t, i, o) {\n        if (this._active && !(o.length < this._minTouches)) {\n          if (this._map._cooperativeGestures && !this._map.isMoving()) {\n            if (1 === o.length && !e.eL()) return void this._showTouchPanBlockerAlert();\n            \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n          }\n          return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);\n        }\n      }\n      touchend(e, t, i) {\n        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();\n      }\n      touchcancel() {\n        this.reset();\n      }\n      _calculateTransform(t, i, o) {\n        o.length > 0 && (this._active = !0);\n        const s = La(o, i),\n          r = new e.P(0, 0),\n          n = new e.P(0, 0);\n        let a = 0;\n        for (const e in s) {\n          const t = s[e],\n            i = this._touches[e];\n          i && (r._add(t), n._add(t.sub(i)), a++, s[e] = t);\n        }\n        if (this._touches = s, a < this._minTouches || !n.mag()) return;\n        const l = n.div(a);\n        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {\n          around: r.div(a),\n          panDelta: l\n        };\n      }\n      enable() {\n        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\"));\n      }\n      disable() {\n        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\")), this.reset();\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      _addTouchPanBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = l(\"div\", \"mapboxgl-touch-pan-blocker\", this._map._container), this._alertContainer.textContent = this._map._getUIString(\"TouchPanBlocker.Message\"), this._alertContainer.style.fontSize = \"\".concat(Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth))), \"px\"));\n      }\n      _showTouchPanBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.removeAttribute(\"role\");\n        }, 500);\n      }\n    }\n    class Va {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._firstTwoTouches = void 0;\n      }\n      _start(e) {}\n      _move(e, t, i) {\n        return {};\n      }\n      touchstart(e, t, i) {\n        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));\n      }\n      touchmove(e, t, i) {\n        const o = this._firstTwoTouches;\n        if (!o) return;\n        e.preventDefault();\n        const [s, r] = o,\n          n = Ga(i, t, s),\n          a = Ga(i, t, r);\n        if (!n || !a) return;\n        const l = this._aroundCenter ? null : n.add(a).div(2);\n        return this._move([n, a], l, e);\n      }\n      touchend(e, t, i) {\n        if (!this._firstTwoTouches) return;\n        const [o, s] = this._firstTwoTouches,\n          r = Ga(i, t, o),\n          n = Ga(i, t, s);\n        r && n || (this._active && m(), this.reset());\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable(e) {\n        this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    function Ga(e, t, i) {\n      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];\n    }\n    function Ha(e, t) {\n      return Math.log2(e / t);\n    }\n    class qa extends Va {\n      reset() {\n        super.reset(), this._distance = 0, this._startDistance = 0;\n      }\n      _start(e) {\n        this._startDistance = this._distance = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._distance;\n        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Ha(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Ha(this._distance, i),\n          pinchAround: t\n        };\n      }\n    }\n    function Za(e, t) {\n      return 180 * e.angleWith(t) / Math.PI;\n    }\n    class Wa extends Va {\n      reset() {\n        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;\n      }\n      _start(e) {\n        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._vector;\n        if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {\n          bearingDelta: Za(this._vector, i),\n          pinchAround: t\n        };\n      }\n      _isBelowThreshold(e) {\n        this._minDiameter = Math.min(this._minDiameter, e.mag());\n        const t = 25 / (Math.PI * this._minDiameter) * 360,\n          i = this._startVector;\n        if (!i) return !1;\n        const o = Za(e, i);\n        return Math.abs(o) < t;\n      }\n    }\n    function $a(e) {\n      return Math.abs(e.y) > Math.abs(e.x);\n    }\n    class Xa extends Va {\n      constructor(e) {\n        super(), this._map = e;\n      }\n      reset() {\n        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;\n      }\n      _start(e) {\n        this._lastPoints = e, $a(e[0].sub(e[1])) && (this._valid = !1);\n      }\n      _move(t, i, o) {\n        const s = this._lastPoints;\n        if (!s) return;\n        const r = t[0].sub(s[0]),\n          n = t[1].sub(s[1]);\n        return this._map._cooperativeGestures && !e.eL() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r, n, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {\n          pitchDelta: (r.y + n.y) / 2 * -.5\n        });\n      }\n      gestureBeginsVertically(e, t, i) {\n        if (void 0 !== this._valid) return this._valid;\n        const o = e.mag() >= 2,\n          s = t.mag() >= 2;\n        if (!o && !s) return;\n        if (!o || !s) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n        const r = e.y > 0 == t.y > 0;\n        return $a(e) && $a(t) && r;\n      }\n    }\n    const Ya = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    };\n    class Ka {\n      constructor() {\n        const e = Ya;\n        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      keydown(e) {\n        if (e.altKey || e.ctrlKey || e.metaKey) return;\n        let t = 0,\n          i = 0,\n          o = 0,\n          s = 0,\n          r = 0;\n        switch (e.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            t = 1;\n            break;\n          case 189:\n          case 109:\n          case 173:\n            t = -1;\n            break;\n          case 37:\n            e.shiftKey ? i = -1 : (e.preventDefault(), s = -1);\n            break;\n          case 39:\n            e.shiftKey ? i = 1 : (e.preventDefault(), s = 1);\n            break;\n          case 38:\n            e.shiftKey ? o = 1 : (e.preventDefault(), r = -1);\n            break;\n          case 40:\n            e.shiftKey ? o = -1 : (e.preventDefault(), r = 1);\n            break;\n          default:\n            return;\n        }\n        return this._rotationDisabled && (i = 0, o = 0), {\n          cameraAnimation: n => {\n            const a = n.getZoom();\n            n.easeTo({\n              duration: 300,\n              easeId: \"keyboardHandler\",\n              easing: Ja,\n              zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a,\n              bearing: n.getBearing() + i * this._bearingStep,\n              pitch: n.getPitch() + o * this._pitchStep,\n              offset: [-s * this._panStep, -r * this._panStep],\n              center: n.getCenter()\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n      disableRotation() {\n        this._rotationDisabled = !0;\n      }\n      enableRotation() {\n        this._rotationDisabled = !1;\n      }\n    }\n    function Ja(e) {\n      return e * (2 - e);\n    }\n    const Qa = 4.000244140625,\n      el = 1 / 450;\n    class tl {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = el, e.aY([\"_onTimeout\", \"_addScrollZoomBlocker\", \"_showBlockerAlert\"], this);\n      }\n      setZoomRate(e) {\n        this._defaultZoomRate = e;\n      }\n      setWheelZoomRate(e) {\n        this._wheelZoomRate = e;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return this._active || void 0 !== this._finishTimeout;\n      }\n      isZooming() {\n        return !!this._zooming;\n      }\n      enable(e) {\n        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));\n      }\n      wheel(t) {\n        if (!this.isEnabled()) return;\n        if (this._map._cooperativeGestures) {\n          if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.eL())) return void this._showBlockerAlert();\n          \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n        }\n        let i = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;\n        const o = e.o.now(),\n          s = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % Qa == 0 ? this._type = \"wheel\" : 0 !== i && Math.abs(i) < 4 ? this._type = \"trackpad\" : s > 400 ? (this._type = null, this._lastValue = i, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(s * i) < 200 ? \"trackpad\" : \"wheel\", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();\n      }\n      _onTimeout(e) {\n        this._type = \"wheel\", this._delta -= this._lastValue, this._active || this._start(e);\n      }\n      _start(e) {\n        if (!this._delta) return;\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        const t = g(this._el, e);\n        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n      renderFrame() {\n        if (!this._frameId) return;\n        if (this._frameId = null, !this.isActive()) return;\n        const t = this._map.transform;\n        \"wheel\" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);\n        const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;\n        if (0 !== this._delta) {\n          const e = \"wheel\" === this._type && Math.abs(this._delta) > Qa ? this._wheelZoomRate : this._defaultZoomRate;\n          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));\n          this._delta < 0 && 0 !== o && (o = 1 / o);\n          const s = i(),\n            r = Math.pow(2, s),\n            n = \"number\" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : r;\n          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(n * o))), \"wheel\" === this._type && (this._startZoom = s, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;\n        }\n        const o = \"number\" == typeof this._targetZoom ? this._targetZoom : i(),\n          s = this._startZoom,\n          r = this._easing;\n        let n,\n          a = !1;\n        if (\"wheel\" === this._type && s && r) {\n          const t = Math.min((e.o.now() - this._lastWheelEventTime) / 200, 1),\n            i = r(t);\n          n = e.ak(s, o, i), t < 1 ? this._frameId || (this._frameId = !0) : a = !0;\n        } else n = o, a = !0;\n        this._active = !0, a && (this._active = !1, this._finishTimeout = window.setTimeout(() => {\n          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;\n        }, 200));\n        let l = n - i();\n        return l * this._lastDelta < 0 && (l = 0), {\n          noInertia: !0,\n          needsRenderFrame: !a,\n          zoomDelta: l,\n          around: this._aroundPoint,\n          aroundCoord: this._aroundCoord,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n      _smoothOutEasing(t) {\n        let i = e.eM;\n        if (this._prevEase) {\n          const t = this._prevEase,\n            o = (e.o.now() - t.start) / t.duration,\n            s = t.easing(o + .01) - t.easing(o),\n            r = .27 / Math.sqrt(s * s + 1e-4) * .01,\n            n = Math.sqrt(.0729 - r * r);\n          i = e.eK(r, n, .25, 1);\n        }\n        return this._prevEase = {\n          start: e.o.now(),\n          duration: t,\n          easing: i\n        }, i;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      _addScrollZoomBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = l(\"div\", \"mapboxgl-scroll-zoom-blocker\", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString(\"ScrollZoomBlocker.CmdMessage\") : this._map._getUIString(\"ScrollZoomBlocker.CtrlMessage\"), this._alertContainer.style.fontSize = \"\".concat(Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth))), \"px\"));\n      }\n      _showBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.removeAttribute(\"role\");\n        }, 200);\n      }\n    }\n    class il {\n      constructor(e, t) {\n        this._clickZoom = e, this._tapZoom = t;\n      }\n      enable() {\n        this._clickZoom.enable(), this._tapZoom.enable();\n      }\n      disable() {\n        this._clickZoom.disable(), this._tapZoom.disable();\n      }\n      isEnabled() {\n        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n      }\n      isActive() {\n        return this._clickZoom.isActive() || this._tapZoom.isActive();\n      }\n    }\n    class ol {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      dblclick(e, t) {\n        return e.preventDefault(), {\n          cameraAnimation: i => {\n            i.easeTo({\n              duration: 300,\n              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),\n              around: i.unproject(t)\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class sl {\n      constructor() {\n        this._tap = new za({\n          numTouches: 1,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();\n      }\n      touchstart(e, t, i) {\n        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));\n      }\n      touchmove(e, t, i) {\n        if (this._tapTime) {\n          if (this._swipePoint) {\n            if (i[0].identifier !== this._swipeTouch) return;\n            const o = t[0],\n              s = o.y - this._swipePoint.y;\n            return this._swipePoint = o, e.preventDefault(), this._active = !0, {\n              zoomDelta: s / 128\n            };\n          }\n        } else this._tap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class rl {\n      constructor(e, t, i) {\n        this._el = e, this._mousePan = t, this._touchPan = i;\n      }\n      enable(e) {\n        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(\"mapboxgl-touch-drag-pan\");\n      }\n      disable() {\n        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(\"mapboxgl-touch-drag-pan\");\n      }\n      isEnabled() {\n        return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n      }\n      isActive() {\n        return this._mousePan.isActive() || this._touchPan.isActive();\n      }\n    }\n    class nl {\n      constructor(e, t, i) {\n        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;\n      }\n      enable() {\n        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n      }\n      disable() {\n        this._mouseRotate.disable(), this._mousePitch.disable();\n      }\n      isEnabled() {\n        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n      }\n      isActive() {\n        return this._mouseRotate.isActive() || this._mousePitch.isActive();\n      }\n    }\n    class al {\n      constructor(e, t, i, o) {\n        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n      }\n      enable(e) {\n        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add(\"mapboxgl-touch-zoom-rotate\");\n      }\n      disable() {\n        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(\"mapboxgl-touch-zoom-rotate\");\n      }\n      isEnabled() {\n        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n      }\n      isActive() {\n        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n      }\n      disableRotation() {\n        this._rotationDisabled = !0, this._touchRotate.disable();\n      }\n      enableRotation() {\n        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n      }\n    }\n    const ll = e => e.zoom || e.drag || e.pitch || e.rotate;\n    class cl extends e.z {}\n    class hl {\n      constructor() {\n        this.constants = [1, 1, .01], this.radius = 0;\n      }\n      setup(t, i) {\n        const o = e.av([], i, t);\n        this.radius = e.ag(o[2] < 0 ? e.eO([], o, this.constants) : [o[0], o[1], 0]);\n      }\n      projectRay(t) {\n        e.eO(t, t, this.constants), e.aw(t, t), e.eP(t, t, this.constants);\n        const i = e.c4([], t, this.radius);\n        if (i[2] > 0) {\n          const t = e.c4([], [0, 0, 1], e.bJ(i, [0, 0, 1])),\n            o = e.c4([], e.aw([], [i[0], i[1], 0]), this.radius),\n            s = e.d7([], i, e.c4([], e.av([], e.d7([], o, t), i), 2));\n          i[0] = s[0], i[1] = s[1];\n        }\n        return i;\n      }\n    }\n    function dl(e) {\n      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;\n    }\n    class ul {\n      constructor(t, i) {\n        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new wa(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new hl(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.aY([\"handleEvent\", \"handleWindowEvent\"], this);\n        const o = this._el;\n        this._listeners = [[o, \"touchstart\", {\n          passive: !0\n        }], [o, \"touchmove\", {\n          passive: !1\n        }], [o, \"touchend\", void 0], [o, \"touchcancel\", void 0], [o, \"mousedown\", void 0], [o, \"mousemove\", void 0], [o, \"mouseup\", void 0], [document, \"mousemove\", {\n          capture: !0\n        }], [document, \"mouseup\", void 0], [o, \"mouseover\", void 0], [o, \"mouseout\", void 0], [o, \"dblclick\", void 0], [o, \"click\", void 0], [o, \"keydown\", {\n          capture: !1\n        }], [o, \"keyup\", void 0], [o, \"wheel\", {\n          passive: !1\n        }], [o, \"contextmenu\", void 0], [window, \"blur\", void 0]];\n        for (const [e, t, i] of this._listeners) {\n          const o = e === document ? this.handleWindowEvent : this.handleEvent;\n          e.addEventListener(t, o, i);\n        }\n      }\n      destroy() {\n        for (const [e, t, i] of this._listeners) {\n          const o = e === document ? this.handleWindowEvent : this.handleEvent;\n          e.removeEventListener(t, o, i);\n        }\n      }\n      _addDefaultHandlers(e) {\n        const t = this._map,\n          i = t.getCanvasContainer();\n        this._add(\"mapEvent\", new Ra(t, e));\n        const o = t.boxZoom = new Da(t, e);\n        this._add(\"boxZoom\", o);\n        const s = new Oa(),\n          r = new ol();\n        t.doubleClickZoom = new il(r, s), this._add(\"tapZoom\", s), this._add(\"clickZoom\", r);\n        const n = new sl();\n        this._add(\"tapDragZoom\", n);\n        const a = t.touchPitch = new Xa(t);\n        this._add(\"touchPitch\", a);\n        const l = new Na(e),\n          c = new Ua(e);\n        t.dragRotate = new nl(e, l, c), this._add(\"mouseRotate\", l, [\"mousePitch\"]), this._add(\"mousePitch\", c, [\"mouseRotate\"]);\n        const h = new ka(e),\n          d = new ja(t, e);\n        t.dragPan = new rl(i, h, d), this._add(\"mousePan\", h), this._add(\"touchPan\", d, [\"touchZoom\", \"touchRotate\"]);\n        const u = new Wa(),\n          _ = new qa();\n        t.touchZoomRotate = new al(i, _, u, n), this._add(\"touchRotate\", u, [\"touchPan\", \"touchZoom\"]), this._add(\"touchZoom\", _, [\"touchPan\", \"touchRotate\"]), this._add(\"blockableMapEvent\", new Aa(t));\n        const p = t.scrollZoom = new tl(t, this);\n        this._add(\"scrollZoom\", p, [\"mousePan\"]);\n        const f = t.keyboard = new Ka();\n        this._add(\"keyboard\", f);\n        for (const i of [\"boxZoom\", \"doubleClickZoom\", \"tapDragZoom\", \"touchPitch\", \"dragRotate\", \"dragPan\", \"touchZoomRotate\", \"scrollZoom\", \"keyboard\"]) e.interactive && e[i] && t[i].enable(e[i]);\n      }\n      _add(e, t, i) {\n        this._handlers.push({\n          handlerName: e,\n          handler: t,\n          allowed: i\n        }), this._handlersById[e] = t;\n      }\n      stop(e) {\n        if (!this._updatingCamera) {\n          for (const {\n            handler: e\n          } of this._handlers) e.reset();\n          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;\n        }\n      }\n      isActive() {\n        for (const {\n          handler: e\n        } of this._handlers) if (e.isActive()) return !0;\n        return !1;\n      }\n      isZooming() {\n        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n      }\n      isRotating() {\n        return !!this._eventsInProgress.rotate;\n      }\n      isMoving() {\n        return !!ll(this._eventsInProgress) || this.isZooming();\n      }\n      _isDragging() {\n        return !!this._eventsInProgress.drag;\n      }\n      _blockedByActive(e, t, i) {\n        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;\n        return !1;\n      }\n      handleWindowEvent(e) {\n        this.handleEvent(e, \"\".concat(e.type, \"Window\"));\n      }\n      _getMapTouches(e) {\n        const t = [];\n        for (const i of e) this._el.contains(i.target) && t.push(i);\n        return t;\n      }\n      handleEvent(e, t) {\n        this._updatingCamera = !0;\n        const i = \"renderFrame\" === e.type,\n          o = i ? void 0 : e,\n          s = {\n            needsRenderFrame: !1\n          },\n          r = {},\n          n = {},\n          a = e.touches ? this._getMapTouches(e.touches) : void 0,\n          l = a ? v(this._el, a) : i ? void 0 : g(this._el, e);\n        for (const {\n          handlerName: i,\n          handler: c,\n          allowed: h\n        } of this._handlers) {\n          if (!c.isEnabled()) continue;\n          let d;\n          this._blockedByActive(n, h, i) ? c.reset() : c[t || e.type] && (d = c[t || e.type](e, l, a), this.mergeHandlerResult(s, r, d, i, o), d && d.needsRenderFrame && this._triggerRenderFrame()), (d || c.isActive()) && (n[i] = c);\n        }\n        const c = {};\n        for (const e in this._previousActiveHandlers) n[e] || (c[e] = o);\n        this._previousActiveHandlers = n, (Object.keys(c).length || dl(s)) && (this._changes.push([s, r, c]), this._triggerRenderFrame()), (Object.keys(n).length || dl(s)) && this._map._stop(!0), this._updatingCamera = !1;\n        const {\n          cameraAnimation: h\n        } = s;\n        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));\n      }\n      mergeHandlerResult(e, t, i, o, s) {\n        if (!i) return;\n        Object.assign(e, i);\n        const r = {\n          handlerName: o,\n          originalEvent: i.originalEvent || s\n        };\n        void 0 !== i.zoomDelta && (t.zoom = r), void 0 !== i.panDelta && (t.drag = r), void 0 !== i.pitchDelta && (t.pitch = r), void 0 !== i.bearingDelta && (t.rotate = r);\n      }\n      _applyChanges() {\n        const t = {},\n          i = {},\n          o = {};\n        for (const [s, r, n] of this._changes) s.panDelta && (t.panDelta = (t.panDelta || new e.P(0, 0))._add(s.panDelta)), s.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (t.around = s.around), void 0 !== s.aroundCoord && (t.aroundCoord = s.aroundCoord), void 0 !== s.pinchAround && (t.pinchAround = s.pinchAround), s.noInertia && (t.noInertia = s.noInertia), Object.assign(i, r), Object.assign(o, n);\n        this._updateMapTransform(t, i, o), this._changes = [];\n      }\n      _updateMapTransform(t, i, o) {\n        const s = this._map,\n          r = s.transform,\n          n = e => [e.x, e.y, e.z];\n        if ((e => {\n          const t = this._eventsInProgress.drag;\n          return t && !this._handlersById[t.handlerName].isActive();\n        })() && !dl(t)) {\n          const e = r.zoom;\n          r.cameraElevationReference = \"sea\", null != this._originalZoom && r._orthographicProjectionAtLowPitch && \"globe\" !== r.projection.name && 0 === r.pitch ? (r.cameraElevationReference = \"ground\", r.zoom = this._originalZoom) : (r.recenterOnTerrain(), r.cameraElevationReference = \"ground\"), e !== r.zoom && this._map._update(!0);\n        }\n        if (r._isCameraConstrained && s._stop(!0), !dl(t)) return void this._fireEvents(i, o, !0);\n        let {\n          panDelta: a,\n          zoomDelta: l,\n          bearingDelta: c,\n          pitchDelta: h,\n          around: d,\n          aroundCoord: u,\n          pinchAround: _\n        } = t;\n        r._isCameraConstrained && (l > 0 && (l = 0), r._isCameraConstrained = !1), void 0 !== _ && (d = _), (l || (e => i[e] && !this._eventsInProgress[e])(\"drag\")) && d && (this._dragOrigin = n(r.pointCoordinate3D(d)), this._originalZoom = r.zoom, this._trackingEllipsoid.setup(r._camera.position, this._dragOrigin)), r.cameraElevationReference = \"sea\", s._stop(!0), d = d || s.transform.centerPoint, c && (r.bearing += c), h && (r.pitch += h), r._updateCameraState();\n        const p = [0, 0, 0];\n        if (a) if (\"mercator\" === r.projection.name) {\n          const e = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(d).dir),\n            t = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(d.sub(a)).dir);\n          p[0] = t[0] - e[0], p[1] = t[1] - e[1];\n        } else {\n          const t = r.pointCoordinate(d);\n          if (\"globe\" === r.projection.name) {\n            a = a.rotate(-r.angle);\n            const i = r._pixelsPerMercatorPixel / r.worldSize;\n            p[0] = -a.x * e.eN(e.a$(t.y)) * i, p[1] = -a.y * e.eN(r.center.lat) * i;\n          } else {\n            const e = r.pointCoordinate(d.sub(a));\n            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);\n          }\n        }\n        const f = r.zoom,\n          m = [0, 0, 0];\n        if (l) {\n          const t = n(u || r.pointCoordinate3D(d)),\n            i = {\n              dir: e.aw([], e.av([], t, r._camera.position))\n            };\n          if (i.dir[2] < 0) {\n            const o = r.zoomDeltaToMovement(t, l);\n            e.c4(m, i.dir, o);\n          }\n        }\n        const g = e.d7(p, p, m);\n        r._translateCameraConstrained(g), l && Math.abs(r.zoom - f) > 1e-4 && r.recenterOnTerrain(), r.cameraElevationReference = \"ground\", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);\n      }\n      _fireEvents(t, i, o) {\n        const s = ll(this._eventsInProgress),\n          r = ll(t),\n          n = {};\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._eventsInProgress[e] || (n[\"\".concat(e, \"start\")] = i), this._eventsInProgress[e] = t[e];\n        }\n        !s && r && this._fireEvent(\"movestart\", r.originalEvent);\n        for (const e in n) this._fireEvent(e, n[e]);\n        r && this._fireEvent(\"move\", r.originalEvent);\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._fireEvent(e, i);\n        }\n        const a = {};\n        let l;\n        for (const e in this._eventsInProgress) {\n          const {\n            handlerName: t,\n            originalEvent: o\n          } = this._eventsInProgress[e];\n          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, a[\"\".concat(e, \"end\")] = l);\n        }\n        for (const e in a) this._fireEvent(e, a[e]);\n        const c = ll(this._eventsInProgress);\n        if (o && (s || r) && !c) {\n          this._updatingCamera = !0;\n          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n            i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;\n          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {\n            originalEvent: l\n          })) : (this._map.fire(new e.z(\"moveend\", {\n            originalEvent: l\n          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n        }\n      }\n      _fireEvent(t, i) {\n        this._map.fire(new e.z(t, i ? {\n          originalEvent: i\n        } : {}));\n      }\n      _requestFrame() {\n        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {\n          this._frameId = void 0, this.handleEvent(new cl(\"renderFrame\", {\n            timeStamp: e\n          })), this._applyChanges();\n        });\n      }\n      _triggerRenderFrame() {\n        void 0 === this._frameId && (this._frameId = this._requestFrame());\n      }\n    }\n    const _l = \"map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.\";\n    class pl extends e.E {\n      constructor(t, i) {\n        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.aY([\"_renderFrameCallback\"], this);\n      }\n      getCenter() {\n        return new e.aR(this.transform.center.lng, this.transform.center.lat);\n      }\n      setCenter(e, t) {\n        return this.jumpTo({\n          center: e\n        }, t);\n      }\n      panBy(t, i, o) {\n        return t = e.P.convert(t).mult(-1), this.panTo(this.transform.center, Object.assign({\n          offset: t\n        }, i), o);\n      }\n      panTo(e, t, i) {\n        return this.easeTo(Object.assign({\n          center: e\n        }, t), i);\n      }\n      getZoom() {\n        return this.transform.zoom;\n      }\n      setZoom(e, t) {\n        return this.jumpTo({\n          zoom: e\n        }, t), this;\n      }\n      zoomTo(e, t, i) {\n        return this.easeTo(Object.assign({\n          zoom: e\n        }, t), i);\n      }\n      zoomIn(e, t) {\n        return this.zoomTo(this.getZoom() + 1, e, t), this;\n      }\n      zoomOut(e, t) {\n        return this.zoomTo(this.getZoom() - 1, e, t), this;\n      }\n      getBearing() {\n        return this.transform.bearing;\n      }\n      setBearing(e, t) {\n        return this.jumpTo({\n          bearing: e\n        }, t), this;\n      }\n      getPadding() {\n        return this.transform.padding;\n      }\n      setPadding(e, t) {\n        return this.jumpTo({\n          padding: e\n        }, t), this;\n      }\n      rotateTo(e, t, i) {\n        return this.easeTo(Object.assign({\n          bearing: e\n        }, t), i);\n      }\n      resetNorth(e, t) {\n        return this.rotateTo(0, Object.assign({\n          duration: 1e3\n        }, e), t), this;\n      }\n      resetNorthPitch(e, t) {\n        return this.easeTo(Object.assign({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, e), t), this;\n      }\n      snapToNorth(e, t) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;\n      }\n      getPitch() {\n        return this.transform.pitch;\n      }\n      setPitch(e, t) {\n        return this.jumpTo({\n          pitch: e\n        }, t), this;\n      }\n      cameraForBounds(t, i) {\n        t = e.aI.convert(t);\n        const o = i && i.bearing || 0,\n          s = i && i.pitch || 0,\n          r = t.getNorthWest(),\n          n = t.getSouthEast();\n        return this._cameraForBounds(this.transform, r, n, o, s, i);\n      }\n      _extendPadding(e) {\n        const t = {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        };\n        return null == e ? Object.assign({}, t, this.transform.padding) : \"number\" == typeof e ? {\n          top: e,\n          bottom: e,\n          right: e,\n          left: e\n        } : Object.assign({}, t, e);\n      }\n      _extendCameraOptions(e) {\n        return (e = Object.assign({\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, e)).padding = this._extendPadding(e.padding), e;\n      }\n      _minimumAABBFrustumDistance(e, t) {\n        const i = t.max[0] - t.min[0],\n          o = t.max[1] - t.min[1];\n        return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);\n      }\n      _cameraForBoundsOnGlobe(t, i, o, s, r, n) {\n        const a = t.clone(),\n          l = this._extendCameraOptions(n);\n        a.bearing = s, a.pitch = r;\n        const c = e.aR.convert(i),\n          h = e.aR.convert(o),\n          d = .5 * (c.lat + h.lat),\n          u = .5 * (c.lng + h.lng),\n          _ = e.eQ(d, u),\n          p = e.aw([], _),\n          f = e.aw([], e.bI([], p, [0, 1, 0])),\n          m = e.bI([], f, p),\n          g = [f[0], f[1], f[2], 0, m[0], m[1], m[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],\n          v = [_, e.eQ(c.lat, c.lng), e.eQ(h.lat, c.lng), e.eQ(h.lat, h.lng), e.eQ(c.lat, h.lng), e.eQ(d, c.lng), e.eQ(d, h.lng), e.eQ(c.lat, u), e.eQ(h.lat, u)];\n        let y = e.d8.fromPoints(v.map(t => [e.bJ(f, t), e.bJ(m, t), e.bJ(p, t)]));\n        const x = e.af([], y.center, g);\n        0 === e.eR(x) && e.eS(x, 0, 0, 1), e.aw(x, x), e.c4(x, x, e.aD), a.center = e.eT(x);\n        const b = a.getWorldToCameraMatrix(),\n          w = e.bl(new Float64Array(16), b);\n        y = e.d8.applyTransform(y, e.aB([], b, g));\n        const T = this._extendAABB(y, a, l, s);\n        if (!T) return void e.w(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        y = T, e.af(x, x, b);\n        const E = .5 * (y.max[2] - y.min[2]),\n          S = this._minimumAABBFrustumDistance(a, y),\n          I = e.c4([], [0, 0, 1], E),\n          C = e.d7(I, x, I),\n          R = S + (0 === a.pitch ? 0 : e.bG(x, C)),\n          A = a.globeCenterInViewSpace,\n          D = e.av([], x, [A[0], A[1], A[2]]);\n        e.aw(D, D), e.c4(D, D, R);\n        const L = e.d7([], x, D);\n        e.af(L, L, w);\n        const P = e.eD / e.aD,\n          z = e.ag(L),\n          O = e.ce(Math.max(z * P - e.eD, Number.EPSILON), 0),\n          M = Math.min(a.zoomFromMercatorZAdjusted(O), l.maxZoom);\n        return M > .5 * (e.cZ + e.cK) ? (a.setProjection({\n          name: \"mercator\"\n        }), a.zoom = M, this._cameraForBounds(a, i, o, s, r, n)) : {\n          center: a.center,\n          zoom: M,\n          bearing: s,\n          pitch: r\n        };\n      }\n      _extendAABB(t, i, o, s) {\n        const r = .5 * ((o.padding.left || 0) + (o.padding.right || 0)),\n          n = .5 * ((o.padding.top || 0) + (o.padding.bottom || 0)),\n          a = n,\n          l = r,\n          c = r,\n          h = n,\n          d = i.width - (l + c),\n          u = i.height - (a + h),\n          _ = e.av([], t.max, t.min),\n          p = Math.min(d / _[0], u / _[1]),\n          f = Math.min(i.scaleZoom(i.scale * p), o.maxZoom);\n        if (isNaN(f)) return null;\n        const m = i.scale / i.zoomScale(f),\n          g = new e.d8([t.min[0] - l * m, t.min[1] - h * m, t.min[2]], [t.max[0] + c * m, t.max[1] + a * m, t.max[2]]),\n          v = (\"number\" == typeof o.offset.x && \"number\" == typeof o.offset.y ? new e.P(o.offset.x, o.offset.y) : e.P.convert(o.offset)).rotate(-e.an(s));\n        return g.center[0] -= v.x * m, g.center[1] += v.y * m, g;\n      }\n      queryTerrainElevation(t, i) {\n        const o = this.transform.elevation;\n        return o ? (i = Object.assign({}, {\n          exaggerated: !0\n        }, i), o.getAtPoint(e.ae.fromLngLat(t), null, i.exaggerated)) : null;\n      }\n      _cameraForBounds(t, i, o, s, r, n) {\n        if (\"globe\" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, s, r, n);\n        const a = t.clone(),\n          l = this._extendCameraOptions(n);\n        a.bearing = s, a.pitch = r;\n        const c = e.aR.convert(i),\n          h = e.aR.convert(o),\n          d = new e.aR(c.lng, h.lat),\n          u = new e.aR(h.lng, c.lat),\n          _ = a.project(c),\n          p = a.project(h),\n          f = this.queryTerrainElevation(c),\n          m = this.queryTerrainElevation(h),\n          g = this.queryTerrainElevation(d),\n          v = this.queryTerrainElevation(u),\n          y = [[_.x, _.y, Math.min(f || 0, m || 0, g || 0, v || 0)], [p.x, p.y, Math.max(f || 0, m || 0, g || 0, v || 0)]];\n        let x = e.d8.fromPoints(y);\n        const b = a.getWorldToCameraMatrix(),\n          w = e.bl(new Float64Array(16), b);\n        x = e.d8.applyTransform(x, b);\n        const T = this._extendAABB(x, a, l, s);\n        if (!T) return void e.w(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        x = T;\n        const E = .5 * e.av([], x.max, x.min)[2],\n          S = this._minimumAABBFrustumDistance(a, x),\n          I = [0, 0, 1, 0];\n        e.aC(I, I, b), e.eU(I, I);\n        const C = e.c4([], I, S + E),\n          R = e.d7([], x.center, C);\n        e.af(x.center, x.center, w), e.af(R, R, w);\n        const A = a.unproject(new e.P(x.center[0], x.center[1])),\n          D = e.eV(a.projection, A),\n          L = Math.pow(2, D),\n          P = Math.min(a._zoomFromMercatorZ(R[2] * a.pixelsPerMeter * L / a.worldSize), l.maxZoom);\n        return a.mercatorFromTransition && P < .5 * (e.cZ + e.cK) ? (a.setProjection({\n          name: \"globe\"\n        }), a.zoom = P, this._cameraForBounds(a, i, o, s, r, n)) : {\n          center: A,\n          zoom: P,\n          bearing: s,\n          pitch: r\n        };\n      }\n      fitBounds(e, t, i) {\n        const o = this.cameraForBounds(e, t);\n        return this._fitInternal(o, t, i);\n      }\n      fitScreenCoordinates(t, i, o, s, r) {\n        const n = e.P.convert(t),\n          a = e.P.convert(i),\n          l = new e.P(Math.min(n.x, a.x), Math.min(n.y, a.y)),\n          c = new e.P(Math.max(n.x, a.x), Math.max(n.y, a.y));\n        if (\"mercator\" === this.transform.projection.name && this.transform.anyCornerOffEdge(n, a)) return this;\n        const h = this.transform.pointLocation3D(l),\n          d = this.transform.pointLocation3D(c),\n          u = this.transform.pointLocation3D(new e.P(l.x, c.y)),\n          _ = this.transform.pointLocation3D(new e.P(c.x, l.y)),\n          p = [Math.min(h.lng, d.lng, u.lng, _.lng), Math.min(h.lat, d.lat, u.lat, _.lat)],\n          f = [Math.max(h.lng, d.lng, u.lng, _.lng), Math.max(h.lat, d.lat, u.lat, _.lat)],\n          m = s && s.pitch ? s.pitch : this.getPitch(),\n          g = this._cameraForBounds(this.transform, p, f, o, m, s);\n        return this._fitInternal(g, s, r);\n      }\n      _fitInternal(e, t, i) {\n        return e ? (t = Object.assign(e, t)).linear ? this.easeTo(t, i) : this.flyTo(t, i) : this;\n      }\n      jumpTo(t, i) {\n        this.stop();\n        const o = t.preloadOnly ? this.transform.clone() : this.transform;\n        let s = !1,\n          r = !1,\n          n = !1;\n        \"zoom\" in t && o.zoom !== +t.zoom && (s = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.aR.convert(t.center)), \"bearing\" in t && o.bearing !== +t.bearing && (r = !0, o.bearing = +t.bearing), \"pitch\" in t && o.pitch !== +t.pitch && (n = !0, o.pitch = +t.pitch);\n        const a = \"number\" == typeof t.padding ? this._extendPadding(t.padding) : t.padding;\n        if (null != t.padding && !o.isPaddingEqual(a)) if (!1 === t.retainPadding) {\n          const e = o.clone();\n          e.padding = a, o.setLocationAtPoint(o.center, e.centerPoint);\n        } else o.padding = a;\n        return t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.z(\"movestart\", i)).fire(new e.z(\"move\", i)), s && this.fire(new e.z(\"zoomstart\", i)).fire(new e.z(\"zoom\", i)).fire(new e.z(\"zoomend\", i)), r && this.fire(new e.z(\"rotatestart\", i)).fire(new e.z(\"rotate\", i)).fire(new e.z(\"rotateend\", i)), n && this.fire(new e.z(\"pitchstart\", i)).fire(new e.z(\"pitch\", i)).fire(new e.z(\"pitchend\", i)), this.fire(new e.z(\"moveend\", i)));\n      }\n      getFreeCameraOptions() {\n        return this.transform.projection.supportsFreeCamera || e.w(_l), this.transform.getFreeCameraOptions();\n      }\n      setFreeCameraOptions(t, i) {\n        const o = this.transform;\n        if (!o.projection.supportsFreeCamera) return e.w(_l), this;\n        this.stop();\n        const s = o.zoom,\n          r = o.pitch,\n          n = o.bearing;\n        o.setFreeCameraOptions(t);\n        const a = s !== o.zoom,\n          l = r !== o.pitch,\n          c = n !== o.bearing;\n        return this.fire(new e.z(\"movestart\", i)).fire(new e.z(\"move\", i)), a && this.fire(new e.z(\"zoomstart\", i)).fire(new e.z(\"zoom\", i)).fire(new e.z(\"zoomend\", i)), c && this.fire(new e.z(\"rotatestart\", i)).fire(new e.z(\"rotate\", i)).fire(new e.z(\"rotateend\", i)), l && this.fire(new e.z(\"pitchstart\", i)).fire(new e.z(\"pitch\", i)).fire(new e.z(\"pitchend\", i)), this.fire(new e.z(\"moveend\", i)), this;\n      }\n      easeTo(t, i) {\n        this._stop(!1, t.easeId), (!1 === (t = Object.assign({\n          offset: [0, 0],\n          duration: 500,\n          easing: e.eM\n        }, t)).animate || this._prefersReducedMotion(t)) && (t.duration = 0);\n        const o = this.transform,\n          s = this.getZoom(),\n          r = this.getBearing(),\n          n = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? +t.zoom : s,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, r) : r,\n          h = \"pitch\" in t ? +t.pitch : n,\n          d = this._extendPadding(t.padding),\n          u = e.P.convert(t.offset);\n        let _, p, f;\n        if (\"globe\" === o.projection.name) {\n          const i = e.ae.fromLngLat(o.center),\n            s = u.rotate(-o.angle);\n          i.x += s.x / o.worldSize, i.y += s.y / o.worldSize;\n          const r = i.toLngLat(),\n            n = e.aR.convert(t.center || r);\n          this._normalizeCenter(n), _ = o.centerPoint.add(s), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.aF(n.lng), e.aJ(n.lat)).mult(o.worldSize).sub(p);\n        } else {\n          _ = o.centerPoint.add(u);\n          const i = o.pointLocation(_),\n            s = e.aR.convert(t.center || i);\n          this._normalizeCenter(s), p = o.project(i), f = o.project(s).sub(p);\n        }\n        const m = o.zoomScale(l - s);\n        let g, v;\n        t.around && (g = e.aR.convert(t.around), v = o.locationPoint(g));\n        const y = this._zooming || l !== s,\n          x = this._rotating || r !== c,\n          b = this._pitching || h !== n,\n          w = !o.isPaddingEqual(d),\n          T = !1 === t.retainPadding ? o.clone() : o,\n          E = o => E => {\n            if (y && (o.zoom = e.ak(s, l, E)), x && (o.bearing = e.ak(r, c, E)), b && (o.pitch = e.ak(n, h, E)), w && (T.interpolatePadding(a, d, E), _ = T.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);else {\n              const e = o.zoomScale(o.zoom - s),\n                t = l > s ? Math.min(2, m) : Math.max(.5, m),\n                i = Math.pow(t, 1 - E),\n                r = o.unproject(p.add(f.mult(E * i)).mult(e));\n              o.setLocationAtPoint(o.renderWorldCopies ? r.wrap() : r, _);\n            }\n            return t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(E, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        const S = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = y, this._rotating = x, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, S), this._ease(E(o), e => {\n          \"sea\" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);\n        }, t), this;\n      }\n      _prepareEase(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this._moving = !0, this.transform.cameraElevationReference = \"sea\", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && \"globe\" !== this.transform.projection.name && (this.transform.cameraElevationReference = \"ground\"), i || o.moving || this.fire(new e.z(\"movestart\", t)), this._zooming && !o.zooming && this.fire(new e.z(\"zoomstart\", t)), this._rotating && !o.rotating && this.fire(new e.z(\"rotatestart\", t)), this._pitching && !o.pitching && this.fire(new e.z(\"pitchstart\", t));\n      }\n      _fireMoveEvents(t) {\n        this.fire(new e.z(\"move\", t)), this._zooming && this.fire(new e.z(\"zoom\", t)), this._rotating && this.fire(new e.z(\"rotate\", t)), this._pitching && this.fire(new e.z(\"pitch\", t));\n      }\n      _afterEase(t, i) {\n        if (this._easeId && i && this._easeId === i) return;\n        this._easeId = void 0, this.transform.cameraElevationReference = \"ground\";\n        const o = this._zooming,\n          s = this._rotating,\n          r = this._pitching;\n        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.z(\"zoomend\", t)), s && this.fire(new e.z(\"rotateend\", t)), r && this.fire(new e.z(\"pitchend\", t)), this.fire(new e.z(\"moveend\", t));\n      }\n      flyTo(t, i) {\n        if (this._prefersReducedMotion(t)) {\n          const o = e.aH(t, [\"center\", \"zoom\", \"bearing\", \"pitch\", \"around\", \"padding\", \"retainPadding\"]);\n          return this.jumpTo(o, i);\n        }\n        this.stop(), t = Object.assign({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: e.eM\n        }, t);\n        const o = this.transform,\n          s = this.getZoom(),\n          r = this.getBearing(),\n          n = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? e.aA(+t.zoom, o.minZoom, o.maxZoom) : s,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, r) : r,\n          h = \"pitch\" in t ? +t.pitch : n,\n          d = this._extendPadding(t.padding),\n          u = o.zoomScale(l - s),\n          _ = e.P.convert(t.offset);\n        let p = o.centerPoint.add(_);\n        const f = o.pointLocation(p),\n          m = e.aR.convert(t.center || f);\n        this._normalizeCenter(m);\n        const g = o.project(f),\n          v = o.project(m).sub(g);\n        let y = t.curve;\n        const x = Math.max(o.width, o.height),\n          b = x / u,\n          w = v.mag();\n        if (\"minZoom\" in t) {\n          const i = e.aA(Math.min(t.minZoom, s, l), o.minZoom, o.maxZoom),\n            r = x / o.zoomScale(i - s);\n          y = Math.sqrt(r / w * 2);\n        }\n        const T = y * y;\n        function E(e) {\n          const t = (b * b - x * x + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : x) * T * w);\n          return Math.log(Math.sqrt(t * t + 1) - t);\n        }\n        function S(e) {\n          return (Math.exp(e) - Math.exp(-e)) / 2;\n        }\n        function I(e) {\n          return (Math.exp(e) + Math.exp(-e)) / 2;\n        }\n        const C = E(0);\n        let R = function (e) {\n            return I(C) / I(C + y * e);\n          },\n          A = function (e) {\n            return x * ((I(C) * (S(t = C + y * e) / I(t)) - S(C)) / T) / w;\n            var t;\n          },\n          D = (E(1) - C) / y;\n        if (Math.abs(w) < 1e-6 || !isFinite(D)) {\n          if (Math.abs(x - b) < 1e-6) return this.easeTo(t, i);\n          const e = b < x ? -1 : 1;\n          D = Math.abs(Math.log(b / x)) / y, A = function () {\n            return 0;\n          }, R = function (t) {\n            return Math.exp(e * y * t);\n          };\n        }\n        t.duration = \"duration\" in t ? +t.duration : 1e3 * D / (\"screenSpeed\" in t ? +t.screenSpeed / y : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);\n        const L = r !== c,\n          P = h !== n,\n          z = !o.isPaddingEqual(d),\n          O = !1 === t.retainPadding ? o.clone() : o,\n          M = o => u => {\n            const f = u * D,\n              y = 1 / R(f);\n            o.zoom = 1 === u ? l : s + o.scaleZoom(y), L && (o.bearing = e.ak(r, c, u)), P && (o.pitch = e.ak(n, h, u)), z && (O.interpolatePadding(a, d, u), p = O.centerPoint.add(_));\n            const x = 1 === u ? m : o.unproject(g.add(v.mult(A(f))).mult(y));\n            return o.setLocationAtPoint(o.renderWorldCopies ? x.wrap() : x, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(M, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        return this._zooming = !0, this._rotating = L, this._pitching = P, this._padding = z, this._prepareEase(i, !1), this._ease(M(o), () => this._afterEase(i), t), this;\n      }\n      isEasing() {\n        return !!this._easeFrameId;\n      }\n      stop() {\n        return this._stop();\n      }\n      _requestRenderFrame(e) {}\n      _cancelRenderFrame(e) {}\n      _stop(e, t) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {\n          const e = this._onEaseEnd;\n          this._onEaseEnd = void 0, e.call(this, t);\n        }\n        if (!e) {\n          const e = this.handlers;\n          e && e.stop(!1);\n        }\n        return this;\n      }\n      _ease(t, i, o) {\n        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.o.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }\n      _renderFrameCallback() {\n        const t = Math.min((e.o.now() - this._easeStart) / this._easeOptions.duration, 1),\n          i = this._onEaseFrame;\n        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }\n      _normalizeBearing(t, i) {\n        t = e.bT(t, -180, 180);\n        const o = Math.abs(t - i);\n        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;\n      }\n      _normalizeCenter(e) {\n        const t = this.transform;\n        if (t.maxBounds) return;\n        if (\"globe\" !== t.projection.name && !t.renderWorldCopies) return;\n        const i = e.lng - t.center.lng;\n        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n      }\n      _prefersReducedMotion(t) {\n        return this._respectPrefersReducedMotion && e.o.prefersReducedMotion && !(t && t.essential);\n      }\n      _emulate(e, t, i) {\n        const o = Math.ceil(15 * t / 1e3),\n          s = [],\n          r = e(i.clone());\n        for (let e = 0; e <= o; e++) {\n          const t = r(e / o);\n          s.push(t.clone());\n        }\n        return s;\n      }\n      _preloadTiles(e, t) {}\n    }\n    class fl {\n      constructor() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.options = t, e.aY([\"_toggleAttribution\", \"_updateEditLink\", \"_updateData\", \"_updateCompact\"], this);\n      }\n      getDefaultPosition() {\n        return \"bottom-right\";\n      }\n      onAdd(e) {\n        const t = this.options && this.options.compact,\n          i = e._getUIString(\"AttributionControl.ToggleAttribution\");\n        this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-attrib\"), this._compactButton = l(\"button\", \"mapboxgl-ctrl-attrib-button\", this._container), this._compactButton.type = \"button\", this._compactButton.addEventListener(\"click\", this._toggleAttribution), this._compactButton.setAttribute(\"aria-label\", i);\n        const o = l(\"span\", \"mapboxgl-ctrl-icon\", this._compactButton);\n        return o.setAttribute(\"aria-hidden\", \"true\"), o.setAttribute(\"title\", i), this._innerContainer = l(\"div\", \"mapboxgl-ctrl-attrib-inner\", this._container), t && this._container.classList.add(\"mapboxgl-compact\"), this._updateAttributions(), this._updateEditLink(), this._map.on(\"styledata\", this._updateData), this._map.on(\"sourcedata\", this._updateData), this._map.on(\"moveend\", this._updateEditLink), void 0 === t && (this._map.on(\"resize\", this._updateCompact), this._updateCompact()), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"styledata\", this._updateData), this._map.off(\"sourcedata\", this._updateData), this._map.off(\"moveend\", this._updateEditLink), this._map.off(\"resize\", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n      }\n      _toggleAttribution() {\n        this._container.classList.contains(\"mapboxgl-compact-show\") ? (this._container.classList.remove(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"false\")) : (this._container.classList.add(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"true\"));\n      }\n      _updateEditLink() {\n        let t = this._editLink;\n        t || (t = this._editLink = this._container.querySelector(\".mapbox-improve-map\"));\n        const i = [{\n          key: \"owner\",\n          value: this.styleOwner\n        }, {\n          key: \"id\",\n          value: this.styleId\n        }, {\n          key: \"access_token\",\n          value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN\n        }];\n        if (t) {\n          const o = i.reduce((e, t, o) => (t.value && (e += \"\".concat(t.key, \"=\").concat(t.value).concat(o < i.length - 1 ? \"&\" : \"\")), e), \"?\");\n          t.href = \"\".concat(e.e.FEEDBACK_URL, \"/\").concat(o, \"#\").concat(ma(this._map, !0)), t.rel = \"noopener nofollow\";\n        }\n      }\n      _updateData(e) {\n        !e || (\"source\" !== e.dataType || \"metadata\" !== e.sourceDataType && \"visibility\" !== e.sourceDataType) && \"style\" !== e.dataType || (this._updateAttributions(), this._updateEditLink());\n      }\n      _updateAttributions() {\n        if (!this._map.style) return;\n        let e = [];\n        if (this._map.style.stylesheet) {\n          const e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n        const t = this._map.style._mergedSourceCaches;\n        for (const i in t) {\n          const o = t[i];\n          if (o.used) {\n            const t = o.getSource();\n            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);\n          }\n        }\n        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {\n          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;\n          return !0;\n        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));\n        const i = e.join(\" | \");\n        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove(\"mapboxgl-attrib-empty\")) : this._container.classList.add(\"mapboxgl-attrib-empty\"), this._editLink = null);\n      }\n      _updateCompact() {\n        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add(\"mapboxgl-compact\") : this._container.classList.remove(\"mapboxgl-compact\", \"mapboxgl-compact-show\");\n      }\n    }\n    class ml {\n      constructor() {\n        e.aY([\"_updateLogo\", \"_updateCompact\"], this);\n      }\n      onAdd(e) {\n        this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl\");\n        const t = l(\"a\", \"mapboxgl-ctrl-logo\");\n        return t.target = \"_blank\", t.rel = \"noopener nofollow\", t.href = \"https://www.mapbox.com/\", t.setAttribute(\"aria-label\", this._map._getUIString(\"LogoControl.Title\")), t.setAttribute(\"rel\", \"noopener nofollow\"), this._container.appendChild(t), this._container.style.display = \"none\", this._map.on(\"sourcedata\", this._updateLogo), this._updateLogo(), this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"sourcedata\", this._updateLogo), this._map.off(\"resize\", this._updateCompact);\n      }\n      getDefaultPosition() {\n        return \"bottom-left\";\n      }\n      _updateLogo(e) {\n        e && \"metadata\" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? \"block\" : \"none\");\n      }\n      _logoRequired() {\n        if (!this._map.style) return !0;\n        const e = this._map.style._sourceCaches;\n        if (0 === Object.entries(e).length) return !0;\n        for (const t in e) {\n          const i = e[t].getSource();\n          if (i.hasOwnProperty(\"mapbox_logo\") && !i.mapbox_logo) return !1;\n        }\n        return !0;\n      }\n      _updateCompact() {\n        const e = this._container.children;\n        if (e.length) {\n          const t = e[0];\n          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add(\"mapboxgl-compact\") : t.classList.remove(\"mapboxgl-compact\");\n        }\n      }\n    }\n    class gl {\n      constructor() {\n        e.aY([\"_onIndoorUpdate\"], this);\n      }\n      onAdd(e) {\n        return this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._map.indoor.on(\"indoorupdate\", e => this._onIndoorUpdate({\n          selectedFloorId: e.selectedFloorId,\n          floors: e.floors\n        })), this._container;\n      }\n      _createButton(e, t) {\n        const i = l(\"button\", e, this._container);\n        return i.type = \"button\", i.addEventListener(\"click\", t), i;\n      }\n      _createSeparator() {\n        return l(\"div\", \"mapboxgl-ctrl-separator\", this._container);\n      }\n      _setButtonTitle(e, t) {\n        this._map && (e.setAttribute(\"aria-label\", t), e.textContent = t);\n      }\n      onRemove() {\n        this._container && this._container.remove(), this._map && this._map.indoor && (this._map.indoor.off(\"indoorupdate\", this._onIndoorUpdate), this._map = null);\n      }\n      getDefaultPosition() {\n        return \"right\";\n      }\n      _onIndoorUpdate(e) {\n        if (!e || !e.floors) return void (this._container.style.display = \"none\");\n        const t = this._model;\n        this._model = e, this._container.style.display = \"inline-block\", this._container.style.borderRadius = \"8px\";\n        const i = e.floors.sort((e, t) => t.levelOrder - e.levelOrder);\n        t ? (Array.from(this._container.children).forEach(e => e.remove()), this.addCurrentFloors(i)) : this.addCurrentFloors(i);\n      }\n      addCurrentFloors(e) {\n        for (let t = 0; t < e.length; t++) {\n          const i = e[t],\n            o = this._createButton(\"mapboxgl-ctrl-level-button\", () => {\n              this._map._selectIndoorFloor(i.id), this._model && (this._model.selectedFloorId = i.id), Array.from(this._container.children).forEach(e => {\n                e.classList.contains(\"mapboxgl-ctrl-level-button\") && e.classList.remove(\"mapboxgl-ctrl-level-button-selected\");\n              }), o.classList.add(\"mapboxgl-ctrl-level-button-selected\");\n            });\n          this._setButtonTitle(o, i.shortName), this._model && i.id === this._model.selectedFloorId && o.classList.add(\"mapboxgl-ctrl-level-button-selected\"), this._container.append(o), t < e.length - 1 && this._createSeparator();\n        }\n      }\n    }\n    class vl {\n      constructor() {\n        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n      }\n      add(e) {\n        const t = ++this._id;\n        return this._queue.push({\n          callback: e,\n          id: t,\n          cancelled: !1\n        }), t;\n      }\n      remove(e) {\n        const t = this._currentlyRunning,\n          i = t ? this._queue.concat(t) : this._queue;\n        for (const t of i) if (t.id === e) return void (t.cancelled = !0);\n      }\n      run() {\n        let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        const t = this._currentlyRunning = this._queue;\n        this._queue = [];\n        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;\n        this._cleared = !1, this._currentlyRunning = !1;\n      }\n      clear() {\n        this._currentlyRunning && (this._cleared = !0), this._queue = [];\n      }\n    }\n    class yl {\n      constructor(e) {\n        this.jumpTo(e);\n      }\n      getValue(t) {\n        if (t <= this._startTime) return this._start;\n        if (t >= this._endTime) return this._end;\n        const i = e.dz((t - this._startTime) / (this._endTime - this._startTime));\n        return this._start * (1 - i) + this._end * i;\n      }\n      isEasing(e) {\n        return e >= this._startTime && e <= this._endTime;\n      }\n      jumpTo(e) {\n        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;\n      }\n      easeTo(e, t, i) {\n        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;\n      }\n    }\n    const xl = {\n      \"AttributionControl.ToggleAttribution\": \"Toggle attribution\",\n      \"FullscreenControl.Enter\": \"Enter fullscreen\",\n      \"FullscreenControl.Exit\": \"Exit fullscreen\",\n      \"GeolocateControl.FindMyLocation\": \"Find my location\",\n      \"GeolocateControl.LocationNotAvailable\": \"Location not available\",\n      \"LogoControl.Title\": \"Mapbox homepage\",\n      \"Map.Title\": \"Map\",\n      \"NavigationControl.ResetBearing\": \"Reset bearing to north\",\n      \"NavigationControl.ZoomIn\": \"Zoom in\",\n      \"NavigationControl.ZoomOut\": \"Zoom out\",\n      \"ScrollZoomBlocker.CtrlMessage\": \"Use ctrl + scroll to zoom the map\",\n      \"ScrollZoomBlocker.CmdMessage\": \"Use â + scroll to zoom the map\",\n      \"TouchPanBlocker.Message\": \"Use two fingers to move the map\"\n    };\n    class bl extends e.z {\n      constructor(e, t, i, o) {\n        const {\n          point: s,\n          lngLat: r,\n          originalEvent: n,\n          target: a\n        } = e;\n        super(e.type, {\n          point: s,\n          lngLat: r,\n          originalEvent: n,\n          target: a\n        }), this.preventDefault = () => {\n          e.preventDefault();\n        }, this.id = t, this.interaction = i, this.feature = o;\n      }\n    }\n    class wl {\n      constructor(e) {\n        this.map = e, this.interactionsByType = new Map(), this.delegatedInteractions = new Map(), this.typeById = new Map(), this.filters = new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = new Map(), this.prevHoveredFeatures = new Map();\n      }\n      add(t, i) {\n        if (this.typeById.has(t)) throw new Error(\"Interaction id \\\"\".concat(t, \"\\\" already exists.\"));\n        const o = i.filter;\n        let s = i.type;\n        o && this.filters.set(t, e.b6(o)), \"mouseover\" === s && (s = \"mouseenter\"), \"mouseout\" === s && (s = \"mouseleave\");\n        const r = this.interactionsByType.get(s) || new Map();\n        \"mouseenter\" === s || \"mouseleave\" === s ? (0 === this.delegatedInteractions.size && (this.map.on(\"mousemove\", this.handleMove), this.map.on(\"mouseout\", this.handleOut)), this.delegatedInteractions.set(t, i)) : 0 === r.size && this.map.on(s, this.handleType), 0 === r.size && this.interactionsByType.set(s, r), r.set(t, i), this.typeById.set(t, s);\n      }\n      get(e) {\n        const t = this.typeById.get(e);\n        if (!t) return;\n        const i = this.interactionsByType.get(t);\n        return i ? i.get(e) : void 0;\n      }\n      remove(e) {\n        const t = this.typeById.get(e);\n        if (!t) return;\n        this.typeById.delete(e), this.filters.delete(e);\n        const i = this.interactionsByType.get(t);\n        i && (i.delete(e), \"mouseenter\" === t || \"mouseleave\" === t ? (this.delegatedInteractions.delete(e), 0 === this.delegatedInteractions.size && (this.map.off(\"mousemove\", this.handleMove), this.map.off(\"mouseout\", this.handleOut))) : 0 === i.size && this.map.off(t, this.handleType));\n      }\n      queryTargets(e, t) {\n        const i = [];\n        for (const [e, o] of t) o.target && i.push({\n          targetId: e,\n          target: o.target,\n          filter: this.filters.get(e)\n        });\n        return this.map.style.queryRenderedTargets(e, i, this.map.transform);\n      }\n      handleMove(e) {\n        this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = new Map();\n        const t = this.queryTargets(e.point, Array.from(this.delegatedInteractions).reverse());\n        t.length && (e.type = \"mouseenter\", this.handleType(e, t));\n        const i = new Map();\n        for (const [e, {\n          feature: t\n        }] of this.prevHoveredFeatures) this.hoveredFeatures.has(e) || i.set(t.id, t);\n        i.size && (e.type = \"mouseleave\", this.handleType(e, Array.from(i.values())));\n      }\n      handleOut(e) {\n        const t = Array.from(this.hoveredFeatures.values()).map(_ref104 => {\n          let {\n            feature: e\n          } = _ref104;\n          return e;\n        });\n        t.length && (e.type = \"mouseleave\", this.handleType(e, t)), this.hoveredFeatures.clear();\n      }\n      handleType(t, i) {\n        const o = \"mouseenter\" === t.type;\n        if (o && !this.interactionsByType.has(t.type)) return void e.w(\"mouseenter interaction required for mouseleave to work.\");\n        const s = Array.from(this.interactionsByType.get(t.type)).reverse(),\n          r = !!i;\n        i = i || this.queryTargets(t.point, s);\n        let n = !1;\n        const a = new Set();\n        for (const l of i) {\n          for (const [i, c] of s) {\n            if (!c.target) continue;\n            const s = l.variants ? l.variants[i] : null;\n            if (s) {\n              for (const h of s) {\n                if (ht(h, l, a, i)) continue;\n                const s = new e.dt(l, h),\n                  d = ct(h, l, i);\n                r && (s.state = this.map.getFeatureState(s));\n                const u = o ? this.prevHoveredFeatures.get(d) : null,\n                  _ = new bl(t, i, c, s),\n                  p = u ? u.stop : c.handler(_);\n                if (o && this.hoveredFeatures.set(d, {\n                  feature: l,\n                  stop: p\n                }), !1 !== p) {\n                  n = !0;\n                  break;\n                }\n              }\n              if (n) break;\n            }\n          }\n          if (n) break;\n        }\n        if (!n) for (const [e, i] of s) {\n          const {\n            handler: o,\n            target: s\n          } = i;\n          if (!s && !1 !== o(new bl(t, e, i, null))) break;\n        }\n      }\n    }\n    function Tl(t, i) {\n      if (Array.isArray(t) && Array.isArray(i)) {\n        const e = new Set(t),\n          o = new Set(i);\n        return e.size === o.size && t.every(e => o.has(e));\n      }\n      return e.by(t, i);\n    }\n    const El = {\n        center: [0, 0],\n        zoom: 0,\n        bearing: 0,\n        pitch: 0,\n        minZoom: -2,\n        maxZoom: 22,\n        minPitch: 0,\n        maxPitch: 85,\n        interactive: !0,\n        scrollZoom: !0,\n        boxZoom: !0,\n        dragRotate: !0,\n        dragPan: !0,\n        keyboard: !0,\n        doubleClickZoom: !0,\n        touchZoomRotate: !0,\n        touchPitch: !0,\n        cooperativeGestures: !1,\n        performanceMetricsCollection: !0,\n        bearingSnap: 7,\n        clickTolerance: 3,\n        pitchWithRotate: !0,\n        hash: !1,\n        attributionControl: !0,\n        antialias: !1,\n        failIfMajorPerformanceCaveat: !1,\n        preserveDrawingBuffer: !1,\n        trackResize: !0,\n        renderWorldCopies: !0,\n        refreshExpiredTiles: !0,\n        minTileCacheSize: null,\n        maxTileCacheSize: null,\n        localIdeographFontFamily: \"sans-serif\",\n        localFontFamily: null,\n        transformRequest: null,\n        accessToken: null,\n        fadeDuration: 300,\n        respectPrefersReducedMotion: !0,\n        crossSourceCollisions: !0,\n        collectResourceTiming: !1,\n        testMode: !1,\n        precompilePrograms: !0,\n        scaleFactor: 1,\n        spriteFormat: \"auto\"\n      },\n      Sl = {\n        showCompass: !0,\n        showZoom: !0,\n        visualizePitch: !1\n      };\n    class Il {\n      constructor(t, i) {\n        let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        this._clickTolerance = 10, this.element = i, this.mouseRotate = new Na({\n          clickTolerance: t.dragRotate._mouseRotate._clickTolerance\n        }), this.map = t, o && (this.mousePitch = new Ua({\n          clickTolerance: t.dragRotate._mousePitch._clickTolerance\n        })), e.aY([\"mousedown\", \"mousemove\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\", \"reset\"], this), i.addEventListener(\"mousedown\", this.mousedown), i.addEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), i.addEventListener(\"touchmove\", this.touchmove), i.addEventListener(\"touchend\", this.touchend), i.addEventListener(\"touchcancel\", this.reset);\n      }\n      down(e, t) {\n        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), _();\n      }\n      move(e, t) {\n        const i = this.map,\n          o = this.mouseRotate.mousemoveWindow(e, t),\n          s = o && o.bearingDelta;\n        if (s && i.setBearing(i.getBearing() + s), this.mousePitch) {\n          const o = this.mousePitch.mousemoveWindow(e, t),\n            s = o && o.pitchDelta;\n          s && i.setPitch(i.getPitch() + s);\n        }\n      }\n      off() {\n        const e = this.element;\n        e.removeEventListener(\"mousedown\", this.mousedown), e.removeEventListener(\"touchstart\", this.touchstart), e.removeEventListener(\"touchmove\", this.touchmove), e.removeEventListener(\"touchend\", this.touchend), e.removeEventListener(\"touchcancel\", this.reset), this.offTemp();\n      }\n      offTemp() {\n        p(), window.removeEventListener(\"mousemove\", this.mousemove), window.removeEventListener(\"mouseup\", this.mouseup);\n      }\n      mousedown(e) {\n        this.down(Object.assign({}, e, {\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }), g(this.element, e)), window.addEventListener(\"mousemove\", this.mousemove), window.addEventListener(\"mouseup\", this.mouseup);\n      }\n      mousemove(e) {\n        this.move(e, g(this.element, e));\n      }\n      mouseup(e) {\n        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();\n      }\n      touchstart(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e.targetTouches)[0], this.down({\n          type: \"mousedown\",\n          button: 0,\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }, this._startPos));\n      }\n      touchmove(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e.targetTouches)[0], this.move({\n          preventDefault: () => e.preventDefault()\n        }, this._lastPos));\n      }\n      touchend(e) {\n        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n      }\n      reset() {\n        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n      }\n    }\n    function Cl(t, i, o) {\n      if (t = new e.aR(t.lng, t.lat), i) {\n        const s = new e.aR(t.lng - 360, t.lat),\n          r = new e.aR(t.lng + 360, t.lat),\n          n = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),\n          a = o.locationPoint3D(t).distSqr(i),\n          l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;\n        o.locationPoint3D(s).distSqr(i) < a && (l || Math.abs(s.lng - o.center.lng) < n) ? t = s : o.locationPoint3D(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < n) && (t = r);\n      }\n      for (; Math.abs(t.lng - o.center.lng) > 180;) {\n        const e = o.locationPoint3D(t);\n        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;\n        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;\n      }\n      return t;\n    }\n    const Rl = {\n        center: \"translate(-50%,-50%)\",\n        top: \"translate(-50%,0)\",\n        \"top-left\": \"translate(0,0)\",\n        \"top-right\": \"translate(-100%,0)\",\n        bottom: \"translate(-50%,-100%)\",\n        \"bottom-left\": \"translate(0,-100%)\",\n        \"bottom-right\": \"translate(-100%,-100%)\",\n        left: \"translate(0,-50%)\",\n        right: \"translate(-100%,-50%)\"\n      },\n      Al = {\n        rotation: 0,\n        rotationAlignment: \"auto\",\n        pitchAlignment: \"auto\",\n        occludedOpacity: .2,\n        altitude: 0\n      };\n    class Dl extends e.E {\n      constructor(t, i) {\n        super(), (t instanceof HTMLElement || i) && (t = Object.assign({\n          element: t\n        }, i)), e.aY([\"_update\", \"_onMove\", \"_onUp\", \"_addDragHandler\", \"_onMapClick\", \"_onKeyPress\", \"_clearFadeTimer\"], this);\n        const {\n          anchor: o = \"center\",\n          color: s = \"#3FB1CE\",\n          scale: r = 1,\n          draggable: n = !1,\n          clickTolerance: a = 0,\n          rotation: l = Al.rotation,\n          rotationAlignment: c = Al.rotationAlignment,\n          pitchAlignment: h = Al.pitchAlignment,\n          occludedOpacity: d = Al.occludedOpacity,\n          altitude: u = Al.altitude\n        } = t || {};\n        this._anchor = o, this._color = s, this._scale = r, this._draggable = n, this._clickTolerance = a, this._rotation = l, this._rotationAlignment = c, this._pitchAlignment = h, this._occludedOpacity = d, this._altitude = u, this._state = \"inactive\", this._isDragging = !1, this._updateMoving = () => this._update(!0), t && t.element ? (this._element = t.element, this._offset = e.P.convert(t && t.offset || [0, 0])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t && t.offset || [0, -14])), this._element.hasAttribute(\"aria-label\") || this._element.setAttribute(\"aria-label\", \"Map marker\"), this._element.hasAttribute(\"role\") || this._element.setAttribute(\"role\", \"img\"), this._element.classList.add(\"mapboxgl-marker\"), this._element.addEventListener(\"dragstart\", e => {\n          e.preventDefault();\n        }), this._element.addEventListener(\"mousedown\", e => {\n          e.preventDefault();\n        });\n        const _ = this._element.classList;\n        for (const e in Rl) _.remove(\"mapboxgl-marker-anchor-\".concat(e));\n        _.add(\"mapboxgl-marker-anchor-\".concat(this._anchor));\n        const p = t && t.className ? t.className.trim().split(/\\s+/) : [];\n        _.add(...p), this._popup = null;\n      }\n      _createDefaultMarker() {\n        const e = l(\"div\"),\n          t = c(\"svg\", {\n            display: \"block\",\n            height: 41 * this._scale + \"px\",\n            width: 27 * this._scale + \"px\",\n            viewBox: \"0 0 27 41\"\n          }, e);\n        if (0 === this._altitude) {\n          const e = c(\"radialGradient\", {\n            id: \"shadowGradient\"\n          }, c(\"defs\", {}, t));\n          c(\"stop\", {\n            offset: \"10%\",\n            \"stop-opacity\": .4\n          }, e), c(\"stop\", {\n            offset: \"100%\",\n            \"stop-opacity\": .05\n          }, e), c(\"ellipse\", {\n            cx: 13.5,\n            cy: 34.8,\n            rx: 10.5,\n            ry: 5.25,\n            fill: \"url(#shadowGradient)\"\n          }, t);\n        }\n        return c(\"path\", {\n          fill: this._color,\n          d: \"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z\"\n        }, t), c(\"path\", {\n          opacity: .25,\n          d: \"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z\"\n        }, t), c(\"circle\", {\n          fill: \"white\",\n          cx: 13.5,\n          cy: 13.5,\n          r: 5.5\n        }, t), e;\n      }\n      addTo(e) {\n        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on(\"move\", this._updateMoving), e.on(\"moveend\", this._update), e.on(\"remove\", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on(\"click\", this._onMapClick)), this;\n      }\n      remove() {\n        const e = this._map;\n        return e && (e.off(\"click\", this._onMapClick), e.off(\"move\", this._updateMoving), e.off(\"moveend\", this._update), e.off(\"mousedown\", this._addDragHandler), e.off(\"touchstart\", this._addDragHandler), e.off(\"mouseup\", this._onUp), e.off(\"touchend\", this._onUp), e.off(\"mousemove\", this._onMove), e.off(\"touchmove\", this._onMove), e.off(\"remove\", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;\n      }\n      getLngLat() {\n        return this._lngLat;\n      }\n      setLngLat(t) {\n        return this._lngLat = e.aR.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;\n      }\n      setAltitude(e) {\n        return e === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e || 0 !== this._altitude && 0 === e) && (this._element = this._createDefaultMarker()), this._altitude = e || Al.altitude, this._update()), this;\n      }\n      getAltitude() {\n        return this._altitude;\n      }\n      getElement() {\n        return this._element;\n      }\n      setPopup(e) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute(\"role\"), this._element.removeEventListener(\"keypress\", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(\"tabindex\")), e) {\n          if (!(\"offset\" in e.options)) {\n            const t = 38.1,\n              i = 13.5,\n              o = Math.sqrt(Math.pow(i, 2) / 2);\n            e.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              \"top-left\": [0, 0],\n              \"top-right\": [0, 0],\n              bottom: [0, -t],\n              \"bottom-left\": [o, -1 * (t - i + o)],\n              \"bottom-right\": [-o, -1 * (t - i + o)],\n              left: [i, -1 * (t - i)],\n              right: [-i, -1 * (t - i)]\n            } : this._offset;\n          }\n          this._popup = e, e._marker = this, e._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute(\"role\", \"button\"), this._originalTabIndex = this._element.getAttribute(\"tabindex\"), this._originalTabIndex || this._element.setAttribute(\"tabindex\", \"0\"), this._element.addEventListener(\"keypress\", this._onKeyPress), this._element.setAttribute(\"aria-expanded\", \"false\");\n        }\n        return this;\n      }\n      _onKeyPress(e) {\n        const t = e.code,\n          i = e.charCode || e.keyCode;\n        \"Space\" !== t && \"Enter\" !== t && 32 !== i && 13 !== i || this.togglePopup();\n      }\n      _onMapClick(e) {\n        const t = e.originalEvent.target,\n          i = this._element;\n        this._popup && (t === i || i.contains(t)) && this.togglePopup();\n      }\n      getPopup() {\n        return this._popup;\n      }\n      togglePopup() {\n        const e = this._popup;\n        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute(\"aria-expanded\", \"false\")) : this._map && (e.addTo(this._map), this._element.setAttribute(\"aria-expanded\", \"true\")), this) : this;\n      }\n      _behindTerrain() {\n        const e = this._map,\n          t = this._pos;\n        if (!e || !t) return !1;\n        const i = e.unproject(t, this._altitude),\n          o = e.getFreeCameraOptions();\n        if (!o.position) return !1;\n        const s = o.position.toLngLat();\n        return s.distanceTo(i) < .9 * s.distanceTo(this._lngLat);\n      }\n      _evaluateOpacity() {\n        const t = this._map;\n        if (!t) return;\n        const i = this._pos;\n        if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();\n        const o = t.unproject(i, this._altitude);\n        let s;\n        t._showingGlobe() && e.eY(t.transform, this._lngLat) ? s = 0 : (s = 1 - t._queryFogOpacity(o), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (s *= this._occludedOpacity)), this._element.style.opacity = \"\".concat(s), this._element.style.pointerEvents = s > 0 ? \"auto\" : \"none\", this._popup && this._popup._setOpacity(s), this._fadeTimer = null;\n      }\n      _clearFadeTimer() {\n        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);\n      }\n      _updateDOM() {\n        const e = this._pos;\n        if (!e || !this._map) return;\n        const t = this._offset.mult(this._scale);\n        this._element.style.transform = \"\\n            translate(\".concat(e.x, \"px,\").concat(e.y, \"px)\\n            \").concat(Rl[this._anchor], \"\\n            \").concat(this._calculateXYTransform(), \" \").concat(this._calculateZTransform(), \"\\n            translate(\").concat(t.x, \"px,\").concat(t.y, \"px)\\n        \");\n      }\n      _calculateXYTransform() {\n        const t = this._pos,\n          i = this._map,\n          o = this.getPitchAlignment();\n        if (!i || !t || \"map\" !== o) return \"\";\n        if (!i._showingGlobe()) {\n          const e = i.getPitch();\n          return e ? \"rotateX(\".concat(e, \"deg)\") : \"\";\n        }\n        const s = e.cW(e.eZ(i.transform, this._lngLat)),\n          r = t.sub(e.e_(i.transform)),\n          n = Math.abs(r.x) + Math.abs(r.y);\n        if (0 === n) return \"\";\n        const a = s / n;\n        return \"rotateX(\".concat(-r.y * a, \"deg) rotateY(\").concat(r.x * a, \"deg)\");\n      }\n      _calculateZTransform() {\n        const t = this._pos,\n          i = this._map;\n        if (!i || !t) return \"\";\n        let o = 0;\n        const s = this.getRotationAlignment();\n        if (\"map\" === s) {\n          if (i._showingGlobe()) {\n            const t = i.project(new e.aR(this._lngLat.lng, this._lngLat.lat + .001), this._altitude),\n              s = i.project(new e.aR(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(t);\n            o = e.cW(Math.atan2(s.y, s.x)) - 90;\n          } else o = -i.getBearing();\n        } else if (\"horizon\" === s) {\n          const s = e.ah(4, 6, i.getZoom()),\n            r = e.e_(i.transform);\n          r.y += s * i.transform.height;\n          const n = t.sub(r),\n            a = e.cW(Math.atan2(n.y, n.x));\n          o = (a > 90 ? a - 270 : a + 90) * (1 - s);\n        }\n        return o += this._rotation, o ? \"rotateZ(\".concat(o, \"deg)\") : \"\";\n      }\n      _update(e) {\n        cancelAnimationFrame(this._updateFrameId);\n        const t = this._map;\n        t && (t.transform.renderWorldCopies && (this._lngLat = Cl(this._lngLat, this._pos, t.transform)), this._pos = t.project(this._lngLat, this._altitude), !0 === e ? this._updateFrameId = requestAnimationFrame(() => {\n          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());\n        }) : this._pos = this._pos.round(), t._requestDomTask(() => {\n          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t._showingGlobe() || t.getTerrain() || t.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));\n        }));\n      }\n      getOffset() {\n        return this._offset;\n      }\n      setOffset(t) {\n        return this._offset = e.P.convert(t), this._update(), this;\n      }\n      addClassName(e) {\n        return this._element.classList.add(e), this;\n      }\n      removeClassName(e) {\n        return this._element.classList.remove(e), this;\n      }\n      toggleClassName(e) {\n        return this._element.classList.toggle(e);\n      }\n      _onMove(t) {\n        const i = this._map;\n        if (!i) return;\n        const o = this._pointerdownPos,\n          s = this._positionDelta;\n        if (o && s) {\n          if (!this._isDragging) {\n            const e = this._clickTolerance || i._clickTolerance;\n            if (t.point.dist(o) < e) return;\n            this._isDragging = !0;\n          }\n          this._pos = t.point.sub(s), this._lngLat = i.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = \"none\", \"pending\" === this._state && (this._state = \"active\", this.fire(new e.z(\"dragstart\"))), this.fire(new e.z(\"drag\"));\n        }\n      }\n      _onUp() {\n        this._element.style.pointerEvents = \"auto\", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;\n        const t = this._map;\n        t && (t.off(\"mousemove\", this._onMove), t.off(\"touchmove\", this._onMove)), \"active\" === this._state && this.fire(new e.z(\"dragend\")), this._state = \"inactive\";\n      }\n      _addDragHandler(e) {\n        const t = this._map,\n          i = this._pos;\n        t && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = \"pending\", t.on(\"mousemove\", this._onMove), t.on(\"touchmove\", this._onMove), t.once(\"mouseup\", this._onUp), t.once(\"touchend\", this._onUp));\n      }\n      setDraggable(e) {\n        this._draggable = !!e;\n        const t = this._map;\n        return t && (e ? (t.on(\"mousedown\", this._addDragHandler), t.on(\"touchstart\", this._addDragHandler)) : (t.off(\"mousedown\", this._addDragHandler), t.off(\"touchstart\", this._addDragHandler))), this;\n      }\n      isDraggable() {\n        return this._draggable;\n      }\n      setRotation(e) {\n        return this._rotation = e || Al.rotation, this._update(), this;\n      }\n      getRotation() {\n        return this._rotation;\n      }\n      setRotationAlignment(e) {\n        return this._rotationAlignment = e || Al.rotationAlignment, this._update(), this;\n      }\n      getRotationAlignment() {\n        return \"auto\" === this._rotationAlignment || \"horizon\" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? \"viewport\" : this._rotationAlignment;\n      }\n      setPitchAlignment(e) {\n        return this._pitchAlignment = e || Al.pitchAlignment, this._update(), this;\n      }\n      getPitchAlignment() {\n        return \"auto\" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;\n      }\n      setOccludedOpacity(e) {\n        return this._occludedOpacity = e || Al.occludedOpacity, this._update(), this;\n      }\n      getOccludedOpacity() {\n        return this._occludedOpacity;\n      }\n    }\n    const Ll = {\n        positionOptions: {\n          enableHighAccuracy: !1,\n          maximumAge: 0,\n          timeout: 6e3\n        },\n        fitBoundsOptions: {\n          maxZoom: 15\n        },\n        trackUserLocation: !1,\n        showAccuracyCircle: !0,\n        showUserLocation: !0,\n        showUserHeading: !1\n      },\n      Pl = {\n        maxWidth: 100,\n        unit: \"metric\"\n      },\n      zl = {\n        kilometer: \"km\",\n        meter: \"m\",\n        mile: \"mi\",\n        foot: \"ft\",\n        \"nautical-mile\": \"nm\"\n      },\n      Ol = {\n        closeButton: !0,\n        closeOnClick: !0,\n        focusAfterOpen: !0,\n        className: \"\",\n        maxWidth: \"240px\",\n        altitude: 0\n      },\n      Ml = [\"a[href]\", \"[tabindex]:not([tabindex='-1'])\", \"[contenteditable]:not([contenteditable='false'])\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].join(\", \");\n    function Fl() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new e.P(0, 0);\n      let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"bottom\";\n      if (\"number\" == typeof t) {\n        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));\n        switch (i) {\n          case \"top\":\n            return new e.P(0, t);\n          case \"top-left\":\n            return new e.P(o, o);\n          case \"top-right\":\n            return new e.P(-o, o);\n          case \"bottom\":\n            return new e.P(0, -t);\n          case \"bottom-left\":\n            return new e.P(o, -o);\n          case \"bottom-right\":\n            return new e.P(-o, -o);\n          case \"left\":\n            return new e.P(t, 0);\n          case \"right\":\n            return new e.P(-t, 0);\n        }\n        return new e.P(0, 0);\n      }\n      return t instanceof e.P || Array.isArray(t) ? e.P.convert(t) : e.P.convert(t[i] || [0, 0]);\n    }\n    const Bl = {\n      version: t,\n      supported: a.supported,\n      setRTLTextPlugin: e.f2,\n      getRTLTextPluginStatus: e.f1,\n      Map: class extends pl {\n        constructor(t) {\n          o.mark(i.create);\n          const s = t;\n          if (null != (t = Object.assign({}, El, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error(\"maxZoom must be greater than or equal to minZoom\");\n          if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n          if (null != t.minPitch && t.minPitch < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (null != t.maxPitch && t.maxPitch > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n          if (t.antialias && e.eW(window) && (t.antialias = !1, e.w(\"Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609\")), super(new to(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies, null, null), t), this._repaint = !!t.repaint, this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new vl(), this._domRenderTaskQueue = new vl(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.b2(), this._locale = Object.assign({}, xl, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._tessellationStep = t.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = t.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new yl(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = t.scaleFactor, this._requestManager = new T(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, this._contextCreateOptions = t.contextCreateOptions ? Object.assign({}, t.contextCreateOptions) : {}, \"string\" == typeof t.container) {\n            const e = document.getElementById(t.container);\n            if (!e) throw new Error(\"Container '\".concat(t.container.toString(), \"' not found.\"));\n            this._container = e;\n          } else {\n            if (!(t.container instanceof HTMLElement)) throw new Error(\"Invalid type: 'container' must be a String or HTMLElement.\");\n            this._container = t.container;\n          }\n          if (this._container.childNodes.length > 0 && e.w(\"The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.\"), t.maxBounds && this.setMaxBounds(t.maxBounds), this._spriteFormat = t.spriteFormat, e.aY([\"_onWindowOnline\", \"_onWindowResize\", \"_onVisibilityChange\", \"_onMapScroll\", \"_contextLost\", \"_contextRestored\"], this), this._setupContainer(), this._tp || (this._tp = new Kn()), this._tp.registerParameter(this, [\"Debug\"], \"showOverdrawInspector\"), this._tp.registerParameter(this, [\"Debug\"], \"showTileBoundaries\"), this._tp.registerParameter(this, [\"Debug\"], \"showParseStatus\"), this._tp.registerParameter(this, [\"Debug\"], \"repaint\"), this._tp.registerParameter(this, [\"Debug\"], \"showTileAABBs\"), this._tp.registerParameter(this, [\"Debug\"], \"showPadding\"), this._tp.registerParameter(this, [\"Debug\"], \"showCollisionBoxes\", {\n            noSave: !0\n          }), this._tp.registerParameter(this.transform, [\"Debug\"], \"freezeTileCoverage\", {\n            noSave: !0\n          }, () => {\n            this._update();\n          }), this._tp.registerParameter(this, [\"Debug\", \"Wireframe\"], \"showTerrainWireframe\"), this._tp.registerParameter(this, [\"Debug\", \"Wireframe\"], \"showLayers2DWireframe\"), this._tp.registerParameter(this, [\"Debug\", \"Wireframe\"], \"showLayers3DWireframe\"), this._tp.registerParameter(this, [\"Scaling\"], \"_scaleFactor\", {\n            min: .1,\n            max: 10,\n            step: .1\n          }, () => {\n            this.setScaleFactor(this._scaleFactor);\n          }), this._setupPainter(), void 0 === this.painter) throw new Error(\"Failed to initialize WebGL.\");\n          if (this.on(\"move\", () => this._update(!1)), this.on(\"moveend\", () => this._update(!1)), this.on(\"zoom\", () => this._update(!0)), this._fullscreenchangeEvent = \"onfullscreenchange\" in document ? \"fullscreenchange\" : \"webkitfullscreenchange\", window.addEventListener(\"online\", this._onWindowOnline, !1), window.addEventListener(\"resize\", this._onWindowResize, !1), window.addEventListener(\"orientationchange\", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener(\"visibilitychange\", this._onVisibilityChange, !1), this.handlers = new ul(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, (t.style || !t.testMode) && this.setStyle(t.style || e.e.DEFAULT_STYLE, {\n            config: t.config,\n            localFontFamily: this._localFontFamily,\n            localIdeographFontFamily: this._localIdeographFontFamily\n          }), t.projection && this.setProjection(t.projection), this.indoor = new Co(this), t.hash && (this._hash = new fa(\"string\" == typeof t.hash && t.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {\n            null == s.center && null == s.zoom || (this.transform._unmodified = !1), this.jumpTo({\n              center: t.center,\n              zoom: t.zoom,\n              bearing: t.bearing,\n              pitch: t.pitch\n            });\n            const e = t.bounds;\n            e && (this.resize(), this.fitBounds(e, Object.assign({}, t.fitBoundsOptions, {\n              duration: 0\n            })));\n          }\n          this.resize(), t.attributionControl && this.addControl(new fl({\n            customAttribution: t.customAttribution\n          })), this._logoControl = new ml(), this.addControl(this._logoControl, t.logoPosition), this.on(\"style.load\", () => {\n            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();\n          }), this.on(\"data\", t => {\n            this._update(\"style\" === t.dataType), this.fire(new e.z(\"\".concat(t.dataType, \"data\"), t));\n          }), this.on(\"dataloading\", t => {\n            this.fire(new e.z(\"\".concat(t.dataType, \"dataloading\"), t));\n          }), this._interactions = new wl(this);\n        }\n        _getMapId() {\n          return this._mapId;\n        }\n        addControl(t, i) {\n          if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : \"top-right\"), !t || !t.onAdd) return this.fire(new e.y(new Error(\"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.\")));\n          const o = t.onAdd(this);\n          this._controls.push(t);\n          const s = this._controlPositions[i];\n          return -1 !== i.indexOf(\"bottom\") ? s.insertBefore(o, s.firstChild) : s.appendChild(o), this;\n        }\n        removeControl(t) {\n          if (!t || !t.onRemove) return this.fire(new e.y(new Error(\"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.\")));\n          const i = this._controls.indexOf(t);\n          return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;\n        }\n        hasControl(e) {\n          return this._controls.indexOf(e) > -1;\n        }\n        getContainer() {\n          return this._container;\n        }\n        getCanvasContainer() {\n          return this._canvasContainer;\n        }\n        getCanvas() {\n          return this._canvas;\n        }\n        resize(t) {\n          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;\n          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));\n          const i = !this._moving;\n          return i && this.fire(new e.z(\"movestart\", t)).fire(new e.z(\"move\", t)), this.fire(new e.z(\"resize\", t)), i && this.fire(new e.z(\"moveend\", t)), this;\n        }\n        getBounds() {\n          return this.transform.getBounds();\n        }\n        getMaxBounds() {\n          return this.transform.getMaxBounds() || null;\n        }\n        setMaxBounds(t) {\n          return this.transform.setMaxBounds(e.aI.convert(t)), this._update();\n        }\n        setMinZoom(t) {\n          if ((t = t !== null && t !== void 0 ? t : -2) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.z(\"zoomstart\")).fire(new e.z(\"zoom\")).fire(new e.z(\"zoomend\")), this;\n          throw new Error(\"minZoom must be between -2 and the current maxZoom, inclusive\");\n        }\n        getMinZoom() {\n          return this.transform.minZoom;\n        }\n        setMaxZoom(t) {\n          if ((t = t !== null && t !== void 0 ? t : 22) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.z(\"zoomstart\")).fire(new e.z(\"zoom\")).fire(new e.z(\"zoomend\")), this;\n          throw new Error(\"maxZoom must be greater than the current minZoom\");\n        }\n        getMaxZoom() {\n          return this.transform.maxZoom;\n        }\n        setMinPitch(t) {\n          if ((t = t !== null && t !== void 0 ? t : 0) < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.z(\"pitchstart\")).fire(new e.z(\"pitch\")).fire(new e.z(\"pitchend\")), this;\n          throw new Error(\"minPitch must be between 0 and the current maxPitch, inclusive\");\n        }\n        getMinPitch() {\n          return this.transform.minPitch;\n        }\n        setMaxPitch(t) {\n          if ((t = t !== null && t !== void 0 ? t : 85) > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.z(\"pitchstart\")).fire(new e.z(\"pitch\")).fire(new e.z(\"pitchend\")), this;\n          throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n        }\n        getMaxPitch() {\n          return this.transform.maxPitch;\n        }\n        getScaleFactor() {\n          return this._scaleFactor;\n        }\n        setScaleFactor(e) {\n          return this._scaleFactor = e, this.painter.scaleFactor = e, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers(e => \"symbol\" === e.type), this._update(!0), this;\n        }\n        getRenderWorldCopies() {\n          return this.transform.renderWorldCopies;\n        }\n        setRenderWorldCopies(e) {\n          return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();\n        }\n        getLanguage() {\n          return this._language;\n        }\n        _parseLanguage(e) {\n          return \"auto\" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map(e => \"auto\" === e ? navigator.language : e) : e;\n        }\n        setLanguage(e) {\n          const t = this._parseLanguage(e);\n          if (!this.style || t === this._language) return this;\n          this._language = t, this.style.reloadSources();\n          for (const e of this._controls) e._setLanguage && e._setLanguage(this._language);\n          return this;\n        }\n        getWorldview() {\n          return this._worldview;\n        }\n        setWorldview(e) {\n          return this.style && e !== this._worldview ? (this._worldview = e, this._styleDirty = !0, this.style.reloadSources(), this) : this;\n        }\n        getProjection() {\n          return this.transform.mercatorFromTransition ? {\n            name: \"globe\",\n            center: [0, 0]\n          } : this.transform.getProjection();\n        }\n        _showingGlobe() {\n          return \"globe\" === this.transform.projection.name;\n        }\n        setProjection(e) {\n          return this._lazyInitEmptyStyle(), e ? \"string\" == typeof e && (e = {\n            name: e\n          }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);\n        }\n        _updateProjectionTransition() {\n          if (\"globe\" !== this.getProjection().name) return;\n          const t = this.transform,\n            i = t.projection.name;\n          let o;\n          \"globe\" === i && t.zoom >= e.cK ? (t.setMercatorFromTransition(), o = !0) : \"mercator\" === i && t.zoom < e.cK && (t.setProjection({\n            name: \"globe\"\n          }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate(), this._update(!0));\n        }\n        _prioritizeAndUpdateProjection(e, t) {\n          return this._updateProjection(e || t || {\n            name: \"mercator\"\n          });\n        }\n        _updateProjection(t) {\n          let i;\n          return i = \"globe\" === t.name && this.transform.zoom >= e.cK ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;\n        }\n        project(t, i) {\n          return this.transform.locationPoint3D(e.aR.convert(t), i);\n        }\n        unproject(t, i) {\n          return this.transform.pointLocation3D(e.P.convert(t), i);\n        }\n        isMoving() {\n          return this._moving || this.handlers && this.handlers.isMoving() || !1;\n        }\n        isZooming() {\n          return this._zooming || this.handlers && this.handlers.isZooming() || !1;\n        }\n        isRotating() {\n          return this._rotating || this.handlers && this.handlers.isRotating() || !1;\n        }\n        _isDragging() {\n          return this.handlers && this.handlers._isDragging() || !1;\n        }\n        _createDelegatedListener(e, t, i) {\n          const o = e => {\n            let i = [];\n            if (Array.isArray(t)) {\n              const o = t.filter(e => this.getLayer(e));\n              i = o.length ? this.queryRenderedFeatures(e, {\n                layers: o\n              }) : [];\n            } else i = this.queryRenderedFeatures(e, {\n              target: t\n            });\n            return i;\n          };\n          if (\"mouseenter\" === e || \"mouseover\" === e) {\n            let s = !1;\n            const r = t => {\n              const r = o(t.point);\n              r.length ? s || (s = !0, i.call(this, new Sa(e, this, t.originalEvent, {\n                features: r\n              }))) : s = !1;\n            };\n            return {\n              listener: i,\n              targets: t,\n              delegates: {\n                mousemove: r,\n                mouseout: () => {\n                  s = !1;\n                }\n              }\n            };\n          }\n          if (\"mouseleave\" === e || \"mouseout\" === e) {\n            let s = !1;\n            const r = t => {\n                o(t.point).length ? s = !0 : s && (s = !1, i.call(this, new Sa(e, this, t.originalEvent)));\n              },\n              n = t => {\n                s && (s = !1, i.call(this, new Sa(e, this, t.originalEvent)));\n              };\n            return {\n              listener: i,\n              targets: t,\n              delegates: {\n                mousemove: r,\n                mouseout: n\n              }\n            };\n          }\n          {\n            const s = e => {\n              const t = o(e.point);\n              t.length && (e.features = t, i.call(this, e), delete e.features);\n            };\n            return {\n              listener: i,\n              targets: t,\n              delegates: {\n                [e]: s\n              }\n            };\n          }\n        }\n        on(e, t, i) {\n          if (\"function\" == typeof t || void 0 === i) return super.on(e, t);\n          if (\"string\" == typeof t && (t = [t]), !this._areTargetsValid(t)) return this;\n          const o = this._createDelegatedListener(e, t, i);\n          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);\n          for (const e in o.delegates) this.on(e, o.delegates[e]);\n          return this;\n        }\n        once(e, t, i) {\n          if (\"function\" == typeof t || void 0 === i) return super.once(e, t);\n          if (\"string\" == typeof t && (t = [t]), !this._areTargetsValid(t)) return this;\n          const o = this._createDelegatedListener(e, t, i);\n          for (const e in o.delegates) this.once(e, o.delegates[e]);\n          return this;\n        }\n        off(e, t, i) {\n          if (\"function\" == typeof t || void 0 === i) return super.off(e, t);\n          if (\"string\" == typeof t && (t = [t]), !this._areTargetsValid(t)) return this;\n          const o = this._delegatedListeners ? this._delegatedListeners[e] : void 0;\n          return o && (e => {\n            for (let o = 0; o < e.length; o++) {\n              const s = e[o];\n              if (s.listener === i && Tl(s.targets, t)) {\n                for (const e in s.delegates) this.off(e, s.delegates[e]);\n                return e.splice(o, 1), this;\n              }\n            }\n          })(o), this;\n        }\n        queryRenderedFeatures(t, i) {\n          if (!this.style) return [];\n          if (void 0 === t || t instanceof e.P || Array.isArray(t) || void 0 !== i || (i = t, t = void 0), t = t || [[0, 0], [this.transform.width, this.transform.height]], !i) {\n            const e = this.style.queryRenderedFeatures(t, void 0, this.transform),\n              i = this.style.queryRenderedFeatureset(t, void 0, this.transform);\n            return e.concat(i);\n          }\n          let o = !0;\n          if (i.target && (o = this._isTargetValid(i.target), o && !i.layers)) return this.style.queryRenderedFeatureset(t, i, this.transform);\n          let s = !0;\n          if (i.layers && Array.isArray(i.layers)) {\n            for (const e of i.layers) if (!this._isValidId(e)) {\n              s = !1;\n              break;\n            }\n            if (s && !i.target) return this.style.queryRenderedFeatures(t, i, this.transform);\n          }\n          let r = [];\n          return s && (r = r.concat(this.style.queryRenderedFeatures(t, i, this.transform))), o && (r = r.concat(this.style.queryRenderedFeatureset(t, i, this.transform))), r;\n        }\n        querySourceFeatures(e, t) {\n          return !e || \"string\" == typeof e && !this._isValidId(e) ? [] : this.style.querySourceFeatures(e, t);\n        }\n        queryRasterValue(e, t, i) {\n          return this._isValidId(e) ? this.style.queryRasterValue(e, t, i) : Promise.resolve(null);\n        }\n        isPointOnSurface(t) {\n          const {\n            name: i\n          } = this.transform.projection;\n          return \"globe\" !== i && \"mercator\" !== i && e.w(\"\".concat(i, \" projection does not support isPointOnSurface, this API may behave unexpectedly.\")), this.transform.isPointOnSurface(e.P.convert(t));\n        }\n        addInteraction(e, t) {\n          return this._interactions.add(e, t), this;\n        }\n        removeInteraction(e) {\n          return this._interactions.remove(e), this;\n        }\n        getCooperativeGestures() {\n          return this._cooperativeGestures;\n        }\n        setCooperativeGestures(e) {\n          return this._cooperativeGestures = e, this;\n        }\n        setStyle(t, i) {\n          return i = Object.assign({}, {\n            localIdeographFontFamily: this._localIdeographFontFamily,\n            localFontFamily: this._localFontFamily\n          }, i), this.style && t && !1 !== i.diff && i.localFontFamily === this._localFontFamily && i.localIdeographFontFamily === this._localIdeographFontFamily && !i.config ? (this.style._diffStyle(t, (o, s) => {\n            if (o) {\n              const s = \"string\" == typeof o ? o : o instanceof Error ? o.message : o.error;\n              e.w(\"Unable to perform style diff: \".concat(s, \". Rebuilding the style from scratch.\")), this._updateStyle(t, i);\n            } else s && this._update(!0);\n          }, () => this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));\n        }\n        _getUIString(e) {\n          const t = this._locale[e];\n          if (null == t) throw new Error(\"Missing UI string '\".concat(e, \"'\"));\n          return t;\n        }\n        _updateStyle(e, t) {\n          if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e) {\n            const i = Object.assign({}, t);\n            t && t.config && (i.initialConfig = t.config, delete i.config), this.style = new To(this, i).load(e), this.style.setEventedParent(this, {\n              style: this.style\n            });\n          }\n          return this._updateTerrain(), this;\n        }\n        _lazyInitEmptyStyle() {\n          this.style || (this.style = new To(this, {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), this.style.loadEmpty());\n        }\n        getStyle() {\n          if (this.style) return this.style.serialize();\n        }\n        isStyleLoaded() {\n          return this.style ? this.style.loaded() : (e.w(\"There is no style added to the map.\"), !1);\n        }\n        _isValidId(t) {\n          return null == t ? (this.fire(new e.y(new Error(\"IDs can't be empty.\"))), !1) : !e.dm(t) || (this.fire(new e.y(new Error(\"IDs can't contain special symbols: \\\"\".concat(t, \"\\\".\")))), !1);\n        }\n        _isTargetValid(e) {\n          return \"featuresetId\" in e ? this._isValidId(\"importId\" in e ? e.importId : e.featuresetId) : \"layerId\" in e && this._isValidId(e.layerId);\n        }\n        _areTargetsValid(e) {\n          if (Array.isArray(e)) {\n            for (const t of e) if (!this._isValidId(t)) return !1;\n            return !0;\n          }\n          return this._isTargetValid(e);\n        }\n        addSource(e, t) {\n          return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0)) : this;\n        }\n        isSourceLoaded(e) {\n          return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);\n        }\n        areTilesLoaded() {\n          return this.style.areTilesLoaded();\n        }\n        addSourceType(e, t, i) {\n          this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);\n        }\n        removeSource(e) {\n          return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;\n        }\n        getSource(e) {\n          return this._isValidId(e) ? this.style.getOwnSource(e) : null;\n        }\n        addImage(t, i) {\n          let {\n            pixelRatio: o = 1,\n            sdf: s = !1,\n            stretchX: r,\n            stretchY: n,\n            content: a\n          } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          this._lazyInitEmptyStyle();\n          const l = e.I.from(t);\n          if (i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {\n            const {\n              width: t,\n              height: c,\n              data: h\n            } = e.o.getImageData(i);\n            this.style.addImage(l, {\n              data: new e.q({\n                width: t,\n                height: c\n              }, h),\n              pixelRatio: o,\n              stretchX: r,\n              stretchY: n,\n              content: a,\n              sdf: s,\n              version: 0,\n              usvg: !1\n            });\n          } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.y(new Error(\"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));else {\n            const {\n                width: c,\n                height: h\n              } = i,\n              d = i;\n            this.style.addImage(l, {\n              data: new e.q({\n                width: c,\n                height: h\n              }, new Uint8Array(d.data)),\n              pixelRatio: o,\n              stretchX: r,\n              stretchY: n,\n              content: a,\n              sdf: s,\n              usvg: !1,\n              version: 0,\n              userImage: d\n            }), d.onAdd && d.onAdd(this, t);\n          }\n        }\n        updateImage(t, i) {\n          this._lazyInitEmptyStyle();\n          const o = e.I.from(t),\n            s = this.style.getImage(o);\n          if (!s) return void this.fire(new e.y(new Error(\"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.\")));\n          const r = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.o.getImageData(i) : i,\n            {\n              width: n,\n              height: a,\n              data: l\n            } = r;\n          if (void 0 === n || void 0 === a) return void this.fire(new e.y(new Error(\"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n          if (n !== (s.usvg ? s.icon.usvg_tree.width : s.data.width) || a !== (s.usvg ? s.icon.usvg_tree.height : s.data.height)) return void this.fire(new e.y(new Error(\"The width and height of the updated image (\".concat(n, \", \").concat(a, \")\\n                must be that same as the previous version of the image\\n                (\").concat(s.data.width, \", \").concat(s.data.height, \")\"))));\n          const c = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);\n          let h = !1;\n          s.usvg ? (s.data = new e.q({\n            width: n,\n            height: a\n          }, new Uint8Array(l)), s.usvg = !1, s.icon = void 0, h = !0) : s.data.replace(l, c), this.style.updateImage(o, s, h);\n        }\n        hasImage(t) {\n          return t ? !!this.style && !!this.style.getImage(e.I.from(t)) : (this.fire(new e.y(new Error(\"Missing required image id\"))), !1);\n        }\n        removeImage(t) {\n          this.style.removeImage(e.I.from(t));\n        }\n        loadImage(t, i) {\n          e.n(this._requestManager.transformRequest(t, e.R.Image), (t, o) => {\n            i(t, o instanceof HTMLImageElement ? e.o.getImageData(o) : o);\n          });\n        }\n        listImages() {\n          return this.style.listImages().map(e => e.name);\n        }\n        addModel(e, t) {\n          this._lazyInitEmptyStyle(), this.style.addModel(e, t);\n        }\n        hasModel(t) {\n          return t ? this.style.hasModel(t) : (this.fire(new e.y(new Error(\"Missing required model id\"))), !1);\n        }\n        removeModel(e) {\n          this.style.removeModel(e);\n        }\n        listModels() {\n          return this.style.listModels();\n        }\n        addLayer(e, t) {\n          return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0)) : this;\n        }\n        getSlot(e) {\n          const t = this.getLayer(e);\n          return t && t.slot || null;\n        }\n        setSlot(e, t) {\n          return this.style.setSlot(e, t), this.style.mergeLayers(), this._update(!0);\n        }\n        addImport(t, i) {\n          return this.style.addImport(t, i).catch(t => this.fire(new e.y(new Error(\"Failed to add import\", t)))), this;\n        }\n        updateImport(e, t) {\n          return \"string\" != typeof t && t.id !== e ? (this.removeImport(e), this.addImport(t)) : (this.style.updateImport(e, t), this._update(!0));\n        }\n        removeImport(e) {\n          return this.style.removeImport(e), this;\n        }\n        moveImport(e, t) {\n          return this.style.moveImport(e, t), this._update(!0);\n        }\n        moveLayer(e, t) {\n          return this._isValidId(e) ? (this.style.moveLayer(e, t), this._update(!0)) : this;\n        }\n        removeLayer(e) {\n          return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;\n        }\n        getLayer(e) {\n          if (!this._isValidId(e)) return null;\n          const t = this.style.getOwnLayer(e);\n          return t ? \"custom\" === t.type ? t.implementation : t.serialize() : void 0;\n        }\n        getSlots() {\n          return this.style.getSlots();\n        }\n        setLayerZoomRange(e, t, i) {\n          return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t, i), this._update(!0)) : this;\n        }\n        setFilter(e, t) {\n          let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n          return this._isValidId(e) ? (this.style.setFilter(e, t, i), this._update(!0)) : this;\n        }\n        getFilter(e) {\n          return this._isValidId(e) ? this.style.getFilter(e) : null;\n        }\n        setPaintProperty(e, t, i) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          return this._isValidId(e) ? (this.style.setPaintProperty(e, t, i, o), this._update(!0)) : this;\n        }\n        getPaintProperty(e, t) {\n          return this._isValidId(e) ? this.style.getPaintProperty(e, t) : null;\n        }\n        setLayoutProperty(e, t, i) {\n          let o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          return this._isValidId(e) ? (this.style.setLayoutProperty(e, t, i, o), this._update(!0)) : this;\n        }\n        getLayoutProperty(e, t) {\n          return this._isValidId(e) ? this.style.getLayoutProperty(e, t) : null;\n        }\n        getGlyphsUrl() {\n          return this.style.getGlyphsUrl();\n        }\n        setGlyphsUrl(e) {\n          return this.style.setGlyphsUrl(e), this._update(!0);\n        }\n        getSchema(e) {\n          return this.style.getSchema(e);\n        }\n        setSchema(e, t) {\n          return this.style.setSchema(e, t), this._update(!0);\n        }\n        getConfig(e) {\n          return this.style.getConfig(e);\n        }\n        setConfig(e, t) {\n          return this.style.setConfig(e, t), this._update(!0);\n        }\n        getConfigProperty(e, t) {\n          return this.style.getConfigProperty(e, t);\n        }\n        setConfigProperty(e, t, i) {\n          return this.style.setConfigProperty(e, t, i), this._update(!0);\n        }\n        getFeaturesetDescriptors(e) {\n          return this.style.getFeaturesetDescriptors(e);\n        }\n        setLights(e) {\n          if (this._lazyInitEmptyStyle(), e && 1 === e.length && \"flat\" === e[0].type) {\n            const t = e[0];\n            t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, \"flat\");\n          } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);\n          return this._update(!0);\n        }\n        getLights() {\n          const e = this.style.getLights() || [];\n          return 0 === e.length && e.push({\n            id: this.style.light.id,\n            type: \"flat\",\n            properties: this.style.getFlatLight()\n          }), e;\n        }\n        setLight(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          return console.log(\"The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead.\"), this.setLights([{\n            id: \"flat\",\n            type: \"flat\",\n            properties: e\n          }]);\n        }\n        getLight() {\n          return console.log(\"The `map.getLight` function is deprecated, prefer using `map.getLights` instead.\"), this.style.getFlatLight();\n        }\n        setTerrain(e) {\n          return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);\n        }\n        getTerrain() {\n          return this.style ? this.style.getTerrain() : null;\n        }\n        setFog(e) {\n          return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);\n        }\n        getFog() {\n          return this.style ? this.style.getFog() : null;\n        }\n        setSnow(e) {\n          return this._lazyInitEmptyStyle(), this.style.setSnow(e), this._update(!0);\n        }\n        getSnow() {\n          return this.style ? this.style.getSnow() : null;\n        }\n        setRain(e) {\n          return this._lazyInitEmptyStyle(), this.style.setRain(e), this._update(!0);\n        }\n        getRain() {\n          return this.style ? this.style.getRain() : null;\n        }\n        setColorTheme(e) {\n          return this._lazyInitEmptyStyle(), this.style.setColorTheme(e), this._update(!0);\n        }\n        setImportColorTheme(e, t) {\n          return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e, t), this._update(!0);\n        }\n        setCamera(e) {\n          return this.style.setCamera(e), this._triggerCameraUpdate(e);\n        }\n        _triggerCameraUpdate(e) {\n          return this._update(this.transform.setOrthographicProjectionAtLowPitch(\"orthographic\" === e[\"camera-projection\"]));\n        }\n        getCamera() {\n          return this.style.camera;\n        }\n        _queryFogOpacity(t) {\n          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.aR.convert(t), this.transform) : 0;\n        }\n        setFeatureState(e, t) {\n          return e.source && !this._isValidId(e.source) ? this : (this.style.setFeatureState(e, t), this._update());\n        }\n        removeFeatureState(e, t) {\n          return e.source && !this._isValidId(e.source) ? this : (this.style.removeFeatureState(e, t), this._update());\n        }\n        getFeatureState(e) {\n          return e.source && !this._isValidId(e.source) ? null : this.style.getFeatureState(e);\n        }\n        _selectIndoorFloor(e) {\n          this.indoor.selectFloor(e);\n        }\n        _addIndoorControl() {\n          this._indoorControl || (this._indoorControl = new gl()), this.addControl(this._indoorControl, \"right\");\n        }\n        _removeIndoorControl() {\n          this._indoorControl && this.removeControl(this._indoorControl);\n        }\n        _updateContainerDimensions() {\n          if (!this._container) return;\n          const e = this._container.getBoundingClientRect().width || 400,\n            t = this._container.getBoundingClientRect().height || 300;\n          let i,\n            o,\n            s,\n            r = this._container;\n          for (; r && (!o || !s);) {\n            const e = window.getComputedStyle(r).transform;\n            e && \"none\" !== e && (i = e.match(/matrix.*\\((.+)\\)/)[1].split(\", \"), i[0] && \"0\" !== i[0] && \"1\" !== i[0] && (o = i[0]), i[3] && \"0\" !== i[3] && \"1\" !== i[3] && (s = i[3])), r = r.parentElement;\n          }\n          this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = s ? Math.abs(t / s) : t;\n        }\n        _detectMissingCSS() {\n          \"rgb(250, 128, 114)\" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue(\"background-color\") && e.w(\"This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.\");\n        }\n        _setupContainer() {\n          const e = this._container;\n          e.classList.add(\"mapboxgl-map\"), (this._missingCSSCanary = l(\"div\", \"mapboxgl-canary\", e)).style.visibility = \"hidden\", this._detectMissingCSS();\n          const t = this._canvasContainer = l(\"div\", \"mapboxgl-canvas-container\", e);\n          this._canvas = l(\"canvas\", \"mapboxgl-canvas\", t), this._interactive && (t.classList.add(\"mapboxgl-interactive\"), this._canvas.setAttribute(\"tabindex\", \"0\")), this._canvas.addEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.addEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.setAttribute(\"aria-label\", this._getUIString(\"Map.Title\")), this._canvas.setAttribute(\"role\", \"region\"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);\n          const i = this._controlContainer = l(\"div\", \"mapboxgl-control-container\", e),\n            o = this._controlPositions = {};\n          [\"top-left\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\"].forEach(e => {\n            o[e] = l(\"div\", \"mapboxgl-ctrl-\".concat(e), i);\n          }), this._container.addEventListener(\"scroll\", this._onMapScroll, !1);\n        }\n        _resizeCanvas(t, i) {\n          const o = e.o.devicePixelRatio || 1;\n          this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = \"\".concat(t, \"px\"), this._canvas.style.height = \"\".concat(i, \"px\");\n        }\n        _addMarker(e) {\n          this._markers.push(e);\n        }\n        _removeMarker(e) {\n          const t = this._markers.indexOf(e);\n          -1 !== t && this._markers.splice(t, 1);\n        }\n        _addPopup(e) {\n          this._popups.push(e);\n        }\n        _removePopup(e) {\n          const t = this._popups.indexOf(e);\n          -1 !== t && this._popups.splice(t, 1);\n        }\n        _setupPainter() {\n          const t = Object.assign({}, a.supported.webGLContextAttributes, {\n              failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n              preserveDrawingBuffer: this._preserveDrawingBuffer,\n              antialias: this._antialias || !1\n            }),\n            i = this._canvas.getContext(\"webgl2\", t);\n          i ? (j(i, !0), this.painter = new _a(i, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp, this._worldview), this.on(\"data\", e => {\n            \"source\" === e.dataType && this.painter.setTileLoadedFlag(!0);\n          }), e.k.testSupport(i)) : this.fire(new e.y(new Error(\"Failed to initialize WebGL\")));\n        }\n        _contextLost(t) {\n          t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.z(\"webglcontextlost\", {\n            originalEvent: t\n          }));\n        }\n        _contextRestored(t) {\n          this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.clearLayers(), this.style.imageManager.destroyAtlasTextures(), this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e.z(\"webglcontextrestored\", {\n            originalEvent: t\n          }));\n        }\n        _onMapScroll(e) {\n          if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n        }\n        idle() {\n          return !this.isMoving() && this.loaded();\n        }\n        loaded() {\n          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n        }\n        frameReady() {\n          return this.loaded() && !this._placementDirty;\n        }\n        _update(e) {\n          return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n        }\n        _requestRenderFrame(e) {\n          return this._update(), this._renderTaskQueue.add(e);\n        }\n        _cancelRenderFrame(e) {\n          this._renderTaskQueue.remove(e);\n        }\n        _requestDomTask(e) {\n          !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);\n        }\n        _render(t) {\n          let s;\n          this.fire(new e.z(\"renderstart\")), ++this._frameId;\n          const r = this.painter.context.extTimerQuery,\n            n = e.o.now(),\n            a = this.painter.context.gl;\n          if (this.listens(\"gpu-timing-frame\") && (s = a.createQuery(), a.beginQuery(r.TIME_ELAPSED_EXT, s)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;\n          this._updateProjectionTransition();\n          const l = this._isInitialLoad ? 0 : this._fadeDuration;\n          if (this.style && this._styleDirty) {\n            this._styleDirty = !1;\n            const t = this.transform.zoom,\n              i = this.transform.pitch,\n              o = e.o.now(),\n              s = new e.ac(t, {\n                now: o,\n                fadeDuration: l,\n                pitch: i,\n                transition: this.style.transition,\n                worldview: this._worldview\n              });\n            this.style.update(s);\n          }\n          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);\n          let c = !1;\n          this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), c = this._updateAverageElevation(n), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c = this._updateAverageElevation(n);\n          const h = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);\n          if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), h && (this._placementDirty = h.needsRerender), this.style && this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showParseStatus: this.showParseStatus,\n            wireframe: {\n              terrain: this.showTerrainWireframe,\n              layers2D: this.showLayers2DWireframe,\n              layers3D: this.showLayers3DWireframe\n            },\n            showOverdrawInspector: this._showOverdrawInspector,\n            showQueryGeometry: !!this._showQueryGeometry,\n            showTileAABBs: this.showTileAABBs,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: l,\n            isInitialLoad: this._isInitialLoad,\n            showPadding: this.showPadding,\n            gpuTiming: !!this.listens(\"gpu-timing-layer\"),\n            gpuTimingDeferredRender: !!this.listens(\"gpu-timing-deferred-render\"),\n            speedIndexTiming: this.speedIndexTiming\n          }), this.fire(new e.z(\"render\")), this.loaded() && !this._loaded && (this._loaded = !0, o.mark(i.load), this.fire(new e.z(\"load\"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s) {\n            const t = e.o.now() - n;\n            a.endQuery(r.TIME_ELAPSED_EXT), setTimeout(() => {\n              const i = a.getQueryParameter(s, a.QUERY_RESULT) / 1e6;\n              a.deleteQuery(s), this.fire(new e.z(\"gpu-timing-frame\", {\n                cpuTime: t,\n                gpuTime: i\n              }));\n            }, 50);\n          }\n          if (this.listens(\"gpu-timing-layer\")) {\n            const t = this.painter.collectGpuTimers();\n            setTimeout(() => {\n              const i = this.painter.queryGpuTimers(t);\n              this.fire(new e.z(\"gpu-timing-layer\", {\n                layerTimes: i\n              }));\n            }, 50);\n          }\n          if (this.listens(\"gpu-timing-deferred-render\")) {\n            const t = this.painter.collectDeferredRenderGpuQueries();\n            setTimeout(() => {\n              const i = this.painter.queryGpuTimeDeferredRender(t);\n              this.fire(new e.z(\"gpu-timing-deferred-render\", {\n                gpuTime: i\n              }));\n            }, 50);\n          }\n          const d = this._sourcesDirty || this._styleDirty || this._placementDirty || c;\n          if (d || this._repaint) this.triggerRepaint();else {\n            const t = this.idle();\n            if (t && (c = this._updateAverageElevation(n, !0)), c) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.z(\"idle\")), this._isInitialLoad = !1, this.speedIndexTiming)) {\n              const t = this._calculateSpeedIndex();\n              this.fire(new e.z(\"speedindexcompleted\", {\n                speedIndex: t\n              })), this.speedIndexTiming = !1;\n            }\n          }\n          !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0, o.mark(i.fullLoad), this._performanceMetricsCollection && B(this._requestManager._customAccessToken, {\n            width: this.painter.width,\n            height: this.painter.height,\n            interactionRange: this._interactionRange,\n            visibilityHidden: this._visibilityHidden,\n            terrainEnabled: !!this.painter.style.getTerrain(),\n            fogEnabled: !!this.painter.style.getFog(),\n            projection: this.getProjection().name,\n            zoom: this.transform.zoom,\n            renderer: this.painter.context.renderer,\n            vendor: this.painter.context.vendor\n          }), this._authenticate());\n        }\n        _forceMarkerAndPopupUpdate(e) {\n          for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();\n          for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();\n        }\n        _updateAverageElevation(e) {\n          let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          const i = e => (this.transform.averageElevation = e, this._update(!1), !0);\n          if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);\n          const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;\n          if (o || (t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {\n            const t = this.transform.averageElevation;\n            let s = this.transform.sampleAverageElevation();\n            null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s) ? s = 0 : this._averageElevationLastSampledAt = e;\n            const r = Math.abs(t - s);\n            if (r > 1) {\n              if (this._isInitialLoad || o) return this._averageElevation.jumpTo(s), i(s);\n              this._averageElevation.easeTo(s, e, 300);\n            } else if (r > 1e-4) return this._averageElevation.jumpTo(s), i(s);\n          }\n          return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));\n        }\n        _authenticate() {\n          N(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {\n            if (t && (t.message === w || 401 === t.status)) {\n              const t = this.painter.context.gl;\n              j(t, !1), this._logoControl instanceof ml && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.y(new Error(\"A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/\")));\n            }\n          }), z(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});\n        }\n        _postStyleLoadEvent() {\n          this.style.globalId && M(this._requestManager._customAccessToken, {\n            map: this,\n            style: this.style.globalId,\n            importedStyles: this.style.getImportGlobalIds()\n          });\n        }\n        _updateTerrain() {\n          const e = this._isDragging();\n          this.painter.updateTerrain(this.style, e);\n        }\n        _calculateSpeedIndex() {\n          const e = this.painter.canvasCopy(),\n            t = this.painter.getCanvasCopiesAndTimestamps();\n          t.timeStamps.push(performance.now());\n          const i = this.painter.context.gl,\n            o = i.createFramebuffer();\n          function s(e) {\n            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);\n            const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);\n            return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;\n          }\n          return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(s(e), t.canvasCopies.map(s), t.timeStamps);\n        }\n        _canvasPixelComparison(e, t, i) {\n          let o = i[1] - i[0];\n          const s = e.length / 4;\n          for (let r = 0; r < t.length; r++) {\n            const n = t[r];\n            let a = 0;\n            for (let t = 0; t < n.length; t += 4) n[t] === e[t] && n[t + 1] === e[t + 1] && n[t + 2] === e[t + 2] && n[t + 3] === e[t + 3] && (a += 1);\n            o += (i[r + 2] - i[r + 1]) * (1 - a / s);\n          }\n          return o;\n        }\n        remove() {\n          this._hash && this._hash.remove();\n          for (const e of this._controls) e.onRemove(this);\n          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener(\"resize\", this._onWindowResize, !1), window.removeEventListener(\"orientationchange\", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener(\"online\", this._onWindowOnline, !1), window.removeEventListener(\"visibilitychange\", this._onVisibilityChange, !1);\n          const t = this.painter.context.gl.getExtension(\"WEBGL_lose_context\");\n          t && t.loseContext(), this._canvas.removeEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.removeEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove(\"mapboxgl-map\"), this._container.removeEventListener(\"scroll\", this._onMapScroll, !1), U.delete(this.painter.context.gl), k.remove(), P.remove(), this._removed = !0, this.fire(new e.z(\"remove\"));\n        }\n        triggerRepaint() {\n          this._triggerFrame(!0);\n        }\n        _triggerFrame(t) {\n          this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.o.frame(e => {\n            const t = !!this._renderNextFrame;\n            this._frame = null, this._renderNextFrame = null, t && this._render(e);\n          }));\n        }\n        _preloadTiles(t) {\n          const i = this.style ? this.style.getSourceCaches() : [];\n          return e.bw(i, (e, i) => e._preloadTiles(t, i), () => {\n            this.triggerRepaint();\n          }), this;\n        }\n        _onWindowOnline() {\n          this._update();\n        }\n        _onWindowResize(e) {\n          this._trackResize && this.resize({\n            originalEvent: e\n          })._update();\n        }\n        _onVisibilityChange() {\n          \"hidden\" === document.visibilityState && this._visibilityHidden++;\n        }\n        get showTileBoundaries() {\n          return !!this._showTileBoundaries;\n        }\n        set showTileBoundaries(e) {\n          this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._tp.refreshUI(), this._update());\n        }\n        get showParseStatus() {\n          return !!this._showParseStatus;\n        }\n        set showParseStatus(e) {\n          this._showParseStatus !== e && (this._showParseStatus = e, this._tp.refreshUI(), this._update());\n        }\n        get showTerrainWireframe() {\n          return !!this._showTerrainWireframe;\n        }\n        set showTerrainWireframe(e) {\n          this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._tp.refreshUI(), this._update());\n        }\n        get showLayers2DWireframe() {\n          return !!this._showLayers2DWireframe;\n        }\n        set showLayers2DWireframe(e) {\n          this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._tp.refreshUI(), this._update());\n        }\n        get showLayers3DWireframe() {\n          return !!this._showLayers3DWireframe;\n        }\n        set showLayers3DWireframe(e) {\n          this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._tp.refreshUI(), this._update());\n        }\n        get speedIndexTiming() {\n          return !!this._speedIndexTiming;\n        }\n        set speedIndexTiming(e) {\n          this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());\n        }\n        get showPadding() {\n          return !!this._showPadding;\n        }\n        set showPadding(e) {\n          this._showPadding !== e && (this._showPadding = e, this._tp.refreshUI(), this._update());\n        }\n        get showCollisionBoxes() {\n          return !!this._showCollisionBoxes;\n        }\n        set showCollisionBoxes(e) {\n          this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, this._tp.refreshUI(), e ? this.style._generateCollisionBoxes() : this._update());\n        }\n        get showOverdrawInspector() {\n          return !!this._showOverdrawInspector;\n        }\n        set showOverdrawInspector(e) {\n          this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._tp.refreshUI(), this._update());\n        }\n        get repaint() {\n          return !!this._repaint;\n        }\n        set repaint(e) {\n          this._repaint !== e && (this._repaint = e, this._tp.refreshUI(), this.triggerRepaint());\n        }\n        get vertices() {\n          return !!this._vertices;\n        }\n        set vertices(e) {\n          this._vertices = e, this._update();\n        }\n        get showTileAABBs() {\n          return !!this._showTileAABBs;\n        }\n        set showTileAABBs(e) {\n          this._showTileAABBs !== e && (this._showTileAABBs = e, this._tp.refreshUI(), e && this._update());\n        }\n        _setCacheLimits(t, i) {\n          e.eX(t, i);\n        }\n        get version() {\n          return t;\n        }\n      },\n      NavigationControl: class {\n        constructor() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          this.options = Object.assign({}, Sl, t), this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this.options.showZoom && (e.aY([\"_setButtonTitle\", \"_updateZoomButtons\"], this), this._zoomInButton = this._createButton(\"mapboxgl-ctrl-zoom-in\", e => {\n            this._map && this._map.zoomIn({}, {\n              originalEvent: e\n            });\n          }), l(\"span\", \"mapboxgl-ctrl-icon\", this._zoomInButton).setAttribute(\"aria-hidden\", \"true\"), this._zoomOutButton = this._createButton(\"mapboxgl-ctrl-zoom-out\", e => {\n            this._map && this._map.zoomOut({}, {\n              originalEvent: e\n            });\n          }), l(\"span\", \"mapboxgl-ctrl-icon\", this._zoomOutButton).setAttribute(\"aria-hidden\", \"true\")), this.options.showCompass && (e.aY([\"_rotateCompassArrow\"], this), this._compass = this._createButton(\"mapboxgl-ctrl-compass\", e => {\n            const t = this._map;\n            t && (this.options.visualizePitch ? t.resetNorthPitch({}, {\n              originalEvent: e\n            }) : t.resetNorth({}, {\n              originalEvent: e\n            }));\n          }), this._compassIcon = l(\"span\", \"mapboxgl-ctrl-icon\", this._compass), this._compassIcon.setAttribute(\"aria-hidden\", \"true\"));\n        }\n        _updateZoomButtons() {\n          const e = this._map;\n          if (!e) return;\n          const t = e.getZoom(),\n            i = t === e.getMaxZoom(),\n            o = t === e.getMinZoom();\n          this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute(\"aria-disabled\", i.toString()), this._zoomOutButton.setAttribute(\"aria-disabled\", o.toString());\n        }\n        _rotateCompassArrow() {\n          const e = this._map;\n          if (!e) return;\n          const t = this.options.visualizePitch ? \"scale(\".concat(1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5), \") rotateX(\").concat(e.transform.pitch, \"deg) rotateZ(\").concat(e.transform.angle * (180 / Math.PI), \"deg)\") : \"rotate(\".concat(e.transform.angle * (180 / Math.PI), \"deg)\");\n          e._requestDomTask(() => {\n            this._compassIcon && (this._compassIcon.style.transform = t);\n          });\n        }\n        onAdd(e) {\n          return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, \"ZoomIn\"), this._setButtonTitle(this._zoomOutButton, \"ZoomOut\"), e.on(\"zoom\", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, \"ResetBearing\"), this.options.visualizePitch && e.on(\"pitch\", this._rotateCompassArrow), e.on(\"rotate\", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Il(e, this._compass, this.options.visualizePitch)), this._container;\n        }\n        onRemove() {\n          const e = this._map;\n          e && (this._container.remove(), this.options.showZoom && e.off(\"zoom\", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off(\"pitch\", this._rotateCompassArrow), e.off(\"rotate\", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);\n        }\n        _createButton(e, t) {\n          const i = l(\"button\", e, this._container);\n          return i.type = \"button\", i.addEventListener(\"click\", t), i;\n        }\n        _setButtonTitle(e, t) {\n          if (!this._map) return;\n          const i = this._map._getUIString(\"NavigationControl.\".concat(t));\n          e.setAttribute(\"aria-label\", i), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n        }\n      },\n      GeolocateControl: class extends e.E {\n        constructor() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          super();\n          const i = navigator.geolocation;\n          this.options = Object.assign({\n            geolocation: i\n          }, Ll, t), e.aY([\"_onSuccess\", \"_onError\", \"_onZoom\", \"_finish\", \"_setupUI\", \"_updateCamera\", \"_updateMarker\", \"_updateMarkerRotation\", \"_onDeviceOrientation\"], this), this._updateMarkerRotationThrottled = pa(this._updateMarkerRotation, 20), this._numberOfWatches = 0;\n        }\n        onAdd(e) {\n          return this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkGeolocationSupport(this._setupUI), this._container;\n        }\n        onRemove() {\n          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off(\"zoom\", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;\n        }\n        _checkGeolocationSupport(e) {\n          var _this3 = this;\n          const t = function () {\n            let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !!_this3.options.geolocation;\n            _this3._supportsGeolocation = t, e(t);\n          };\n          void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({\n            name: \"geolocation\"\n          }).then(e => t(\"denied\" !== e.state)).catch(() => t()) : t();\n        }\n        _isOutOfMapMaxBounds(e) {\n          const t = this._map.getMaxBounds(),\n            i = e.coords;\n          return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());\n        }\n        _setErrorState() {\n          switch (this._watchState) {\n            case \"WAITING_ACTIVE\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n              break;\n            case \"ACTIVE_LOCK\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n              break;\n            case \"BACKGROUND\":\n              this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n          }\n        }\n        _onSuccess(t) {\n          if (this._map) {\n            if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.z(\"outofmaxbounds\", t)), this._updateMarker(), void this._finish();\n            if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n              case \"BACKGROUND\":\n              case \"BACKGROUND_ERROR\":\n                this._watchState = \"BACKGROUND\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n            }\n            this.options.showUserLocation && \"OFF\" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && \"ACTIVE_LOCK\" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._userLocationDotMarker.removeClassName(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.z(\"geolocate\", t)), this._finish();\n          }\n        }\n        _updateCamera(t) {\n          const i = new e.aR(t.coords.longitude, t.coords.latitude),\n            o = t.coords.accuracy,\n            s = this._map.getBearing(),\n            r = Object.assign({\n              bearing: s\n            }, this.options.fitBoundsOptions);\n          this._map.fitBounds(i.toBounds(o), r, {\n            geolocateSource: !0\n          });\n        }\n        _updateMarker(t) {\n          if (t) {\n            const i = new e.aR(t.coords.longitude, t.coords.latitude);\n            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n        }\n        _updateCircleRadius() {\n          const t = this._map.transform,\n            i = e.ce(1, t._center.lat) * t.worldSize,\n            o = Math.ceil(2 * this._accuracy * i);\n          this._circleElement.style.width = \"\".concat(o, \"px\"), this._circleElement.style.height = \"\".concat(o, \"px\");\n        }\n        _onZoom() {\n          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        }\n        _updateMarkerRotation() {\n          this._userLocationDotMarker && \"number\" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName(\"mapboxgl-user-location-show-heading\")) : (this._userLocationDotMarker.removeClassName(\"mapboxgl-user-location-show-heading\"), this._userLocationDotMarker.setRotation(0));\n        }\n        _onError(t) {\n          if (this._map) {\n            if (this.options.trackUserLocation) if (1 === t.code) {\n              this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.disabled = !0;\n              const e = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n              this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e), void 0 !== this._geolocationWatchID && this._clearWatch();\n            } else {\n              if (3 === t.code && this._noTimeout) return;\n              this._setErrorState();\n            }\n            \"OFF\" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.z(\"error\", t)), this._finish();\n          }\n        }\n        _finish() {\n          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n        }\n        _setupUI(t) {\n          if (void 0 !== this._map) {\n            if (this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this._geolocateButton = l(\"button\", \"mapboxgl-ctrl-geolocate\", this._container), l(\"span\", \"mapboxgl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\"), this._geolocateButton.type = \"button\", !1 === t) {\n              e.w(\"Geolocation support is not available so the GeolocateControl will be disabled.\");\n              const t = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n              this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute(\"aria-label\", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", t);\n            } else {\n              const e = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n              this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e);\n            }\n            this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = l(\"div\", \"mapboxgl-user-location\"), this._dotElement.appendChild(l(\"div\", \"mapboxgl-user-location-dot\")), this._dotElement.appendChild(l(\"div\", \"mapboxgl-user-location-heading\")), this._userLocationDotMarker = new Dl({\n              element: this._dotElement,\n              rotationAlignment: \"map\",\n              pitchAlignment: \"map\"\n            }), this._circleElement = l(\"div\", \"mapboxgl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new Dl({\n              element: this._circleElement,\n              pitchAlignment: \"map\"\n            }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"zoom\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"movestart\", t => {\n              t.geolocateSource || \"ACTIVE_LOCK\" !== this._watchState || t.originalEvent && \"resize\" === t.originalEvent.type || (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this.fire(new e.z(\"trackuserlocationend\")));\n            });\n          }\n        }\n        _onDeviceOrientation(e) {\n          this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());\n        }\n        trigger() {\n          if (!this._setup) return e.w(\"Geolocate control triggered before added to a map\"), !1;\n          if (this.options.trackUserLocation) {\n            switch (this._watchState) {\n              case \"OFF\":\n                this._watchState = \"WAITING_ACTIVE\", this.fire(new e.z(\"trackuserlocationstart\"));\n                break;\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n              case \"BACKGROUND_ERROR\":\n                this._numberOfWatches--, this._noTimeout = !1, this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this.fire(new e.z(\"trackuserlocationend\"));\n                break;\n              case \"BACKGROUND\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z(\"trackuserlocationstart\"));\n            }\n            switch (this._watchState) {\n              case \"WAITING_ACTIVE\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n              case \"ACTIVE_LOCK\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n              case \"ACTIVE_ERROR\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                break;\n              case \"BACKGROUND\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n                break;\n              case \"BACKGROUND_ERROR\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\");\n            }\n            if (\"OFF\" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n              let e;\n              this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"true\"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {\n                maximumAge: 6e5,\n                timeout: 0\n              }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();\n            }\n          } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);\n          return !0;\n        }\n        _addDeviceOrientationListener() {\n          const e = () => {\n            \"ondeviceorientationabsolute\" in window ? window.addEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation) : window.addEventListener(\"deviceorientation\", this._onDeviceOrientation);\n          };\n          \"undefined\" != typeof DeviceMotionEvent && \"function\" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(t => {\n            \"granted\" === t && e();\n          }).catch(console.error) : e();\n        }\n        _clearWatch() {\n          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener(\"deviceorientation\", this._onDeviceOrientation), window.removeEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this.options.showUserLocation && this._updateMarker(null);\n        }\n      },\n      AttributionControl: fl,\n      ScaleControl: class {\n        constructor() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          this.options = Object.assign({}, Pl, t), this._isNumberFormatSupported = function () {\n            try {\n              return new Intl.NumberFormat(\"en\", {\n                style: \"unit\",\n                unitDisplay: \"short\",\n                unit: \"meter\"\n              }), !0;\n            } catch (e) {\n              return !1;\n            }\n          }(), e.aY([\"_update\", \"_setScale\", \"setUnit\"], this);\n        }\n        getDefaultPosition() {\n          return \"bottom-left\";\n        }\n        _update() {\n          const e = this.options.maxWidth || 100,\n            t = this._map,\n            i = t._containerHeight / 2,\n            o = t._containerWidth / 2 - e / 2,\n            s = t.unproject([o, i]),\n            r = t.unproject([o + e, i]),\n            n = s.distanceTo(r);\n          if (\"imperial\" === this.options.unit) {\n            const t = 3.2808 * n;\n            t > 5280 ? this._setScale(e, t / 5280, \"mile\") : this._setScale(e, t, \"foot\");\n          } else \"nautical\" === this.options.unit ? this._setScale(e, n / 1852, \"nautical-mile\") : n >= 1e3 ? this._setScale(e, n / 1e3, \"kilometer\") : this._setScale(e, n, \"meter\");\n        }\n        _setScale(e, t, i) {\n          this._map._requestDomTask(() => {\n            const o = function (e) {\n                const t = Math.pow(10, \"\".concat(Math.floor(e)).length - 1);\n                let i = e / t;\n                return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {\n                  const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));\n                  return Math.round(e * t) / t;\n                }(i), t * i;\n              }(t),\n              s = o / t;\n            this._container.innerHTML = this._isNumberFormatSupported && \"nautical-mile\" !== i ? new Intl.NumberFormat(this._language, {\n              style: \"unit\",\n              unitDisplay: \"short\",\n              unit: i\n            }).format(o) : \"\".concat(o, \"&nbsp;\").concat(zl[i]), this._container.style.width = e * s + \"px\";\n          });\n        }\n        onAdd(e) {\n          return this._map = e, this._language = e.getLanguage(), this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-scale\", e.getContainer()), this._container.dir = \"auto\", this._map.on(\"move\", this._update), this._update(), this._container;\n        }\n        onRemove() {\n          this._container.remove(), this._map.off(\"move\", this._update), this._map = void 0;\n        }\n        _setLanguage(e) {\n          this._language = e, this._update();\n        }\n        setUnit(e) {\n          this.options.unit = e, this._update();\n        }\n      },\n      FullscreenControl: class {\n        constructor() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          this._fullscreen = !1, t && t.container && (t.container instanceof HTMLElement ? this._container = t.container : e.w(\"Full screen control 'container' must be a DOM element.\")), e.aY([\"_onClickFullscreen\", \"_changeIcon\"], this), \"onfullscreenchange\" in document ? this._fullscreenchange = \"fullscreenchange\" : \"onwebkitfullscreenchange\" in document && (this._fullscreenchange = \"webkitfullscreenchange\");\n        }\n        onAdd(t) {\n          return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = \"none\", e.w(\"This device does not support fullscreen mode.\")), this._controlContainer;\n        }\n        onRemove() {\n          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);\n        }\n        _checkFullscreenSupport() {\n          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);\n        }\n        _setupUI() {\n          const e = this._fullscreenButton = l(\"button\", \"mapboxgl-ctrl-fullscreen\", this._controlContainer);\n          l(\"span\", \"mapboxgl-ctrl-icon\", e).setAttribute(\"aria-hidden\", \"true\"), e.type = \"button\", this._updateTitle(), this._fullscreenButton.addEventListener(\"click\", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);\n        }\n        _updateTitle() {\n          const e = this._getTitle();\n          this._fullscreenButton.setAttribute(\"aria-label\", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute(\"title\", e);\n        }\n        _getTitle() {\n          return this._map._getUIString(this._isFullscreen() ? \"FullscreenControl.Exit\" : \"FullscreenControl.Enter\");\n        }\n        _isFullscreen() {\n          return this._fullscreen;\n        }\n        _changeIcon() {\n          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-fullscreen\"), this._updateTitle());\n        }\n        _onClickFullscreen() {\n          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n        }\n      },\n      IndoorControl: gl,\n      Popup: class extends e.E {\n        constructor(t) {\n          super(), this.options = Object.assign(Object.create(Ol), t), this._altitude = this.options.altitude, e.aY([\"_update\", \"_onClose\", \"remove\", \"_onMouseEvent\"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\\s+/) : []);\n        }\n        addTo(t) {\n          return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on(\"preclick\", this._onClose), this.options.closeOnMove && t.on(\"move\", this._onClose), t.on(\"remove\", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on(\"mousemove\", this._onMouseEvent), t.on(\"mouseup\", this._onMouseEvent), t._canvasContainer.classList.add(\"mapboxgl-track-pointer\")) : t.on(\"move\", this._update), this.fire(new e.z(\"open\")), this;\n        }\n        isOpen() {\n          return !!this._map;\n        }\n        remove() {\n          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);\n          const t = this._map;\n          return t && (t.off(\"move\", this._update), t.off(\"move\", this._onClose), t.off(\"preclick\", this._onClose), t.off(\"click\", this._onClose), t.off(\"remove\", this.remove), t.off(\"mousemove\", this._onMouseEvent), t.off(\"mouseup\", this._onMouseEvent), t.off(\"drag\", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove(\"mapboxgl-track-pointer\"), t._removePopup(this), this._map = void 0), this.fire(new e.z(\"close\")), this;\n        }\n        getLngLat() {\n          return this._lngLat;\n        }\n        setLngLat(t) {\n          this._lngLat = e.aR.convert(t), this._pos = null, this._trackPointer = !1, this._update();\n          const i = this._map;\n          return i && (i.on(\"move\", this._update), i.off(\"mousemove\", this._onMouseEvent), i._canvasContainer.classList.remove(\"mapboxgl-track-pointer\")), this;\n        }\n        getAltitude() {\n          return this._altitude;\n        }\n        setAltitude(e) {\n          return this._altitude = e, this._update(), this;\n        }\n        trackPointer() {\n          this._trackPointer = !0, this._pos = null, this._update();\n          const e = this._map;\n          return e && (e.off(\"move\", this._update), e.on(\"mousemove\", this._onMouseEvent), e.on(\"drag\", this._onMouseEvent), e._canvasContainer.classList.add(\"mapboxgl-track-pointer\")), this;\n        }\n        getElement() {\n          return this._container;\n        }\n        setText(e) {\n          return this.setDOMContent(document.createTextNode(e));\n        }\n        setHTML(e) {\n          const t = document.createDocumentFragment(),\n            i = document.createElement(\"body\");\n          let o;\n          for (i.innerHTML = e; o = i.firstChild, o;) t.appendChild(o);\n          return this.setDOMContent(t);\n        }\n        getMaxWidth() {\n          return this._container && this._container.style.maxWidth;\n        }\n        setMaxWidth(e) {\n          return this.options.maxWidth = e, this._update(), this;\n        }\n        setDOMContent(e) {\n          let t = this._content;\n          if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = l(\"div\", \"mapboxgl-popup-content\", this._container || void 0);\n          if (t.appendChild(e), this.options.closeButton) {\n            const e = this._closeButton = l(\"button\", \"mapboxgl-popup-close-button\", t);\n            e.type = \"button\", e.setAttribute(\"aria-label\", \"Close popup\"), e.innerHTML = '<span aria-hidden=\"true\">&#215;</span>', e.addEventListener(\"click\", this._onClose);\n          }\n          return this._update(), this._focusFirstElement(), this;\n        }\n        addClassName(e) {\n          return this._classList.add(e), this._updateClassList(), this;\n        }\n        removeClassName(e) {\n          return this._classList.delete(e), this._updateClassList(), this;\n        }\n        setOffset(e) {\n          return this.options.offset = e, this._update(), this;\n        }\n        toggleClassName(e) {\n          let t;\n          return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;\n        }\n        _onMouseEvent(e) {\n          this._update(e.point);\n        }\n        _getAnchor(e) {\n          if (this.options.anchor) return this.options.anchor;\n          const t = this._map,\n            i = this._container,\n            o = this._pos;\n          if (!t || !i || !o) return \"bottom\";\n          const s = i.offsetWidth,\n            r = i.offsetHeight,\n            n = o.x < s / 2,\n            a = o.x > t.transform.width - s / 2;\n          if (o.y + e < r) return n ? \"top-left\" : a ? \"top-right\" : \"top\";\n          if (o.y > t.transform.height - r) {\n            if (n) return \"bottom-left\";\n            if (a) return \"bottom-right\";\n          }\n          return n ? \"left\" : a ? \"right\" : \"bottom\";\n        }\n        _updateClassList() {\n          const e = this._container;\n          if (!e) return;\n          const t = [...this._classList];\n          t.push(\"mapboxgl-popup\"), this._anchor && t.push(\"mapboxgl-popup-anchor-\".concat(this._anchor)), this._trackPointer && t.push(\"mapboxgl-popup-track-pointer\"), e.className = t.join(\" \");\n        }\n        _update(t) {\n          const i = this._map,\n            o = this._content;\n          if (!i || !this._lngLat && !this._trackPointer || !o) return;\n          let s = this._container;\n          if (s || (s = this._container = l(\"div\", \"mapboxgl-popup\", i.getContainer()), this._tip = l(\"div\", \"mapboxgl-popup-tip\", s), s.appendChild(o)), this.options.maxWidth && s.style.maxWidth !== this.options.maxWidth && (s.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Cl(this._lngLat, this._pos, i.transform)), !this._trackPointer || t) {\n            const o = this._pos = this._trackPointer && t instanceof e.P ? t : i.project(this._lngLat, this._altitude),\n              s = Fl(this.options.offset),\n              r = this._anchor = this._getAnchor(s.y),\n              n = Fl(this.options.offset, r),\n              a = o.add(n).round();\n            i._requestDomTask(() => {\n              this._container && r && (this._container.style.transform = \"\".concat(Rl[r], \" translate(\").concat(a.x, \"px,\").concat(a.y, \"px)\"));\n            });\n          }\n          if (!this._marker && i._showingGlobe()) {\n            const t = e.eY(i.transform, this._lngLat) ? 0 : 1;\n            this._setOpacity(t);\n          }\n          this._updateClassList();\n        }\n        _focusFirstElement() {\n          if (!this.options.focusAfterOpen || !this._container) return;\n          const e = this._container.querySelector(Ml);\n          e && e.focus();\n        }\n        _onClose() {\n          this.remove();\n        }\n        _setOpacity(e) {\n          this._container && (this._container.style.opacity = \"\".concat(e)), this._content && (this._content.style.pointerEvents = e ? \"auto\" : \"none\");\n        }\n      },\n      Marker: Dl,\n      Style: To,\n      LngLat: e.aR,\n      LngLatBounds: e.aI,\n      Point: e.P,\n      MercatorCoordinate: e.ae,\n      FreeCameraOptions: Yi,\n      Evented: e.E,\n      config: e.e,\n      prewarm: e.f0,\n      clearPrewarmedResources: e.e$,\n      get accessToken() {\n        return e.e.ACCESS_TOKEN;\n      },\n      set accessToken(t) {\n        e.e.ACCESS_TOKEN = t;\n      },\n      get baseApiUrl() {\n        return e.e.API_URL;\n      },\n      set baseApiUrl(t) {\n        e.e.API_URL = t;\n      },\n      get workerCount() {\n        return e.f9.workerCount;\n      },\n      set workerCount(t) {\n        e.f9.workerCount = t;\n      },\n      get maxParallelImageRequests() {\n        return e.e.MAX_PARALLEL_IMAGE_REQUESTS;\n      },\n      set maxParallelImageRequests(t) {\n        e.e.MAX_PARALLEL_IMAGE_REQUESTS = t;\n      },\n      clearStorage(t) {\n        e.f8(t);\n      },\n      get workerUrl() {\n        return e.f7.workerUrl;\n      },\n      set workerUrl(t) {\n        e.f7.workerUrl = t;\n      },\n      get workerClass() {\n        return e.f7.workerClass;\n      },\n      set workerClass(t) {\n        e.f7.workerClass = t;\n      },\n      get workerParams() {\n        return e.f7.workerParams;\n      },\n      set workerParams(t) {\n        e.f7.workerParams = t;\n      },\n      get dracoUrl() {\n        return e.f6();\n      },\n      set dracoUrl(t) {\n        e.f5(t);\n      },\n      get meshoptUrl() {\n        return e.f4();\n      },\n      set meshoptUrl(t) {\n        e.f3(t);\n      },\n      setNow: e.o.setNow,\n      restoreNow: e.o.restoreNow\n    };\n    return Bl;\n  });\n\n  //\n  // Our custom intro provides a specialized \"define()\" function, called by the\n  // AMD modules below, that sets up the worker blob URL and then executes the\n  // main module, storing its exported value as 'mapboxgl'\n\n  var mapboxgl$1 = mapboxgl;\n  return mapboxgl$1;\n});\n//# sourceMappingURL=mapbox-gl.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}